// This code conforms with the UFC specification version 2.0.0
// and was automatically generated by FFC version 0.9.10.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
// 
// This code was generated with the following parameters:
// 
//   cache_dir:                      ''
//   convert_exceptions_to_warnings: False
//   cpp_optimize:                   False
//   cpp_optimize_flags:             '-O2'
//   epsilon:                        1e-14
//   error_control:                  True
//   form_postfix:                   True
//   format:                         'dolfin'
//   log_level:                      10
//   log_prefix:                     ''
//   no_ferari:                      True
//   optimize:                       True
//   output_dir:                     '.'
//   precision:                      15
//   quadrature_degree:              'auto'
//   quadrature_rule:                'auto'
//   representation:                 'auto'
//   split:                          False
//   swig_binary:                    'swig'
//   swig_path:                      ''

#ifndef __ADAPTIVENAVIERSTOKES_H
#define __ADAPTIVENAVIERSTOKES_H

#include <cmath>
#include <stdexcept>
#include <fstream>
#include <ufc.h>

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_0: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_0()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 10;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    *values = 0.000000000000000;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, -0.028867513459481, -0.016666666666667, 0.078246079643595, 0.060609152673133, 0.034992710611188, -0.060133779430295, -0.050822319538420, -0.039366799437587, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.028867513459481, -0.016666666666667, 0.078246079643595, -0.060609152673133, 0.034992710611188, 0.060133779430295, -0.050822319538420, 0.039366799437587, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.000000000000000, 0.033333333333333, 0.000000000000000, 0.000000000000000, 0.104978131833565, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, 0.117369119465393, 0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, 0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, 0.117369119465393, -0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, -0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, -0.078246079643595, 0.090913729009699, 0.096229954180768, 0.180401338290886, 0.050822319538420, -0.013122266479196, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, -0.078246079643595, -0.090913729009699, 0.096229954180768, -0.180401338290886, 0.050822319538420, 0.013122266479196, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.000000000000000, 0.000000000000000, -0.234738238930785, 0.000000000000000, -0.262445329583912, 0.000000000000000, -0.203289278153682, 0.000000000000000, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.000000000000000;
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 10; r++)
    {
      evaluate_basis(r, &dof_values, coordinates, c);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, -0.028867513459481, -0.016666666666667, 0.078246079643595, 0.060609152673133, 0.034992710611188, -0.060133779430295, -0.050822319538420, -0.039366799437587, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.028867513459481, -0.016666666666667, 0.078246079643595, -0.060609152673133, 0.034992710611188, 0.060133779430295, -0.050822319538420, 0.039366799437587, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.000000000000000, 0.033333333333333, 0.000000000000000, 0.000000000000000, 0.104978131833565, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, 0.117369119465393, 0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, 0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, 0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, 0.117369119465393, -0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, -0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, -0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, -0.078246079643595, 0.090913729009699, 0.096229954180768, 0.180401338290886, 0.050822319538420, -0.013122266479196, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, -0.078246079643595, -0.090913729009699, 0.096229954180768, -0.180401338290886, 0.050822319538420, 0.013122266479196, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.000000000000000, 0.000000000000000, -0.234738238930785, 0.000000000000000, -0.262445329583912, 0.000000000000000, -0.203289278153682, 0.000000000000000, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 10; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 7:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 8:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 9:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_0();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_1: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_1()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 20;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    values[0] = 0.000000000000000;
    values[1] = 0.000000000000000;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, -0.028867513459481, -0.016666666666667, 0.078246079643595, 0.060609152673133, 0.034992710611188, -0.060133779430295, -0.050822319538420, -0.039366799437587, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.028867513459481, -0.016666666666667, 0.078246079643595, -0.060609152673133, 0.034992710611188, 0.060133779430295, -0.050822319538420, 0.039366799437587, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.000000000000000, 0.033333333333333, 0.000000000000000, 0.000000000000000, 0.104978131833565, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, 0.117369119465393, 0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, 0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, 0.117369119465393, -0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, -0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, -0.078246079643595, 0.090913729009699, 0.096229954180768, 0.180401338290886, 0.050822319538420, -0.013122266479196, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, -0.078246079643595, -0.090913729009699, 0.096229954180768, -0.180401338290886, 0.050822319538420, 0.013122266479196, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.000000000000000, 0.000000000000000, -0.234738238930785, 0.000000000000000, -0.262445329583912, 0.000000000000000, -0.203289278153682, 0.000000000000000, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, -0.028867513459481, -0.016666666666667, 0.078246079643595, 0.060609152673133, 0.034992710611188, -0.060133779430295, -0.050822319538420, -0.039366799437587, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.028867513459481, -0.016666666666667, 0.078246079643595, -0.060609152673133, 0.034992710611188, 0.060133779430295, -0.050822319538420, 0.039366799437587, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.000000000000000, 0.033333333333333, 0.000000000000000, 0.000000000000000, 0.104978131833565, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, 0.117369119465393, 0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, 0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 15:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, 0.117369119465393, -0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 16:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, -0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 17:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, -0.078246079643595, 0.090913729009699, 0.096229954180768, 0.180401338290886, 0.050822319538420, -0.013122266479196, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 18:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, -0.078246079643595, -0.090913729009699, 0.096229954180768, -0.180401338290886, 0.050822319538420, 0.013122266479196, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 19:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.000000000000000, 0.000000000000000, -0.234738238930785, 0.000000000000000, -0.262445329583912, 0.000000000000000, -0.203289278153682, 0.000000000000000, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {0.000000000000000, 0.000000000000000};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 20; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 2; s++)
      {
        values[r*2 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, -0.028867513459481, -0.016666666666667, 0.078246079643595, 0.060609152673133, 0.034992710611188, -0.060133779430295, -0.050822319538420, -0.039366799437587, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.028867513459481, -0.016666666666667, 0.078246079643595, -0.060609152673133, 0.034992710611188, 0.060133779430295, -0.050822319538420, 0.039366799437587, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.000000000000000, 0.033333333333333, 0.000000000000000, 0.000000000000000, 0.104978131833565, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, 0.117369119465393, 0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, 0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, 0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, 0.117369119465393, -0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, -0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, -0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, -0.078246079643595, 0.090913729009699, 0.096229954180768, 0.180401338290886, 0.050822319538420, -0.013122266479196, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, -0.078246079643595, -0.090913729009699, 0.096229954180768, -0.180401338290886, 0.050822319538420, 0.013122266479196, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.000000000000000, 0.000000000000000, -0.234738238930785, 0.000000000000000, -0.262445329583912, 0.000000000000000, -0.203289278153682, 0.000000000000000, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, -0.028867513459481, -0.016666666666667, 0.078246079643595, 0.060609152673133, 0.034992710611188, -0.060133779430295, -0.050822319538420, -0.039366799437587, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.028867513459481, -0.016666666666667, 0.078246079643595, -0.060609152673133, 0.034992710611188, 0.060133779430295, -0.050822319538420, 0.039366799437587, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.000000000000000, 0.033333333333333, 0.000000000000000, 0.000000000000000, 0.104978131833565, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, 0.117369119465393, 0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, 0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, 0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 15:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, 0.117369119465393, -0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 16:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, -0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, -0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 17:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, -0.078246079643595, 0.090913729009699, 0.096229954180768, 0.180401338290886, 0.050822319538420, -0.013122266479196, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 18:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, -0.078246079643595, -0.090913729009699, 0.096229954180768, -0.180401338290886, 0.050822319538420, 0.013122266479196, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 19:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.000000000000000, 0.000000000000000, -0.234738238930785, 0.000000000000000, -0.262445329583912, 0.000000000000000, -0.203289278153682, 0.000000000000000, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[2*num_derivatives];
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 20; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[2];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 7:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 8:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 9:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 10:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 12:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 13:
      {
        y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 14:
      {
        y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 15:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 16:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 17:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 18:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 19:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[2];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[12] = vals[1];
    y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[13] = vals[1];
    y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[14] = vals[1];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[15] = vals[1];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[16] = vals[1];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    f.evaluate(vals, y, c);
    values[17] = vals[1];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    f.evaluate(vals, y, c);
    values[18] = vals[1];
    y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[19] = vals[1];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[10];
    vertex_values[3] = dof_values[11];
    vertex_values[5] = dof_values[12];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_0();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_1();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_2: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_2() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_2()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 6;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    *values = 0.000000000000000;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.000000000000000;
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 6; r++)
    {
      evaluate_basis(r, &dof_values, coordinates, c);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 6; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_2();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_3: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_3() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_3()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 26;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    values[0] = 0.000000000000000;
    values[1] = 0.000000000000000;
    values[2] = 0.000000000000000;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, -0.028867513459481, -0.016666666666667, 0.078246079643595, 0.060609152673133, 0.034992710611188, -0.060133779430295, -0.050822319538420, -0.039366799437587, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.028867513459481, -0.016666666666667, 0.078246079643595, -0.060609152673133, 0.034992710611188, 0.060133779430295, -0.050822319538420, 0.039366799437587, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.000000000000000, 0.033333333333333, 0.000000000000000, 0.000000000000000, 0.104978131833565, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, 0.117369119465393, 0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, 0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, 0.117369119465393, -0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, -0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, -0.078246079643595, 0.090913729009699, 0.096229954180768, 0.180401338290886, 0.050822319538420, -0.013122266479196, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, -0.078246079643595, -0.090913729009699, 0.096229954180768, -0.180401338290886, 0.050822319538420, 0.013122266479196, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.000000000000000, 0.000000000000000, -0.234738238930785, 0.000000000000000, -0.262445329583912, 0.000000000000000, -0.203289278153682, 0.000000000000000, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, -0.028867513459481, -0.016666666666667, 0.078246079643595, 0.060609152673133, 0.034992710611188, -0.060133779430295, -0.050822319538420, -0.039366799437587, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.028867513459481, -0.016666666666667, 0.078246079643595, -0.060609152673133, 0.034992710611188, 0.060133779430295, -0.050822319538420, 0.039366799437587, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.000000000000000, 0.033333333333333, 0.000000000000000, 0.000000000000000, 0.104978131833565, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, 0.117369119465393, 0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, 0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 15:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, 0.117369119465393, -0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 16:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, -0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 17:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, -0.078246079643595, 0.090913729009699, 0.096229954180768, 0.180401338290886, 0.050822319538420, -0.013122266479196, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 18:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, -0.078246079643595, -0.090913729009699, 0.096229954180768, -0.180401338290886, 0.050822319538420, 0.013122266479196, -0.022728432252425};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 19:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.000000000000000, 0.000000000000000, -0.234738238930785, 0.000000000000000, -0.262445329583912, 0.000000000000000, -0.203289278153682, 0.000000000000000, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 20:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 21:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 22:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 23:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 24:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 25:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 26; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, -0.028867513459481, -0.016666666666667, 0.078246079643595, 0.060609152673133, 0.034992710611188, -0.060133779430295, -0.050822319538420, -0.039366799437587, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.028867513459481, -0.016666666666667, 0.078246079643595, -0.060609152673133, 0.034992710611188, 0.060133779430295, -0.050822319538420, 0.039366799437587, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.000000000000000, 0.033333333333333, 0.000000000000000, 0.000000000000000, 0.104978131833565, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, 0.117369119465393, 0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, 0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, 0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, 0.117369119465393, -0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, -0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, -0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, -0.078246079643595, 0.090913729009699, 0.096229954180768, 0.180401338290886, 0.050822319538420, -0.013122266479196, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, -0.078246079643595, -0.090913729009699, 0.096229954180768, -0.180401338290886, 0.050822319538420, 0.013122266479196, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.000000000000000, 0.000000000000000, -0.234738238930785, 0.000000000000000, -0.262445329583912, 0.000000000000000, -0.203289278153682, 0.000000000000000, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, -0.028867513459481, -0.016666666666667, 0.078246079643595, 0.060609152673133, 0.034992710611188, -0.060133779430295, -0.050822319538420, -0.039366799437587, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.028867513459481, -0.016666666666667, 0.078246079643595, -0.060609152673133, 0.034992710611188, 0.060133779430295, -0.050822319538420, 0.039366799437587, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.047140452079103, 0.000000000000000, 0.033333333333333, 0.000000000000000, 0.000000000000000, 0.104978131833565, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, 0.117369119465393, 0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, 0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, 0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 15:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, 0.117369119465393, -0.060609152673133, -0.078733598875174, 0.000000000000000, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 16:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.000000000000000, 0.300000000000000, 0.000000000000000, -0.151522881682832, 0.026244532958391, 0.000000000000000, 0.000000000000000, -0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 17:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.150000000000000, -0.078246079643595, 0.090913729009699, 0.096229954180768, 0.180401338290886, 0.050822319538420, -0.013122266479196, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 18:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.150000000000000, -0.078246079643595, -0.090913729009699, 0.096229954180768, -0.180401338290886, 0.050822319538420, 0.013122266479196, -0.022728432252425};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 19:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 3; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 1; s < 3 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 4; r++)
      {
        for (unsigned int s = 0; s < 4 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.000000000000000, 0.000000000000000, -0.234738238930785, 0.000000000000000, -0.262445329583912, 0.000000000000000, -0.203289278153682, 0.000000000000000, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[10][10] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 20:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 21:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 22:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 23:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 24:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 25:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[3*num_derivatives];
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 26; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[3];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 7:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 8:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 9:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 10:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 12:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 13:
      {
        y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 14:
      {
        y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 15:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 16:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 17:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 18:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 19:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 20:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 21:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 22:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 23:
      {
        y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 24:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 25:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[3];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[12] = vals[1];
    y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[13] = vals[1];
    y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[14] = vals[1];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[15] = vals[1];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[16] = vals[1];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    f.evaluate(vals, y, c);
    values[17] = vals[1];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    f.evaluate(vals, y, c);
    values[18] = vals[1];
    y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[19] = vals[1];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[20] = vals[2];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[21] = vals[2];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[22] = vals[2];
    y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[23] = vals[2];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[24] = vals[2];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    f.evaluate(vals, y, c);
    values[25] = vals[2];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[10];
    vertex_values[4] = dof_values[11];
    vertex_values[7] = dof_values[12];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[20];
    vertex_values[5] = dof_values[21];
    vertex_values[8] = dof_values[22];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_1();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_3();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_4: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_4() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_4()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 1;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    *values = 0.000000000000000;
    
    // Array of basisvalues.
    double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
    
    // Declare helper variables.
    unsigned int rr = 0;
    unsigned int ss = 0;
    unsigned int tt = 0;
    double tmp5 = 0.000000000000000;
    double tmp6 = 0.000000000000000;
    double tmp7 = 0.000000000000000;
    double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
    double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
    double tmp2 = tmp1*tmp1;
    
    // Compute basisvalues.
    basisvalues[0] = 1.000000000000000;
    basisvalues[1] = tmp0;
    for (unsigned int r = 1; r < 3; r++)
    {
      rr = (r + 1)*((r + 1) + 1)/2;
      ss = r*(r + 1)/2;
      tt = (r - 1)*((r - 1) + 1)/2;
      tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
      basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
    }// end loop over 'r'
    for (unsigned int r = 0; r < 3; r++)
    {
      rr = (r + 1)*(r + 1 + 1)/2 + 1;
      ss = r*(r + 1)/2;
      basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
    }// end loop over 'r'
    for (unsigned int r = 0; r < 2; r++)
    {
      for (unsigned int s = 1; s < 3 - r; s++)
      {
        rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
        ss = (r + s)*(r + s + 1)/2 + s;
        tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
        tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
        tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
        tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
        basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
      }// end loop over 's'
    }// end loop over 'r'
    for (unsigned int r = 0; r < 4; r++)
    {
      for (unsigned int s = 0; s < 4 - r; s++)
      {
        rr = (r + s)*(r + s + 1)/2 + s;
        basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
      }// end loop over 's'
    }// end loop over 'r'
    
    // Table(s) of coefficients.
    static const double coefficients0[10] = \
    {0.636396103067893, 0.000000000000000, 0.000000000000000, -0.234738238930785, 0.000000000000000, -0.262445329583912, 0.000000000000000, -0.203289278153682, 0.000000000000000, 0.090913729009699};
    
    // Compute value(s).
    for (unsigned int r = 0; r < 10; r++)
    {
      *values += coefficients0[r]*basisvalues[r];
    }// end loop over 'r'
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Element is constant, calling evaluate_basis.
    evaluate_basis(0, values, coordinates, c);
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    
    // Array of basisvalues.
    double basisvalues[10] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
    
    // Declare helper variables.
    unsigned int rr = 0;
    unsigned int ss = 0;
    unsigned int tt = 0;
    double tmp5 = 0.000000000000000;
    double tmp6 = 0.000000000000000;
    double tmp7 = 0.000000000000000;
    double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
    double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
    double tmp2 = tmp1*tmp1;
    
    // Compute basisvalues.
    basisvalues[0] = 1.000000000000000;
    basisvalues[1] = tmp0;
    for (unsigned int r = 1; r < 3; r++)
    {
      rr = (r + 1)*((r + 1) + 1)/2;
      ss = r*(r + 1)/2;
      tt = (r - 1)*((r - 1) + 1)/2;
      tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
      basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
    }// end loop over 'r'
    for (unsigned int r = 0; r < 3; r++)
    {
      rr = (r + 1)*(r + 1 + 1)/2 + 1;
      ss = r*(r + 1)/2;
      basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
    }// end loop over 'r'
    for (unsigned int r = 0; r < 2; r++)
    {
      for (unsigned int s = 1; s < 3 - r; s++)
      {
        rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
        ss = (r + s)*(r + s + 1)/2 + s;
        tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
        tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
        tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
        tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
        basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
      }// end loop over 's'
    }// end loop over 'r'
    for (unsigned int r = 0; r < 4; r++)
    {
      for (unsigned int s = 0; s < 4 - r; s++)
      {
        rr = (r + s)*(r + s + 1)/2 + s;
        basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
      }// end loop over 's'
    }// end loop over 'r'
    
    // Table(s) of coefficients.
    static const double coefficients0[10] = \
    {0.636396103067893, 0.000000000000000, 0.000000000000000, -0.234738238930785, 0.000000000000000, -0.262445329583912, 0.000000000000000, -0.203289278153682, 0.000000000000000, 0.090913729009699};
    
    // Tables of derivatives of the polynomial base (transpose).
    static const double dmats0[10][10] = \
    {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {4.898979485566357, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {3.999999999999999, 0.000000000000000, 7.071067811865480, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {5.291502622129182, 0.000000000000000, -2.993325909419149, 13.662601021279462, 0.000000000000000, 0.611010092660779, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 4.381780460041329, 0.000000000000000, 0.000000000000000, 12.521980673998820, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {3.464101615137755, 0.000000000000000, 7.838367176906175, 0.000000000000000, 0.000000000000000, 8.400000000000002, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
    
    static const double dmats1[10][10] = \
    {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {2.449489742783178, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {2.581988897471611, 4.743416490252569, -0.912870929175276, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {1.999999999999999, 6.123724356957945, 3.535533905932741, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {-2.309401076758505, 0.000000000000000, 8.164965809277263, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {2.645751311064592, 5.184592558726287, -1.496662954709574, 6.831300510639732, -1.058300524425836, 0.305505046330389, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {2.236067977499790, 2.190890230020665, 2.529822128134708, 8.082903768654759, 6.260990336999411, -1.807392228230127, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {1.732050807568875, -5.091168824543142, 3.919183588453088, 0.000000000000000, 9.699484522385712, 4.200000000000001, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {5.000000000000002, 0.000000000000000, -2.828427124746187, 0.000000000000000, 0.000000000000000, 12.124355652982144, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
    
    // Compute reference derivatives.
    // Declare pointer to array of derivatives on FIAT element.
    double *derivatives = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      derivatives[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Declare derivative matrix (of polynomial basis).
    double dmats[10][10] = \
    {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
    
    // Declare (auxiliary) derivative matrix (of polynomial basis).
    double dmats_old[10][10] = \
    {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
    {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
    
    // Loop possible derivatives.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      // Resetting dmats values to compute next derivative.
      for (unsigned int t = 0; t < 10; t++)
      {
        for (unsigned int u = 0; u < 10; u++)
        {
          dmats[t][u] = 0.000000000000000;
          if (t == u)
          {
          dmats[t][u] = 1.000000000000000;
          }
          
        }// end loop over 'u'
      }// end loop over 't'
      
      // Looping derivative order to generate dmats.
      for (unsigned int s = 0; s < n; s++)
      {
        // Updating dmats_old with new values and resetting dmats.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats_old[t][u] = dmats[t][u];
            dmats[t][u] = 0.000000000000000;
          }// end loop over 'u'
        }// end loop over 't'
        
        // Update dmats using an inner product.
        if (combinations[r][s] == 0)
        {
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            for (unsigned int tu = 0; tu < 10; tu++)
            {
              dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
        if (combinations[r][s] == 1)
        {
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            for (unsigned int tu = 0; tu < 10; tu++)
            {
              dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
      }// end loop over 's'
      for (unsigned int s = 0; s < 10; s++)
      {
        for (unsigned int t = 0; t < 10; t++)
        {
          derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
        }// end loop over 't'
      }// end loop over 's'
    }// end loop over 'r'
    
    // Transform derivatives back to physical element
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r] += transform[r][s]*derivatives[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;
    
    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      delete [] combinations[r];
    }// end loop over 'r'
    delete [] combinations;
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      delete [] transform[r];
    }// end loop over 'r'
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Element is constant, calling evaluate_basis_derivatives.
    evaluate_basis_derivatives(0, n, values, coordinates, c);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = 0;
    vertex_values[1] = 0;
    vertex_values[2] = 0;
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_4();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_5: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_5() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_5()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 6;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    *values = 0.000000000000000;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.000000000000000;
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 6; r++)
    {
      evaluate_basis(r, &dof_values, coordinates, c);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 6; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_5();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_6: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_6() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_6()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 12;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    values[0] = 0.000000000000000;
    values[1] = 0.000000000000000;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {0.000000000000000, 0.000000000000000};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 2; s++)
      {
        values[r*2 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[2*num_derivatives];
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[2];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[2];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[3] = dof_values[7];
    vertex_values[5] = dof_values[8];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_6();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_7: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_7() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_7()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 3;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    *values = 0.000000000000000;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.000000000000000, 0.333333333333333};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.000000000000000;
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 3; r++)
    {
      evaluate_basis(r, &dof_values, coordinates, c);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566356, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566356, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.000000000000000, 0.333333333333333};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566356, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 3; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_7();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_8: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_8() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_8()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    values[0] = 0.000000000000000;
    values[1] = 0.000000000000000;
    values[2] = 0.000000000000000;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.000000000000000, 0.333333333333333};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 15; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566356, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566356, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.000000000000000, 0.333333333333333};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566356, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[3*num_derivatives];
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 15; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[3];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 12:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 13:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 14:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[3];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[12] = vals[2];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[13] = vals[2];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[14] = vals[2];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[4] = dof_values[7];
    vertex_values[7] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[12];
    vertex_values[5] = dof_values[13];
    vertex_values[8] = dof_values[14];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_6();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_7();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_8();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_9: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_9() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_9()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 0, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 1;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Compute constants
    
    // Get coordinates and map to the reference (FIAT) element
    
    // Reset values.
    *values = 0.000000000000000;
    
    // Array of basisvalues.
    double basisvalues[1] = {0.000000000000000};
    
    // Declare helper variables.
    
    // Compute basisvalues.
    basisvalues[0] = 1.000000000000000;
    
    // Table(s) of coefficients.
    static const double coefficients0[1] = \
    {1.000000000000000};
    
    // Compute value(s).
    for (unsigned int r = 0; r < 1; r++)
    {
      *values += coefficients0[r]*basisvalues[r];
    }// end loop over 'r'
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Element is constant, calling evaluate_basis.
    evaluate_basis(0, values, coordinates, c);
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    
    // Get coordinates and map to the reference (FIAT) element
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    
    // Array of basisvalues.
    double basisvalues[1] = {0.000000000000000};
    
    // Declare helper variables.
    
    // Compute basisvalues.
    basisvalues[0] = 1.000000000000000;
    
    // Table(s) of coefficients.
    static const double coefficients0[1] = \
    {1.000000000000000};
    
    // Tables of derivatives of the polynomial base (transpose).
    static const double dmats0[1][1] = \
    {{0.000000000000000}};
    
    static const double dmats1[1][1] = \
    {{0.000000000000000}};
    
    // Compute reference derivatives.
    // Declare pointer to array of derivatives on FIAT element.
    double *derivatives = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      derivatives[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Declare derivative matrix (of polynomial basis).
    double dmats[1][1] = \
    {{1.000000000000000}};
    
    // Declare (auxiliary) derivative matrix (of polynomial basis).
    double dmats_old[1][1] = \
    {{1.000000000000000}};
    
    // Loop possible derivatives.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      // Resetting dmats values to compute next derivative.
      for (unsigned int t = 0; t < 1; t++)
      {
        for (unsigned int u = 0; u < 1; u++)
        {
          dmats[t][u] = 0.000000000000000;
          if (t == u)
          {
          dmats[t][u] = 1.000000000000000;
          }
          
        }// end loop over 'u'
      }// end loop over 't'
      
      // Looping derivative order to generate dmats.
      for (unsigned int s = 0; s < n; s++)
      {
        // Updating dmats_old with new values and resetting dmats.
        for (unsigned int t = 0; t < 1; t++)
        {
          for (unsigned int u = 0; u < 1; u++)
          {
            dmats_old[t][u] = dmats[t][u];
            dmats[t][u] = 0.000000000000000;
          }// end loop over 'u'
        }// end loop over 't'
        
        // Update dmats using an inner product.
        if (combinations[r][s] == 0)
        {
        for (unsigned int t = 0; t < 1; t++)
        {
          for (unsigned int u = 0; u < 1; u++)
          {
            for (unsigned int tu = 0; tu < 1; tu++)
            {
              dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
        if (combinations[r][s] == 1)
        {
        for (unsigned int t = 0; t < 1; t++)
        {
          for (unsigned int u = 0; u < 1; u++)
          {
            for (unsigned int tu = 0; tu < 1; tu++)
            {
              dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
      }// end loop over 's'
      for (unsigned int s = 0; s < 1; s++)
      {
        for (unsigned int t = 0; t < 1; t++)
        {
          derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
        }// end loop over 't'
      }// end loop over 's'
    }// end loop over 'r'
    
    // Transform derivatives back to physical element
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r] += transform[r][s]*derivatives[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;
    
    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      delete [] combinations[r];
    }// end loop over 'r'
    delete [] combinations;
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      delete [] transform[r];
    }// end loop over 'r'
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Element is constant, calling evaluate_basis_derivatives.
    evaluate_basis_derivatives(0, n, values, coordinates, c);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
    vertex_values[2] = dof_values[0];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_9();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_10: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_10() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_10()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 12;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    values[0] = 0.000000000000000;
    values[1] = 0.000000000000000;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {0.000000000000000, 0.000000000000000};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 2; s++)
      {
        values[r*2 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[2*num_derivatives];
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[2];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[2];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[3] = dof_values[7];
    vertex_values[5] = dof_values[8];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_2();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_10();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_11: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_11() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_11()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 3;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    *values = 0.000000000000000;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.000000000000000, 0.333333333333333};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.000000000000000;
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 3; r++)
    {
      evaluate_basis(r, &dof_values, coordinates, c);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566356, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566356, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.000000000000000, 0.333333333333333};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566356, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 3; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_11();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_12: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_12() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_12()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    values[0] = 0.000000000000000;
    values[1] = 0.000000000000000;
    values[2] = 0.000000000000000;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.000000000000000, 0.333333333333333};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 15; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, -0.173205080756888, -0.100000000000000, 0.121716123890037, 0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.173205080756888, -0.100000000000000, 0.121716123890037, -0.094280904158206, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.000000000000000, 0.000000000000000, 0.200000000000000, 0.000000000000000, 0.000000000000000, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.230940107675850, 0.133333333333333, 0.000000000000000, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.230940107675850, 0.133333333333333, 0.000000000000000, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      unsigned int tt = 0;
      double tmp5 = 0.000000000000000;
      double tmp6 = 0.000000000000000;
      double tmp7 = 0.000000000000000;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      double tmp1 = (1.000000000000000 - Y)/2.000000000000000;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 1; r < 2; r++)
      {
        rr = (r + 1)*((r + 1) + 1)/2;
        ss = r*(r + 1)/2;
        tt = (r - 1)*((r - 1) + 1)/2;
        tmp5 = (1.000000000000000 + 2.000000000000000*r)/(1.000000000000000 + r);
        basisvalues[rr] = (basisvalues[ss]*tmp0*tmp5 - basisvalues[tt]*tmp2*r/(1.000000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 1; r++)
      {
        for (unsigned int s = 1; s < 2 - r; s++)
        {
          rr = (r + s + 1)*(r + s + 1 + 1)/2 + s + 1;
          ss = (r + s)*(r + s + 1)/2 + s;
          tt = (r + s - 1)*(r + s - 1 + 1)/2 + s - 1;
          tmp5 = (2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp6 = (1.000000000000000 + 4.000000000000000*r*r + 4.000000000000000*r)*(2.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)/(2.000000000000000*(1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          tmp7 = (1.000000000000000 + s + 2.000000000000000*r)*(3.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*s/((1.000000000000000 + 2.000000000000000*r + 2.000000000000000*s)*(1.000000000000000 + s)*(2.000000000000000 + s + 2.000000000000000*r));
          basisvalues[rr] = (basisvalues[ss]*(tmp6 + Y*tmp5) - basisvalues[tt]*tmp7);
        }// end loop over 's'
      }// end loop over 'r'
      for (unsigned int r = 0; r < 3; r++)
      {
        for (unsigned int s = 0; s < 3 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.000000000000000, -0.266666666666667, -0.243432247780074, 0.000000000000000, 0.054433105395182};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566354, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 9.486832980505138, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {3.999999999999997, 0.000000000000000, 7.071067811865476, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[6][6] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783177, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.581988897471611, 4.743416490252569, -0.912870929175277, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {1.999999999999998, 6.123724356957944, 3.535533905932738, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {-2.309401076758502, 0.000000000000000, 8.164965809277259, 0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566356, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566356, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.000000000000000, 0.000000000000000, 0.000000000000000};
      
      // Declare helper variables.
      unsigned int rr = 0;
      unsigned int ss = 0;
      double tmp0 = (1.000000000000000 + Y + 2.000000000000000*X)/2.000000000000000;
      
      // Compute basisvalues.
      basisvalues[0] = 1.000000000000000;
      basisvalues[1] = tmp0;
      for (unsigned int r = 0; r < 1; r++)
      {
        rr = (r + 1)*(r + 1 + 1)/2 + 1;
        ss = r*(r + 1)/2;
        basisvalues[rr] = basisvalues[ss]*(0.500000000000000 + r + Y*(1.500000000000000 + r));
      }// end loop over 'r'
      for (unsigned int r = 0; r < 2; r++)
      {
        for (unsigned int s = 0; s < 2 - r; s++)
        {
          rr = (r + s)*(r + s + 1)/2 + s;
          basisvalues[rr] *= std::sqrt((0.500000000000000 + r)*(1.000000000000000 + r + s));
        }// end loop over 's'
      }// end loop over 'r'
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.000000000000000, 0.333333333333333};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {4.898979485566356, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 0.000000000000000}};
      
      static const double dmats1[3][3] = \
      {{0.000000000000000, 0.000000000000000, 0.000000000000000},
      {2.449489742783178, 0.000000000000000, 0.000000000000000},
      {4.242640687119285, 0.000000000000000, 0.000000000000000}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.000000000000000;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.000000000000000, 0.000000000000000, 0.000000000000000},
      {0.000000000000000, 1.000000000000000, 0.000000000000000},
      {0.000000000000000, 0.000000000000000, 1.000000000000000}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.000000000000000;
            if (t == u)
            {
            dmats[t][u] = 1.000000000000000;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.000000000000000;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[3*num_derivatives];
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      dof_values[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 15; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[3];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
      y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 12:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 13:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 14:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.000000000000000;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[3];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    y[1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[12] = vals[2];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[13] = vals[2];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[14] = vals[2];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[4] = dof_values[7];
    vertex_values[7] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[12];
    vertex_values[5] = dof_values[13];
    vertex_values[8] = dof_values[14];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_10();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_11();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_12();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_0: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_0() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_0()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = m.num_entities[0] + 2.000000000000000*m.num_entities[1] + m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 10;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 10;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 4;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 2;
        break;
      }
    case 2:
      {
        return 1;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + 2*c.entity_indices[1][0];
    dofs[4] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[5] = offset + 2*c.entity_indices[1][1];
    dofs[6] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[7] = offset + 2*c.entity_indices[1][2];
    dofs[8] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*m.num_entities[1];
    dofs[9] = offset + c.entity_indices[2][0];
    offset += m.num_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 5;
      dofs[3] = 6;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 7;
      dofs[3] = 8;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 4;
          break;
        }
      case 1:
        {
          dofs[0] = 5;
        dofs[1] = 6;
          break;
        }
      case 2:
        {
          dofs[0] = 7;
        dofs[1] = 8;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 9;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[3][1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    coordinates[4][0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    coordinates[4][1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    coordinates[5][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    coordinates[5][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    coordinates[6][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    coordinates[6][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    coordinates[7][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    coordinates[7][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    coordinates[8][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    coordinates[8][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    coordinates[9][0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[9][1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_0();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_1: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_1() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_1()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 2.000000000000000*m.num_entities[0] + 4.000000000000000*m.num_entities[1] + 2.000000000000000*m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 20;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 20;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 8;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 2;
        break;
      }
    case 1:
      {
        return 4;
        break;
      }
    case 2:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + 2*c.entity_indices[1][0];
    dofs[4] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[5] = offset + 2*c.entity_indices[1][1];
    dofs[6] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[7] = offset + 2*c.entity_indices[1][2];
    dofs[8] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*m.num_entities[1];
    dofs[9] = offset + c.entity_indices[2][0];
    offset += m.num_entities[2];
    dofs[10] = offset + c.entity_indices[0][0];
    dofs[11] = offset + c.entity_indices[0][1];
    dofs[12] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[13] = offset + 2*c.entity_indices[1][0];
    dofs[14] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[15] = offset + 2*c.entity_indices[1][1];
    dofs[16] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[17] = offset + 2*c.entity_indices[1][2];
    dofs[18] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*m.num_entities[1];
    dofs[19] = offset + c.entity_indices[2][0];
    offset += m.num_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 11;
      dofs[5] = 12;
      dofs[6] = 13;
      dofs[7] = 14;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 10;
      dofs[5] = 12;
      dofs[6] = 15;
      dofs[7] = 16;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 7;
      dofs[3] = 8;
      dofs[4] = 10;
      dofs[5] = 11;
      dofs[6] = 17;
      dofs[7] = 18;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 10;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 11;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 12;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 4;
        dofs[2] = 13;
        dofs[3] = 14;
          break;
        }
      case 1:
        {
          dofs[0] = 5;
        dofs[1] = 6;
        dofs[2] = 15;
        dofs[3] = 16;
          break;
        }
      case 2:
        {
          dofs[0] = 7;
        dofs[1] = 8;
        dofs[2] = 17;
        dofs[3] = 18;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 9;
      dofs[1] = 19;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[3][1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    coordinates[4][0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    coordinates[4][1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    coordinates[5][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    coordinates[5][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    coordinates[6][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    coordinates[6][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    coordinates[7][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    coordinates[7][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    coordinates[8][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    coordinates[8][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    coordinates[9][0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[9][1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    coordinates[10][0] = x[0][0];
    coordinates[10][1] = x[0][1];
    coordinates[11][0] = x[1][0];
    coordinates[11][1] = x[1][1];
    coordinates[12][0] = x[2][0];
    coordinates[12][1] = x[2][1];
    coordinates[13][0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[13][1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    coordinates[14][0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    coordinates[14][1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    coordinates[15][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    coordinates[15][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    coordinates[16][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    coordinates[16][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    coordinates[17][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    coordinates[17][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    coordinates[18][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    coordinates[18][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    coordinates[19][0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[19][1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_0();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_1();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_2: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_2() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_2()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = m.num_entities[0] + m.num_entities[1];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 6;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 6;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 3;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 1;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    coordinates[3][1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    coordinates[4][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    coordinates[4][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    coordinates[5][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    coordinates[5][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_2();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_3: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_3() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_3()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 3.000000000000000*m.num_entities[0] + 5.000000000000000*m.num_entities[1] + 2.000000000000000*m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 26;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 26;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 11;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 3;
        break;
      }
    case 1:
      {
        return 5;
        break;
      }
    case 2:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + 2*c.entity_indices[1][0];
    dofs[4] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[5] = offset + 2*c.entity_indices[1][1];
    dofs[6] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[7] = offset + 2*c.entity_indices[1][2];
    dofs[8] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*m.num_entities[1];
    dofs[9] = offset + c.entity_indices[2][0];
    offset += m.num_entities[2];
    dofs[10] = offset + c.entity_indices[0][0];
    dofs[11] = offset + c.entity_indices[0][1];
    dofs[12] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[13] = offset + 2*c.entity_indices[1][0];
    dofs[14] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[15] = offset + 2*c.entity_indices[1][1];
    dofs[16] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[17] = offset + 2*c.entity_indices[1][2];
    dofs[18] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*m.num_entities[1];
    dofs[19] = offset + c.entity_indices[2][0];
    offset += m.num_entities[2];
    dofs[20] = offset + c.entity_indices[0][0];
    dofs[21] = offset + c.entity_indices[0][1];
    dofs[22] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[23] = offset + c.entity_indices[1][0];
    dofs[24] = offset + c.entity_indices[1][1];
    dofs[25] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 11;
      dofs[5] = 12;
      dofs[6] = 13;
      dofs[7] = 14;
      dofs[8] = 21;
      dofs[9] = 22;
      dofs[10] = 23;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 10;
      dofs[5] = 12;
      dofs[6] = 15;
      dofs[7] = 16;
      dofs[8] = 20;
      dofs[9] = 22;
      dofs[10] = 24;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 7;
      dofs[3] = 8;
      dofs[4] = 10;
      dofs[5] = 11;
      dofs[6] = 17;
      dofs[7] = 18;
      dofs[8] = 20;
      dofs[9] = 21;
      dofs[10] = 25;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 10;
        dofs[2] = 20;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 11;
        dofs[2] = 21;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 12;
        dofs[2] = 22;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 4;
        dofs[2] = 13;
        dofs[3] = 14;
        dofs[4] = 23;
          break;
        }
      case 1:
        {
          dofs[0] = 5;
        dofs[1] = 6;
        dofs[2] = 15;
        dofs[3] = 16;
        dofs[4] = 24;
          break;
        }
      case 2:
        {
          dofs[0] = 7;
        dofs[1] = 8;
        dofs[2] = 17;
        dofs[3] = 18;
        dofs[4] = 25;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 9;
      dofs[1] = 19;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[3][1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    coordinates[4][0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    coordinates[4][1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    coordinates[5][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    coordinates[5][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    coordinates[6][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    coordinates[6][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    coordinates[7][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    coordinates[7][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    coordinates[8][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    coordinates[8][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    coordinates[9][0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[9][1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    coordinates[10][0] = x[0][0];
    coordinates[10][1] = x[0][1];
    coordinates[11][0] = x[1][0];
    coordinates[11][1] = x[1][1];
    coordinates[12][0] = x[2][0];
    coordinates[12][1] = x[2][1];
    coordinates[13][0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[13][1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    coordinates[14][0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    coordinates[14][1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    coordinates[15][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    coordinates[15][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    coordinates[16][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    coordinates[16][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    coordinates[17][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    coordinates[17][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    coordinates[18][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    coordinates[18][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    coordinates[19][0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[19][1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    coordinates[20][0] = x[0][0];
    coordinates[20][1] = x[0][1];
    coordinates[21][0] = x[1][0];
    coordinates[21][1] = x[1][1];
    coordinates[22][0] = x[2][0];
    coordinates[22][1] = x[2][1];
    coordinates[23][0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    coordinates[23][1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    coordinates[24][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    coordinates[24][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    coordinates[25][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    coordinates[25][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_1();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_3();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_4: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_4() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_4()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 1;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 1;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 1;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = c.entity_indices[2][0];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[0][1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_4();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_5: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_5() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_5()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 6.000000000000000*m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 6;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 6;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 6;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 6*c.entity_indices[2][0];
    dofs[1] = 6*c.entity_indices[2][0] + 1;
    dofs[2] = 6*c.entity_indices[2][0] + 2;
    dofs[3] = 6*c.entity_indices[2][0] + 3;
    dofs[4] = 6*c.entity_indices[2][0] + 4;
    dofs[5] = 6*c.entity_indices[2][0] + 5;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      dofs[3] = 3;
      dofs[4] = 4;
      dofs[5] = 5;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    coordinates[3][1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    coordinates[4][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    coordinates[4][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    coordinates[5][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    coordinates[5][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_5();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_6: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_6() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_6()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 12.000000000000000*m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 12;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 12;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 12;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + 6*c.entity_indices[2][0];
    dofs[1] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[2] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[3] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[4] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[5] = offset + 6*c.entity_indices[2][0] + 5;
    offset += 6*m.num_entities[2];
    dofs[6] = offset + 6*c.entity_indices[2][0];
    dofs[7] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[8] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[9] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[10] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[11] = offset + 6*c.entity_indices[2][0] + 5;
    offset += 6*m.num_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      dofs[3] = 3;
      dofs[4] = 4;
      dofs[5] = 5;
      dofs[6] = 6;
      dofs[7] = 7;
      dofs[8] = 8;
      dofs[9] = 9;
      dofs[10] = 10;
      dofs[11] = 11;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    coordinates[3][1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    coordinates[4][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    coordinates[4][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    coordinates[5][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    coordinates[5][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    coordinates[6][0] = x[0][0];
    coordinates[6][1] = x[0][1];
    coordinates[7][0] = x[1][0];
    coordinates[7][1] = x[1][1];
    coordinates[8][0] = x[2][0];
    coordinates[8][1] = x[2][1];
    coordinates[9][0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    coordinates[9][1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    coordinates[10][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    coordinates[10][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    coordinates[11][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    coordinates[11][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_6();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_7: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_7() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_7()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 3.000000000000000*m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 3;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 3;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 3*c.entity_indices[2][0];
    dofs[1] = 3*c.entity_indices[2][0] + 1;
    dofs[2] = 3*c.entity_indices[2][0] + 2;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_7();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_8: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_8() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_8()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 15.000000000000000*m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 15;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 15;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 15;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + 6*c.entity_indices[2][0];
    dofs[1] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[2] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[3] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[4] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[5] = offset + 6*c.entity_indices[2][0] + 5;
    offset += 6*m.num_entities[2];
    dofs[6] = offset + 6*c.entity_indices[2][0];
    dofs[7] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[8] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[9] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[10] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[11] = offset + 6*c.entity_indices[2][0] + 5;
    offset += 6*m.num_entities[2];
    dofs[12] = offset + 3*c.entity_indices[2][0];
    dofs[13] = offset + 3*c.entity_indices[2][0] + 1;
    dofs[14] = offset + 3*c.entity_indices[2][0] + 2;
    offset += 3*m.num_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      dofs[3] = 3;
      dofs[4] = 4;
      dofs[5] = 5;
      dofs[6] = 6;
      dofs[7] = 7;
      dofs[8] = 8;
      dofs[9] = 9;
      dofs[10] = 10;
      dofs[11] = 11;
      dofs[12] = 12;
      dofs[13] = 13;
      dofs[14] = 14;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    coordinates[3][1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    coordinates[4][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    coordinates[4][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    coordinates[5][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    coordinates[5][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    coordinates[6][0] = x[0][0];
    coordinates[6][1] = x[0][1];
    coordinates[7][0] = x[1][0];
    coordinates[7][1] = x[1][1];
    coordinates[8][0] = x[2][0];
    coordinates[8][1] = x[2][1];
    coordinates[9][0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    coordinates[9][1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    coordinates[10][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    coordinates[10][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    coordinates[11][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    coordinates[11][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    coordinates[12][0] = x[0][0];
    coordinates[12][1] = x[0][1];
    coordinates[13][0] = x[1][0];
    coordinates[13][1] = x[1][1];
    coordinates[14][0] = x[2][0];
    coordinates[14][1] = x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_6();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_7();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_8();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_9: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_9() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_9()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 0, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 1;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 1;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 1;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = c.entity_indices[2][0];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[0][1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_9();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_10: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_10() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_10()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 2.000000000000000*m.num_entities[0] + 2.000000000000000*m.num_entities[1];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 12;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 12;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 6;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 2;
        break;
      }
    case 1:
      {
        return 2;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
    dofs[6] = offset + c.entity_indices[0][0];
    dofs[7] = offset + c.entity_indices[0][1];
    dofs[8] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[9] = offset + c.entity_indices[1][0];
    dofs[10] = offset + c.entity_indices[1][1];
    dofs[11] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 7;
      dofs[4] = 8;
      dofs[5] = 9;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
      dofs[3] = 6;
      dofs[4] = 8;
      dofs[5] = 10;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 7;
      dofs[5] = 11;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 6;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 7;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 8;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 9;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
        dofs[1] = 10;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
        dofs[1] = 11;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    coordinates[3][1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    coordinates[4][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    coordinates[4][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    coordinates[5][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    coordinates[5][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    coordinates[6][0] = x[0][0];
    coordinates[6][1] = x[0][1];
    coordinates[7][0] = x[1][0];
    coordinates[7][1] = x[1][1];
    coordinates[8][0] = x[2][0];
    coordinates[8][1] = x[2][1];
    coordinates[9][0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    coordinates[9][1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    coordinates[10][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    coordinates[10][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    coordinates[11][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    coordinates[11][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_2();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_10();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_11: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_11() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_11()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = m.num_entities[0];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 3;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 3;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 2;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = c.entity_indices[0][0];
    dofs[1] = c.entity_indices[0][1];
    dofs[2] = c.entity_indices[0][2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_11();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_12: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_12() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_12()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 3.000000000000000*m.num_entities[0] + 2.000000000000000*m.num_entities[1];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 15;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 15;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 8;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 3;
        break;
      }
    case 1:
      {
        return 2;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
    dofs[6] = offset + c.entity_indices[0][0];
    dofs[7] = offset + c.entity_indices[0][1];
    dofs[8] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[9] = offset + c.entity_indices[1][0];
    dofs[10] = offset + c.entity_indices[1][1];
    dofs[11] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
    dofs[12] = offset + c.entity_indices[0][0];
    dofs[13] = offset + c.entity_indices[0][1];
    dofs[14] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 7;
      dofs[4] = 8;
      dofs[5] = 9;
      dofs[6] = 13;
      dofs[7] = 14;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
      dofs[3] = 6;
      dofs[4] = 8;
      dofs[5] = 10;
      dofs[6] = 12;
      dofs[7] = 14;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 7;
      dofs[5] = 11;
      dofs[6] = 12;
      dofs[7] = 13;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 6;
        dofs[2] = 12;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 7;
        dofs[2] = 13;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 8;
        dofs[2] = 14;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 9;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
        dofs[1] = 10;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
        dofs[1] = 11;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    coordinates[3][1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    coordinates[4][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    coordinates[4][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    coordinates[5][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    coordinates[5][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    coordinates[6][0] = x[0][0];
    coordinates[6][1] = x[0][1];
    coordinates[7][0] = x[1][0];
    coordinates[7][1] = x[1][1];
    coordinates[8][0] = x[2][0];
    coordinates[8][1] = x[2][1];
    coordinates[9][0] = 0.500000000000000*x[1][0] + 0.500000000000000*x[2][0];
    coordinates[9][1] = 0.500000000000000*x[1][1] + 0.500000000000000*x[2][1];
    coordinates[10][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[2][0];
    coordinates[10][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[2][1];
    coordinates[11][0] = 0.500000000000000*x[0][0] + 0.500000000000000*x[1][0];
    coordinates[11][1] = 0.500000000000000*x[0][1] + 0.500000000000000*x[1][1];
    coordinates[12][0] = x[0][0];
    coordinates[12][1] = x[0][1];
    coordinates[13][0] = x[1][0];
    coordinates[13][1] = x[1][1];
    coordinates[14][0] = x[2][0];
    coordinates[14][1] = x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_10();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_11();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_12();
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_0_0: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_0_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_0_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      11
    // Number of operations (multiply-add pairs) for geometry tensor:    172
    // Number of operations (multiply-add pairs) for tensor contraction: 2992
    // Total number of operations (multiply-add pairs):                  3175
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0 = det*K_00*(1.0);
    const double G0_1 = det*K_10*(1.0);
    const double G1_0 = det*K_01*(1.0);
    const double G1_1 = det*K_11*(1.0);
    const double G2_0_0_0 = det*w[1][0]*K_00*K_00*(1.0);
    const double G2_0_0_1 = det*w[1][0]*K_00*K_10*(1.0);
    const double G2_0_1_0 = det*w[1][0]*K_10*K_00*(1.0);
    const double G2_0_1_1 = det*w[1][0]*K_10*K_10*(1.0);
    const double G3_0_0_0 = det*w[1][0]*K_00*K_00*(1.0);
    const double G3_0_0_1 = det*w[1][0]*K_00*K_10*(1.0);
    const double G3_0_1_0 = det*w[1][0]*K_10*K_00*(1.0);
    const double G3_0_1_1 = det*w[1][0]*K_10*K_10*(1.0);
    const double G4_0_0_0 = det*w[1][0]*K_01*K_01*(1.0);
    const double G4_0_0_1 = det*w[1][0]*K_01*K_11*(1.0);
    const double G4_0_1_0 = det*w[1][0]*K_11*K_01*(1.0);
    const double G4_0_1_1 = det*w[1][0]*K_11*K_11*(1.0);
    const double G5_0_0_0 = det*w[1][0]*K_01*K_01*(1.0);
    const double G5_0_0_1 = det*w[1][0]*K_01*K_11*(1.0);
    const double G5_0_1_0 = det*w[1][0]*K_11*K_01*(1.0);
    const double G5_0_1_1 = det*w[1][0]*K_11*K_11*(1.0);
    const double G6_0 = det*K_00*(1.0);
    const double G6_1 = det*K_10*(1.0);
    const double G7_0 = det*K_01*(1.0);
    const double G7_1 = det*K_11*(1.0);
    const double G8_0_0 = det*w[0][0]*K_00*(1.0);
    const double G8_0_1 = det*w[0][0]*K_10*(1.0);
    const double G8_1_0 = det*w[0][1]*K_00*(1.0);
    const double G8_2_1 = det*w[0][2]*K_10*(1.0);
    const double G8_3_0 = det*w[0][3]*K_00*(1.0);
    const double G8_3_1 = det*w[0][3]*K_10*(1.0);
    const double G8_4_0 = det*w[0][4]*K_00*(1.0);
    const double G8_4_1 = det*w[0][4]*K_10*(1.0);
    const double G8_5_0 = det*w[0][5]*K_00*(1.0);
    const double G8_5_1 = det*w[0][5]*K_10*(1.0);
    const double G9_0_0 = det*w[0][0]*K_00*(1.0);
    const double G9_0_1 = det*w[0][0]*K_10*(1.0);
    const double G9_1_0 = det*w[0][1]*K_00*(1.0);
    const double G9_1_1 = det*w[0][1]*K_10*(1.0);
    const double G9_2_0 = det*w[0][2]*K_00*(1.0);
    const double G9_2_1 = det*w[0][2]*K_10*(1.0);
    const double G9_3_0 = det*w[0][3]*K_00*(1.0);
    const double G9_3_1 = det*w[0][3]*K_10*(1.0);
    const double G9_4_0 = det*w[0][4]*K_00*(1.0);
    const double G9_4_1 = det*w[0][4]*K_10*(1.0);
    const double G9_5_0 = det*w[0][5]*K_00*(1.0);
    const double G9_5_1 = det*w[0][5]*K_10*(1.0);
    const double G10_0_0 = det*w[0][0]*K_01*(1.0);
    const double G10_0_1 = det*w[0][0]*K_11*(1.0);
    const double G10_1_0 = det*w[0][1]*K_01*(1.0);
    const double G10_2_1 = det*w[0][2]*K_11*(1.0);
    const double G10_3_0 = det*w[0][3]*K_01*(1.0);
    const double G10_3_1 = det*w[0][3]*K_11*(1.0);
    const double G10_4_0 = det*w[0][4]*K_01*(1.0);
    const double G10_4_1 = det*w[0][4]*K_11*(1.0);
    const double G10_5_0 = det*w[0][5]*K_01*(1.0);
    const double G10_5_1 = det*w[0][5]*K_11*(1.0);
    const double G11_6_0 = det*w[0][6]*K_01*(1.0);
    const double G11_6_1 = det*w[0][6]*K_11*(1.0);
    const double G11_7_0 = det*w[0][7]*K_01*(1.0);
    const double G11_7_1 = det*w[0][7]*K_11*(1.0);
    const double G11_8_0 = det*w[0][8]*K_01*(1.0);
    const double G11_8_1 = det*w[0][8]*K_11*(1.0);
    const double G11_9_0 = det*w[0][9]*K_01*(1.0);
    const double G11_9_1 = det*w[0][9]*K_11*(1.0);
    const double G11_10_0 = det*w[0][10]*K_01*(1.0);
    const double G11_10_1 = det*w[0][10]*K_11*(1.0);
    const double G11_11_0 = det*w[0][11]*K_01*(1.0);
    const double G11_11_1 = det*w[0][11]*K_11*(1.0);
    const double G12_6_0 = det*w[0][6]*K_00*(1.0);
    const double G12_6_1 = det*w[0][6]*K_10*(1.0);
    const double G12_7_0 = det*w[0][7]*K_00*(1.0);
    const double G12_8_1 = det*w[0][8]*K_10*(1.0);
    const double G12_9_0 = det*w[0][9]*K_00*(1.0);
    const double G12_9_1 = det*w[0][9]*K_10*(1.0);
    const double G12_10_0 = det*w[0][10]*K_00*(1.0);
    const double G12_10_1 = det*w[0][10]*K_10*(1.0);
    const double G12_11_0 = det*w[0][11]*K_00*(1.0);
    const double G12_11_1 = det*w[0][11]*K_10*(1.0);
    const double G13_0_0 = det*w[0][0]*K_00*(1.0);
    const double G13_0_1 = det*w[0][0]*K_10*(1.0);
    const double G13_1_0 = det*w[0][1]*K_00*(1.0);
    const double G13_1_1 = det*w[0][1]*K_10*(1.0);
    const double G13_2_0 = det*w[0][2]*K_00*(1.0);
    const double G13_2_1 = det*w[0][2]*K_10*(1.0);
    const double G13_3_0 = det*w[0][3]*K_00*(1.0);
    const double G13_3_1 = det*w[0][3]*K_10*(1.0);
    const double G13_4_0 = det*w[0][4]*K_00*(1.0);
    const double G13_4_1 = det*w[0][4]*K_10*(1.0);
    const double G13_5_0 = det*w[0][5]*K_00*(1.0);
    const double G13_5_1 = det*w[0][5]*K_10*(1.0);
    const double G14_6_0 = det*w[0][6]*K_01*(1.0);
    const double G14_6_1 = det*w[0][6]*K_11*(1.0);
    const double G14_7_0 = det*w[0][7]*K_01*(1.0);
    const double G14_8_1 = det*w[0][8]*K_11*(1.0);
    const double G14_9_0 = det*w[0][9]*K_01*(1.0);
    const double G14_9_1 = det*w[0][9]*K_11*(1.0);
    const double G14_10_0 = det*w[0][10]*K_01*(1.0);
    const double G14_10_1 = det*w[0][10]*K_11*(1.0);
    const double G14_11_0 = det*w[0][11]*K_01*(1.0);
    const double G14_11_1 = det*w[0][11]*K_11*(1.0);
    const double G15_6_0 = det*w[0][6]*K_01*(1.0);
    const double G15_6_1 = det*w[0][6]*K_11*(1.0);
    const double G15_7_0 = det*w[0][7]*K_01*(1.0);
    const double G15_7_1 = det*w[0][7]*K_11*(1.0);
    const double G15_8_0 = det*w[0][8]*K_01*(1.0);
    const double G15_8_1 = det*w[0][8]*K_11*(1.0);
    const double G15_9_0 = det*w[0][9]*K_01*(1.0);
    const double G15_9_1 = det*w[0][9]*K_11*(1.0);
    const double G15_10_0 = det*w[0][10]*K_01*(1.0);
    const double G15_10_1 = det*w[0][10]*K_11*(1.0);
    const double G15_11_0 = det*w[0][11]*K_01*(1.0);
    const double G15_11_1 = det*w[0][11]*K_11*(1.0);
    
    // Compute element tensor
    A[0] = 0.500000000000000*G2_0_0_0 + 0.500000000000000*G2_0_0_1 + 0.500000000000000*G2_0_1_0 + 0.500000000000000*G2_0_1_1 + 0.500000000000000*G4_0_0_0 + 0.500000000000000*G4_0_0_1 + 0.500000000000000*G4_0_1_0 + 0.500000000000000*G4_0_1_1 - 0.030952380952381*G8_0_0 - 0.030952380952381*G8_0_1 - 0.007142857142857*G8_1_0 - 0.007142857142857*G8_2_1 + 0.009523809523810*G8_3_0 + 0.009523809523810*G8_3_1 - 0.009523809523810*G8_4_0 + 0.038095238095238*G8_4_1 + 0.038095238095238*G8_5_0 - 0.009523809523810*G8_5_1 - 0.030952380952381*G9_0_0 - 0.030952380952381*G9_0_1 + 0.003571428571429*G9_1_0 + 0.003571428571429*G9_1_1 + 0.003571428571429*G9_2_0 + 0.003571428571429*G9_2_1 - 0.004761904761905*G9_3_0 - 0.004761904761905*G9_3_1 - 0.019047619047619*G9_4_0 - 0.019047619047619*G9_4_1 - 0.019047619047619*G9_5_0 - 0.019047619047619*G9_5_1 - 0.030952380952381*G11_6_0 - 0.030952380952381*G11_6_1 + 0.003571428571429*G11_7_0 + 0.003571428571429*G11_7_1 + 0.003571428571429*G11_8_0 + 0.003571428571429*G11_8_1 - 0.004761904761905*G11_9_0 - 0.004761904761905*G11_9_1 - 0.019047619047619*G11_10_0 - 0.019047619047619*G11_10_1 - 0.019047619047619*G11_11_0 - 0.019047619047619*G11_11_1;
    A[1] = 0.166666666666667*G2_0_0_0 + 0.166666666666667*G2_0_1_0 + 0.166666666666667*G4_0_0_0 + 0.166666666666667*G4_0_1_0 + 0.003571428571429*G8_0_0 + 0.003571428571429*G8_0_1 - 0.003571428571429*G8_1_0 + 0.004365079365079*G8_2_1 + 0.001587301587302*G8_3_0 - 0.006349206349206*G8_3_1 - 0.001587301587302*G8_4_0 - 0.007936507936508*G8_4_1 + 0.006349206349206*G8_5_1 + 0.003571428571429*G9_0_0 + 0.003571428571429*G9_0_1 + 0.007142857142857*G9_1_0 + 0.007142857142857*G9_1_1 - 0.004365079365079*G9_2_0 - 0.004365079365079*G9_2_1 + 0.006349206349206*G9_3_0 + 0.006349206349206*G9_3_1 + 0.007936507936508*G9_4_0 + 0.007936507936508*G9_4_1 + 0.012698412698413*G9_5_0 + 0.012698412698413*G9_5_1 + 0.003571428571429*G11_6_0 + 0.003571428571429*G11_6_1 + 0.007142857142857*G11_7_0 + 0.007142857142857*G11_7_1 - 0.004365079365079*G11_8_0 - 0.004365079365079*G11_8_1 + 0.006349206349206*G11_9_0 + 0.006349206349206*G11_9_1 + 0.007936507936508*G11_10_0 + 0.007936507936508*G11_10_1 + 0.012698412698413*G11_11_0 + 0.012698412698413*G11_11_1;
    A[2] = 0.166666666666667*G2_0_0_1 + 0.166666666666667*G2_0_1_1 + 0.166666666666667*G4_0_0_1 + 0.166666666666667*G4_0_1_1 + 0.003571428571429*G8_0_0 + 0.003571428571429*G8_0_1 + 0.004365079365079*G8_1_0 - 0.003571428571429*G8_2_1 - 0.006349206349206*G8_3_0 + 0.001587301587302*G8_3_1 + 0.006349206349206*G8_4_0 - 0.007936507936508*G8_5_0 - 0.001587301587302*G8_5_1 + 0.003571428571429*G9_0_0 + 0.003571428571429*G9_0_1 - 0.004365079365079*G9_1_0 - 0.004365079365079*G9_1_1 + 0.007142857142857*G9_2_0 + 0.007142857142857*G9_2_1 + 0.006349206349206*G9_3_0 + 0.006349206349206*G9_3_1 + 0.012698412698413*G9_4_0 + 0.012698412698413*G9_4_1 + 0.007936507936508*G9_5_0 + 0.007936507936508*G9_5_1 + 0.003571428571429*G11_6_0 + 0.003571428571429*G11_6_1 - 0.004365079365079*G11_7_0 - 0.004365079365079*G11_7_1 + 0.007142857142857*G11_8_0 + 0.007142857142857*G11_8_1 + 0.006349206349206*G11_9_0 + 0.006349206349206*G11_9_1 + 0.012698412698413*G11_10_0 + 0.012698412698413*G11_10_1 + 0.007936507936508*G11_11_0 + 0.007936507936508*G11_11_1;
    A[3] = -0.004761904761905*G8_0_0 - 0.004761904761905*G8_0_1 - 0.007936507936508*G8_1_0 - 0.007936507936508*G8_2_1 - 0.019047619047619*G8_3_0 - 0.019047619047619*G8_3_1 + 0.019047619047619*G8_4_0 + 0.012698412698413*G8_4_1 + 0.012698412698413*G8_5_0 + 0.019047619047619*G8_5_1 - 0.004761904761905*G9_0_0 - 0.004761904761905*G9_0_1 + 0.006349206349206*G9_1_0 + 0.006349206349206*G9_1_1 + 0.006349206349206*G9_2_0 + 0.006349206349206*G9_2_1 + 0.038095238095238*G9_3_0 + 0.038095238095238*G9_3_1 - 0.006349206349206*G9_4_0 - 0.006349206349206*G9_4_1 - 0.006349206349206*G9_5_0 - 0.006349206349206*G9_5_1 - 0.004761904761905*G11_6_0 - 0.004761904761905*G11_6_1 + 0.006349206349206*G11_7_0 + 0.006349206349206*G11_7_1 + 0.006349206349206*G11_8_0 + 0.006349206349206*G11_8_1 + 0.038095238095238*G11_9_0 + 0.038095238095238*G11_9_1 - 0.006349206349206*G11_10_0 - 0.006349206349206*G11_10_1 - 0.006349206349206*G11_11_0 - 0.006349206349206*G11_11_1;
    A[4] = -0.666666666666667*G2_0_0_1 - 0.666666666666667*G2_0_1_1 - 0.666666666666667*G4_0_0_1 - 0.666666666666667*G4_0_1_1 - 0.019047619047619*G8_0_0 - 0.019047619047619*G8_0_1 - 0.006349206349206*G8_1_0 - 0.012698412698413*G8_2_1 - 0.012698412698413*G8_3_0 - 0.006349206349206*G8_3_1 + 0.012698412698413*G8_4_0 + 0.031746031746032*G8_4_1 + 0.025396825396825*G8_5_0 + 0.006349206349206*G8_5_1 - 0.019047619047619*G9_0_0 - 0.019047619047619*G9_0_1 + 0.007936507936508*G9_1_0 + 0.007936507936508*G9_1_1 + 0.012698412698413*G9_2_0 + 0.012698412698413*G9_2_1 - 0.006349206349206*G9_3_0 - 0.006349206349206*G9_3_1 - 0.063492063492063*G9_4_0 - 0.063492063492063*G9_4_1 - 0.031746031746032*G9_5_0 - 0.031746031746032*G9_5_1 - 0.019047619047619*G11_6_0 - 0.019047619047619*G11_6_1 + 0.007936507936508*G11_7_0 + 0.007936507936508*G11_7_1 + 0.012698412698413*G11_8_0 + 0.012698412698413*G11_8_1 - 0.006349206349206*G11_9_0 - 0.006349206349206*G11_9_1 - 0.063492063492063*G11_10_0 - 0.063492063492063*G11_10_1 - 0.031746031746032*G11_11_0 - 0.031746031746032*G11_11_1;
    A[5] = -0.666666666666667*G2_0_0_0 - 0.666666666666667*G2_0_1_0 - 0.666666666666667*G4_0_0_0 - 0.666666666666667*G4_0_1_0 - 0.019047619047619*G8_0_0 - 0.019047619047619*G8_0_1 - 0.012698412698413*G8_1_0 - 0.006349206349206*G8_2_1 - 0.006349206349206*G8_3_0 - 0.012698412698413*G8_3_1 + 0.006349206349206*G8_4_0 + 0.025396825396825*G8_4_1 + 0.031746031746032*G8_5_0 + 0.012698412698413*G8_5_1 - 0.019047619047619*G9_0_0 - 0.019047619047619*G9_0_1 + 0.012698412698413*G9_1_0 + 0.012698412698413*G9_1_1 + 0.007936507936508*G9_2_0 + 0.007936507936508*G9_2_1 - 0.006349206349206*G9_3_0 - 0.006349206349206*G9_3_1 - 0.031746031746032*G9_4_0 - 0.031746031746032*G9_4_1 - 0.063492063492063*G9_5_0 - 0.063492063492063*G9_5_1 - 0.019047619047619*G11_6_0 - 0.019047619047619*G11_6_1 + 0.012698412698413*G11_7_0 + 0.012698412698413*G11_7_1 + 0.007936507936508*G11_8_0 + 0.007936507936508*G11_8_1 - 0.006349206349206*G11_9_0 - 0.006349206349206*G11_9_1 - 0.031746031746032*G11_10_0 - 0.031746031746032*G11_10_1 - 0.063492063492063*G11_11_0 - 0.063492063492063*G11_11_1;
    A[6] = -0.030952380952381*G12_6_0 - 0.030952380952381*G12_6_1 - 0.007142857142857*G12_7_0 - 0.007142857142857*G12_8_1 + 0.009523809523810*G12_9_0 + 0.009523809523810*G12_9_1 - 0.009523809523810*G12_10_0 + 0.038095238095238*G12_10_1 + 0.038095238095238*G12_11_0 - 0.009523809523810*G12_11_1;
    A[7] = 0.003571428571429*G12_6_0 + 0.003571428571429*G12_6_1 - 0.003571428571429*G12_7_0 + 0.004365079365079*G12_8_1 + 0.001587301587302*G12_9_0 - 0.006349206349206*G12_9_1 - 0.001587301587302*G12_10_0 - 0.007936507936508*G12_10_1 + 0.006349206349206*G12_11_1;
    A[8] = 0.003571428571429*G12_6_0 + 0.003571428571429*G12_6_1 + 0.004365079365079*G12_7_0 - 0.003571428571429*G12_8_1 - 0.006349206349206*G12_9_0 + 0.001587301587302*G12_9_1 + 0.006349206349206*G12_10_0 - 0.007936507936508*G12_11_0 - 0.001587301587302*G12_11_1;
    A[9] = -0.004761904761905*G12_6_0 - 0.004761904761905*G12_6_1 - 0.007936507936508*G12_7_0 - 0.007936507936508*G12_8_1 - 0.019047619047619*G12_9_0 - 0.019047619047619*G12_9_1 + 0.019047619047619*G12_10_0 + 0.012698412698413*G12_10_1 + 0.012698412698413*G12_11_0 + 0.019047619047619*G12_11_1;
    A[10] = -0.019047619047619*G12_6_0 - 0.019047619047619*G12_6_1 - 0.006349206349206*G12_7_0 - 0.012698412698413*G12_8_1 - 0.012698412698413*G12_9_0 - 0.006349206349206*G12_9_1 + 0.012698412698413*G12_10_0 + 0.031746031746032*G12_10_1 + 0.025396825396825*G12_11_0 + 0.006349206349206*G12_11_1;
    A[11] = -0.019047619047619*G12_6_0 - 0.019047619047619*G12_6_1 - 0.012698412698413*G12_7_0 - 0.006349206349206*G12_8_1 - 0.006349206349206*G12_9_0 - 0.012698412698413*G12_9_1 + 0.006349206349206*G12_10_0 + 0.025396825396825*G12_10_1 + 0.031746031746032*G12_11_0 + 0.012698412698413*G12_11_1;
    A[12] = -0.166666666666667*G0_0 - 0.166666666666667*G0_1;
    A[13] = 0.000000000000000;
    A[14] = 0.000000000000000;
    A[15] = 0.166666666666667*G2_0_0_0 + 0.166666666666667*G2_0_0_1 + 0.166666666666667*G4_0_0_0 + 0.166666666666667*G4_0_0_1 + 0.003571428571429*G8_0_0 + 0.003571428571429*G8_0_1 - 0.003571428571429*G8_1_0 + 0.004365079365079*G8_2_1 + 0.001587301587302*G8_3_0 - 0.006349206349206*G8_3_1 - 0.001587301587302*G8_4_0 - 0.007936507936508*G8_4_1 + 0.006349206349206*G8_5_1 - 0.007142857142857*G9_0_0 - 0.003571428571429*G9_1_0 + 0.004365079365079*G9_2_0 - 0.007936507936508*G9_3_0 - 0.006349206349206*G9_4_0 - 0.012698412698413*G9_5_0 - 0.007142857142857*G11_6_0 - 0.003571428571429*G11_7_0 + 0.004365079365079*G11_8_0 - 0.007936507936508*G11_9_0 - 0.006349206349206*G11_10_0 - 0.012698412698413*G11_11_0;
    A[16] = 0.500000000000000*G2_0_0_0 + 0.500000000000000*G4_0_0_0 + 0.007142857142857*G8_0_0 + 0.007142857142857*G8_0_1 + 0.030952380952381*G8_1_0 - 0.007142857142857*G8_2_1 + 0.009523809523810*G8_3_0 + 0.047619047619048*G8_3_1 - 0.009523809523810*G8_4_0 - 0.038095238095238*G8_5_0 - 0.047619047619048*G8_5_1 - 0.003571428571429*G9_0_0 + 0.030952380952381*G9_1_0 - 0.003571428571429*G9_2_0 + 0.019047619047619*G9_3_0 + 0.004761904761905*G9_4_0 + 0.019047619047619*G9_5_0 - 0.003571428571429*G11_6_0 + 0.030952380952381*G11_7_0 - 0.003571428571429*G11_8_0 + 0.019047619047619*G11_9_0 + 0.004761904761905*G11_10_0 + 0.019047619047619*G11_11_0;
    A[17] = -0.166666666666667*G2_0_0_1 - 0.166666666666667*G4_0_0_1 - 0.004365079365079*G8_0_0 - 0.004365079365079*G8_0_1 - 0.003571428571429*G8_1_0 - 0.003571428571429*G8_2_1 - 0.006349206349206*G8_3_0 - 0.006349206349206*G8_3_1 + 0.006349206349206*G8_4_0 + 0.007936507936508*G8_4_1 + 0.007936507936508*G8_5_0 + 0.006349206349206*G8_5_1 + 0.004365079365079*G9_0_0 - 0.003571428571429*G9_1_0 - 0.007142857142857*G9_2_0 - 0.012698412698413*G9_3_0 - 0.006349206349206*G9_4_0 - 0.007936507936508*G9_5_0 + 0.004365079365079*G11_6_0 - 0.003571428571429*G11_7_0 - 0.007142857142857*G11_8_0 - 0.012698412698413*G11_9_0 - 0.006349206349206*G11_10_0 - 0.007936507936508*G11_11_0;
    A[18] = 0.666666666666666*G2_0_0_1 + 0.666666666666666*G4_0_0_1 + 0.006349206349206*G8_0_0 + 0.006349206349206*G8_0_1 + 0.019047619047619*G8_1_0 - 0.012698412698413*G8_2_1 - 0.012698412698413*G8_3_0 + 0.019047619047619*G8_3_1 + 0.012698412698413*G8_4_0 + 0.006349206349206*G8_4_1 - 0.025396825396825*G8_5_0 - 0.019047619047619*G8_5_1 - 0.007936507936508*G9_0_0 + 0.019047619047619*G9_1_0 - 0.012698412698413*G9_2_0 + 0.063492063492063*G9_3_0 + 0.006349206349206*G9_4_0 + 0.031746031746032*G9_5_0 - 0.007936507936508*G11_6_0 + 0.019047619047619*G11_7_0 - 0.012698412698413*G11_8_0 + 0.063492063492063*G11_9_0 + 0.006349206349206*G11_10_0 + 0.031746031746032*G11_11_0;
    A[19] = 0.007936507936508*G8_0_0 + 0.007936507936508*G8_0_1 + 0.004761904761905*G8_1_0 - 0.007936507936508*G8_2_1 - 0.019047619047619*G8_3_0 - 0.006349206349206*G8_3_1 + 0.019047619047619*G8_4_0 - 0.012698412698413*G8_5_0 + 0.006349206349206*G8_5_1 - 0.006349206349206*G9_0_0 + 0.004761904761905*G9_1_0 - 0.006349206349206*G9_2_0 + 0.006349206349206*G9_3_0 - 0.038095238095238*G9_4_0 + 0.006349206349206*G9_5_0 - 0.006349206349206*G11_6_0 + 0.004761904761905*G11_7_0 - 0.006349206349206*G11_8_0 + 0.006349206349206*G11_9_0 - 0.038095238095238*G11_10_0 + 0.006349206349206*G11_11_0;
    A[20] = -0.666666666666666*G2_0_0_0 - 0.666666666666666*G2_0_0_1 - 0.666666666666666*G4_0_0_0 - 0.666666666666666*G4_0_0_1 + 0.012698412698413*G8_0_0 + 0.012698412698413*G8_0_1 + 0.019047619047619*G8_1_0 - 0.006349206349206*G8_2_1 - 0.006349206349206*G8_3_0 + 0.019047619047619*G8_3_1 + 0.006349206349206*G8_4_0 - 0.006349206349206*G8_4_1 - 0.031746031746032*G8_5_0 - 0.019047619047619*G8_5_1 - 0.012698412698413*G9_0_0 + 0.019047619047619*G9_1_0 - 0.007936507936508*G9_2_0 + 0.031746031746032*G9_3_0 + 0.006349206349206*G9_4_0 + 0.063492063492064*G9_5_0 - 0.012698412698413*G11_6_0 + 0.019047619047619*G11_7_0 - 0.007936507936508*G11_8_0 + 0.031746031746032*G11_9_0 + 0.006349206349206*G11_10_0 + 0.063492063492064*G11_11_0;
    A[21] = 0.003571428571429*G12_6_0 + 0.003571428571429*G12_6_1 - 0.003571428571429*G12_7_0 + 0.004365079365079*G12_8_1 + 0.001587301587302*G12_9_0 - 0.006349206349206*G12_9_1 - 0.001587301587302*G12_10_0 - 0.007936507936508*G12_10_1 + 0.006349206349206*G12_11_1;
    A[22] = 0.007142857142857*G12_6_0 + 0.007142857142857*G12_6_1 + 0.030952380952381*G12_7_0 - 0.007142857142857*G12_8_1 + 0.009523809523810*G12_9_0 + 0.047619047619048*G12_9_1 - 0.009523809523810*G12_10_0 - 0.038095238095238*G12_11_0 - 0.047619047619048*G12_11_1;
    A[23] = -0.004365079365079*G12_6_0 - 0.004365079365079*G12_6_1 - 0.003571428571429*G12_7_0 - 0.003571428571429*G12_8_1 - 0.006349206349206*G12_9_0 - 0.006349206349206*G12_9_1 + 0.006349206349206*G12_10_0 + 0.007936507936508*G12_10_1 + 0.007936507936508*G12_11_0 + 0.006349206349206*G12_11_1;
    A[24] = 0.006349206349206*G12_6_0 + 0.006349206349206*G12_6_1 + 0.019047619047619*G12_7_0 - 0.012698412698413*G12_8_1 - 0.012698412698413*G12_9_0 + 0.019047619047619*G12_9_1 + 0.012698412698413*G12_10_0 + 0.006349206349206*G12_10_1 - 0.025396825396825*G12_11_0 - 0.019047619047619*G12_11_1;
    A[25] = 0.007936507936508*G12_6_0 + 0.007936507936508*G12_6_1 + 0.004761904761905*G12_7_0 - 0.007936507936508*G12_8_1 - 0.019047619047619*G12_9_0 - 0.006349206349206*G12_9_1 + 0.019047619047619*G12_10_0 - 0.012698412698413*G12_11_0 + 0.006349206349206*G12_11_1;
    A[26] = 0.012698412698413*G12_6_0 + 0.012698412698413*G12_6_1 + 0.019047619047619*G12_7_0 - 0.006349206349206*G12_8_1 - 0.006349206349206*G12_9_0 + 0.019047619047619*G12_9_1 + 0.006349206349206*G12_10_0 - 0.006349206349206*G12_10_1 - 0.031746031746032*G12_11_0 - 0.019047619047619*G12_11_1;
    A[27] = 0.000000000000000;
    A[28] = 0.166666666666667*G0_0;
    A[29] = 0.000000000000000;
    A[30] = 0.166666666666667*G2_0_1_0 + 0.166666666666667*G2_0_1_1 + 0.166666666666667*G4_0_1_0 + 0.166666666666667*G4_0_1_1 + 0.003571428571429*G8_0_0 + 0.003571428571429*G8_0_1 + 0.004365079365079*G8_1_0 - 0.003571428571429*G8_2_1 - 0.006349206349206*G8_3_0 + 0.001587301587302*G8_3_1 + 0.006349206349206*G8_4_0 - 0.007936507936508*G8_5_0 - 0.001587301587302*G8_5_1 - 0.007142857142857*G9_0_1 + 0.004365079365079*G9_1_1 - 0.003571428571429*G9_2_1 - 0.007936507936508*G9_3_1 - 0.012698412698413*G9_4_1 - 0.006349206349206*G9_5_1 - 0.007142857142857*G11_6_1 + 0.004365079365079*G11_7_1 - 0.003571428571429*G11_8_1 - 0.007936507936508*G11_9_1 - 0.012698412698413*G11_10_1 - 0.006349206349206*G11_11_1;
    A[31] = -0.166666666666667*G2_0_1_0 - 0.166666666666667*G4_0_1_0 - 0.004365079365079*G8_0_0 - 0.004365079365079*G8_0_1 - 0.003571428571429*G8_1_0 - 0.003571428571429*G8_2_1 - 0.006349206349206*G8_3_0 - 0.006349206349206*G8_3_1 + 0.006349206349206*G8_4_0 + 0.007936507936508*G8_4_1 + 0.007936507936508*G8_5_0 + 0.006349206349206*G8_5_1 + 0.004365079365079*G9_0_1 - 0.007142857142857*G9_1_1 - 0.003571428571429*G9_2_1 - 0.012698412698413*G9_3_1 - 0.007936507936508*G9_4_1 - 0.006349206349206*G9_5_1 + 0.004365079365079*G11_6_1 - 0.007142857142857*G11_7_1 - 0.003571428571429*G11_8_1 - 0.012698412698413*G11_9_1 - 0.007936507936508*G11_10_1 - 0.006349206349206*G11_11_1;
    A[32] = 0.500000000000000*G2_0_1_1 + 0.500000000000000*G4_0_1_1 + 0.007142857142857*G8_0_0 + 0.007142857142857*G8_0_1 - 0.007142857142857*G8_1_0 + 0.030952380952381*G8_2_1 + 0.047619047619048*G8_3_0 + 0.009523809523809*G8_3_1 - 0.047619047619048*G8_4_0 - 0.038095238095238*G8_4_1 - 0.009523809523810*G8_5_1 - 0.003571428571429*G9_0_1 - 0.003571428571429*G9_1_1 + 0.030952380952381*G9_2_1 + 0.019047619047619*G9_3_1 + 0.019047619047619*G9_4_1 + 0.004761904761905*G9_5_1 - 0.003571428571429*G11_6_1 - 0.003571428571429*G11_7_1 + 0.030952380952381*G11_8_1 + 0.019047619047619*G11_9_1 + 0.019047619047619*G11_10_1 + 0.004761904761905*G11_11_1;
    A[33] = 0.666666666666666*G2_0_1_0 + 0.666666666666666*G4_0_1_0 + 0.006349206349206*G8_0_0 + 0.006349206349206*G8_0_1 - 0.012698412698413*G8_1_0 + 0.019047619047619*G8_2_1 + 0.019047619047619*G8_3_0 - 0.012698412698413*G8_3_1 - 0.019047619047619*G8_4_0 - 0.025396825396825*G8_4_1 + 0.006349206349206*G8_5_0 + 0.012698412698413*G8_5_1 - 0.007936507936508*G9_0_1 - 0.012698412698413*G9_1_1 + 0.019047619047619*G9_2_1 + 0.063492063492063*G9_3_1 + 0.031746031746032*G9_4_1 + 0.006349206349206*G9_5_1 - 0.007936507936508*G11_6_1 - 0.012698412698413*G11_7_1 + 0.019047619047619*G11_8_1 + 0.063492063492063*G11_9_1 + 0.031746031746032*G11_10_1 + 0.006349206349206*G11_11_1;
    A[34] = -0.666666666666666*G2_0_1_0 - 0.666666666666666*G2_0_1_1 - 0.666666666666666*G4_0_1_0 - 0.666666666666666*G4_0_1_1 + 0.012698412698413*G8_0_0 + 0.012698412698413*G8_0_1 - 0.006349206349206*G8_1_0 + 0.019047619047619*G8_2_1 + 0.019047619047619*G8_3_0 - 0.006349206349206*G8_3_1 - 0.019047619047619*G8_4_0 - 0.031746031746032*G8_4_1 - 0.006349206349206*G8_5_0 + 0.006349206349206*G8_5_1 - 0.012698412698413*G9_0_1 - 0.007936507936508*G9_1_1 + 0.019047619047619*G9_2_1 + 0.031746031746032*G9_3_1 + 0.063492063492063*G9_4_1 + 0.006349206349206*G9_5_1 - 0.012698412698413*G11_6_1 - 0.007936507936508*G11_7_1 + 0.019047619047619*G11_8_1 + 0.031746031746032*G11_9_1 + 0.063492063492063*G11_10_1 + 0.006349206349206*G11_11_1;
    A[35] = 0.007936507936508*G8_0_0 + 0.007936507936508*G8_0_1 - 0.007936507936508*G8_1_0 + 0.004761904761905*G8_2_1 - 0.006349206349206*G8_3_0 - 0.019047619047619*G8_3_1 + 0.006349206349206*G8_4_0 - 0.012698412698413*G8_4_1 + 0.019047619047619*G8_5_1 - 0.006349206349206*G9_0_1 - 0.006349206349206*G9_1_1 + 0.004761904761905*G9_2_1 + 0.006349206349206*G9_3_1 + 0.006349206349206*G9_4_1 - 0.038095238095238*G9_5_1 - 0.006349206349206*G11_6_1 - 0.006349206349206*G11_7_1 + 0.004761904761905*G11_8_1 + 0.006349206349206*G11_9_1 + 0.006349206349206*G11_10_1 - 0.038095238095238*G11_11_1;
    A[36] = 0.003571428571429*G12_6_0 + 0.003571428571429*G12_6_1 + 0.004365079365079*G12_7_0 - 0.003571428571429*G12_8_1 - 0.006349206349206*G12_9_0 + 0.001587301587302*G12_9_1 + 0.006349206349206*G12_10_0 - 0.007936507936508*G12_11_0 - 0.001587301587302*G12_11_1;
    A[37] = -0.004365079365079*G12_6_0 - 0.004365079365079*G12_6_1 - 0.003571428571429*G12_7_0 - 0.003571428571429*G12_8_1 - 0.006349206349206*G12_9_0 - 0.006349206349206*G12_9_1 + 0.006349206349206*G12_10_0 + 0.007936507936508*G12_10_1 + 0.007936507936508*G12_11_0 + 0.006349206349206*G12_11_1;
    A[38] = 0.007142857142857*G12_6_0 + 0.007142857142857*G12_6_1 - 0.007142857142857*G12_7_0 + 0.030952380952381*G12_8_1 + 0.047619047619048*G12_9_0 + 0.009523809523809*G12_9_1 - 0.047619047619048*G12_10_0 - 0.038095238095238*G12_10_1 - 0.009523809523810*G12_11_1;
    A[39] = 0.006349206349206*G12_6_0 + 0.006349206349206*G12_6_1 - 0.012698412698413*G12_7_0 + 0.019047619047619*G12_8_1 + 0.019047619047619*G12_9_0 - 0.012698412698413*G12_9_1 - 0.019047619047619*G12_10_0 - 0.025396825396825*G12_10_1 + 0.006349206349206*G12_11_0 + 0.012698412698413*G12_11_1;
    A[40] = 0.012698412698413*G12_6_0 + 0.012698412698413*G12_6_1 - 0.006349206349206*G12_7_0 + 0.019047619047619*G12_8_1 + 0.019047619047619*G12_9_0 - 0.006349206349206*G12_9_1 - 0.019047619047619*G12_10_0 - 0.031746031746032*G12_10_1 - 0.006349206349206*G12_11_0 + 0.006349206349206*G12_11_1;
    A[41] = 0.007936507936508*G12_6_0 + 0.007936507936508*G12_6_1 - 0.007936507936508*G12_7_0 + 0.004761904761905*G12_8_1 - 0.006349206349206*G12_9_0 - 0.019047619047619*G12_9_1 + 0.006349206349206*G12_10_0 - 0.012698412698413*G12_10_1 + 0.019047619047619*G12_11_1;
    A[42] = 0.000000000000000;
    A[43] = 0.000000000000000;
    A[44] = 0.166666666666667*G0_1;
    A[45] = -0.004761904761905*G8_0_0 - 0.004761904761905*G8_0_1 - 0.007936507936508*G8_1_0 - 0.007936507936508*G8_2_1 - 0.019047619047619*G8_3_0 - 0.019047619047619*G8_3_1 + 0.019047619047619*G8_4_0 + 0.012698412698413*G8_4_1 + 0.012698412698413*G8_5_0 + 0.019047619047619*G8_5_1 + 0.009523809523810*G9_0_0 + 0.009523809523810*G9_0_1 + 0.001587301587302*G9_1_0 - 0.006349206349206*G9_1_1 - 0.006349206349206*G9_2_0 + 0.001587301587302*G9_2_1 - 0.019047619047619*G9_3_0 - 0.019047619047619*G9_3_1 - 0.012698412698413*G9_4_0 - 0.006349206349206*G9_4_1 - 0.006349206349206*G9_5_0 - 0.012698412698413*G9_5_1 + 0.009523809523810*G11_6_0 + 0.009523809523810*G11_6_1 + 0.001587301587302*G11_7_0 - 0.006349206349206*G11_7_1 - 0.006349206349206*G11_8_0 + 0.001587301587302*G11_8_1 - 0.019047619047619*G11_9_0 - 0.019047619047619*G11_9_1 - 0.012698412698413*G11_10_0 - 0.006349206349206*G11_10_1 - 0.006349206349206*G11_11_0 - 0.012698412698413*G11_11_1;
    A[46] = 0.666666666666666*G2_0_1_0 + 0.666666666666666*G4_0_1_0 + 0.006349206349206*G8_0_0 + 0.006349206349206*G8_0_1 + 0.019047619047619*G8_1_0 - 0.012698412698413*G8_2_1 - 0.012698412698413*G8_3_0 + 0.019047619047619*G8_3_1 + 0.012698412698413*G8_4_0 + 0.006349206349206*G8_4_1 - 0.025396825396825*G8_5_0 - 0.019047619047619*G8_5_1 + 0.001587301587302*G9_0_0 - 0.006349206349206*G9_0_1 + 0.009523809523810*G9_1_0 + 0.047619047619048*G9_1_1 - 0.006349206349206*G9_2_0 - 0.006349206349206*G9_2_1 - 0.012698412698413*G9_3_0 + 0.019047619047619*G9_3_1 - 0.019047619047619*G9_4_0 - 0.006349206349206*G9_4_1 - 0.006349206349206*G9_5_0 + 0.019047619047619*G9_5_1 + 0.001587301587302*G11_6_0 - 0.006349206349206*G11_6_1 + 0.009523809523810*G11_7_0 + 0.047619047619048*G11_7_1 - 0.006349206349206*G11_8_0 - 0.006349206349206*G11_8_1 - 0.012698412698413*G11_9_0 + 0.019047619047619*G11_9_1 - 0.019047619047619*G11_10_0 - 0.006349206349206*G11_10_1 - 0.006349206349206*G11_11_0 + 0.019047619047619*G11_11_1;
    A[47] = 0.666666666666666*G2_0_0_1 + 0.666666666666666*G4_0_0_1 + 0.006349206349206*G8_0_0 + 0.006349206349206*G8_0_1 - 0.012698412698413*G8_1_0 + 0.019047619047619*G8_2_1 + 0.019047619047619*G8_3_0 - 0.012698412698413*G8_3_1 - 0.019047619047619*G8_4_0 - 0.025396825396825*G8_4_1 + 0.006349206349206*G8_5_0 + 0.012698412698413*G8_5_1 - 0.006349206349206*G9_0_0 + 0.001587301587302*G9_0_1 - 0.006349206349206*G9_1_0 - 0.006349206349206*G9_1_1 + 0.047619047619048*G9_2_0 + 0.009523809523809*G9_2_1 + 0.019047619047619*G9_3_0 - 0.012698412698413*G9_3_1 + 0.019047619047619*G9_4_0 - 0.006349206349206*G9_4_1 - 0.006349206349206*G9_5_0 - 0.019047619047619*G9_5_1 - 0.006349206349206*G11_6_0 + 0.001587301587302*G11_6_1 - 0.006349206349206*G11_7_0 - 0.006349206349206*G11_7_1 + 0.047619047619048*G11_8_0 + 0.009523809523809*G11_8_1 + 0.019047619047619*G11_9_0 - 0.012698412698413*G11_9_1 + 0.019047619047619*G11_10_0 - 0.006349206349206*G11_10_1 - 0.006349206349206*G11_11_0 - 0.019047619047619*G11_11_1;
    A[48] = 1.333333333333332*G2_0_0_0 + 0.666666666666666*G2_0_0_1 + 0.666666666666666*G2_0_1_0 + 1.333333333333332*G2_0_1_1 + 1.333333333333332*G4_0_0_0 + 0.666666666666666*G4_0_0_1 + 0.666666666666666*G4_0_1_0 + 1.333333333333332*G4_0_1_1 + 0.038095238095238*G8_0_0 + 0.038095238095238*G8_0_1 + 0.063492063492063*G8_1_0 + 0.063492063492063*G8_2_1 + 0.152380952380952*G8_3_0 + 0.152380952380952*G8_3_1 - 0.152380952380952*G8_4_0 - 0.101587301587301*G8_4_1 - 0.101587301587301*G8_5_0 - 0.152380952380952*G8_5_1 - 0.019047619047619*G9_0_0 - 0.019047619047619*G9_0_1 - 0.012698412698413*G9_1_0 + 0.019047619047619*G9_1_1 + 0.019047619047619*G9_2_0 - 0.012698412698413*G9_2_1 + 0.152380952380952*G9_3_0 + 0.152380952380952*G9_3_1 + 0.076190476190476*G9_4_0 + 0.050793650793651*G9_4_1 + 0.050793650793651*G9_5_0 + 0.076190476190476*G9_5_1 - 0.019047619047619*G11_6_0 - 0.019047619047619*G11_6_1 - 0.012698412698413*G11_7_0 + 0.019047619047619*G11_7_1 + 0.019047619047619*G11_8_0 - 0.012698412698413*G11_8_1 + 0.152380952380952*G11_9_0 + 0.152380952380952*G11_9_1 + 0.076190476190476*G11_10_0 + 0.050793650793651*G11_10_1 + 0.050793650793651*G11_11_0 + 0.076190476190476*G11_11_1;
    A[49] = -1.333333333333332*G2_0_0_0 - 0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_0 - 1.333333333333332*G4_0_0_0 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_0 - 0.006349206349206*G8_0_0 - 0.006349206349206*G8_0_1 + 0.006349206349206*G8_1_0 + 0.031746031746032*G8_2_1 + 0.076190476190476*G8_3_0 + 0.050793650793651*G8_3_1 - 0.076190476190476*G8_4_0 - 0.025396825396825*G8_4_1 - 0.050793650793651*G8_5_1 - 0.012698412698413*G9_0_0 - 0.006349206349206*G9_0_1 - 0.019047619047619*G9_1_0 - 0.006349206349206*G9_1_1 + 0.019047619047619*G9_2_0 - 0.006349206349206*G9_2_1 + 0.076190476190476*G9_3_0 + 0.050793650793651*G9_3_1 + 0.152380952380952*G9_4_0 + 0.050793650793651*G9_4_1 + 0.050793650793651*G9_5_0 + 0.050793650793651*G9_5_1 - 0.012698412698413*G11_6_0 - 0.006349206349206*G11_6_1 - 0.019047619047619*G11_7_0 - 0.006349206349206*G11_7_1 + 0.019047619047619*G11_8_0 - 0.006349206349206*G11_8_1 + 0.076190476190476*G11_9_0 + 0.050793650793651*G11_9_1 + 0.152380952380952*G11_10_0 + 0.050793650793651*G11_10_1 + 0.050793650793651*G11_11_0 + 0.050793650793651*G11_11_1;
    A[50] = -0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_0 - 1.333333333333332*G2_0_1_1 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_0 - 1.333333333333332*G4_0_1_1 - 0.006349206349206*G8_0_0 - 0.006349206349206*G8_0_1 + 0.031746031746032*G8_1_0 + 0.006349206349206*G8_2_1 + 0.050793650793651*G8_3_0 + 0.076190476190476*G8_3_1 - 0.050793650793651*G8_4_0 - 0.025396825396825*G8_5_0 - 0.076190476190476*G8_5_1 - 0.006349206349206*G9_0_0 - 0.012698412698413*G9_0_1 - 0.006349206349206*G9_1_0 + 0.019047619047619*G9_1_1 - 0.006349206349206*G9_2_0 - 0.019047619047619*G9_2_1 + 0.050793650793651*G9_3_0 + 0.076190476190476*G9_3_1 + 0.050793650793651*G9_4_0 + 0.050793650793651*G9_4_1 + 0.050793650793651*G9_5_0 + 0.152380952380952*G9_5_1 - 0.006349206349206*G11_6_0 - 0.012698412698413*G11_6_1 - 0.006349206349206*G11_7_0 + 0.019047619047619*G11_7_1 - 0.006349206349206*G11_8_0 - 0.019047619047619*G11_8_1 + 0.050793650793651*G11_9_0 + 0.076190476190476*G11_9_1 + 0.050793650793651*G11_10_0 + 0.050793650793651*G11_10_1 + 0.050793650793651*G11_11_0 + 0.152380952380952*G11_11_1;
    A[51] = -0.004761904761905*G12_6_0 - 0.004761904761905*G12_6_1 - 0.007936507936508*G12_7_0 - 0.007936507936508*G12_8_1 - 0.019047619047619*G12_9_0 - 0.019047619047619*G12_9_1 + 0.019047619047619*G12_10_0 + 0.012698412698413*G12_10_1 + 0.012698412698413*G12_11_0 + 0.019047619047619*G12_11_1;
    A[52] = 0.006349206349206*G12_6_0 + 0.006349206349206*G12_6_1 + 0.019047619047619*G12_7_0 - 0.012698412698413*G12_8_1 - 0.012698412698413*G12_9_0 + 0.019047619047619*G12_9_1 + 0.012698412698413*G12_10_0 + 0.006349206349206*G12_10_1 - 0.025396825396825*G12_11_0 - 0.019047619047619*G12_11_1;
    A[53] = 0.006349206349206*G12_6_0 + 0.006349206349206*G12_6_1 - 0.012698412698413*G12_7_0 + 0.019047619047619*G12_8_1 + 0.019047619047619*G12_9_0 - 0.012698412698413*G12_9_1 - 0.019047619047619*G12_10_0 - 0.025396825396825*G12_10_1 + 0.006349206349206*G12_11_0 + 0.012698412698413*G12_11_1;
    A[54] = 0.038095238095238*G12_6_0 + 0.038095238095238*G12_6_1 + 0.063492063492063*G12_7_0 + 0.063492063492063*G12_8_1 + 0.152380952380952*G12_9_0 + 0.152380952380952*G12_9_1 - 0.152380952380952*G12_10_0 - 0.101587301587301*G12_10_1 - 0.101587301587301*G12_11_0 - 0.152380952380952*G12_11_1;
    A[55] = -0.006349206349206*G12_6_0 - 0.006349206349206*G12_6_1 + 0.006349206349206*G12_7_0 + 0.031746031746032*G12_8_1 + 0.076190476190476*G12_9_0 + 0.050793650793651*G12_9_1 - 0.076190476190476*G12_10_0 - 0.025396825396825*G12_10_1 - 0.050793650793651*G12_11_1;
    A[56] = -0.006349206349206*G12_6_0 - 0.006349206349206*G12_6_1 + 0.031746031746032*G12_7_0 + 0.006349206349206*G12_8_1 + 0.050793650793651*G12_9_0 + 0.076190476190476*G12_9_1 - 0.050793650793651*G12_10_0 - 0.025396825396825*G12_11_0 - 0.076190476190476*G12_11_1;
    A[57] = 0.166666666666667*G0_0 + 0.166666666666667*G0_1;
    A[58] = 0.166666666666667*G0_0 + 0.333333333333333*G0_1;
    A[59] = 0.333333333333333*G0_0 + 0.166666666666667*G0_1;
    A[60] = -0.666666666666667*G2_0_1_0 - 0.666666666666667*G2_0_1_1 - 0.666666666666667*G4_0_1_0 - 0.666666666666667*G4_0_1_1 - 0.019047619047619*G8_0_0 - 0.019047619047619*G8_0_1 - 0.006349206349206*G8_1_0 - 0.012698412698413*G8_2_1 - 0.012698412698413*G8_3_0 - 0.006349206349206*G8_3_1 + 0.012698412698413*G8_4_0 + 0.031746031746032*G8_4_1 + 0.025396825396825*G8_5_0 + 0.006349206349206*G8_5_1 - 0.009523809523810*G9_0_0 + 0.038095238095238*G9_0_1 - 0.001587301587302*G9_1_0 - 0.007936507936508*G9_1_1 + 0.006349206349206*G9_2_0 + 0.019047619047619*G9_3_0 + 0.012698412698413*G9_3_1 + 0.012698412698413*G9_4_0 + 0.031746031746032*G9_4_1 + 0.006349206349206*G9_5_0 + 0.025396825396825*G9_5_1 - 0.009523809523810*G11_6_0 + 0.038095238095238*G11_6_1 - 0.001587301587302*G11_7_0 - 0.007936507936508*G11_7_1 + 0.006349206349206*G11_8_0 + 0.019047619047619*G11_9_0 + 0.012698412698413*G11_9_1 + 0.012698412698413*G11_10_0 + 0.031746031746032*G11_10_1 + 0.006349206349206*G11_11_0 + 0.025396825396825*G11_11_1;
    A[61] = 0.007936507936508*G8_0_0 + 0.007936507936508*G8_0_1 + 0.004761904761905*G8_1_0 - 0.007936507936508*G8_2_1 - 0.019047619047619*G8_3_0 - 0.006349206349206*G8_3_1 + 0.019047619047619*G8_4_0 - 0.012698412698413*G8_5_0 + 0.006349206349206*G8_5_1 - 0.001587301587302*G9_0_0 - 0.007936507936508*G9_0_1 - 0.009523809523810*G9_1_0 + 0.006349206349206*G9_2_0 + 0.007936507936508*G9_2_1 + 0.012698412698413*G9_3_0 + 0.006349206349206*G9_3_1 + 0.019047619047619*G9_4_0 + 0.006349206349206*G9_5_0 - 0.006349206349206*G9_5_1 - 0.001587301587302*G11_6_0 - 0.007936507936508*G11_6_1 - 0.009523809523810*G11_7_0 + 0.006349206349206*G11_8_0 + 0.007936507936508*G11_8_1 + 0.012698412698413*G11_9_0 + 0.006349206349206*G11_9_1 + 0.019047619047619*G11_10_0 + 0.006349206349206*G11_11_0 - 0.006349206349206*G11_11_1;
    A[62] = -0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_1 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_1 + 0.012698412698413*G8_0_0 + 0.012698412698413*G8_0_1 - 0.006349206349206*G8_1_0 + 0.019047619047619*G8_2_1 + 0.019047619047619*G8_3_0 - 0.006349206349206*G8_3_1 - 0.019047619047619*G8_4_0 - 0.031746031746032*G8_4_1 - 0.006349206349206*G8_5_0 + 0.006349206349206*G8_5_1 + 0.006349206349206*G9_0_0 + 0.006349206349206*G9_1_0 + 0.007936507936508*G9_1_1 - 0.047619047619048*G9_2_0 - 0.038095238095238*G9_2_1 - 0.019047619047619*G9_3_0 - 0.025396825396825*G9_3_1 - 0.019047619047619*G9_4_0 - 0.031746031746032*G9_4_1 + 0.006349206349206*G9_5_0 - 0.012698412698413*G9_5_1 + 0.006349206349206*G11_6_0 + 0.006349206349206*G11_7_0 + 0.007936507936508*G11_7_1 - 0.047619047619048*G11_8_0 - 0.038095238095238*G11_8_1 - 0.019047619047619*G11_9_0 - 0.025396825396825*G11_9_1 - 0.019047619047619*G11_10_0 - 0.031746031746032*G11_10_1 + 0.006349206349206*G11_11_0 - 0.012698412698413*G11_11_1;
    A[63] = -1.333333333333332*G2_0_0_0 - 0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_0 - 1.333333333333332*G4_0_0_0 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_0 - 0.006349206349206*G8_0_0 - 0.006349206349206*G8_0_1 + 0.006349206349206*G8_1_0 + 0.031746031746032*G8_2_1 + 0.076190476190476*G8_3_0 + 0.050793650793651*G8_3_1 - 0.076190476190476*G8_4_0 - 0.025396825396825*G8_4_1 - 0.050793650793651*G8_5_1 + 0.019047619047619*G9_0_0 + 0.012698412698413*G9_0_1 + 0.012698412698413*G9_1_0 + 0.006349206349206*G9_1_1 - 0.019047619047619*G9_2_0 - 0.025396825396825*G9_2_1 - 0.152380952380952*G9_3_0 - 0.101587301587301*G9_3_1 - 0.076190476190476*G9_4_0 - 0.025396825396825*G9_4_1 - 0.050793650793651*G9_5_0 + 0.019047619047619*G11_6_0 + 0.012698412698413*G11_6_1 + 0.012698412698413*G11_7_0 + 0.006349206349206*G11_7_1 - 0.019047619047619*G11_8_0 - 0.025396825396825*G11_8_1 - 0.152380952380952*G11_9_0 - 0.101587301587301*G11_9_1 - 0.076190476190476*G11_10_0 - 0.025396825396825*G11_10_1 - 0.050793650793651*G11_11_0;
    A[64] = 1.333333333333332*G2_0_0_0 + 0.666666666666666*G2_0_0_1 + 0.666666666666666*G2_0_1_0 + 1.333333333333333*G2_0_1_1 + 1.333333333333332*G4_0_0_0 + 0.666666666666666*G4_0_0_1 + 0.666666666666666*G4_0_1_0 + 1.333333333333333*G4_0_1_1 - 0.063492063492063*G8_0_0 - 0.063492063492063*G8_0_1 - 0.038095238095238*G8_1_0 + 0.063492063492063*G8_2_1 + 0.152380952380952*G8_3_0 + 0.050793650793651*G8_3_1 - 0.152380952380952*G8_4_0 + 0.101587301587302*G8_5_0 - 0.050793650793651*G8_5_1 + 0.012698412698413*G9_0_0 + 0.031746031746032*G9_0_1 + 0.019047619047619*G9_1_0 - 0.019047619047619*G9_2_0 - 0.031746031746032*G9_2_1 - 0.076190476190476*G9_3_0 - 0.025396825396825*G9_3_1 - 0.152380952380952*G9_4_0 - 0.050793650793651*G9_5_0 + 0.025396825396825*G9_5_1 + 0.012698412698413*G11_6_0 + 0.031746031746032*G11_6_1 + 0.019047619047619*G11_7_0 - 0.019047619047619*G11_8_0 - 0.031746031746032*G11_8_1 - 0.076190476190476*G11_9_0 - 0.025396825396825*G11_9_1 - 0.152380952380952*G11_10_0 - 0.050793650793651*G11_11_0 + 0.025396825396825*G11_11_1;
    A[65] = 0.666666666666666*G2_0_0_1 + 0.666666666666667*G2_0_1_0 + 0.666666666666666*G4_0_0_1 + 0.666666666666667*G4_0_1_0 - 0.031746031746032*G8_0_0 - 0.031746031746032*G8_0_1 + 0.006349206349206*G8_1_0 + 0.006349206349206*G8_2_1 + 0.050793650793651*G8_3_0 + 0.050793650793651*G8_3_1 - 0.050793650793651*G8_4_0 + 0.025396825396825*G8_4_1 + 0.025396825396825*G8_5_0 - 0.050793650793651*G8_5_1 + 0.006349206349206*G9_0_0 + 0.025396825396825*G9_0_1 + 0.006349206349206*G9_1_0 - 0.006349206349206*G9_1_1 + 0.006349206349206*G9_2_0 - 0.012698412698413*G9_2_1 - 0.050793650793651*G9_3_0 - 0.050793650793651*G9_4_0 + 0.025396825396825*G9_4_1 - 0.050793650793651*G9_5_0 + 0.101587301587302*G9_5_1 + 0.006349206349206*G11_6_0 + 0.025396825396825*G11_6_1 + 0.006349206349206*G11_7_0 - 0.006349206349206*G11_7_1 + 0.006349206349206*G11_8_0 - 0.012698412698413*G11_8_1 - 0.050793650793651*G11_9_0 - 0.050793650793651*G11_10_0 + 0.025396825396825*G11_10_1 - 0.050793650793651*G11_11_0 + 0.101587301587302*G11_11_1;
    A[66] = -0.019047619047619*G12_6_0 - 0.019047619047619*G12_6_1 - 0.006349206349206*G12_7_0 - 0.012698412698413*G12_8_1 - 0.012698412698413*G12_9_0 - 0.006349206349206*G12_9_1 + 0.012698412698413*G12_10_0 + 0.031746031746032*G12_10_1 + 0.025396825396825*G12_11_0 + 0.006349206349206*G12_11_1;
    A[67] = 0.007936507936508*G12_6_0 + 0.007936507936508*G12_6_1 + 0.004761904761905*G12_7_0 - 0.007936507936508*G12_8_1 - 0.019047619047619*G12_9_0 - 0.006349206349206*G12_9_1 + 0.019047619047619*G12_10_0 - 0.012698412698413*G12_11_0 + 0.006349206349206*G12_11_1;
    A[68] = 0.012698412698413*G12_6_0 + 0.012698412698413*G12_6_1 - 0.006349206349206*G12_7_0 + 0.019047619047619*G12_8_1 + 0.019047619047619*G12_9_0 - 0.006349206349206*G12_9_1 - 0.019047619047619*G12_10_0 - 0.031746031746032*G12_10_1 - 0.006349206349206*G12_11_0 + 0.006349206349206*G12_11_1;
    A[69] = -0.006349206349206*G12_6_0 - 0.006349206349206*G12_6_1 + 0.006349206349206*G12_7_0 + 0.031746031746032*G12_8_1 + 0.076190476190476*G12_9_0 + 0.050793650793651*G12_9_1 - 0.076190476190476*G12_10_0 - 0.025396825396825*G12_10_1 - 0.050793650793651*G12_11_1;
    A[70] = -0.063492063492063*G12_6_0 - 0.063492063492063*G12_6_1 - 0.038095238095238*G12_7_0 + 0.063492063492063*G12_8_1 + 0.152380952380952*G12_9_0 + 0.050793650793651*G12_9_1 - 0.152380952380952*G12_10_0 + 0.101587301587302*G12_11_0 - 0.050793650793651*G12_11_1;
    A[71] = -0.031746031746032*G12_6_0 - 0.031746031746032*G12_6_1 + 0.006349206349206*G12_7_0 + 0.006349206349206*G12_8_1 + 0.050793650793651*G12_9_0 + 0.050793650793651*G12_9_1 - 0.050793650793651*G12_10_0 + 0.025396825396825*G12_10_1 + 0.025396825396825*G12_11_0 - 0.050793650793651*G12_11_1;
    A[72] = -0.166666666666667*G0_0 + 0.166666666666667*G0_1;
    A[73] = -0.166666666666667*G0_0;
    A[74] = -0.333333333333333*G0_0 - 0.166666666666666*G0_1;
    A[75] = -0.666666666666667*G2_0_0_0 - 0.666666666666667*G2_0_0_1 - 0.666666666666667*G4_0_0_0 - 0.666666666666667*G4_0_0_1 - 0.019047619047619*G8_0_0 - 0.019047619047619*G8_0_1 - 0.012698412698413*G8_1_0 - 0.006349206349206*G8_2_1 - 0.006349206349206*G8_3_0 - 0.012698412698413*G8_3_1 + 0.006349206349206*G8_4_0 + 0.025396825396825*G8_4_1 + 0.031746031746032*G8_5_0 + 0.012698412698413*G8_5_1 + 0.038095238095238*G9_0_0 - 0.009523809523810*G9_0_1 + 0.006349206349206*G9_1_1 - 0.007936507936508*G9_2_0 - 0.001587301587302*G9_2_1 + 0.012698412698413*G9_3_0 + 0.019047619047619*G9_3_1 + 0.025396825396825*G9_4_0 + 0.006349206349206*G9_4_1 + 0.031746031746032*G9_5_0 + 0.012698412698413*G9_5_1 + 0.038095238095238*G11_6_0 - 0.009523809523810*G11_6_1 + 0.006349206349206*G11_7_1 - 0.007936507936508*G11_8_0 - 0.001587301587302*G11_8_1 + 0.012698412698413*G11_9_0 + 0.019047619047619*G11_9_1 + 0.025396825396825*G11_10_0 + 0.006349206349206*G11_10_1 + 0.031746031746032*G11_11_0 + 0.012698412698413*G11_11_1;
    A[76] = -0.666666666666666*G2_0_0_0 - 0.666666666666666*G2_0_1_0 - 0.666666666666666*G4_0_0_0 - 0.666666666666666*G4_0_1_0 + 0.012698412698413*G8_0_0 + 0.012698412698413*G8_0_1 + 0.019047619047619*G8_1_0 - 0.006349206349206*G8_2_1 - 0.006349206349206*G8_3_0 + 0.019047619047619*G8_3_1 + 0.006349206349206*G8_4_0 - 0.006349206349206*G8_4_1 - 0.031746031746032*G8_5_0 - 0.019047619047619*G8_5_1 + 0.006349206349206*G9_0_1 - 0.038095238095238*G9_1_0 - 0.047619047619048*G9_1_1 + 0.007936507936508*G9_2_0 + 0.006349206349206*G9_2_1 - 0.025396825396825*G9_3_0 - 0.019047619047619*G9_3_1 - 0.012698412698413*G9_4_0 + 0.006349206349206*G9_4_1 - 0.031746031746032*G9_5_0 - 0.019047619047619*G9_5_1 + 0.006349206349206*G11_6_1 - 0.038095238095238*G11_7_0 - 0.047619047619048*G11_7_1 + 0.007936507936508*G11_8_0 + 0.006349206349206*G11_8_1 - 0.025396825396825*G11_9_0 - 0.019047619047619*G11_9_1 - 0.012698412698413*G11_10_0 + 0.006349206349206*G11_10_1 - 0.031746031746032*G11_11_0 - 0.019047619047619*G11_11_1;
    A[77] = 0.007936507936508*G8_0_0 + 0.007936507936508*G8_0_1 - 0.007936507936508*G8_1_0 + 0.004761904761905*G8_2_1 - 0.006349206349206*G8_3_0 - 0.019047619047619*G8_3_1 + 0.006349206349206*G8_4_0 - 0.012698412698413*G8_4_1 + 0.019047619047619*G8_5_1 - 0.007936507936508*G9_0_0 - 0.001587301587302*G9_0_1 + 0.007936507936508*G9_1_0 + 0.006349206349206*G9_1_1 - 0.009523809523810*G9_2_1 + 0.006349206349206*G9_3_0 + 0.012698412698413*G9_3_1 - 0.006349206349206*G9_4_0 + 0.006349206349206*G9_4_1 + 0.019047619047619*G9_5_1 - 0.007936507936508*G11_6_0 - 0.001587301587302*G11_6_1 + 0.007936507936508*G11_7_0 + 0.006349206349206*G11_7_1 - 0.009523809523810*G11_8_1 + 0.006349206349206*G11_9_0 + 0.012698412698413*G11_9_1 - 0.006349206349206*G11_10_0 + 0.006349206349206*G11_10_1 + 0.019047619047619*G11_11_1;
    A[78] = -0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_0 - 1.333333333333333*G2_0_1_1 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_0 - 1.333333333333333*G4_0_1_1 - 0.006349206349206*G8_0_0 - 0.006349206349206*G8_0_1 + 0.031746031746032*G8_1_0 + 0.006349206349206*G8_2_1 + 0.050793650793651*G8_3_0 + 0.076190476190476*G8_3_1 - 0.050793650793651*G8_4_0 - 0.025396825396825*G8_5_0 - 0.076190476190476*G8_5_1 + 0.012698412698413*G9_0_0 + 0.019047619047619*G9_0_1 - 0.025396825396825*G9_1_0 - 0.019047619047619*G9_1_1 + 0.006349206349206*G9_2_0 + 0.012698412698413*G9_2_1 - 0.101587301587301*G9_3_0 - 0.152380952380952*G9_3_1 - 0.050793650793651*G9_4_1 - 0.025396825396825*G9_5_0 - 0.076190476190476*G9_5_1 + 0.012698412698413*G11_6_0 + 0.019047619047619*G11_6_1 - 0.025396825396825*G11_7_0 - 0.019047619047619*G11_7_1 + 0.006349206349206*G11_8_0 + 0.012698412698413*G11_8_1 - 0.101587301587301*G11_9_0 - 0.152380952380952*G11_9_1 - 0.050793650793651*G11_10_1 - 0.025396825396825*G11_11_0 - 0.076190476190476*G11_11_1;
    A[79] = 0.666666666666667*G2_0_0_1 + 0.666666666666666*G2_0_1_0 + 0.666666666666667*G4_0_0_1 + 0.666666666666666*G4_0_1_0 - 0.031746031746032*G8_0_0 - 0.031746031746032*G8_0_1 + 0.006349206349206*G8_1_0 + 0.006349206349206*G8_2_1 + 0.050793650793651*G8_3_0 + 0.050793650793651*G8_3_1 - 0.050793650793651*G8_4_0 + 0.025396825396825*G8_4_1 + 0.025396825396825*G8_5_0 - 0.050793650793651*G8_5_1 + 0.025396825396825*G9_0_0 + 0.006349206349206*G9_0_1 - 0.012698412698413*G9_1_0 + 0.006349206349206*G9_1_1 - 0.006349206349206*G9_2_0 + 0.006349206349206*G9_2_1 - 0.050793650793651*G9_3_1 + 0.101587301587302*G9_4_0 - 0.050793650793651*G9_4_1 + 0.025396825396825*G9_5_0 - 0.050793650793651*G9_5_1 + 0.025396825396825*G11_6_0 + 0.006349206349206*G11_6_1 - 0.012698412698413*G11_7_0 + 0.006349206349206*G11_7_1 - 0.006349206349206*G11_8_0 + 0.006349206349206*G11_8_1 - 0.050793650793651*G11_9_1 + 0.101587301587302*G11_10_0 - 0.050793650793651*G11_10_1 + 0.025396825396825*G11_11_0 - 0.050793650793651*G11_11_1;
    A[80] = 1.333333333333333*G2_0_0_0 + 0.666666666666666*G2_0_0_1 + 0.666666666666666*G2_0_1_0 + 1.333333333333333*G2_0_1_1 + 1.333333333333333*G4_0_0_0 + 0.666666666666666*G4_0_0_1 + 0.666666666666666*G4_0_1_0 + 1.333333333333333*G4_0_1_1 - 0.063492063492063*G8_0_0 - 0.063492063492063*G8_0_1 + 0.063492063492064*G8_1_0 - 0.038095238095238*G8_2_1 + 0.050793650793651*G8_3_0 + 0.152380952380952*G8_3_1 - 0.050793650793651*G8_4_0 + 0.101587301587302*G8_4_1 - 0.152380952380952*G8_5_1 + 0.031746031746032*G9_0_0 + 0.012698412698413*G9_0_1 - 0.031746031746032*G9_1_0 - 0.019047619047619*G9_1_1 + 0.019047619047619*G9_2_1 - 0.025396825396825*G9_3_0 - 0.076190476190476*G9_3_1 + 0.025396825396825*G9_4_0 - 0.050793650793651*G9_4_1 - 0.152380952380952*G9_5_1 + 0.031746031746032*G11_6_0 + 0.012698412698413*G11_6_1 - 0.031746031746032*G11_7_0 - 0.019047619047619*G11_7_1 + 0.019047619047619*G11_8_1 - 0.025396825396825*G11_9_0 - 0.076190476190476*G11_9_1 + 0.025396825396825*G11_10_0 - 0.050793650793651*G11_10_1 - 0.152380952380952*G11_11_1;
    A[81] = -0.019047619047619*G12_6_0 - 0.019047619047619*G12_6_1 - 0.012698412698413*G12_7_0 - 0.006349206349206*G12_8_1 - 0.006349206349206*G12_9_0 - 0.012698412698413*G12_9_1 + 0.006349206349206*G12_10_0 + 0.025396825396825*G12_10_1 + 0.031746031746032*G12_11_0 + 0.012698412698413*G12_11_1;
    A[82] = 0.012698412698413*G12_6_0 + 0.012698412698413*G12_6_1 + 0.019047619047619*G12_7_0 - 0.006349206349206*G12_8_1 - 0.006349206349206*G12_9_0 + 0.019047619047619*G12_9_1 + 0.006349206349206*G12_10_0 - 0.006349206349206*G12_10_1 - 0.031746031746032*G12_11_0 - 0.019047619047619*G12_11_1;
    A[83] = 0.007936507936508*G12_6_0 + 0.007936507936508*G12_6_1 - 0.007936507936508*G12_7_0 + 0.004761904761905*G12_8_1 - 0.006349206349206*G12_9_0 - 0.019047619047619*G12_9_1 + 0.006349206349206*G12_10_0 - 0.012698412698413*G12_10_1 + 0.019047619047619*G12_11_1;
    A[84] = -0.006349206349206*G12_6_0 - 0.006349206349206*G12_6_1 + 0.031746031746032*G12_7_0 + 0.006349206349206*G12_8_1 + 0.050793650793651*G12_9_0 + 0.076190476190476*G12_9_1 - 0.050793650793651*G12_10_0 - 0.025396825396825*G12_11_0 - 0.076190476190476*G12_11_1;
    A[85] = -0.031746031746032*G12_6_0 - 0.031746031746032*G12_6_1 + 0.006349206349206*G12_7_0 + 0.006349206349206*G12_8_1 + 0.050793650793651*G12_9_0 + 0.050793650793651*G12_9_1 - 0.050793650793651*G12_10_0 + 0.025396825396825*G12_10_1 + 0.025396825396825*G12_11_0 - 0.050793650793651*G12_11_1;
    A[86] = -0.063492063492063*G12_6_0 - 0.063492063492063*G12_6_1 + 0.063492063492064*G12_7_0 - 0.038095238095238*G12_8_1 + 0.050793650793651*G12_9_0 + 0.152380952380952*G12_9_1 - 0.050793650793651*G12_10_0 + 0.101587301587302*G12_10_1 - 0.152380952380952*G12_11_1;
    A[87] = 0.166666666666667*G0_0 - 0.166666666666667*G0_1;
    A[88] = -0.166666666666667*G0_0 - 0.333333333333333*G0_1;
    A[89] = -0.166666666666667*G0_1;
    A[90] = -0.030952380952381*G10_0_0 - 0.030952380952381*G10_0_1 - 0.007142857142857*G10_1_0 - 0.007142857142857*G10_2_1 + 0.009523809523810*G10_3_0 + 0.009523809523810*G10_3_1 - 0.009523809523810*G10_4_0 + 0.038095238095238*G10_4_1 + 0.038095238095238*G10_5_0 - 0.009523809523810*G10_5_1;
    A[91] = 0.003571428571429*G10_0_0 + 0.003571428571429*G10_0_1 - 0.003571428571429*G10_1_0 + 0.004365079365079*G10_2_1 + 0.001587301587302*G10_3_0 - 0.006349206349206*G10_3_1 - 0.001587301587302*G10_4_0 - 0.007936507936508*G10_4_1 + 0.006349206349206*G10_5_1;
    A[92] = 0.003571428571429*G10_0_0 + 0.003571428571429*G10_0_1 + 0.004365079365079*G10_1_0 - 0.003571428571429*G10_2_1 - 0.006349206349206*G10_3_0 + 0.001587301587302*G10_3_1 + 0.006349206349206*G10_4_0 - 0.007936507936508*G10_5_0 - 0.001587301587302*G10_5_1;
    A[93] = -0.004761904761905*G10_0_0 - 0.004761904761905*G10_0_1 - 0.007936507936508*G10_1_0 - 0.007936507936508*G10_2_1 - 0.019047619047619*G10_3_0 - 0.019047619047619*G10_3_1 + 0.019047619047619*G10_4_0 + 0.012698412698413*G10_4_1 + 0.012698412698413*G10_5_0 + 0.019047619047619*G10_5_1;
    A[94] = -0.019047619047619*G10_0_0 - 0.019047619047619*G10_0_1 - 0.006349206349206*G10_1_0 - 0.012698412698413*G10_2_1 - 0.012698412698413*G10_3_0 - 0.006349206349206*G10_3_1 + 0.012698412698413*G10_4_0 + 0.031746031746032*G10_4_1 + 0.025396825396825*G10_5_0 + 0.006349206349206*G10_5_1;
    A[95] = -0.019047619047619*G10_0_0 - 0.019047619047619*G10_0_1 - 0.012698412698413*G10_1_0 - 0.006349206349206*G10_2_1 - 0.006349206349206*G10_3_0 - 0.012698412698413*G10_3_1 + 0.006349206349206*G10_4_0 + 0.025396825396825*G10_4_1 + 0.031746031746032*G10_5_0 + 0.012698412698413*G10_5_1;
    A[96] = 0.500000000000000*G3_0_0_0 + 0.500000000000000*G3_0_0_1 + 0.500000000000000*G3_0_1_0 + 0.500000000000000*G3_0_1_1 + 0.500000000000000*G5_0_0_0 + 0.500000000000000*G5_0_0_1 + 0.500000000000000*G5_0_1_0 + 0.500000000000000*G5_0_1_1 - 0.030952380952381*G13_0_0 - 0.030952380952381*G13_0_1 + 0.003571428571429*G13_1_0 + 0.003571428571429*G13_1_1 + 0.003571428571429*G13_2_0 + 0.003571428571429*G13_2_1 - 0.004761904761905*G13_3_0 - 0.004761904761905*G13_3_1 - 0.019047619047619*G13_4_0 - 0.019047619047619*G13_4_1 - 0.019047619047619*G13_5_0 - 0.019047619047619*G13_5_1 - 0.030952380952381*G14_6_0 - 0.030952380952381*G14_6_1 - 0.007142857142857*G14_7_0 - 0.007142857142857*G14_8_1 + 0.009523809523810*G14_9_0 + 0.009523809523810*G14_9_1 - 0.009523809523810*G14_10_0 + 0.038095238095238*G14_10_1 + 0.038095238095238*G14_11_0 - 0.009523809523810*G14_11_1 - 0.030952380952381*G15_6_0 - 0.030952380952381*G15_6_1 + 0.003571428571429*G15_7_0 + 0.003571428571429*G15_7_1 + 0.003571428571429*G15_8_0 + 0.003571428571429*G15_8_1 - 0.004761904761905*G15_9_0 - 0.004761904761905*G15_9_1 - 0.019047619047619*G15_10_0 - 0.019047619047619*G15_10_1 - 0.019047619047619*G15_11_0 - 0.019047619047619*G15_11_1;
    A[97] = 0.166666666666667*G3_0_0_0 + 0.166666666666667*G3_0_1_0 + 0.166666666666667*G5_0_0_0 + 0.166666666666667*G5_0_1_0 + 0.003571428571429*G13_0_0 + 0.003571428571429*G13_0_1 + 0.007142857142857*G13_1_0 + 0.007142857142857*G13_1_1 - 0.004365079365079*G13_2_0 - 0.004365079365079*G13_2_1 + 0.006349206349206*G13_3_0 + 0.006349206349206*G13_3_1 + 0.007936507936508*G13_4_0 + 0.007936507936508*G13_4_1 + 0.012698412698413*G13_5_0 + 0.012698412698413*G13_5_1 + 0.003571428571429*G14_6_0 + 0.003571428571429*G14_6_1 - 0.003571428571429*G14_7_0 + 0.004365079365079*G14_8_1 + 0.001587301587302*G14_9_0 - 0.006349206349206*G14_9_1 - 0.001587301587302*G14_10_0 - 0.007936507936508*G14_10_1 + 0.006349206349206*G14_11_1 + 0.003571428571429*G15_6_0 + 0.003571428571429*G15_6_1 + 0.007142857142857*G15_7_0 + 0.007142857142857*G15_7_1 - 0.004365079365079*G15_8_0 - 0.004365079365079*G15_8_1 + 0.006349206349206*G15_9_0 + 0.006349206349206*G15_9_1 + 0.007936507936508*G15_10_0 + 0.007936507936508*G15_10_1 + 0.012698412698413*G15_11_0 + 0.012698412698413*G15_11_1;
    A[98] = 0.166666666666667*G3_0_0_1 + 0.166666666666667*G3_0_1_1 + 0.166666666666667*G5_0_0_1 + 0.166666666666667*G5_0_1_1 + 0.003571428571429*G13_0_0 + 0.003571428571429*G13_0_1 - 0.004365079365079*G13_1_0 - 0.004365079365079*G13_1_1 + 0.007142857142857*G13_2_0 + 0.007142857142857*G13_2_1 + 0.006349206349206*G13_3_0 + 0.006349206349206*G13_3_1 + 0.012698412698413*G13_4_0 + 0.012698412698413*G13_4_1 + 0.007936507936508*G13_5_0 + 0.007936507936508*G13_5_1 + 0.003571428571429*G14_6_0 + 0.003571428571429*G14_6_1 + 0.004365079365079*G14_7_0 - 0.003571428571429*G14_8_1 - 0.006349206349206*G14_9_0 + 0.001587301587302*G14_9_1 + 0.006349206349206*G14_10_0 - 0.007936507936508*G14_11_0 - 0.001587301587302*G14_11_1 + 0.003571428571429*G15_6_0 + 0.003571428571429*G15_6_1 - 0.004365079365079*G15_7_0 - 0.004365079365079*G15_7_1 + 0.007142857142857*G15_8_0 + 0.007142857142857*G15_8_1 + 0.006349206349206*G15_9_0 + 0.006349206349206*G15_9_1 + 0.012698412698413*G15_10_0 + 0.012698412698413*G15_10_1 + 0.007936507936508*G15_11_0 + 0.007936507936508*G15_11_1;
    A[99] = -0.004761904761905*G13_0_0 - 0.004761904761905*G13_0_1 + 0.006349206349206*G13_1_0 + 0.006349206349206*G13_1_1 + 0.006349206349206*G13_2_0 + 0.006349206349206*G13_2_1 + 0.038095238095238*G13_3_0 + 0.038095238095238*G13_3_1 - 0.006349206349206*G13_4_0 - 0.006349206349206*G13_4_1 - 0.006349206349206*G13_5_0 - 0.006349206349206*G13_5_1 - 0.004761904761905*G14_6_0 - 0.004761904761905*G14_6_1 - 0.007936507936508*G14_7_0 - 0.007936507936508*G14_8_1 - 0.019047619047619*G14_9_0 - 0.019047619047619*G14_9_1 + 0.019047619047619*G14_10_0 + 0.012698412698413*G14_10_1 + 0.012698412698413*G14_11_0 + 0.019047619047619*G14_11_1 - 0.004761904761905*G15_6_0 - 0.004761904761905*G15_6_1 + 0.006349206349206*G15_7_0 + 0.006349206349206*G15_7_1 + 0.006349206349206*G15_8_0 + 0.006349206349206*G15_8_1 + 0.038095238095238*G15_9_0 + 0.038095238095238*G15_9_1 - 0.006349206349206*G15_10_0 - 0.006349206349206*G15_10_1 - 0.006349206349206*G15_11_0 - 0.006349206349206*G15_11_1;
    A[100] = -0.666666666666667*G3_0_0_1 - 0.666666666666667*G3_0_1_1 - 0.666666666666667*G5_0_0_1 - 0.666666666666667*G5_0_1_1 - 0.019047619047619*G13_0_0 - 0.019047619047619*G13_0_1 + 0.007936507936508*G13_1_0 + 0.007936507936508*G13_1_1 + 0.012698412698413*G13_2_0 + 0.012698412698413*G13_2_1 - 0.006349206349206*G13_3_0 - 0.006349206349206*G13_3_1 - 0.063492063492063*G13_4_0 - 0.063492063492063*G13_4_1 - 0.031746031746032*G13_5_0 - 0.031746031746032*G13_5_1 - 0.019047619047619*G14_6_0 - 0.019047619047619*G14_6_1 - 0.006349206349206*G14_7_0 - 0.012698412698413*G14_8_1 - 0.012698412698413*G14_9_0 - 0.006349206349206*G14_9_1 + 0.012698412698413*G14_10_0 + 0.031746031746032*G14_10_1 + 0.025396825396825*G14_11_0 + 0.006349206349206*G14_11_1 - 0.019047619047619*G15_6_0 - 0.019047619047619*G15_6_1 + 0.007936507936508*G15_7_0 + 0.007936507936508*G15_7_1 + 0.012698412698413*G15_8_0 + 0.012698412698413*G15_8_1 - 0.006349206349206*G15_9_0 - 0.006349206349206*G15_9_1 - 0.063492063492063*G15_10_0 - 0.063492063492063*G15_10_1 - 0.031746031746032*G15_11_0 - 0.031746031746032*G15_11_1;
    A[101] = -0.666666666666667*G3_0_0_0 - 0.666666666666667*G3_0_1_0 - 0.666666666666667*G5_0_0_0 - 0.666666666666667*G5_0_1_0 - 0.019047619047619*G13_0_0 - 0.019047619047619*G13_0_1 + 0.012698412698413*G13_1_0 + 0.012698412698413*G13_1_1 + 0.007936507936508*G13_2_0 + 0.007936507936508*G13_2_1 - 0.006349206349206*G13_3_0 - 0.006349206349206*G13_3_1 - 0.031746031746032*G13_4_0 - 0.031746031746032*G13_4_1 - 0.063492063492063*G13_5_0 - 0.063492063492063*G13_5_1 - 0.019047619047619*G14_6_0 - 0.019047619047619*G14_6_1 - 0.012698412698413*G14_7_0 - 0.006349206349206*G14_8_1 - 0.006349206349206*G14_9_0 - 0.012698412698413*G14_9_1 + 0.006349206349206*G14_10_0 + 0.025396825396825*G14_10_1 + 0.031746031746032*G14_11_0 + 0.012698412698413*G14_11_1 - 0.019047619047619*G15_6_0 - 0.019047619047619*G15_6_1 + 0.012698412698413*G15_7_0 + 0.012698412698413*G15_7_1 + 0.007936507936508*G15_8_0 + 0.007936507936508*G15_8_1 - 0.006349206349206*G15_9_0 - 0.006349206349206*G15_9_1 - 0.031746031746032*G15_10_0 - 0.031746031746032*G15_10_1 - 0.063492063492063*G15_11_0 - 0.063492063492063*G15_11_1;
    A[102] = -0.166666666666667*G1_0 - 0.166666666666667*G1_1;
    A[103] = 0.000000000000000;
    A[104] = 0.000000000000000;
    A[105] = 0.003571428571429*G10_0_0 + 0.003571428571429*G10_0_1 - 0.003571428571429*G10_1_0 + 0.004365079365079*G10_2_1 + 0.001587301587302*G10_3_0 - 0.006349206349206*G10_3_1 - 0.001587301587302*G10_4_0 - 0.007936507936508*G10_4_1 + 0.006349206349206*G10_5_1;
    A[106] = 0.007142857142857*G10_0_0 + 0.007142857142857*G10_0_1 + 0.030952380952381*G10_1_0 - 0.007142857142857*G10_2_1 + 0.009523809523810*G10_3_0 + 0.047619047619048*G10_3_1 - 0.009523809523810*G10_4_0 - 0.038095238095238*G10_5_0 - 0.047619047619048*G10_5_1;
    A[107] = -0.004365079365079*G10_0_0 - 0.004365079365079*G10_0_1 - 0.003571428571429*G10_1_0 - 0.003571428571429*G10_2_1 - 0.006349206349206*G10_3_0 - 0.006349206349206*G10_3_1 + 0.006349206349206*G10_4_0 + 0.007936507936508*G10_4_1 + 0.007936507936508*G10_5_0 + 0.006349206349206*G10_5_1;
    A[108] = 0.006349206349206*G10_0_0 + 0.006349206349206*G10_0_1 + 0.019047619047619*G10_1_0 - 0.012698412698413*G10_2_1 - 0.012698412698413*G10_3_0 + 0.019047619047619*G10_3_1 + 0.012698412698413*G10_4_0 + 0.006349206349206*G10_4_1 - 0.025396825396825*G10_5_0 - 0.019047619047619*G10_5_1;
    A[109] = 0.007936507936508*G10_0_0 + 0.007936507936508*G10_0_1 + 0.004761904761905*G10_1_0 - 0.007936507936508*G10_2_1 - 0.019047619047619*G10_3_0 - 0.006349206349206*G10_3_1 + 0.019047619047619*G10_4_0 - 0.012698412698413*G10_5_0 + 0.006349206349206*G10_5_1;
    A[110] = 0.012698412698413*G10_0_0 + 0.012698412698413*G10_0_1 + 0.019047619047619*G10_1_0 - 0.006349206349206*G10_2_1 - 0.006349206349206*G10_3_0 + 0.019047619047619*G10_3_1 + 0.006349206349206*G10_4_0 - 0.006349206349206*G10_4_1 - 0.031746031746032*G10_5_0 - 0.019047619047619*G10_5_1;
    A[111] = 0.166666666666667*G3_0_0_0 + 0.166666666666667*G3_0_0_1 + 0.166666666666667*G5_0_0_0 + 0.166666666666667*G5_0_0_1 - 0.007142857142857*G13_0_0 - 0.003571428571429*G13_1_0 + 0.004365079365079*G13_2_0 - 0.007936507936508*G13_3_0 - 0.006349206349206*G13_4_0 - 0.012698412698413*G13_5_0 + 0.003571428571429*G14_6_0 + 0.003571428571429*G14_6_1 - 0.003571428571429*G14_7_0 + 0.004365079365079*G14_8_1 + 0.001587301587302*G14_9_0 - 0.006349206349206*G14_9_1 - 0.001587301587302*G14_10_0 - 0.007936507936508*G14_10_1 + 0.006349206349206*G14_11_1 - 0.007142857142857*G15_6_0 - 0.003571428571429*G15_7_0 + 0.004365079365079*G15_8_0 - 0.007936507936508*G15_9_0 - 0.006349206349206*G15_10_0 - 0.012698412698413*G15_11_0;
    A[112] = 0.500000000000000*G3_0_0_0 + 0.500000000000000*G5_0_0_0 - 0.003571428571429*G13_0_0 + 0.030952380952381*G13_1_0 - 0.003571428571429*G13_2_0 + 0.019047619047619*G13_3_0 + 0.004761904761905*G13_4_0 + 0.019047619047619*G13_5_0 + 0.007142857142857*G14_6_0 + 0.007142857142857*G14_6_1 + 0.030952380952381*G14_7_0 - 0.007142857142857*G14_8_1 + 0.009523809523810*G14_9_0 + 0.047619047619048*G14_9_1 - 0.009523809523810*G14_10_0 - 0.038095238095238*G14_11_0 - 0.047619047619048*G14_11_1 - 0.003571428571429*G15_6_0 + 0.030952380952381*G15_7_0 - 0.003571428571429*G15_8_0 + 0.019047619047619*G15_9_0 + 0.004761904761905*G15_10_0 + 0.019047619047619*G15_11_0;
    A[113] = -0.166666666666667*G3_0_0_1 - 0.166666666666667*G5_0_0_1 + 0.004365079365079*G13_0_0 - 0.003571428571429*G13_1_0 - 0.007142857142857*G13_2_0 - 0.012698412698413*G13_3_0 - 0.006349206349206*G13_4_0 - 0.007936507936508*G13_5_0 - 0.004365079365079*G14_6_0 - 0.004365079365079*G14_6_1 - 0.003571428571429*G14_7_0 - 0.003571428571429*G14_8_1 - 0.006349206349206*G14_9_0 - 0.006349206349206*G14_9_1 + 0.006349206349206*G14_10_0 + 0.007936507936508*G14_10_1 + 0.007936507936508*G14_11_0 + 0.006349206349206*G14_11_1 + 0.004365079365079*G15_6_0 - 0.003571428571429*G15_7_0 - 0.007142857142857*G15_8_0 - 0.012698412698413*G15_9_0 - 0.006349206349206*G15_10_0 - 0.007936507936508*G15_11_0;
    A[114] = 0.666666666666666*G3_0_0_1 + 0.666666666666666*G5_0_0_1 - 0.007936507936508*G13_0_0 + 0.019047619047619*G13_1_0 - 0.012698412698413*G13_2_0 + 0.063492063492063*G13_3_0 + 0.006349206349206*G13_4_0 + 0.031746031746032*G13_5_0 + 0.006349206349206*G14_6_0 + 0.006349206349206*G14_6_1 + 0.019047619047619*G14_7_0 - 0.012698412698413*G14_8_1 - 0.012698412698413*G14_9_0 + 0.019047619047619*G14_9_1 + 0.012698412698413*G14_10_0 + 0.006349206349206*G14_10_1 - 0.025396825396825*G14_11_0 - 0.019047619047619*G14_11_1 - 0.007936507936508*G15_6_0 + 0.019047619047619*G15_7_0 - 0.012698412698413*G15_8_0 + 0.063492063492063*G15_9_0 + 0.006349206349206*G15_10_0 + 0.031746031746032*G15_11_0;
    A[115] = -0.006349206349206*G13_0_0 + 0.004761904761905*G13_1_0 - 0.006349206349206*G13_2_0 + 0.006349206349206*G13_3_0 - 0.038095238095238*G13_4_0 + 0.006349206349206*G13_5_0 + 0.007936507936508*G14_6_0 + 0.007936507936508*G14_6_1 + 0.004761904761905*G14_7_0 - 0.007936507936508*G14_8_1 - 0.019047619047619*G14_9_0 - 0.006349206349206*G14_9_1 + 0.019047619047619*G14_10_0 - 0.012698412698413*G14_11_0 + 0.006349206349206*G14_11_1 - 0.006349206349206*G15_6_0 + 0.004761904761905*G15_7_0 - 0.006349206349206*G15_8_0 + 0.006349206349206*G15_9_0 - 0.038095238095238*G15_10_0 + 0.006349206349206*G15_11_0;
    A[116] = -0.666666666666666*G3_0_0_0 - 0.666666666666666*G3_0_0_1 - 0.666666666666666*G5_0_0_0 - 0.666666666666666*G5_0_0_1 - 0.012698412698413*G13_0_0 + 0.019047619047619*G13_1_0 - 0.007936507936508*G13_2_0 + 0.031746031746032*G13_3_0 + 0.006349206349206*G13_4_0 + 0.063492063492064*G13_5_0 + 0.012698412698413*G14_6_0 + 0.012698412698413*G14_6_1 + 0.019047619047619*G14_7_0 - 0.006349206349206*G14_8_1 - 0.006349206349206*G14_9_0 + 0.019047619047619*G14_9_1 + 0.006349206349206*G14_10_0 - 0.006349206349206*G14_10_1 - 0.031746031746032*G14_11_0 - 0.019047619047619*G14_11_1 - 0.012698412698413*G15_6_0 + 0.019047619047619*G15_7_0 - 0.007936507936508*G15_8_0 + 0.031746031746032*G15_9_0 + 0.006349206349206*G15_10_0 + 0.063492063492064*G15_11_0;
    A[117] = 0.000000000000000;
    A[118] = 0.166666666666667*G1_0;
    A[119] = 0.000000000000000;
    A[120] = 0.003571428571429*G10_0_0 + 0.003571428571429*G10_0_1 + 0.004365079365079*G10_1_0 - 0.003571428571429*G10_2_1 - 0.006349206349206*G10_3_0 + 0.001587301587302*G10_3_1 + 0.006349206349206*G10_4_0 - 0.007936507936508*G10_5_0 - 0.001587301587302*G10_5_1;
    A[121] = -0.004365079365079*G10_0_0 - 0.004365079365079*G10_0_1 - 0.003571428571429*G10_1_0 - 0.003571428571429*G10_2_1 - 0.006349206349206*G10_3_0 - 0.006349206349206*G10_3_1 + 0.006349206349206*G10_4_0 + 0.007936507936508*G10_4_1 + 0.007936507936508*G10_5_0 + 0.006349206349206*G10_5_1;
    A[122] = 0.007142857142857*G10_0_0 + 0.007142857142857*G10_0_1 - 0.007142857142857*G10_1_0 + 0.030952380952381*G10_2_1 + 0.047619047619048*G10_3_0 + 0.009523809523809*G10_3_1 - 0.047619047619048*G10_4_0 - 0.038095238095238*G10_4_1 - 0.009523809523810*G10_5_1;
    A[123] = 0.006349206349206*G10_0_0 + 0.006349206349206*G10_0_1 - 0.012698412698413*G10_1_0 + 0.019047619047619*G10_2_1 + 0.019047619047619*G10_3_0 - 0.012698412698413*G10_3_1 - 0.019047619047619*G10_4_0 - 0.025396825396825*G10_4_1 + 0.006349206349206*G10_5_0 + 0.012698412698413*G10_5_1;
    A[124] = 0.012698412698413*G10_0_0 + 0.012698412698413*G10_0_1 - 0.006349206349206*G10_1_0 + 0.019047619047619*G10_2_1 + 0.019047619047619*G10_3_0 - 0.006349206349206*G10_3_1 - 0.019047619047619*G10_4_0 - 0.031746031746032*G10_4_1 - 0.006349206349206*G10_5_0 + 0.006349206349206*G10_5_1;
    A[125] = 0.007936507936508*G10_0_0 + 0.007936507936508*G10_0_1 - 0.007936507936508*G10_1_0 + 0.004761904761905*G10_2_1 - 0.006349206349206*G10_3_0 - 0.019047619047619*G10_3_1 + 0.006349206349206*G10_4_0 - 0.012698412698413*G10_4_1 + 0.019047619047619*G10_5_1;
    A[126] = 0.166666666666667*G3_0_1_0 + 0.166666666666667*G3_0_1_1 + 0.166666666666667*G5_0_1_0 + 0.166666666666667*G5_0_1_1 - 0.007142857142857*G13_0_1 + 0.004365079365079*G13_1_1 - 0.003571428571429*G13_2_1 - 0.007936507936508*G13_3_1 - 0.012698412698413*G13_4_1 - 0.006349206349206*G13_5_1 + 0.003571428571429*G14_6_0 + 0.003571428571429*G14_6_1 + 0.004365079365079*G14_7_0 - 0.003571428571429*G14_8_1 - 0.006349206349206*G14_9_0 + 0.001587301587302*G14_9_1 + 0.006349206349206*G14_10_0 - 0.007936507936508*G14_11_0 - 0.001587301587302*G14_11_1 - 0.007142857142857*G15_6_1 + 0.004365079365079*G15_7_1 - 0.003571428571429*G15_8_1 - 0.007936507936508*G15_9_1 - 0.012698412698413*G15_10_1 - 0.006349206349206*G15_11_1;
    A[127] = -0.166666666666667*G3_0_1_0 - 0.166666666666667*G5_0_1_0 + 0.004365079365079*G13_0_1 - 0.007142857142857*G13_1_1 - 0.003571428571429*G13_2_1 - 0.012698412698413*G13_3_1 - 0.007936507936508*G13_4_1 - 0.006349206349206*G13_5_1 - 0.004365079365079*G14_6_0 - 0.004365079365079*G14_6_1 - 0.003571428571429*G14_7_0 - 0.003571428571429*G14_8_1 - 0.006349206349206*G14_9_0 - 0.006349206349206*G14_9_1 + 0.006349206349206*G14_10_0 + 0.007936507936508*G14_10_1 + 0.007936507936508*G14_11_0 + 0.006349206349206*G14_11_1 + 0.004365079365079*G15_6_1 - 0.007142857142857*G15_7_1 - 0.003571428571429*G15_8_1 - 0.012698412698413*G15_9_1 - 0.007936507936508*G15_10_1 - 0.006349206349206*G15_11_1;
    A[128] = 0.500000000000000*G3_0_1_1 + 0.500000000000000*G5_0_1_1 - 0.003571428571429*G13_0_1 - 0.003571428571429*G13_1_1 + 0.030952380952381*G13_2_1 + 0.019047619047619*G13_3_1 + 0.019047619047619*G13_4_1 + 0.004761904761905*G13_5_1 + 0.007142857142857*G14_6_0 + 0.007142857142857*G14_6_1 - 0.007142857142857*G14_7_0 + 0.030952380952381*G14_8_1 + 0.047619047619048*G14_9_0 + 0.009523809523809*G14_9_1 - 0.047619047619048*G14_10_0 - 0.038095238095238*G14_10_1 - 0.009523809523810*G14_11_1 - 0.003571428571429*G15_6_1 - 0.003571428571429*G15_7_1 + 0.030952380952381*G15_8_1 + 0.019047619047619*G15_9_1 + 0.019047619047619*G15_10_1 + 0.004761904761905*G15_11_1;
    A[129] = 0.666666666666666*G3_0_1_0 + 0.666666666666666*G5_0_1_0 - 0.007936507936508*G13_0_1 - 0.012698412698413*G13_1_1 + 0.019047619047619*G13_2_1 + 0.063492063492063*G13_3_1 + 0.031746031746032*G13_4_1 + 0.006349206349206*G13_5_1 + 0.006349206349206*G14_6_0 + 0.006349206349206*G14_6_1 - 0.012698412698413*G14_7_0 + 0.019047619047619*G14_8_1 + 0.019047619047619*G14_9_0 - 0.012698412698413*G14_9_1 - 0.019047619047619*G14_10_0 - 0.025396825396825*G14_10_1 + 0.006349206349206*G14_11_0 + 0.012698412698413*G14_11_1 - 0.007936507936508*G15_6_1 - 0.012698412698413*G15_7_1 + 0.019047619047619*G15_8_1 + 0.063492063492063*G15_9_1 + 0.031746031746032*G15_10_1 + 0.006349206349206*G15_11_1;
    A[130] = -0.666666666666666*G3_0_1_0 - 0.666666666666666*G3_0_1_1 - 0.666666666666666*G5_0_1_0 - 0.666666666666666*G5_0_1_1 - 0.012698412698413*G13_0_1 - 0.007936507936508*G13_1_1 + 0.019047619047619*G13_2_1 + 0.031746031746032*G13_3_1 + 0.063492063492063*G13_4_1 + 0.006349206349206*G13_5_1 + 0.012698412698413*G14_6_0 + 0.012698412698413*G14_6_1 - 0.006349206349206*G14_7_0 + 0.019047619047619*G14_8_1 + 0.019047619047619*G14_9_0 - 0.006349206349206*G14_9_1 - 0.019047619047619*G14_10_0 - 0.031746031746032*G14_10_1 - 0.006349206349206*G14_11_0 + 0.006349206349206*G14_11_1 - 0.012698412698413*G15_6_1 - 0.007936507936508*G15_7_1 + 0.019047619047619*G15_8_1 + 0.031746031746032*G15_9_1 + 0.063492063492063*G15_10_1 + 0.006349206349206*G15_11_1;
    A[131] = -0.006349206349206*G13_0_1 - 0.006349206349206*G13_1_1 + 0.004761904761905*G13_2_1 + 0.006349206349206*G13_3_1 + 0.006349206349206*G13_4_1 - 0.038095238095238*G13_5_1 + 0.007936507936508*G14_6_0 + 0.007936507936508*G14_6_1 - 0.007936507936508*G14_7_0 + 0.004761904761905*G14_8_1 - 0.006349206349206*G14_9_0 - 0.019047619047619*G14_9_1 + 0.006349206349206*G14_10_0 - 0.012698412698413*G14_10_1 + 0.019047619047619*G14_11_1 - 0.006349206349206*G15_6_1 - 0.006349206349206*G15_7_1 + 0.004761904761905*G15_8_1 + 0.006349206349206*G15_9_1 + 0.006349206349206*G15_10_1 - 0.038095238095238*G15_11_1;
    A[132] = 0.000000000000000;
    A[133] = 0.000000000000000;
    A[134] = 0.166666666666667*G1_1;
    A[135] = -0.004761904761905*G10_0_0 - 0.004761904761905*G10_0_1 - 0.007936507936508*G10_1_0 - 0.007936507936508*G10_2_1 - 0.019047619047619*G10_3_0 - 0.019047619047619*G10_3_1 + 0.019047619047619*G10_4_0 + 0.012698412698413*G10_4_1 + 0.012698412698413*G10_5_0 + 0.019047619047619*G10_5_1;
    A[136] = 0.006349206349206*G10_0_0 + 0.006349206349206*G10_0_1 + 0.019047619047619*G10_1_0 - 0.012698412698413*G10_2_1 - 0.012698412698413*G10_3_0 + 0.019047619047619*G10_3_1 + 0.012698412698413*G10_4_0 + 0.006349206349206*G10_4_1 - 0.025396825396825*G10_5_0 - 0.019047619047619*G10_5_1;
    A[137] = 0.006349206349206*G10_0_0 + 0.006349206349206*G10_0_1 - 0.012698412698413*G10_1_0 + 0.019047619047619*G10_2_1 + 0.019047619047619*G10_3_0 - 0.012698412698413*G10_3_1 - 0.019047619047619*G10_4_0 - 0.025396825396825*G10_4_1 + 0.006349206349206*G10_5_0 + 0.012698412698413*G10_5_1;
    A[138] = 0.038095238095238*G10_0_0 + 0.038095238095238*G10_0_1 + 0.063492063492063*G10_1_0 + 0.063492063492063*G10_2_1 + 0.152380952380952*G10_3_0 + 0.152380952380952*G10_3_1 - 0.152380952380952*G10_4_0 - 0.101587301587301*G10_4_1 - 0.101587301587301*G10_5_0 - 0.152380952380952*G10_5_1;
    A[139] = -0.006349206349206*G10_0_0 - 0.006349206349206*G10_0_1 + 0.006349206349206*G10_1_0 + 0.031746031746032*G10_2_1 + 0.076190476190476*G10_3_0 + 0.050793650793651*G10_3_1 - 0.076190476190476*G10_4_0 - 0.025396825396825*G10_4_1 - 0.050793650793651*G10_5_1;
    A[140] = -0.006349206349206*G10_0_0 - 0.006349206349206*G10_0_1 + 0.031746031746032*G10_1_0 + 0.006349206349206*G10_2_1 + 0.050793650793651*G10_3_0 + 0.076190476190476*G10_3_1 - 0.050793650793651*G10_4_0 - 0.025396825396825*G10_5_0 - 0.076190476190476*G10_5_1;
    A[141] = 0.009523809523810*G13_0_0 + 0.009523809523810*G13_0_1 + 0.001587301587302*G13_1_0 - 0.006349206349206*G13_1_1 - 0.006349206349206*G13_2_0 + 0.001587301587302*G13_2_1 - 0.019047619047619*G13_3_0 - 0.019047619047619*G13_3_1 - 0.012698412698413*G13_4_0 - 0.006349206349206*G13_4_1 - 0.006349206349206*G13_5_0 - 0.012698412698413*G13_5_1 - 0.004761904761905*G14_6_0 - 0.004761904761905*G14_6_1 - 0.007936507936508*G14_7_0 - 0.007936507936508*G14_8_1 - 0.019047619047619*G14_9_0 - 0.019047619047619*G14_9_1 + 0.019047619047619*G14_10_0 + 0.012698412698413*G14_10_1 + 0.012698412698413*G14_11_0 + 0.019047619047619*G14_11_1 + 0.009523809523810*G15_6_0 + 0.009523809523810*G15_6_1 + 0.001587301587302*G15_7_0 - 0.006349206349206*G15_7_1 - 0.006349206349206*G15_8_0 + 0.001587301587302*G15_8_1 - 0.019047619047619*G15_9_0 - 0.019047619047619*G15_9_1 - 0.012698412698413*G15_10_0 - 0.006349206349206*G15_10_1 - 0.006349206349206*G15_11_0 - 0.012698412698413*G15_11_1;
    A[142] = 0.666666666666666*G3_0_1_0 + 0.666666666666666*G5_0_1_0 + 0.001587301587302*G13_0_0 - 0.006349206349206*G13_0_1 + 0.009523809523810*G13_1_0 + 0.047619047619048*G13_1_1 - 0.006349206349206*G13_2_0 - 0.006349206349206*G13_2_1 - 0.012698412698413*G13_3_0 + 0.019047619047619*G13_3_1 - 0.019047619047619*G13_4_0 - 0.006349206349206*G13_4_1 - 0.006349206349206*G13_5_0 + 0.019047619047619*G13_5_1 + 0.006349206349206*G14_6_0 + 0.006349206349206*G14_6_1 + 0.019047619047619*G14_7_0 - 0.012698412698413*G14_8_1 - 0.012698412698413*G14_9_0 + 0.019047619047619*G14_9_1 + 0.012698412698413*G14_10_0 + 0.006349206349206*G14_10_1 - 0.025396825396825*G14_11_0 - 0.019047619047619*G14_11_1 + 0.001587301587302*G15_6_0 - 0.006349206349206*G15_6_1 + 0.009523809523810*G15_7_0 + 0.047619047619048*G15_7_1 - 0.006349206349206*G15_8_0 - 0.006349206349206*G15_8_1 - 0.012698412698413*G15_9_0 + 0.019047619047619*G15_9_1 - 0.019047619047619*G15_10_0 - 0.006349206349206*G15_10_1 - 0.006349206349206*G15_11_0 + 0.019047619047619*G15_11_1;
    A[143] = 0.666666666666666*G3_0_0_1 + 0.666666666666666*G5_0_0_1 - 0.006349206349206*G13_0_0 + 0.001587301587302*G13_0_1 - 0.006349206349206*G13_1_0 - 0.006349206349206*G13_1_1 + 0.047619047619048*G13_2_0 + 0.009523809523809*G13_2_1 + 0.019047619047619*G13_3_0 - 0.012698412698413*G13_3_1 + 0.019047619047619*G13_4_0 - 0.006349206349206*G13_4_1 - 0.006349206349206*G13_5_0 - 0.019047619047619*G13_5_1 + 0.006349206349206*G14_6_0 + 0.006349206349206*G14_6_1 - 0.012698412698413*G14_7_0 + 0.019047619047619*G14_8_1 + 0.019047619047619*G14_9_0 - 0.012698412698413*G14_9_1 - 0.019047619047619*G14_10_0 - 0.025396825396825*G14_10_1 + 0.006349206349206*G14_11_0 + 0.012698412698413*G14_11_1 - 0.006349206349206*G15_6_0 + 0.001587301587302*G15_6_1 - 0.006349206349206*G15_7_0 - 0.006349206349206*G15_7_1 + 0.047619047619048*G15_8_0 + 0.009523809523809*G15_8_1 + 0.019047619047619*G15_9_0 - 0.012698412698413*G15_9_1 + 0.019047619047619*G15_10_0 - 0.006349206349206*G15_10_1 - 0.006349206349206*G15_11_0 - 0.019047619047619*G15_11_1;
    A[144] = 1.333333333333332*G3_0_0_0 + 0.666666666666666*G3_0_0_1 + 0.666666666666666*G3_0_1_0 + 1.333333333333332*G3_0_1_1 + 1.333333333333332*G5_0_0_0 + 0.666666666666666*G5_0_0_1 + 0.666666666666666*G5_0_1_0 + 1.333333333333332*G5_0_1_1 - 0.019047619047619*G13_0_0 - 0.019047619047619*G13_0_1 - 0.012698412698413*G13_1_0 + 0.019047619047619*G13_1_1 + 0.019047619047619*G13_2_0 - 0.012698412698413*G13_2_1 + 0.152380952380952*G13_3_0 + 0.152380952380952*G13_3_1 + 0.076190476190476*G13_4_0 + 0.050793650793651*G13_4_1 + 0.050793650793651*G13_5_0 + 0.076190476190476*G13_5_1 + 0.038095238095238*G14_6_0 + 0.038095238095238*G14_6_1 + 0.063492063492063*G14_7_0 + 0.063492063492063*G14_8_1 + 0.152380952380952*G14_9_0 + 0.152380952380952*G14_9_1 - 0.152380952380952*G14_10_0 - 0.101587301587301*G14_10_1 - 0.101587301587301*G14_11_0 - 0.152380952380952*G14_11_1 - 0.019047619047619*G15_6_0 - 0.019047619047619*G15_6_1 - 0.012698412698413*G15_7_0 + 0.019047619047619*G15_7_1 + 0.019047619047619*G15_8_0 - 0.012698412698413*G15_8_1 + 0.152380952380952*G15_9_0 + 0.152380952380952*G15_9_1 + 0.076190476190476*G15_10_0 + 0.050793650793651*G15_10_1 + 0.050793650793651*G15_11_0 + 0.076190476190476*G15_11_1;
    A[145] = -1.333333333333332*G3_0_0_0 - 0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_0 - 1.333333333333332*G5_0_0_0 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_0 - 0.012698412698413*G13_0_0 - 0.006349206349206*G13_0_1 - 0.019047619047619*G13_1_0 - 0.006349206349206*G13_1_1 + 0.019047619047619*G13_2_0 - 0.006349206349206*G13_2_1 + 0.076190476190476*G13_3_0 + 0.050793650793651*G13_3_1 + 0.152380952380952*G13_4_0 + 0.050793650793651*G13_4_1 + 0.050793650793651*G13_5_0 + 0.050793650793651*G13_5_1 - 0.006349206349206*G14_6_0 - 0.006349206349206*G14_6_1 + 0.006349206349206*G14_7_0 + 0.031746031746032*G14_8_1 + 0.076190476190476*G14_9_0 + 0.050793650793651*G14_9_1 - 0.076190476190476*G14_10_0 - 0.025396825396825*G14_10_1 - 0.050793650793651*G14_11_1 - 0.012698412698413*G15_6_0 - 0.006349206349206*G15_6_1 - 0.019047619047619*G15_7_0 - 0.006349206349206*G15_7_1 + 0.019047619047619*G15_8_0 - 0.006349206349206*G15_8_1 + 0.076190476190476*G15_9_0 + 0.050793650793651*G15_9_1 + 0.152380952380952*G15_10_0 + 0.050793650793651*G15_10_1 + 0.050793650793651*G15_11_0 + 0.050793650793651*G15_11_1;
    A[146] = -0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_0 - 1.333333333333332*G3_0_1_1 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_0 - 1.333333333333332*G5_0_1_1 - 0.006349206349206*G13_0_0 - 0.012698412698413*G13_0_1 - 0.006349206349206*G13_1_0 + 0.019047619047619*G13_1_1 - 0.006349206349206*G13_2_0 - 0.019047619047619*G13_2_1 + 0.050793650793651*G13_3_0 + 0.076190476190476*G13_3_1 + 0.050793650793651*G13_4_0 + 0.050793650793651*G13_4_1 + 0.050793650793651*G13_5_0 + 0.152380952380952*G13_5_1 - 0.006349206349206*G14_6_0 - 0.006349206349206*G14_6_1 + 0.031746031746032*G14_7_0 + 0.006349206349206*G14_8_1 + 0.050793650793651*G14_9_0 + 0.076190476190476*G14_9_1 - 0.050793650793651*G14_10_0 - 0.025396825396825*G14_11_0 - 0.076190476190476*G14_11_1 - 0.006349206349206*G15_6_0 - 0.012698412698413*G15_6_1 - 0.006349206349206*G15_7_0 + 0.019047619047619*G15_7_1 - 0.006349206349206*G15_8_0 - 0.019047619047619*G15_8_1 + 0.050793650793651*G15_9_0 + 0.076190476190476*G15_9_1 + 0.050793650793651*G15_10_0 + 0.050793650793651*G15_10_1 + 0.050793650793651*G15_11_0 + 0.152380952380952*G15_11_1;
    A[147] = 0.166666666666667*G1_0 + 0.166666666666667*G1_1;
    A[148] = 0.166666666666667*G1_0 + 0.333333333333333*G1_1;
    A[149] = 0.333333333333333*G1_0 + 0.166666666666667*G1_1;
    A[150] = -0.019047619047619*G10_0_0 - 0.019047619047619*G10_0_1 - 0.006349206349206*G10_1_0 - 0.012698412698413*G10_2_1 - 0.012698412698413*G10_3_0 - 0.006349206349206*G10_3_1 + 0.012698412698413*G10_4_0 + 0.031746031746032*G10_4_1 + 0.025396825396825*G10_5_0 + 0.006349206349206*G10_5_1;
    A[151] = 0.007936507936508*G10_0_0 + 0.007936507936508*G10_0_1 + 0.004761904761905*G10_1_0 - 0.007936507936508*G10_2_1 - 0.019047619047619*G10_3_0 - 0.006349206349206*G10_3_1 + 0.019047619047619*G10_4_0 - 0.012698412698413*G10_5_0 + 0.006349206349206*G10_5_1;
    A[152] = 0.012698412698413*G10_0_0 + 0.012698412698413*G10_0_1 - 0.006349206349206*G10_1_0 + 0.019047619047619*G10_2_1 + 0.019047619047619*G10_3_0 - 0.006349206349206*G10_3_1 - 0.019047619047619*G10_4_0 - 0.031746031746032*G10_4_1 - 0.006349206349206*G10_5_0 + 0.006349206349206*G10_5_1;
    A[153] = -0.006349206349206*G10_0_0 - 0.006349206349206*G10_0_1 + 0.006349206349206*G10_1_0 + 0.031746031746032*G10_2_1 + 0.076190476190476*G10_3_0 + 0.050793650793651*G10_3_1 - 0.076190476190476*G10_4_0 - 0.025396825396825*G10_4_1 - 0.050793650793651*G10_5_1;
    A[154] = -0.063492063492063*G10_0_0 - 0.063492063492063*G10_0_1 - 0.038095238095238*G10_1_0 + 0.063492063492063*G10_2_1 + 0.152380952380952*G10_3_0 + 0.050793650793651*G10_3_1 - 0.152380952380952*G10_4_0 + 0.101587301587302*G10_5_0 - 0.050793650793651*G10_5_1;
    A[155] = -0.031746031746032*G10_0_0 - 0.031746031746032*G10_0_1 + 0.006349206349206*G10_1_0 + 0.006349206349206*G10_2_1 + 0.050793650793651*G10_3_0 + 0.050793650793651*G10_3_1 - 0.050793650793651*G10_4_0 + 0.025396825396825*G10_4_1 + 0.025396825396825*G10_5_0 - 0.050793650793651*G10_5_1;
    A[156] = -0.666666666666667*G3_0_1_0 - 0.666666666666667*G3_0_1_1 - 0.666666666666667*G5_0_1_0 - 0.666666666666667*G5_0_1_1 - 0.009523809523810*G13_0_0 + 0.038095238095238*G13_0_1 - 0.001587301587302*G13_1_0 - 0.007936507936508*G13_1_1 + 0.006349206349206*G13_2_0 + 0.019047619047619*G13_3_0 + 0.012698412698413*G13_3_1 + 0.012698412698413*G13_4_0 + 0.031746031746032*G13_4_1 + 0.006349206349206*G13_5_0 + 0.025396825396825*G13_5_1 - 0.019047619047619*G14_6_0 - 0.019047619047619*G14_6_1 - 0.006349206349206*G14_7_0 - 0.012698412698413*G14_8_1 - 0.012698412698413*G14_9_0 - 0.006349206349206*G14_9_1 + 0.012698412698413*G14_10_0 + 0.031746031746032*G14_10_1 + 0.025396825396825*G14_11_0 + 0.006349206349206*G14_11_1 - 0.009523809523810*G15_6_0 + 0.038095238095238*G15_6_1 - 0.001587301587302*G15_7_0 - 0.007936507936508*G15_7_1 + 0.006349206349206*G15_8_0 + 0.019047619047619*G15_9_0 + 0.012698412698413*G15_9_1 + 0.012698412698413*G15_10_0 + 0.031746031746032*G15_10_1 + 0.006349206349206*G15_11_0 + 0.025396825396825*G15_11_1;
    A[157] = -0.001587301587302*G13_0_0 - 0.007936507936508*G13_0_1 - 0.009523809523810*G13_1_0 + 0.006349206349206*G13_2_0 + 0.007936507936508*G13_2_1 + 0.012698412698413*G13_3_0 + 0.006349206349206*G13_3_1 + 0.019047619047619*G13_4_0 + 0.006349206349206*G13_5_0 - 0.006349206349206*G13_5_1 + 0.007936507936508*G14_6_0 + 0.007936507936508*G14_6_1 + 0.004761904761905*G14_7_0 - 0.007936507936508*G14_8_1 - 0.019047619047619*G14_9_0 - 0.006349206349206*G14_9_1 + 0.019047619047619*G14_10_0 - 0.012698412698413*G14_11_0 + 0.006349206349206*G14_11_1 - 0.001587301587302*G15_6_0 - 0.007936507936508*G15_6_1 - 0.009523809523810*G15_7_0 + 0.006349206349206*G15_8_0 + 0.007936507936508*G15_8_1 + 0.012698412698413*G15_9_0 + 0.006349206349206*G15_9_1 + 0.019047619047619*G15_10_0 + 0.006349206349206*G15_11_0 - 0.006349206349206*G15_11_1;
    A[158] = -0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_1 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_1 + 0.006349206349206*G13_0_0 + 0.006349206349206*G13_1_0 + 0.007936507936508*G13_1_1 - 0.047619047619048*G13_2_0 - 0.038095238095238*G13_2_1 - 0.019047619047619*G13_3_0 - 0.025396825396825*G13_3_1 - 0.019047619047619*G13_4_0 - 0.031746031746032*G13_4_1 + 0.006349206349206*G13_5_0 - 0.012698412698413*G13_5_1 + 0.012698412698413*G14_6_0 + 0.012698412698413*G14_6_1 - 0.006349206349206*G14_7_0 + 0.019047619047619*G14_8_1 + 0.019047619047619*G14_9_0 - 0.006349206349206*G14_9_1 - 0.019047619047619*G14_10_0 - 0.031746031746032*G14_10_1 - 0.006349206349206*G14_11_0 + 0.006349206349206*G14_11_1 + 0.006349206349206*G15_6_0 + 0.006349206349206*G15_7_0 + 0.007936507936508*G15_7_1 - 0.047619047619048*G15_8_0 - 0.038095238095238*G15_8_1 - 0.019047619047619*G15_9_0 - 0.025396825396825*G15_9_1 - 0.019047619047619*G15_10_0 - 0.031746031746032*G15_10_1 + 0.006349206349206*G15_11_0 - 0.012698412698413*G15_11_1;
    A[159] = -1.333333333333332*G3_0_0_0 - 0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_0 - 1.333333333333332*G5_0_0_0 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_0 + 0.019047619047619*G13_0_0 + 0.012698412698413*G13_0_1 + 0.012698412698413*G13_1_0 + 0.006349206349206*G13_1_1 - 0.019047619047619*G13_2_0 - 0.025396825396825*G13_2_1 - 0.152380952380952*G13_3_0 - 0.101587301587301*G13_3_1 - 0.076190476190476*G13_4_0 - 0.025396825396825*G13_4_1 - 0.050793650793651*G13_5_0 - 0.006349206349206*G14_6_0 - 0.006349206349206*G14_6_1 + 0.006349206349206*G14_7_0 + 0.031746031746032*G14_8_1 + 0.076190476190476*G14_9_0 + 0.050793650793651*G14_9_1 - 0.076190476190476*G14_10_0 - 0.025396825396825*G14_10_1 - 0.050793650793651*G14_11_1 + 0.019047619047619*G15_6_0 + 0.012698412698413*G15_6_1 + 0.012698412698413*G15_7_0 + 0.006349206349206*G15_7_1 - 0.019047619047619*G15_8_0 - 0.025396825396825*G15_8_1 - 0.152380952380952*G15_9_0 - 0.101587301587301*G15_9_1 - 0.076190476190476*G15_10_0 - 0.025396825396825*G15_10_1 - 0.050793650793651*G15_11_0;
    A[160] = 1.333333333333332*G3_0_0_0 + 0.666666666666666*G3_0_0_1 + 0.666666666666666*G3_0_1_0 + 1.333333333333333*G3_0_1_1 + 1.333333333333332*G5_0_0_0 + 0.666666666666666*G5_0_0_1 + 0.666666666666666*G5_0_1_0 + 1.333333333333333*G5_0_1_1 + 0.012698412698413*G13_0_0 + 0.031746031746032*G13_0_1 + 0.019047619047619*G13_1_0 - 0.019047619047619*G13_2_0 - 0.031746031746032*G13_2_1 - 0.076190476190476*G13_3_0 - 0.025396825396825*G13_3_1 - 0.152380952380952*G13_4_0 - 0.050793650793651*G13_5_0 + 0.025396825396825*G13_5_1 - 0.063492063492063*G14_6_0 - 0.063492063492063*G14_6_1 - 0.038095238095238*G14_7_0 + 0.063492063492063*G14_8_1 + 0.152380952380952*G14_9_0 + 0.050793650793651*G14_9_1 - 0.152380952380952*G14_10_0 + 0.101587301587302*G14_11_0 - 0.050793650793651*G14_11_1 + 0.012698412698413*G15_6_0 + 0.031746031746032*G15_6_1 + 0.019047619047619*G15_7_0 - 0.019047619047619*G15_8_0 - 0.031746031746032*G15_8_1 - 0.076190476190476*G15_9_0 - 0.025396825396825*G15_9_1 - 0.152380952380952*G15_10_0 - 0.050793650793651*G15_11_0 + 0.025396825396825*G15_11_1;
    A[161] = 0.666666666666666*G3_0_0_1 + 0.666666666666667*G3_0_1_0 + 0.666666666666666*G5_0_0_1 + 0.666666666666667*G5_0_1_0 + 0.006349206349206*G13_0_0 + 0.025396825396825*G13_0_1 + 0.006349206349206*G13_1_0 - 0.006349206349206*G13_1_1 + 0.006349206349206*G13_2_0 - 0.012698412698413*G13_2_1 - 0.050793650793651*G13_3_0 - 0.050793650793651*G13_4_0 + 0.025396825396825*G13_4_1 - 0.050793650793651*G13_5_0 + 0.101587301587302*G13_5_1 - 0.031746031746032*G14_6_0 - 0.031746031746032*G14_6_1 + 0.006349206349206*G14_7_0 + 0.006349206349206*G14_8_1 + 0.050793650793651*G14_9_0 + 0.050793650793651*G14_9_1 - 0.050793650793651*G14_10_0 + 0.025396825396825*G14_10_1 + 0.025396825396825*G14_11_0 - 0.050793650793651*G14_11_1 + 0.006349206349206*G15_6_0 + 0.025396825396825*G15_6_1 + 0.006349206349206*G15_7_0 - 0.006349206349206*G15_7_1 + 0.006349206349206*G15_8_0 - 0.012698412698413*G15_8_1 - 0.050793650793651*G15_9_0 - 0.050793650793651*G15_10_0 + 0.025396825396825*G15_10_1 - 0.050793650793651*G15_11_0 + 0.101587301587302*G15_11_1;
    A[162] = -0.166666666666667*G1_0 + 0.166666666666667*G1_1;
    A[163] = -0.166666666666667*G1_0;
    A[164] = -0.333333333333333*G1_0 - 0.166666666666666*G1_1;
    A[165] = -0.019047619047619*G10_0_0 - 0.019047619047619*G10_0_1 - 0.012698412698413*G10_1_0 - 0.006349206349206*G10_2_1 - 0.006349206349206*G10_3_0 - 0.012698412698413*G10_3_1 + 0.006349206349206*G10_4_0 + 0.025396825396825*G10_4_1 + 0.031746031746032*G10_5_0 + 0.012698412698413*G10_5_1;
    A[166] = 0.012698412698413*G10_0_0 + 0.012698412698413*G10_0_1 + 0.019047619047619*G10_1_0 - 0.006349206349206*G10_2_1 - 0.006349206349206*G10_3_0 + 0.019047619047619*G10_3_1 + 0.006349206349206*G10_4_0 - 0.006349206349206*G10_4_1 - 0.031746031746032*G10_5_0 - 0.019047619047619*G10_5_1;
    A[167] = 0.007936507936508*G10_0_0 + 0.007936507936508*G10_0_1 - 0.007936507936508*G10_1_0 + 0.004761904761905*G10_2_1 - 0.006349206349206*G10_3_0 - 0.019047619047619*G10_3_1 + 0.006349206349206*G10_4_0 - 0.012698412698413*G10_4_1 + 0.019047619047619*G10_5_1;
    A[168] = -0.006349206349206*G10_0_0 - 0.006349206349206*G10_0_1 + 0.031746031746032*G10_1_0 + 0.006349206349206*G10_2_1 + 0.050793650793651*G10_3_0 + 0.076190476190476*G10_3_1 - 0.050793650793651*G10_4_0 - 0.025396825396825*G10_5_0 - 0.076190476190476*G10_5_1;
    A[169] = -0.031746031746032*G10_0_0 - 0.031746031746032*G10_0_1 + 0.006349206349206*G10_1_0 + 0.006349206349206*G10_2_1 + 0.050793650793651*G10_3_0 + 0.050793650793651*G10_3_1 - 0.050793650793651*G10_4_0 + 0.025396825396825*G10_4_1 + 0.025396825396825*G10_5_0 - 0.050793650793651*G10_5_1;
    A[170] = -0.063492063492063*G10_0_0 - 0.063492063492063*G10_0_1 + 0.063492063492064*G10_1_0 - 0.038095238095238*G10_2_1 + 0.050793650793651*G10_3_0 + 0.152380952380952*G10_3_1 - 0.050793650793651*G10_4_0 + 0.101587301587302*G10_4_1 - 0.152380952380952*G10_5_1;
    A[171] = -0.666666666666667*G3_0_0_0 - 0.666666666666667*G3_0_0_1 - 0.666666666666667*G5_0_0_0 - 0.666666666666667*G5_0_0_1 + 0.038095238095238*G13_0_0 - 0.009523809523810*G13_0_1 + 0.006349206349206*G13_1_1 - 0.007936507936508*G13_2_0 - 0.001587301587302*G13_2_1 + 0.012698412698413*G13_3_0 + 0.019047619047619*G13_3_1 + 0.025396825396825*G13_4_0 + 0.006349206349206*G13_4_1 + 0.031746031746032*G13_5_0 + 0.012698412698413*G13_5_1 - 0.019047619047619*G14_6_0 - 0.019047619047619*G14_6_1 - 0.012698412698413*G14_7_0 - 0.006349206349206*G14_8_1 - 0.006349206349206*G14_9_0 - 0.012698412698413*G14_9_1 + 0.006349206349206*G14_10_0 + 0.025396825396825*G14_10_1 + 0.031746031746032*G14_11_0 + 0.012698412698413*G14_11_1 + 0.038095238095238*G15_6_0 - 0.009523809523810*G15_6_1 + 0.006349206349206*G15_7_1 - 0.007936507936508*G15_8_0 - 0.001587301587302*G15_8_1 + 0.012698412698413*G15_9_0 + 0.019047619047619*G15_9_1 + 0.025396825396825*G15_10_0 + 0.006349206349206*G15_10_1 + 0.031746031746032*G15_11_0 + 0.012698412698413*G15_11_1;
    A[172] = -0.666666666666666*G3_0_0_0 - 0.666666666666666*G3_0_1_0 - 0.666666666666666*G5_0_0_0 - 0.666666666666666*G5_0_1_0 + 0.006349206349206*G13_0_1 - 0.038095238095238*G13_1_0 - 0.047619047619048*G13_1_1 + 0.007936507936508*G13_2_0 + 0.006349206349206*G13_2_1 - 0.025396825396825*G13_3_0 - 0.019047619047619*G13_3_1 - 0.012698412698413*G13_4_0 + 0.006349206349206*G13_4_1 - 0.031746031746032*G13_5_0 - 0.019047619047619*G13_5_1 + 0.012698412698413*G14_6_0 + 0.012698412698413*G14_6_1 + 0.019047619047619*G14_7_0 - 0.006349206349206*G14_8_1 - 0.006349206349206*G14_9_0 + 0.019047619047619*G14_9_1 + 0.006349206349206*G14_10_0 - 0.006349206349206*G14_10_1 - 0.031746031746032*G14_11_0 - 0.019047619047619*G14_11_1 + 0.006349206349206*G15_6_1 - 0.038095238095238*G15_7_0 - 0.047619047619048*G15_7_1 + 0.007936507936508*G15_8_0 + 0.006349206349206*G15_8_1 - 0.025396825396825*G15_9_0 - 0.019047619047619*G15_9_1 - 0.012698412698413*G15_10_0 + 0.006349206349206*G15_10_1 - 0.031746031746032*G15_11_0 - 0.019047619047619*G15_11_1;
    A[173] = -0.007936507936508*G13_0_0 - 0.001587301587302*G13_0_1 + 0.007936507936508*G13_1_0 + 0.006349206349206*G13_1_1 - 0.009523809523810*G13_2_1 + 0.006349206349206*G13_3_0 + 0.012698412698413*G13_3_1 - 0.006349206349206*G13_4_0 + 0.006349206349206*G13_4_1 + 0.019047619047619*G13_5_1 + 0.007936507936508*G14_6_0 + 0.007936507936508*G14_6_1 - 0.007936507936508*G14_7_0 + 0.004761904761905*G14_8_1 - 0.006349206349206*G14_9_0 - 0.019047619047619*G14_9_1 + 0.006349206349206*G14_10_0 - 0.012698412698413*G14_10_1 + 0.019047619047619*G14_11_1 - 0.007936507936508*G15_6_0 - 0.001587301587302*G15_6_1 + 0.007936507936508*G15_7_0 + 0.006349206349206*G15_7_1 - 0.009523809523810*G15_8_1 + 0.006349206349206*G15_9_0 + 0.012698412698413*G15_9_1 - 0.006349206349206*G15_10_0 + 0.006349206349206*G15_10_1 + 0.019047619047619*G15_11_1;
    A[174] = -0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_0 - 1.333333333333333*G3_0_1_1 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_0 - 1.333333333333333*G5_0_1_1 + 0.012698412698413*G13_0_0 + 0.019047619047619*G13_0_1 - 0.025396825396825*G13_1_0 - 0.019047619047619*G13_1_1 + 0.006349206349206*G13_2_0 + 0.012698412698413*G13_2_1 - 0.101587301587301*G13_3_0 - 0.152380952380952*G13_3_1 - 0.050793650793651*G13_4_1 - 0.025396825396825*G13_5_0 - 0.076190476190476*G13_5_1 - 0.006349206349206*G14_6_0 - 0.006349206349206*G14_6_1 + 0.031746031746032*G14_7_0 + 0.006349206349206*G14_8_1 + 0.050793650793651*G14_9_0 + 0.076190476190476*G14_9_1 - 0.050793650793651*G14_10_0 - 0.025396825396825*G14_11_0 - 0.076190476190476*G14_11_1 + 0.012698412698413*G15_6_0 + 0.019047619047619*G15_6_1 - 0.025396825396825*G15_7_0 - 0.019047619047619*G15_7_1 + 0.006349206349206*G15_8_0 + 0.012698412698413*G15_8_1 - 0.101587301587301*G15_9_0 - 0.152380952380952*G15_9_1 - 0.050793650793651*G15_10_1 - 0.025396825396825*G15_11_0 - 0.076190476190476*G15_11_1;
    A[175] = 0.666666666666667*G3_0_0_1 + 0.666666666666666*G3_0_1_0 + 0.666666666666667*G5_0_0_1 + 0.666666666666666*G5_0_1_0 + 0.025396825396825*G13_0_0 + 0.006349206349206*G13_0_1 - 0.012698412698413*G13_1_0 + 0.006349206349206*G13_1_1 - 0.006349206349206*G13_2_0 + 0.006349206349206*G13_2_1 - 0.050793650793651*G13_3_1 + 0.101587301587302*G13_4_0 - 0.050793650793651*G13_4_1 + 0.025396825396825*G13_5_0 - 0.050793650793651*G13_5_1 - 0.031746031746032*G14_6_0 - 0.031746031746032*G14_6_1 + 0.006349206349206*G14_7_0 + 0.006349206349206*G14_8_1 + 0.050793650793651*G14_9_0 + 0.050793650793651*G14_9_1 - 0.050793650793651*G14_10_0 + 0.025396825396825*G14_10_1 + 0.025396825396825*G14_11_0 - 0.050793650793651*G14_11_1 + 0.025396825396825*G15_6_0 + 0.006349206349206*G15_6_1 - 0.012698412698413*G15_7_0 + 0.006349206349206*G15_7_1 - 0.006349206349206*G15_8_0 + 0.006349206349206*G15_8_1 - 0.050793650793651*G15_9_1 + 0.101587301587302*G15_10_0 - 0.050793650793651*G15_10_1 + 0.025396825396825*G15_11_0 - 0.050793650793651*G15_11_1;
    A[176] = 1.333333333333333*G3_0_0_0 + 0.666666666666666*G3_0_0_1 + 0.666666666666666*G3_0_1_0 + 1.333333333333333*G3_0_1_1 + 1.333333333333333*G5_0_0_0 + 0.666666666666666*G5_0_0_1 + 0.666666666666666*G5_0_1_0 + 1.333333333333333*G5_0_1_1 + 0.031746031746032*G13_0_0 + 0.012698412698413*G13_0_1 - 0.031746031746032*G13_1_0 - 0.019047619047619*G13_1_1 + 0.019047619047619*G13_2_1 - 0.025396825396825*G13_3_0 - 0.076190476190476*G13_3_1 + 0.025396825396825*G13_4_0 - 0.050793650793651*G13_4_1 - 0.152380952380952*G13_5_1 - 0.063492063492063*G14_6_0 - 0.063492063492063*G14_6_1 + 0.063492063492064*G14_7_0 - 0.038095238095238*G14_8_1 + 0.050793650793651*G14_9_0 + 0.152380952380952*G14_9_1 - 0.050793650793651*G14_10_0 + 0.101587301587302*G14_10_1 - 0.152380952380952*G14_11_1 + 0.031746031746032*G15_6_0 + 0.012698412698413*G15_6_1 - 0.031746031746032*G15_7_0 - 0.019047619047619*G15_7_1 + 0.019047619047619*G15_8_1 - 0.025396825396825*G15_9_0 - 0.076190476190476*G15_9_1 + 0.025396825396825*G15_10_0 - 0.050793650793651*G15_10_1 - 0.152380952380952*G15_11_1;
    A[177] = 0.166666666666667*G1_0 - 0.166666666666667*G1_1;
    A[178] = -0.166666666666667*G1_0 - 0.333333333333333*G1_1;
    A[179] = -0.166666666666667*G1_1;
    A[180] = 0.166666666666667*G6_0 + 0.166666666666667*G6_1;
    A[181] = 0.000000000000000;
    A[182] = 0.000000000000000;
    A[183] = -0.166666666666667*G6_0 - 0.166666666666667*G6_1;
    A[184] = 0.166666666666667*G6_0 - 0.166666666666667*G6_1;
    A[185] = -0.166666666666667*G6_0 + 0.166666666666667*G6_1;
    A[186] = 0.166666666666667*G7_0 + 0.166666666666667*G7_1;
    A[187] = 0.000000000000000;
    A[188] = 0.000000000000000;
    A[189] = -0.166666666666667*G7_0 - 0.166666666666667*G7_1;
    A[190] = 0.166666666666667*G7_0 - 0.166666666666667*G7_1;
    A[191] = -0.166666666666667*G7_0 + 0.166666666666667*G7_1;
    A[192] = 0.000000000000000;
    A[193] = 0.000000000000000;
    A[194] = 0.000000000000000;
    A[195] = 0.000000000000000;
    A[196] = -0.166666666666667*G6_0;
    A[197] = 0.000000000000000;
    A[198] = -0.166666666666667*G6_0 - 0.333333333333333*G6_1;
    A[199] = 0.166666666666667*G6_0;
    A[200] = 0.166666666666667*G6_0 + 0.333333333333333*G6_1;
    A[201] = 0.000000000000000;
    A[202] = -0.166666666666667*G7_0;
    A[203] = 0.000000000000000;
    A[204] = -0.166666666666667*G7_0 - 0.333333333333333*G7_1;
    A[205] = 0.166666666666667*G7_0;
    A[206] = 0.166666666666667*G7_0 + 0.333333333333333*G7_1;
    A[207] = 0.000000000000000;
    A[208] = 0.000000000000000;
    A[209] = 0.000000000000000;
    A[210] = 0.000000000000000;
    A[211] = 0.000000000000000;
    A[212] = -0.166666666666667*G6_1;
    A[213] = -0.333333333333333*G6_0 - 0.166666666666667*G6_1;
    A[214] = 0.333333333333333*G6_0 + 0.166666666666666*G6_1;
    A[215] = 0.166666666666667*G6_1;
    A[216] = 0.000000000000000;
    A[217] = 0.000000000000000;
    A[218] = -0.166666666666667*G7_1;
    A[219] = -0.333333333333333*G7_0 - 0.166666666666667*G7_1;
    A[220] = 0.333333333333333*G7_0 + 0.166666666666666*G7_1;
    A[221] = 0.166666666666667*G7_1;
    A[222] = 0.000000000000000;
    A[223] = 0.000000000000000;
    A[224] = 0.000000000000000;
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_1_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_1_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_1_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      9
    // Number of operations (multiply-add pairs) for geometry tensor:    0
    // Number of operations (multiply-add pairs) for tensor contraction: 4
    // Total number of operations (multiply-add pairs):                  13
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x[v1][0] - x[v0][0];
    const double dx1 = x[v1][1] - x[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    // Compute geometry tensor
    const double G0_ = det;
    
    // Compute element tensor
    switch (facet)
    {
    case 0:
      {
        A[0] = 0.000000000000000;
      A[1] = 0.166666666666667*G0_;
      A[2] = 0.166666666666667*G0_;
      A[3] = 0.666666666666666*G0_;
      A[4] = 0.000000000000000;
      A[5] = 0.000000000000000;
      A[6] = 0.000000000000000;
      A[7] = 0.000000000000000;
      A[8] = 0.000000000000000;
      A[9] = 0.000000000000000;
      A[10] = 0.000000000000000;
      A[11] = 0.000000000000000;
      A[12] = 0.000000000000000;
      A[13] = 0.000000000000000;
      A[14] = 0.000000000000000;
        break;
      }
    case 1:
      {
        A[0] = 0.166666666666667*G0_;
      A[1] = 0.000000000000000;
      A[2] = 0.166666666666667*G0_;
      A[3] = 0.000000000000000;
      A[4] = 0.666666666666666*G0_;
      A[5] = 0.000000000000000;
      A[6] = 0.000000000000000;
      A[7] = 0.000000000000000;
      A[8] = 0.000000000000000;
      A[9] = 0.000000000000000;
      A[10] = 0.000000000000000;
      A[11] = 0.000000000000000;
      A[12] = 0.000000000000000;
      A[13] = 0.000000000000000;
      A[14] = 0.000000000000000;
        break;
      }
    case 2:
      {
        A[0] = 0.166666666666667*G0_;
      A[1] = 0.166666666666667*G0_;
      A[2] = 0.000000000000000;
      A[3] = 0.000000000000000;
      A[4] = 0.000000000000000;
      A[5] = 0.666666666666666*G0_;
      A[6] = 0.000000000000000;
      A[7] = 0.000000000000000;
      A[8] = 0.000000000000000;
      A[9] = 0.000000000000000;
      A[10] = 0.000000000000000;
      A[11] = 0.000000000000000;
      A[12] = 0.000000000000000;
      A[13] = 0.000000000000000;
      A[14] = 0.000000000000000;
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_2_0: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_2_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_2_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      9
    // Number of operations (multiply-add pairs) for geometry tensor:    1
    // Number of operations (multiply-add pairs) for tensor contraction: 34
    // Total number of operations (multiply-add pairs):                  44
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0 = det*w[0][0]*(1.0);
    
    // Compute element tensor
    A[0] = 0.003571428571429*G0_0;
    A[1] = 0.000000000000000;
    A[2] = 0.000000000000000;
    A[3] = -0.007142857142857*G0_0;
    A[4] = -0.003571428571429*G0_0;
    A[5] = -0.003571428571429*G0_0;
    A[6] = 0.000000000000000;
    A[7] = 0.000000000000000;
    A[8] = 0.000000000000000;
    A[9] = 0.000000000000000;
    A[10] = 0.000000000000000;
    A[11] = 0.000000000000000;
    A[12] = 0.000000000000000;
    A[13] = 0.000000000000000;
    A[14] = 0.000000000000000;
    A[15] = 0.000000000000000;
    A[16] = 0.003571428571429*G0_0;
    A[17] = 0.000000000000000;
    A[18] = -0.003571428571429*G0_0;
    A[19] = -0.007142857142857*G0_0;
    A[20] = -0.003571428571429*G0_0;
    A[21] = 0.000000000000000;
    A[22] = 0.000000000000000;
    A[23] = 0.000000000000000;
    A[24] = 0.000000000000000;
    A[25] = 0.000000000000000;
    A[26] = 0.000000000000000;
    A[27] = 0.000000000000000;
    A[28] = 0.000000000000000;
    A[29] = 0.000000000000000;
    A[30] = 0.000000000000000;
    A[31] = 0.000000000000000;
    A[32] = 0.003571428571429*G0_0;
    A[33] = -0.003571428571429*G0_0;
    A[34] = -0.003571428571429*G0_0;
    A[35] = -0.007142857142857*G0_0;
    A[36] = 0.000000000000000;
    A[37] = 0.000000000000000;
    A[38] = 0.000000000000000;
    A[39] = 0.000000000000000;
    A[40] = 0.000000000000000;
    A[41] = 0.000000000000000;
    A[42] = 0.000000000000000;
    A[43] = 0.000000000000000;
    A[44] = 0.000000000000000;
    A[45] = -0.007142857142857*G0_0;
    A[46] = -0.003571428571429*G0_0;
    A[47] = -0.003571428571429*G0_0;
    A[48] = 0.042857142857143*G0_0;
    A[49] = 0.028571428571429*G0_0;
    A[50] = 0.028571428571429*G0_0;
    A[51] = 0.000000000000000;
    A[52] = 0.000000000000000;
    A[53] = 0.000000000000000;
    A[54] = 0.000000000000000;
    A[55] = 0.000000000000000;
    A[56] = 0.000000000000000;
    A[57] = 0.000000000000000;
    A[58] = 0.000000000000000;
    A[59] = 0.000000000000000;
    A[60] = -0.003571428571429*G0_0;
    A[61] = -0.007142857142857*G0_0;
    A[62] = -0.003571428571429*G0_0;
    A[63] = 0.028571428571429*G0_0;
    A[64] = 0.042857142857143*G0_0;
    A[65] = 0.028571428571429*G0_0;
    A[66] = 0.000000000000000;
    A[67] = 0.000000000000000;
    A[68] = 0.000000000000000;
    A[69] = 0.000000000000000;
    A[70] = 0.000000000000000;
    A[71] = 0.000000000000000;
    A[72] = 0.000000000000000;
    A[73] = 0.000000000000000;
    A[74] = 0.000000000000000;
    A[75] = -0.003571428571429*G0_0;
    A[76] = -0.003571428571429*G0_0;
    A[77] = -0.007142857142857*G0_0;
    A[78] = 0.028571428571429*G0_0;
    A[79] = 0.028571428571429*G0_0;
    A[80] = 0.042857142857143*G0_0;
    A[81] = 0.000000000000000;
    A[82] = 0.000000000000000;
    A[83] = 0.000000000000000;
    A[84] = 0.000000000000000;
    A[85] = 0.000000000000000;
    A[86] = 0.000000000000000;
    A[87] = 0.000000000000000;
    A[88] = 0.000000000000000;
    A[89] = 0.000000000000000;
    A[90] = 0.000000000000000;
    A[91] = 0.000000000000000;
    A[92] = 0.000000000000000;
    A[93] = 0.000000000000000;
    A[94] = 0.000000000000000;
    A[95] = 0.000000000000000;
    A[96] = 0.003571428571429*G0_0;
    A[97] = 0.000000000000000;
    A[98] = 0.000000000000000;
    A[99] = -0.007142857142857*G0_0;
    A[100] = -0.003571428571429*G0_0;
    A[101] = -0.003571428571429*G0_0;
    A[102] = 0.000000000000000;
    A[103] = 0.000000000000000;
    A[104] = 0.000000000000000;
    A[105] = 0.000000000000000;
    A[106] = 0.000000000000000;
    A[107] = 0.000000000000000;
    A[108] = 0.000000000000000;
    A[109] = 0.000000000000000;
    A[110] = 0.000000000000000;
    A[111] = 0.000000000000000;
    A[112] = 0.003571428571429*G0_0;
    A[113] = 0.000000000000000;
    A[114] = -0.003571428571429*G0_0;
    A[115] = -0.007142857142857*G0_0;
    A[116] = -0.003571428571429*G0_0;
    A[117] = 0.000000000000000;
    A[118] = 0.000000000000000;
    A[119] = 0.000000000000000;
    A[120] = 0.000000000000000;
    A[121] = 0.000000000000000;
    A[122] = 0.000000000000000;
    A[123] = 0.000000000000000;
    A[124] = 0.000000000000000;
    A[125] = 0.000000000000000;
    A[126] = 0.000000000000000;
    A[127] = 0.000000000000000;
    A[128] = 0.003571428571429*G0_0;
    A[129] = -0.003571428571429*G0_0;
    A[130] = -0.003571428571429*G0_0;
    A[131] = -0.007142857142857*G0_0;
    A[132] = 0.000000000000000;
    A[133] = 0.000000000000000;
    A[134] = 0.000000000000000;
    A[135] = 0.000000000000000;
    A[136] = 0.000000000000000;
    A[137] = 0.000000000000000;
    A[138] = 0.000000000000000;
    A[139] = 0.000000000000000;
    A[140] = 0.000000000000000;
    A[141] = -0.007142857142857*G0_0;
    A[142] = -0.003571428571429*G0_0;
    A[143] = -0.003571428571429*G0_0;
    A[144] = 0.042857142857143*G0_0;
    A[145] = 0.028571428571429*G0_0;
    A[146] = 0.028571428571429*G0_0;
    A[147] = 0.000000000000000;
    A[148] = 0.000000000000000;
    A[149] = 0.000000000000000;
    A[150] = 0.000000000000000;
    A[151] = 0.000000000000000;
    A[152] = 0.000000000000000;
    A[153] = 0.000000000000000;
    A[154] = 0.000000000000000;
    A[155] = 0.000000000000000;
    A[156] = -0.003571428571429*G0_0;
    A[157] = -0.007142857142857*G0_0;
    A[158] = -0.003571428571429*G0_0;
    A[159] = 0.028571428571429*G0_0;
    A[160] = 0.042857142857143*G0_0;
    A[161] = 0.028571428571429*G0_0;
    A[162] = 0.000000000000000;
    A[163] = 0.000000000000000;
    A[164] = 0.000000000000000;
    A[165] = 0.000000000000000;
    A[166] = 0.000000000000000;
    A[167] = 0.000000000000000;
    A[168] = 0.000000000000000;
    A[169] = 0.000000000000000;
    A[170] = 0.000000000000000;
    A[171] = -0.003571428571429*G0_0;
    A[172] = -0.003571428571429*G0_0;
    A[173] = -0.007142857142857*G0_0;
    A[174] = 0.028571428571429*G0_0;
    A[175] = 0.028571428571429*G0_0;
    A[176] = 0.042857142857143*G0_0;
    A[177] = 0.000000000000000;
    A[178] = 0.000000000000000;
    A[179] = 0.000000000000000;
    A[180] = 0.000000000000000;
    A[181] = 0.000000000000000;
    A[182] = 0.000000000000000;
    A[183] = 0.000000000000000;
    A[184] = 0.000000000000000;
    A[185] = 0.000000000000000;
    A[186] = 0.000000000000000;
    A[187] = 0.000000000000000;
    A[188] = 0.000000000000000;
    A[189] = 0.000000000000000;
    A[190] = 0.000000000000000;
    A[191] = 0.000000000000000;
    A[192] = 0.032142857142857*G0_0;
    A[193] = 0.021428571428571*G0_0;
    A[194] = 0.021428571428571*G0_0;
    A[195] = 0.000000000000000;
    A[196] = 0.000000000000000;
    A[197] = 0.000000000000000;
    A[198] = 0.000000000000000;
    A[199] = 0.000000000000000;
    A[200] = 0.000000000000000;
    A[201] = 0.000000000000000;
    A[202] = 0.000000000000000;
    A[203] = 0.000000000000000;
    A[204] = 0.000000000000000;
    A[205] = 0.000000000000000;
    A[206] = 0.000000000000000;
    A[207] = 0.021428571428571*G0_0;
    A[208] = 0.032142857142857*G0_0;
    A[209] = 0.021428571428571*G0_0;
    A[210] = 0.000000000000000;
    A[211] = 0.000000000000000;
    A[212] = 0.000000000000000;
    A[213] = 0.000000000000000;
    A[214] = 0.000000000000000;
    A[215] = 0.000000000000000;
    A[216] = 0.000000000000000;
    A[217] = 0.000000000000000;
    A[218] = 0.000000000000000;
    A[219] = 0.000000000000000;
    A[220] = 0.000000000000000;
    A[221] = 0.000000000000000;
    A[222] = 0.021428571428571*G0_0;
    A[223] = 0.021428571428571*G0_0;
    A[224] = 0.032142857142857*G0_0;
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_3_0: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_3_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_3_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Cell Volume.
    
    // Compute circumradius, assuming triangle is embedded in 2D.
    
    
    // Array of quadrature weights.
    static const double W25[25] = {0.011465080351592, 0.019804083132047, 0.017341506431366, 0.008755499182164, 0.001865552166878, 0.023161221929498, 0.040007287386160, 0.035032504503372, 0.017687452110483, 0.003768701695328, 0.027528985664470, 0.047551897057954, 0.041638965215195, 0.021022967487322, 0.004479406797281, 0.023161221929498, 0.040007287386160, 0.035032504503372, 0.017687452110483, 0.003768701695328, 0.011465080351592, 0.019804083132047, 0.017341506431366, 0.008755499182164, 0.001865552166878};
    // Quadrature points on the UFC reference element: (0.045042593569804, 0.039809857051469), (0.037621252345111, 0.198013417873608), (0.026364644944471, 0.437974810247386), (0.014285794395571, 0.695464273353636), (0.004622288465046, 0.901464914201174), (0.221578609552379, 0.039809857051469), (0.185070710267389, 0.198013417873608), (0.129695936782254, 0.437974810247386), (0.070276292008282, 0.695464273353636), (0.022738483063764, 0.901464914201174), (0.480095071474266, 0.039809857051469), (0.400993291063196, 0.198013417873608), (0.281012594876307, 0.437974810247386), (0.152267863323182, 0.695464273353636), (0.049267542899413, 0.901464914201174), (0.738611533396152, 0.039809857051469), (0.616915871859002, 0.198013417873608), (0.432329252970360, 0.437974810247386), (0.234259434638082, 0.695464273353636), (0.075796602735062, 0.901464914201174), (0.915147549378728, 0.039809857051469), (0.764365329781281, 0.198013417873608), (0.535660544808143, 0.437974810247386), (0.290249932250792, 0.695464273353636), (0.093912797333780, 0.901464914201174)
    
    // Value of basis functions at quadrature points.
    static const double FE0[25][1] = \
    {{0.044306647781284},
    {0.153742030524499},
    {0.167003080840912},
    {0.077860127642167},
    {0.010565606073051},
    {0.175913147778989},
    {0.610410534080673},
    {0.663061619658879},
    {0.309132394931336},
    {0.041949213392946},
    {0.247747270005307},
    {0.859671635180817},
    {0.933822788062264},
    {0.435366587895191},
    {0.059079171899246},
    {0.175913147778989},
    {0.610410534080673},
    {0.663061619658879},
    {0.309132394931336},
    {0.041949213392946},
    {0.044306647781284},
    {0.153742030524499},
    {0.167003080840912},
    {0.077860127642168},
    {0.010565606073051}};
    
    static const double FE0_D01[25][1] = \
    {{1.064541957619325},
    {0.575285441238399},
    {0.069537142111521},
    {-0.156297836604570},
    {-0.100783948537443},
    {4.180666602527824},
    {2.093217516679392},
    {-0.019769557671950},
    {-0.875117679872583},
    {-0.506910012747092},
    {5.707226560159129},
    {2.197626318986839},
    {-1.190925704851940},
    {-2.233206631444328},
    {-1.133613104833174},
    {3.624925419221488},
    {-0.215583167171879},
    {-3.598505326936564},
    {-3.954316942417136},
    {-1.798320911770480},
    {0.129295602035074},
    {-3.310151683460130},
    {-5.953049785657692},
    {-5.338224198943455},
    {-2.274074993278407}};
    
    static const double FE0_D10[25][1] = \
    {{0.935246355584253},
    {3.885437124698530},
    {6.022586927769215},
    {5.181926362338886},
    {2.173291044740961},
    {0.555741183306335},
    {2.308800683851271},
    {3.578735769264615},
    {3.079199262544555},
    {1.291410899023387},
    {0.000000000000000},
    {0.000000000000000},
    {0.000000000000000},
    {0.000000000000000},
    {0.000000000000000},
    {-0.555741183306333},
    {-2.308800683851270},
    {-3.578735769264614},
    {-3.079199262544551},
    {-1.291410899023389},
    {-0.935246355584244},
    {-3.885437124698528},
    {-6.022586927769213},
    {-5.181926362338880},
    {-2.173291044740964}};
    
    static const double FE2_C0[25][6] = \
    {{0.759842524889054, -0.040984923098815, -0.036640207614552, 0.007172556844965, 0.145727572487076, 0.164882476492272},
    {0.404143384962011, -0.034790535089082, -0.119594790557632, 0.029798051046164, 0.605418365816316, 0.115025523822223},
    {0.038203893720170, -0.024974455938375, -0.054330941424918, 0.046188201467177, 0.938423301877431, 0.056490000298514},
    {-0.121759885907613, -0.013877626552546, 0.271876837668966, 0.039741038474382, 0.807433832894958, 0.016585803421853},
    {-0.076273570327669, -0.004579557363738, 0.723813068870285, 0.016667323498225, 0.338636367163553, 0.001736368159345},
    {0.352482461135478, -0.123384449130048, -0.036640207614552, 0.035284051087774, 0.117616078244268, 0.654642066277080},
    {0.144254514044104, -0.116568374669637, -0.119594790557632, 0.146585935553368, 0.488630481309112, 0.456692234320686},
    {-0.058512087022541, -0.096053864746601, -0.054330941424918, 0.227214213208259, 0.757397290136350, 0.224285389849452},
    {-0.124504469204174, -0.060398777571415, 0.271876837668966, 0.195498601422110, 0.651676269947230, 0.065851537737284},
    {-0.064306352762709, -0.021704405839682, 0.723813068870285, 0.081991778736563, 0.273311911925214, 0.006893999070328},
    {-0.019112516166505, -0.019112516166505, -0.036640207614552, 0.076450064666021, 0.076450064666021, 0.921965110615521},
    {-0.079402052107810, -0.079402052107810, -0.119594790557632, 0.317608208431240, 0.317608208431240, 0.643182477910772},
    {-0.123076437918076, -0.123076437918076, -0.054330941424918, 0.492305751672304, 0.492305751672304, 0.315872313916462},
    {-0.105896858921167, -0.105896858921167, 0.271876837668966, 0.423587435684670, 0.423587435684670, 0.092742008804029},
    {-0.044412961332722, -0.044412961332722, 0.723813068870285, 0.177651845330889, 0.177651845330889, 0.009709163133382},
    {-0.123384449130048, 0.352482461135478, -0.036640207614552, 0.117616078244268, 0.035284051087774, 0.654642066277080},
    {-0.116568374669637, 0.144254514044104, -0.119594790557632, 0.488630481309112, 0.146585935553368, 0.456692234320686},
    {-0.096053864746601, -0.058512087022541, -0.054330941424918, 0.757397290136350, 0.227214213208259, 0.224285389849452},
    {-0.060398777571415, -0.124504469204174, 0.271876837668966, 0.651676269947229, 0.195498601422110, 0.065851537737284},
    {-0.021704405839682, -0.064306352762709, 0.723813068870285, 0.273311911925214, 0.081991778736563, 0.006893999070328},
    {-0.040984923098815, 0.759842524889054, -0.036640207614552, 0.145727572487076, 0.007172556844965, 0.164882476492272},
    {-0.034790535089082, 0.404143384962011, -0.119594790557632, 0.605418365816316, 0.029798051046164, 0.115025523822223},
    {-0.024974455938375, 0.038203893720170, -0.054330941424918, 0.938423301877431, 0.046188201467178, 0.056490000298514},
    {-0.013877626552546, -0.121759885907613, 0.271876837668966, 0.807433832894958, 0.039741038474382, 0.016585803421854},
    {-0.004579557363738, -0.076273570327669, 0.723813068870285, 0.338636367163553, 0.016667323498224, 0.001736368159345}};
    
    // Array of non-zero columns
    static const unsigned int nzc3[6] = {6, 7, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc0[6] = {0, 1, 2, 3, 4, 5};
    
    static const double FE2_C0_D01[25][5] = \
    {{-2.660590197514910, -0.840760571794125, 0.180170374279214, 3.501350769309035, -0.180170374279215},
    {-2.057461319125122, -0.207946328505567, 0.150485009380445, 2.265407647630689, -0.150485009380445},
    {-1.142642179232572, 0.751899240989545, 0.105458579777883, 0.390742938243027, -0.105458579777883},
    {-0.160999729003170, 1.781857093414544, 0.057143177582284, -1.620857364411373, -0.057143177582285},
    {0.624348810664880, 2.605859656804694, 0.018489153860184, -3.230208467469573, -0.018489153860185},
    {-1.954446133584608, -0.840760571794125, 0.886314438209516, 2.795206705378734, -0.886314438209517},
    {-1.467663487436009, -0.207946328505567, 0.740282841069557, 1.675609815941576, -0.740282841069557},
    {-0.729317011881439, 0.751899240989545, 0.518783747129016, -0.022582229108105, -0.518783747129016},
    {0.062962261447671, 1.781857093414544, 0.281105168033126, -1.844819354862214, -0.281105168033126},
    {0.696813589059751, 2.605859656804694, 0.090953932255055, -3.302673245864443, -0.090953932255055},
    {-0.920380285897062, -0.840760571794125, 1.920380285897062, 1.761140857691188, -1.920380285897063},
    {-0.603973164252783, -0.207946328505567, 1.603973164252783, 0.811919492758351, -1.603973164252783},
    {-0.124050379505228, 0.751899240989545, 1.124050379505227, -0.627848861484317, -1.124050379505227},
    {0.390928546707272, 1.781857093414544, 0.609071453292727, -2.172785640121816, -0.609071453292727},
    {0.802929828402348, 2.605859656804694, 0.197070171597651, -3.408789485207040, -0.197070171597652},
    {0.113685561790483, -0.840760571794125, 2.954446133584606, 0.727075010003643, -2.954446133584608},
    {0.259717158930442, -0.207946328505567, 2.467663487436008, -0.051770830424875, -2.467663487436009},
    {0.481216252870984, 0.751899240989545, 1.729317011881439, -1.233115493860528, -1.729317011881439},
    {0.718894831966873, 1.781857093414544, 0.937037738552328, -2.500751925381417, -0.937037738552329},
    {0.909046067744944, 2.605859656804694, 0.303186410940248, -3.514905724549637, -0.303186410940249},
    {0.819829625720785, -0.840760571794125, 3.660590197514908, 0.020930946073341, -3.660590197514909},
    {0.849514990619555, -0.207946328505567, 3.057461319125121, -0.641568662113987, -3.057461319125122},
    {0.894541420222116, 0.751899240989545, 2.142642179232571, -1.646440661211660, -2.142642179232571},
    {0.942856822417714, 1.781857093414544, 1.160999729003170, -2.724713915832258, -1.160999729003170},
    {0.981510846139815, 2.605859656804694, 0.375651189335118, -3.587370502944507, -0.375651189335119}};
    
    // Array of non-zero columns
    static const unsigned int nzc4[5] = {6, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc1[5] = {0, 2, 3, 4, 5};
    
    static const double FE2_C0_D10[25][5] = \
    {{-2.660590197514911, -0.819829625720785, 0.159239428205874, -0.159239428205874, 3.480419823235696},
    {-2.057461319125122, -0.849514990619555, 0.792053671494432, -0.792053671494432, 2.906976309744678},
    {-1.142642179232572, -0.894541420222117, 1.751899240989544, -1.751899240989544, 2.037183599454689},
    {-0.160999729003170, -0.942856822417715, 2.781857093414543, -2.781857093414543, 1.103856551420885},
    {0.624348810664881, -0.981510846139815, 3.605859656804691, -3.605859656804691, 0.357162035474935},
    {-1.954446133584608, -0.113685561790483, 0.159239428205874, -0.159239428205874, 2.068131695375091},
    {-1.467663487436009, -0.259717158930443, 0.792053671494432, -0.792053671494432, 1.727380646366452},
    {-0.729317011881439, -0.481216252870984, 1.751899240989544, -1.751899240989544, 1.210533264752423},
    {0.062962261447672, -0.718894831966874, 2.781857093414543, -2.781857093414543, 0.655932570519203},
    {0.696813589059751, -0.909046067744944, 3.605859656804691, -3.605859656804691, 0.212232478685194},
    {-0.920380285897062, 0.920380285897063, 0.159239428205874, -0.159239428205874, 0.000000000000000},
    {-0.603973164252783, 0.603973164252784, 0.792053671494432, -0.792053671494432, 0.000000000000000},
    {-0.124050379505227, 0.124050379505228, 1.751899240989544, -1.751899240989544, 0.000000000000000},
    {0.390928546707273, -0.390928546707272, 2.781857093414543, -2.781857093414543, 0.000000000000000},
    {0.802929828402348, -0.802929828402348, 3.605859656804691, -3.605859656804691, 0.000000000000000},
    {0.113685561790483, 1.954446133584607, 0.159239428205874, -0.159239428205874, -2.068131695375090},
    {0.259717158930442, 1.467663487436009, 0.792053671494432, -0.792053671494432, -1.727380646366451},
    {0.481216252870984, 0.729317011881439, 1.751899240989545, -1.751899240989545, -1.210533264752422},
    {0.718894831966873, -0.062962261447671, 2.781857093414543, -2.781857093414543, -0.655932570519202},
    {0.909046067744945, -0.696813589059751, 3.605859656804691, -3.605859656804691, -0.212232478685193},
    {0.819829625720784, 2.660590197514909, 0.159239428205873, -0.159239428205873, -3.480419823235693},
    {0.849514990619555, 2.057461319125121, 0.792053671494432, -0.792053671494432, -2.906976309744676},
    {0.894541420222116, 1.142642179232571, 1.751899240989545, -1.751899240989545, -2.037183599454687},
    {0.942856822417715, 0.160999729003170, 2.781857093414543, -2.781857093414543, -1.103856551420884},
    {0.981510846139815, -0.624348810664880, 3.605859656804691, -3.605859656804691, -0.357162035474934}};
    
    // Array of non-zero columns
    static const unsigned int nzc5[5] = {6, 7, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc2[5] = {0, 1, 3, 4, 5};
    
    static const double FE2_C2[25][3] = \
    {{0.915147549378728, 0.045042593569804, 0.039809857051469},
    {0.764365329781281, 0.037621252345111, 0.198013417873608},
    {0.535660544808143, 0.026364644944471, 0.437974810247386},
    {0.290249932250793, 0.014285794395571, 0.695464273353636},
    {0.093912797333780, 0.004622288465046, 0.901464914201173},
    {0.738611533396152, 0.221578609552379, 0.039809857051469},
    {0.616915871859002, 0.185070710267389, 0.198013417873608},
    {0.432329252970360, 0.129695936782254, 0.437974810247386},
    {0.234259434638082, 0.070276292008282, 0.695464273353636},
    {0.075796602735062, 0.022738483063764, 0.901464914201173},
    {0.480095071474266, 0.480095071474266, 0.039809857051469},
    {0.400993291063196, 0.400993291063196, 0.198013417873608},
    {0.281012594876307, 0.281012594876307, 0.437974810247386},
    {0.152267863323182, 0.152267863323182, 0.695464273353636},
    {0.049267542899413, 0.049267542899413, 0.901464914201173},
    {0.221578609552379, 0.738611533396152, 0.039809857051469},
    {0.185070710267389, 0.616915871859002, 0.198013417873608},
    {0.129695936782254, 0.432329252970360, 0.437974810247386},
    {0.070276292008282, 0.234259434638082, 0.695464273353636},
    {0.022738483063764, 0.075796602735062, 0.901464914201173},
    {0.045042593569804, 0.915147549378728, 0.039809857051469},
    {0.037621252345111, 0.764365329781281, 0.198013417873608},
    {0.026364644944471, 0.535660544808143, 0.437974810247386},
    {0.014285794395572, 0.290249932250793, 0.695464273353636},
    {0.004622288465046, 0.093912797333780, 0.901464914201173}};
    
    // Array of non-zero columns
    static const unsigned int nzc6[3] = {12, 13, 14};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.000000000000000;
    }// end loop over 'r'
    // Number of operations to compute geometry constants: 23.
    double G[11];
    G[0] =  - K_00*det;
    G[1] =  - K_10*det;
    G[2] =  - K_01*det;
    G[3] =  - K_11*det;
    G[4] =  - det*w[2][0]*(K_00*K_10 + K_01*K_11);
    G[5] =  - det*w[2][0]*(K_10*K_10 + K_11*K_11);
    G[6] = K_11*det;
    G[7] =  - det*w[2][0]*(K_00*K_00 + K_01*K_01);
    G[8] = K_00*det;
    G[9] = K_10*det;
    G[10] = K_01*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 5825
    for (unsigned int ip = 0; ip < 25; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.000000000000000;
      double F1 = 0.000000000000000;
      double F2 = 0.000000000000000;
      double F3 = 0.000000000000000;
      double F4 = 0.000000000000000;
      double F5 = 0.000000000000000;
      double F6 = 0.000000000000000;
      double F7 = 0.000000000000000;
      double F8 = 0.000000000000000;
      double F9 = 0.000000000000000;
      
      // Total number of operations to compute function values = 6
      for (unsigned int r = 0; r < 1; r++)
      {
        F4 += FE0[ip][r]*w[3][r];
        F7 += FE0_D10[ip][r]*w[3][r];
        F8 += FE0_D01[ip][r]*w[3][r];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 6
      for (unsigned int r = 0; r < 3; r++)
      {
        F9 += FE2_C2[ip][r]*w[0][nzc6[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 40
      for (unsigned int r = 0; r < 5; r++)
      {
        F0 += FE2_C0_D10[ip][r]*w[0][nzc2[r]];
        F1 += FE2_C0_D01[ip][r]*w[0][nzc1[r]];
        F5 += FE2_C0_D10[ip][r]*w[0][nzc5[r]];
        F6 += FE2_C0_D01[ip][r]*w[0][nzc4[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 24
      for (unsigned int r = 0; r < 6; r++)
      {
        F2 += FE2_C0[ip][r]*w[0][nzc0[r]];
        F3 += FE2_C0[ip][r]*w[0][nzc3[r]];
      }// end loop over 'r'
      
      // Number of operations to compute ip constants: 87
      double I[7];
      // Number of operations: 9
      I[0] = F4*W25[ip]*(F0*G[0] + F1*G[1] + F5*G[2] + F6*G[3]);
      
      // Number of operations: 7
      I[1] = F4*W25[ip]*(F5*G[4] + F6*G[5] + F9*G[6]);
      
      // Number of operations: 7
      I[2] = F4*W25[ip]*(F0*G[7] + F1*G[4] + F9*G[8]);
      
      // Number of operations: 7
      I[3] = F4*W25[ip]*(F0*G[4] + F1*G[5] + F9*G[9]);
      
      // Number of operations: 7
      I[4] = F4*W25[ip]*(F5*G[7] + F6*G[4] + F9*G[10]);
      
      // Number of operations: 25
      I[5] = W25[ip]*(F0*(F4*(F2*G[0] + F3*G[2]) + F7*G[7] + F8*G[4]) + F1*(F4*(F2*G[1] + F3*G[3]) + F7*G[4] + F8*G[5]) + F9*(F7*G[8] + F8*G[9]));
      
      // Number of operations: 25
      I[6] = W25[ip]*(F5*(F4*(F2*G[0] + F3*G[2]) + F7*G[7] + F8*G[4]) + F6*(F4*(F2*G[1] + F3*G[3]) + F7*G[4] + F8*G[5]) + F9*(F7*G[10] + F8*G[6]));
      
      
      // Number of operations for primary indices: 6
      for (unsigned int j = 0; j < 3; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc6[j]] += FE2_C2[ip][j]*I[0];
      }// end loop over 'j'
      
      // Number of operations for primary indices: 40
      for (unsigned int j = 0; j < 5; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc4[j]] += FE2_C0_D01[ip][j]*I[1];
        // Number of operations to compute entry: 2
        A[nzc2[j]] += FE2_C0_D10[ip][j]*I[2];
        // Number of operations to compute entry: 2
        A[nzc1[j]] += FE2_C0_D01[ip][j]*I[3];
        // Number of operations to compute entry: 2
        A[nzc5[j]] += FE2_C0_D10[ip][j]*I[4];
      }// end loop over 'j'
      
      // Number of operations for primary indices: 24
      for (unsigned int j = 0; j < 6; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc0[j]] += FE2_C0[ip][j]*I[5];
        // Number of operations to compute entry: 2
        A[nzc3[j]] += FE2_C0[ip][j]*I[6];
      }// end loop over 'j'
    }// end loop over 'ip'
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not yet implemented (introduced in UFC 2.0).");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_3_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_3_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_3_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Extract vertex coordinates
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    
    
    // Cell Volume.
    
    // Compute circumradius, assuming triangle is embedded in 2D.
    
    
    // Array of quadrature weights.
    // Value of basis functions at quadrature points.
    static const double FE1_f0[4][2] = \
    {{0.930568155797026, 0.069431844202974},
    {0.669990521792428, 0.330009478207572},
    {0.330009478207572, 0.669990521792428},
    {0.069431844202974, 0.930568155797026}};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc0[2] = {1, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 2};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.000000000000000;
    }// end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    switch (facet)
    {
    case 0:
      {
        // Total number of operations to compute element tensor (from this point): 16
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 16
      for (unsigned int ip = 0; ip < 4; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.000000000000000;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE1_f0[ip][r]*w[1][nzc0[r]];
        }// end loop over 'r'
      }// end loop over 'ip'
        break;
      }
    case 1:
      {
        // Total number of operations to compute element tensor (from this point): 16
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 16
      for (unsigned int ip = 0; ip < 4; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.000000000000000;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE1_f0[ip][r]*w[1][nzc1[r]];
        }// end loop over 'r'
      }// end loop over 'ip'
        break;
      }
    case 2:
      {
        // Total number of operations to compute element tensor (from this point): 16
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 16
      for (unsigned int ip = 0; ip < 4; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.000000000000000;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE1_f0[ip][r]*w[1][nzc2[r]];
        }// end loop over 'r'
      }// end loop over 'ip'
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not yet implemented (introduced in UFC 2.0).");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_4_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_4_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_4_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      9
    // Number of operations (multiply-add pairs) for geometry tensor:    6
    // Number of operations (multiply-add pairs) for tensor contraction: 165
    // Total number of operations (multiply-add pairs):                  180
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x[v1][0] - x[v0][0];
    const double dx1 = x[v1][1] - x[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    // Compute geometry tensor
    const double G0_0 = det*w[0][0]*(1.0);
    const double G0_1 = det*w[0][1]*(1.0);
    const double G0_2 = det*w[0][2]*(1.0);
    const double G0_3 = det*w[0][3]*(1.0);
    const double G0_4 = det*w[0][4]*(1.0);
    const double G0_5 = det*w[0][5]*(1.0);
    
    // Compute element tensor
    switch (facet)
    {
    case 0:
      {
        A[0] = 0.000000000000000;
      A[1] = 0.000000000000000;
      A[2] = 0.000000000000000;
      A[3] = 0.000000000000000;
      A[4] = 0.000000000000000;
      A[5] = 0.000000000000000;
      A[6] = 0.000000000000000;
      A[7] = 0.000000000000000;
      A[8] = 0.000000000000000;
      A[9] = 0.000000000000000;
      A[10] = 0.000000000000000;
      A[11] = 0.000000000000000;
      A[12] = 0.000000000000000;
      A[13] = 0.000000000000000;
      A[14] = 0.000000000000000;
      A[15] = 0.000000000000000;
      A[16] = 0.092857142857143*G0_1 - 0.007142857142857*G0_2 + 0.047619047619048*G0_3;
      A[17] = -0.007142857142857*G0_1 - 0.007142857142857*G0_2 - 0.019047619047619*G0_3;
      A[18] = 0.047619047619048*G0_1 - 0.019047619047619*G0_2 + 0.038095238095238*G0_3;
      A[19] = 0.000000000000000;
      A[20] = 0.000000000000000;
      A[21] = 0.000000000000000;
      A[22] = 0.000000000000000;
      A[23] = 0.000000000000000;
      A[24] = 0.000000000000000;
      A[25] = 0.000000000000000;
      A[26] = 0.000000000000000;
      A[27] = 0.000000000000000;
      A[28] = 0.000000000000000;
      A[29] = 0.000000000000000;
      A[30] = 0.000000000000000;
      A[31] = -0.007142857142857*G0_1 - 0.007142857142857*G0_2 - 0.019047619047619*G0_3;
      A[32] = -0.007142857142857*G0_1 + 0.092857142857143*G0_2 + 0.047619047619048*G0_3;
      A[33] = -0.019047619047619*G0_1 + 0.047619047619048*G0_2 + 0.038095238095238*G0_3;
      A[34] = 0.000000000000000;
      A[35] = 0.000000000000000;
      A[36] = 0.000000000000000;
      A[37] = 0.000000000000000;
      A[38] = 0.000000000000000;
      A[39] = 0.000000000000000;
      A[40] = 0.000000000000000;
      A[41] = 0.000000000000000;
      A[42] = 0.000000000000000;
      A[43] = 0.000000000000000;
      A[44] = 0.000000000000000;
      A[45] = 0.000000000000000;
      A[46] = 0.047619047619048*G0_1 - 0.019047619047619*G0_2 + 0.038095238095238*G0_3;
      A[47] = -0.019047619047619*G0_1 + 0.047619047619048*G0_2 + 0.038095238095238*G0_3;
      A[48] = 0.038095238095238*G0_1 + 0.038095238095238*G0_2 + 0.457142857142857*G0_3;
      A[49] = 0.000000000000000;
      A[50] = 0.000000000000000;
      A[51] = 0.000000000000000;
      A[52] = 0.000000000000000;
      A[53] = 0.000000000000000;
      A[54] = 0.000000000000000;
      A[55] = 0.000000000000000;
      A[56] = 0.000000000000000;
      A[57] = 0.000000000000000;
      A[58] = 0.000000000000000;
      A[59] = 0.000000000000000;
      A[60] = 0.000000000000000;
      A[61] = 0.000000000000000;
      A[62] = 0.000000000000000;
      A[63] = 0.000000000000000;
      A[64] = 0.000000000000000;
      A[65] = 0.000000000000000;
      A[66] = 0.000000000000000;
      A[67] = 0.000000000000000;
      A[68] = 0.000000000000000;
      A[69] = 0.000000000000000;
      A[70] = 0.000000000000000;
      A[71] = 0.000000000000000;
      A[72] = 0.000000000000000;
      A[73] = 0.000000000000000;
      A[74] = 0.000000000000000;
      A[75] = 0.000000000000000;
      A[76] = 0.000000000000000;
      A[77] = 0.000000000000000;
      A[78] = 0.000000000000000;
      A[79] = 0.000000000000000;
      A[80] = 0.000000000000000;
      A[81] = 0.000000000000000;
      A[82] = 0.000000000000000;
      A[83] = 0.000000000000000;
      A[84] = 0.000000000000000;
      A[85] = 0.000000000000000;
      A[86] = 0.000000000000000;
      A[87] = 0.000000000000000;
      A[88] = 0.000000000000000;
      A[89] = 0.000000000000000;
      A[90] = 0.000000000000000;
      A[91] = 0.000000000000000;
      A[92] = 0.000000000000000;
      A[93] = 0.000000000000000;
      A[94] = 0.000000000000000;
      A[95] = 0.000000000000000;
      A[96] = 0.000000000000000;
      A[97] = 0.000000000000000;
      A[98] = 0.000000000000000;
      A[99] = 0.000000000000000;
      A[100] = 0.000000000000000;
      A[101] = 0.000000000000000;
      A[102] = 0.000000000000000;
      A[103] = 0.000000000000000;
      A[104] = 0.000000000000000;
      A[105] = 0.000000000000000;
      A[106] = 0.000000000000000;
      A[107] = 0.000000000000000;
      A[108] = 0.000000000000000;
      A[109] = 0.000000000000000;
      A[110] = 0.000000000000000;
      A[111] = 0.000000000000000;
      A[112] = 0.092857142857143*G0_1 - 0.007142857142857*G0_2 + 0.047619047619048*G0_3;
      A[113] = -0.007142857142857*G0_1 - 0.007142857142857*G0_2 - 0.019047619047619*G0_3;
      A[114] = 0.047619047619048*G0_1 - 0.019047619047619*G0_2 + 0.038095238095238*G0_3;
      A[115] = 0.000000000000000;
      A[116] = 0.000000000000000;
      A[117] = 0.000000000000000;
      A[118] = 0.000000000000000;
      A[119] = 0.000000000000000;
      A[120] = 0.000000000000000;
      A[121] = 0.000000000000000;
      A[122] = 0.000000000000000;
      A[123] = 0.000000000000000;
      A[124] = 0.000000000000000;
      A[125] = 0.000000000000000;
      A[126] = 0.000000000000000;
      A[127] = -0.007142857142857*G0_1 - 0.007142857142857*G0_2 - 0.019047619047619*G0_3;
      A[128] = -0.007142857142857*G0_1 + 0.092857142857143*G0_2 + 0.047619047619048*G0_3;
      A[129] = -0.019047619047619*G0_1 + 0.047619047619048*G0_2 + 0.038095238095238*G0_3;
      A[130] = 0.000000000000000;
      A[131] = 0.000000000000000;
      A[132] = 0.000000000000000;
      A[133] = 0.000000000000000;
      A[134] = 0.000000000000000;
      A[135] = 0.000000000000000;
      A[136] = 0.000000000000000;
      A[137] = 0.000000000000000;
      A[138] = 0.000000000000000;
      A[139] = 0.000000000000000;
      A[140] = 0.000000000000000;
      A[141] = 0.000000000000000;
      A[142] = 0.047619047619048*G0_1 - 0.019047619047619*G0_2 + 0.038095238095238*G0_3;
      A[143] = -0.019047619047619*G0_1 + 0.047619047619048*G0_2 + 0.038095238095238*G0_3;
      A[144] = 0.038095238095238*G0_1 + 0.038095238095238*G0_2 + 0.457142857142857*G0_3;
      A[145] = 0.000000000000000;
      A[146] = 0.000000000000000;
      A[147] = 0.000000000000000;
      A[148] = 0.000000000000000;
      A[149] = 0.000000000000000;
      A[150] = 0.000000000000000;
      A[151] = 0.000000000000000;
      A[152] = 0.000000000000000;
      A[153] = 0.000000000000000;
      A[154] = 0.000000000000000;
      A[155] = 0.000000000000000;
      A[156] = 0.000000000000000;
      A[157] = 0.000000000000000;
      A[158] = 0.000000000000000;
      A[159] = 0.000000000000000;
      A[160] = 0.000000000000000;
      A[161] = 0.000000000000000;
      A[162] = 0.000000000000000;
      A[163] = 0.000000000000000;
      A[164] = 0.000000000000000;
      A[165] = 0.000000000000000;
      A[166] = 0.000000000000000;
      A[167] = 0.000000000000000;
      A[168] = 0.000000000000000;
      A[169] = 0.000000000000000;
      A[170] = 0.000000000000000;
      A[171] = 0.000000000000000;
      A[172] = 0.000000000000000;
      A[173] = 0.000000000000000;
      A[174] = 0.000000000000000;
      A[175] = 0.000000000000000;
      A[176] = 0.000000000000000;
      A[177] = 0.000000000000000;
      A[178] = 0.000000000000000;
      A[179] = 0.000000000000000;
      A[180] = 0.000000000000000;
      A[181] = 0.000000000000000;
      A[182] = 0.000000000000000;
      A[183] = 0.000000000000000;
      A[184] = 0.000000000000000;
      A[185] = 0.000000000000000;
      A[186] = 0.000000000000000;
      A[187] = 0.000000000000000;
      A[188] = 0.000000000000000;
      A[189] = 0.000000000000000;
      A[190] = 0.000000000000000;
      A[191] = 0.000000000000000;
      A[192] = 0.000000000000000;
      A[193] = 0.000000000000000;
      A[194] = 0.000000000000000;
      A[195] = 0.000000000000000;
      A[196] = 0.000000000000000;
      A[197] = 0.000000000000000;
      A[198] = 0.000000000000000;
      A[199] = 0.000000000000000;
      A[200] = 0.000000000000000;
      A[201] = 0.000000000000000;
      A[202] = 0.000000000000000;
      A[203] = 0.000000000000000;
      A[204] = 0.000000000000000;
      A[205] = 0.000000000000000;
      A[206] = 0.000000000000000;
      A[207] = 0.000000000000000;
      A[208] = 0.150000000000000*G0_1 - 0.016666666666667*G0_2 + 0.200000000000000*G0_3;
      A[209] = 0.016666666666667*G0_1 + 0.016666666666667*G0_2 + 0.133333333333333*G0_3;
      A[210] = 0.000000000000000;
      A[211] = 0.000000000000000;
      A[212] = 0.000000000000000;
      A[213] = 0.000000000000000;
      A[214] = 0.000000000000000;
      A[215] = 0.000000000000000;
      A[216] = 0.000000000000000;
      A[217] = 0.000000000000000;
      A[218] = 0.000000000000000;
      A[219] = 0.000000000000000;
      A[220] = 0.000000000000000;
      A[221] = 0.000000000000000;
      A[222] = 0.000000000000000;
      A[223] = 0.016666666666667*G0_1 + 0.016666666666667*G0_2 + 0.133333333333333*G0_3;
      A[224] = -0.016666666666667*G0_1 + 0.150000000000000*G0_2 + 0.200000000000000*G0_3;
        break;
      }
    case 1:
      {
        A[0] = 0.092857142857143*G0_0 - 0.007142857142857*G0_2 + 0.047619047619048*G0_4;
      A[1] = 0.000000000000000;
      A[2] = -0.007142857142857*G0_0 - 0.007142857142857*G0_2 - 0.019047619047619*G0_4;
      A[3] = 0.000000000000000;
      A[4] = 0.047619047619048*G0_0 - 0.019047619047619*G0_2 + 0.038095238095238*G0_4;
      A[5] = 0.000000000000000;
      A[6] = 0.000000000000000;
      A[7] = 0.000000000000000;
      A[8] = 0.000000000000000;
      A[9] = 0.000000000000000;
      A[10] = 0.000000000000000;
      A[11] = 0.000000000000000;
      A[12] = 0.000000000000000;
      A[13] = 0.000000000000000;
      A[14] = 0.000000000000000;
      A[15] = 0.000000000000000;
      A[16] = 0.000000000000000;
      A[17] = 0.000000000000000;
      A[18] = 0.000000000000000;
      A[19] = 0.000000000000000;
      A[20] = 0.000000000000000;
      A[21] = 0.000000000000000;
      A[22] = 0.000000000000000;
      A[23] = 0.000000000000000;
      A[24] = 0.000000000000000;
      A[25] = 0.000000000000000;
      A[26] = 0.000000000000000;
      A[27] = 0.000000000000000;
      A[28] = 0.000000000000000;
      A[29] = 0.000000000000000;
      A[30] = -0.007142857142857*G0_0 - 0.007142857142857*G0_2 - 0.019047619047619*G0_4;
      A[31] = 0.000000000000000;
      A[32] = -0.007142857142857*G0_0 + 0.092857142857143*G0_2 + 0.047619047619048*G0_4;
      A[33] = 0.000000000000000;
      A[34] = -0.019047619047619*G0_0 + 0.047619047619048*G0_2 + 0.038095238095238*G0_4;
      A[35] = 0.000000000000000;
      A[36] = 0.000000000000000;
      A[37] = 0.000000000000000;
      A[38] = 0.000000000000000;
      A[39] = 0.000000000000000;
      A[40] = 0.000000000000000;
      A[41] = 0.000000000000000;
      A[42] = 0.000000000000000;
      A[43] = 0.000000000000000;
      A[44] = 0.000000000000000;
      A[45] = 0.000000000000000;
      A[46] = 0.000000000000000;
      A[47] = 0.000000000000000;
      A[48] = 0.000000000000000;
      A[49] = 0.000000000000000;
      A[50] = 0.000000000000000;
      A[51] = 0.000000000000000;
      A[52] = 0.000000000000000;
      A[53] = 0.000000000000000;
      A[54] = 0.000000000000000;
      A[55] = 0.000000000000000;
      A[56] = 0.000000000000000;
      A[57] = 0.000000000000000;
      A[58] = 0.000000000000000;
      A[59] = 0.000000000000000;
      A[60] = 0.047619047619048*G0_0 - 0.019047619047619*G0_2 + 0.038095238095238*G0_4;
      A[61] = 0.000000000000000;
      A[62] = -0.019047619047619*G0_0 + 0.047619047619048*G0_2 + 0.038095238095238*G0_4;
      A[63] = 0.000000000000000;
      A[64] = 0.038095238095238*G0_0 + 0.038095238095238*G0_2 + 0.457142857142857*G0_4;
      A[65] = 0.000000000000000;
      A[66] = 0.000000000000000;
      A[67] = 0.000000000000000;
      A[68] = 0.000000000000000;
      A[69] = 0.000000000000000;
      A[70] = 0.000000000000000;
      A[71] = 0.000000000000000;
      A[72] = 0.000000000000000;
      A[73] = 0.000000000000000;
      A[74] = 0.000000000000000;
      A[75] = 0.000000000000000;
      A[76] = 0.000000000000000;
      A[77] = 0.000000000000000;
      A[78] = 0.000000000000000;
      A[79] = 0.000000000000000;
      A[80] = 0.000000000000000;
      A[81] = 0.000000000000000;
      A[82] = 0.000000000000000;
      A[83] = 0.000000000000000;
      A[84] = 0.000000000000000;
      A[85] = 0.000000000000000;
      A[86] = 0.000000000000000;
      A[87] = 0.000000000000000;
      A[88] = 0.000000000000000;
      A[89] = 0.000000000000000;
      A[90] = 0.000000000000000;
      A[91] = 0.000000000000000;
      A[92] = 0.000000000000000;
      A[93] = 0.000000000000000;
      A[94] = 0.000000000000000;
      A[95] = 0.000000000000000;
      A[96] = 0.092857142857143*G0_0 - 0.007142857142857*G0_2 + 0.047619047619048*G0_4;
      A[97] = 0.000000000000000;
      A[98] = -0.007142857142857*G0_0 - 0.007142857142857*G0_2 - 0.019047619047619*G0_4;
      A[99] = 0.000000000000000;
      A[100] = 0.047619047619048*G0_0 - 0.019047619047619*G0_2 + 0.038095238095238*G0_4;
      A[101] = 0.000000000000000;
      A[102] = 0.000000000000000;
      A[103] = 0.000000000000000;
      A[104] = 0.000000000000000;
      A[105] = 0.000000000000000;
      A[106] = 0.000000000000000;
      A[107] = 0.000000000000000;
      A[108] = 0.000000000000000;
      A[109] = 0.000000000000000;
      A[110] = 0.000000000000000;
      A[111] = 0.000000000000000;
      A[112] = 0.000000000000000;
      A[113] = 0.000000000000000;
      A[114] = 0.000000000000000;
      A[115] = 0.000000000000000;
      A[116] = 0.000000000000000;
      A[117] = 0.000000000000000;
      A[118] = 0.000000000000000;
      A[119] = 0.000000000000000;
      A[120] = 0.000000000000000;
      A[121] = 0.000000000000000;
      A[122] = 0.000000000000000;
      A[123] = 0.000000000000000;
      A[124] = 0.000000000000000;
      A[125] = 0.000000000000000;
      A[126] = -0.007142857142857*G0_0 - 0.007142857142857*G0_2 - 0.019047619047619*G0_4;
      A[127] = 0.000000000000000;
      A[128] = -0.007142857142857*G0_0 + 0.092857142857143*G0_2 + 0.047619047619048*G0_4;
      A[129] = 0.000000000000000;
      A[130] = -0.019047619047619*G0_0 + 0.047619047619048*G0_2 + 0.038095238095238*G0_4;
      A[131] = 0.000000000000000;
      A[132] = 0.000000000000000;
      A[133] = 0.000000000000000;
      A[134] = 0.000000000000000;
      A[135] = 0.000000000000000;
      A[136] = 0.000000000000000;
      A[137] = 0.000000000000000;
      A[138] = 0.000000000000000;
      A[139] = 0.000000000000000;
      A[140] = 0.000000000000000;
      A[141] = 0.000000000000000;
      A[142] = 0.000000000000000;
      A[143] = 0.000000000000000;
      A[144] = 0.000000000000000;
      A[145] = 0.000000000000000;
      A[146] = 0.000000000000000;
      A[147] = 0.000000000000000;
      A[148] = 0.000000000000000;
      A[149] = 0.000000000000000;
      A[150] = 0.000000000000000;
      A[151] = 0.000000000000000;
      A[152] = 0.000000000000000;
      A[153] = 0.000000000000000;
      A[154] = 0.000000000000000;
      A[155] = 0.000000000000000;
      A[156] = 0.047619047619048*G0_0 - 0.019047619047619*G0_2 + 0.038095238095238*G0_4;
      A[157] = 0.000000000000000;
      A[158] = -0.019047619047619*G0_0 + 0.047619047619048*G0_2 + 0.038095238095238*G0_4;
      A[159] = 0.000000000000000;
      A[160] = 0.038095238095238*G0_0 + 0.038095238095238*G0_2 + 0.457142857142857*G0_4;
      A[161] = 0.000000000000000;
      A[162] = 0.000000000000000;
      A[163] = 0.000000000000000;
      A[164] = 0.000000000000000;
      A[165] = 0.000000000000000;
      A[166] = 0.000000000000000;
      A[167] = 0.000000000000000;
      A[168] = 0.000000000000000;
      A[169] = 0.000000000000000;
      A[170] = 0.000000000000000;
      A[171] = 0.000000000000000;
      A[172] = 0.000000000000000;
      A[173] = 0.000000000000000;
      A[174] = 0.000000000000000;
      A[175] = 0.000000000000000;
      A[176] = 0.000000000000000;
      A[177] = 0.000000000000000;
      A[178] = 0.000000000000000;
      A[179] = 0.000000000000000;
      A[180] = 0.000000000000000;
      A[181] = 0.000000000000000;
      A[182] = 0.000000000000000;
      A[183] = 0.000000000000000;
      A[184] = 0.000000000000000;
      A[185] = 0.000000000000000;
      A[186] = 0.000000000000000;
      A[187] = 0.000000000000000;
      A[188] = 0.000000000000000;
      A[189] = 0.000000000000000;
      A[190] = 0.000000000000000;
      A[191] = 0.000000000000000;
      A[192] = 0.150000000000000*G0_0 - 0.016666666666667*G0_2 + 0.200000000000000*G0_4;
      A[193] = 0.000000000000000;
      A[194] = 0.016666666666667*G0_0 + 0.016666666666667*G0_2 + 0.133333333333333*G0_4;
      A[195] = 0.000000000000000;
      A[196] = 0.000000000000000;
      A[197] = 0.000000000000000;
      A[198] = 0.000000000000000;
      A[199] = 0.000000000000000;
      A[200] = 0.000000000000000;
      A[201] = 0.000000000000000;
      A[202] = 0.000000000000000;
      A[203] = 0.000000000000000;
      A[204] = 0.000000000000000;
      A[205] = 0.000000000000000;
      A[206] = 0.000000000000000;
      A[207] = 0.000000000000000;
      A[208] = 0.000000000000000;
      A[209] = 0.000000000000000;
      A[210] = 0.000000000000000;
      A[211] = 0.000000000000000;
      A[212] = 0.000000000000000;
      A[213] = 0.000000000000000;
      A[214] = 0.000000000000000;
      A[215] = 0.000000000000000;
      A[216] = 0.000000000000000;
      A[217] = 0.000000000000000;
      A[218] = 0.000000000000000;
      A[219] = 0.000000000000000;
      A[220] = 0.000000000000000;
      A[221] = 0.000000000000000;
      A[222] = 0.016666666666667*G0_0 + 0.016666666666667*G0_2 + 0.133333333333333*G0_4;
      A[223] = 0.000000000000000;
      A[224] = -0.016666666666667*G0_0 + 0.150000000000000*G0_2 + 0.200000000000000*G0_4;
        break;
      }
    case 2:
      {
        A[0] = 0.092857142857143*G0_0 - 0.007142857142857*G0_1 + 0.047619047619048*G0_5;
      A[1] = -0.007142857142857*G0_0 - 0.007142857142857*G0_1 - 0.019047619047619*G0_5;
      A[2] = 0.000000000000000;
      A[3] = 0.000000000000000;
      A[4] = 0.000000000000000;
      A[5] = 0.047619047619048*G0_0 - 0.019047619047619*G0_1 + 0.038095238095238*G0_5;
      A[6] = 0.000000000000000;
      A[7] = 0.000000000000000;
      A[8] = 0.000000000000000;
      A[9] = 0.000000000000000;
      A[10] = 0.000000000000000;
      A[11] = 0.000000000000000;
      A[12] = 0.000000000000000;
      A[13] = 0.000000000000000;
      A[14] = 0.000000000000000;
      A[15] = -0.007142857142857*G0_0 - 0.007142857142857*G0_1 - 0.019047619047619*G0_5;
      A[16] = -0.007142857142857*G0_0 + 0.092857142857143*G0_1 + 0.047619047619048*G0_5;
      A[17] = 0.000000000000000;
      A[18] = 0.000000000000000;
      A[19] = 0.000000000000000;
      A[20] = -0.019047619047619*G0_0 + 0.047619047619048*G0_1 + 0.038095238095238*G0_5;
      A[21] = 0.000000000000000;
      A[22] = 0.000000000000000;
      A[23] = 0.000000000000000;
      A[24] = 0.000000000000000;
      A[25] = 0.000000000000000;
      A[26] = 0.000000000000000;
      A[27] = 0.000000000000000;
      A[28] = 0.000000000000000;
      A[29] = 0.000000000000000;
      A[30] = 0.000000000000000;
      A[31] = 0.000000000000000;
      A[32] = 0.000000000000000;
      A[33] = 0.000000000000000;
      A[34] = 0.000000000000000;
      A[35] = 0.000000000000000;
      A[36] = 0.000000000000000;
      A[37] = 0.000000000000000;
      A[38] = 0.000000000000000;
      A[39] = 0.000000000000000;
      A[40] = 0.000000000000000;
      A[41] = 0.000000000000000;
      A[42] = 0.000000000000000;
      A[43] = 0.000000000000000;
      A[44] = 0.000000000000000;
      A[45] = 0.000000000000000;
      A[46] = 0.000000000000000;
      A[47] = 0.000000000000000;
      A[48] = 0.000000000000000;
      A[49] = 0.000000000000000;
      A[50] = 0.000000000000000;
      A[51] = 0.000000000000000;
      A[52] = 0.000000000000000;
      A[53] = 0.000000000000000;
      A[54] = 0.000000000000000;
      A[55] = 0.000000000000000;
      A[56] = 0.000000000000000;
      A[57] = 0.000000000000000;
      A[58] = 0.000000000000000;
      A[59] = 0.000000000000000;
      A[60] = 0.000000000000000;
      A[61] = 0.000000000000000;
      A[62] = 0.000000000000000;
      A[63] = 0.000000000000000;
      A[64] = 0.000000000000000;
      A[65] = 0.000000000000000;
      A[66] = 0.000000000000000;
      A[67] = 0.000000000000000;
      A[68] = 0.000000000000000;
      A[69] = 0.000000000000000;
      A[70] = 0.000000000000000;
      A[71] = 0.000000000000000;
      A[72] = 0.000000000000000;
      A[73] = 0.000000000000000;
      A[74] = 0.000000000000000;
      A[75] = 0.047619047619048*G0_0 - 0.019047619047619*G0_1 + 0.038095238095238*G0_5;
      A[76] = -0.019047619047619*G0_0 + 0.047619047619048*G0_1 + 0.038095238095238*G0_5;
      A[77] = 0.000000000000000;
      A[78] = 0.000000000000000;
      A[79] = 0.000000000000000;
      A[80] = 0.038095238095238*G0_0 + 0.038095238095238*G0_1 + 0.457142857142857*G0_5;
      A[81] = 0.000000000000000;
      A[82] = 0.000000000000000;
      A[83] = 0.000000000000000;
      A[84] = 0.000000000000000;
      A[85] = 0.000000000000000;
      A[86] = 0.000000000000000;
      A[87] = 0.000000000000000;
      A[88] = 0.000000000000000;
      A[89] = 0.000000000000000;
      A[90] = 0.000000000000000;
      A[91] = 0.000000000000000;
      A[92] = 0.000000000000000;
      A[93] = 0.000000000000000;
      A[94] = 0.000000000000000;
      A[95] = 0.000000000000000;
      A[96] = 0.092857142857143*G0_0 - 0.007142857142857*G0_1 + 0.047619047619048*G0_5;
      A[97] = -0.007142857142857*G0_0 - 0.007142857142857*G0_1 - 0.019047619047619*G0_5;
      A[98] = 0.000000000000000;
      A[99] = 0.000000000000000;
      A[100] = 0.000000000000000;
      A[101] = 0.047619047619048*G0_0 - 0.019047619047619*G0_1 + 0.038095238095238*G0_5;
      A[102] = 0.000000000000000;
      A[103] = 0.000000000000000;
      A[104] = 0.000000000000000;
      A[105] = 0.000000000000000;
      A[106] = 0.000000000000000;
      A[107] = 0.000000000000000;
      A[108] = 0.000000000000000;
      A[109] = 0.000000000000000;
      A[110] = 0.000000000000000;
      A[111] = -0.007142857142857*G0_0 - 0.007142857142857*G0_1 - 0.019047619047619*G0_5;
      A[112] = -0.007142857142857*G0_0 + 0.092857142857143*G0_1 + 0.047619047619048*G0_5;
      A[113] = 0.000000000000000;
      A[114] = 0.000000000000000;
      A[115] = 0.000000000000000;
      A[116] = -0.019047619047619*G0_0 + 0.047619047619048*G0_1 + 0.038095238095238*G0_5;
      A[117] = 0.000000000000000;
      A[118] = 0.000000000000000;
      A[119] = 0.000000000000000;
      A[120] = 0.000000000000000;
      A[121] = 0.000000000000000;
      A[122] = 0.000000000000000;
      A[123] = 0.000000000000000;
      A[124] = 0.000000000000000;
      A[125] = 0.000000000000000;
      A[126] = 0.000000000000000;
      A[127] = 0.000000000000000;
      A[128] = 0.000000000000000;
      A[129] = 0.000000000000000;
      A[130] = 0.000000000000000;
      A[131] = 0.000000000000000;
      A[132] = 0.000000000000000;
      A[133] = 0.000000000000000;
      A[134] = 0.000000000000000;
      A[135] = 0.000000000000000;
      A[136] = 0.000000000000000;
      A[137] = 0.000000000000000;
      A[138] = 0.000000000000000;
      A[139] = 0.000000000000000;
      A[140] = 0.000000000000000;
      A[141] = 0.000000000000000;
      A[142] = 0.000000000000000;
      A[143] = 0.000000000000000;
      A[144] = 0.000000000000000;
      A[145] = 0.000000000000000;
      A[146] = 0.000000000000000;
      A[147] = 0.000000000000000;
      A[148] = 0.000000000000000;
      A[149] = 0.000000000000000;
      A[150] = 0.000000000000000;
      A[151] = 0.000000000000000;
      A[152] = 0.000000000000000;
      A[153] = 0.000000000000000;
      A[154] = 0.000000000000000;
      A[155] = 0.000000000000000;
      A[156] = 0.000000000000000;
      A[157] = 0.000000000000000;
      A[158] = 0.000000000000000;
      A[159] = 0.000000000000000;
      A[160] = 0.000000000000000;
      A[161] = 0.000000000000000;
      A[162] = 0.000000000000000;
      A[163] = 0.000000000000000;
      A[164] = 0.000000000000000;
      A[165] = 0.000000000000000;
      A[166] = 0.000000000000000;
      A[167] = 0.000000000000000;
      A[168] = 0.000000000000000;
      A[169] = 0.000000000000000;
      A[170] = 0.000000000000000;
      A[171] = 0.047619047619048*G0_0 - 0.019047619047619*G0_1 + 0.038095238095238*G0_5;
      A[172] = -0.019047619047619*G0_0 + 0.047619047619048*G0_1 + 0.038095238095238*G0_5;
      A[173] = 0.000000000000000;
      A[174] = 0.000000000000000;
      A[175] = 0.000000000000000;
      A[176] = 0.038095238095238*G0_0 + 0.038095238095238*G0_1 + 0.457142857142857*G0_5;
      A[177] = 0.000000000000000;
      A[178] = 0.000000000000000;
      A[179] = 0.000000000000000;
      A[180] = 0.000000000000000;
      A[181] = 0.000000000000000;
      A[182] = 0.000000000000000;
      A[183] = 0.000000000000000;
      A[184] = 0.000000000000000;
      A[185] = 0.000000000000000;
      A[186] = 0.000000000000000;
      A[187] = 0.000000000000000;
      A[188] = 0.000000000000000;
      A[189] = 0.000000000000000;
      A[190] = 0.000000000000000;
      A[191] = 0.000000000000000;
      A[192] = 0.150000000000000*G0_0 - 0.016666666666667*G0_1 + 0.200000000000000*G0_5;
      A[193] = 0.016666666666667*G0_0 + 0.016666666666667*G0_1 + 0.133333333333333*G0_5;
      A[194] = 0.000000000000000;
      A[195] = 0.000000000000000;
      A[196] = 0.000000000000000;
      A[197] = 0.000000000000000;
      A[198] = 0.000000000000000;
      A[199] = 0.000000000000000;
      A[200] = 0.000000000000000;
      A[201] = 0.000000000000000;
      A[202] = 0.000000000000000;
      A[203] = 0.000000000000000;
      A[204] = 0.000000000000000;
      A[205] = 0.000000000000000;
      A[206] = 0.000000000000000;
      A[207] = 0.016666666666667*G0_0 + 0.016666666666667*G0_1 + 0.133333333333333*G0_5;
      A[208] = -0.016666666666667*G0_0 + 0.150000000000000*G0_1 + 0.200000000000000*G0_5;
      A[209] = 0.000000000000000;
      A[210] = 0.000000000000000;
      A[211] = 0.000000000000000;
      A[212] = 0.000000000000000;
      A[213] = 0.000000000000000;
      A[214] = 0.000000000000000;
      A[215] = 0.000000000000000;
      A[216] = 0.000000000000000;
      A[217] = 0.000000000000000;
      A[218] = 0.000000000000000;
      A[219] = 0.000000000000000;
      A[220] = 0.000000000000000;
      A[221] = 0.000000000000000;
      A[222] = 0.000000000000000;
      A[223] = 0.000000000000000;
      A[224] = 0.000000000000000;
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the
/// interior facet tensor corresponding to the local contribution to
/// a form from the integral over an interior facet.

class adaptivenavierstokes_interior_facet_integral_4_0: public ufc::interior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_interior_facet_integral_4_0() : ufc::interior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_interior_facet_integral_4_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local interior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c0,
                               const ufc::cell& c1,
                               unsigned int facet0,
                               unsigned int facet1) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      12
    // Number of operations (multiply-add pairs) for geometry tensor:    12
    // Number of operations (multiply-add pairs) for tensor contraction: 990
    // Total number of operations (multiply-add pairs):                  1014
    
    // Extract vertex coordinates
    const double * const * x0 = c0.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet0][0];
    const unsigned int v1 = edge_vertices[facet0][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x0[v1][0] - x0[v0][0];
    const double dx1 = x0[v1][1] - x0[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    // Compute geometry tensor
    const double G0_6 = det*w[0][6]*(1.0);
    const double G0_7 = det*w[0][7]*(1.0);
    const double G0_8 = det*w[0][8]*(1.0);
    const double G0_9 = det*w[0][9]*(1.0);
    const double G0_10 = det*w[0][10]*(1.0);
    const double G0_11 = det*w[0][11]*(1.0);
    const double G1_0 = det*w[0][0]*(1.0);
    const double G1_1 = det*w[0][1]*(1.0);
    const double G1_2 = det*w[0][2]*(1.0);
    const double G1_3 = det*w[0][3]*(1.0);
    const double G1_4 = det*w[0][4]*(1.0);
    const double G1_5 = det*w[0][5]*(1.0);
    
    // Compute element tensor
    switch (facet0)
    {
    case 0:
      {
        switch (facet1)
      {
      case 0:
        {
          A[0] = 0.000000000000000;
        A[1] = 0.000000000000000;
        A[2] = 0.000000000000000;
        A[3] = 0.000000000000000;
        A[4] = 0.000000000000000;
        A[5] = 0.000000000000000;
        A[6] = 0.000000000000000;
        A[7] = 0.000000000000000;
        A[8] = 0.000000000000000;
        A[9] = 0.000000000000000;
        A[10] = 0.000000000000000;
        A[11] = 0.000000000000000;
        A[12] = 0.000000000000000;
        A[13] = 0.000000000000000;
        A[14] = 0.000000000000000;
        A[15] = 0.000000000000000;
        A[16] = 0.000000000000000;
        A[17] = 0.000000000000000;
        A[18] = 0.000000000000000;
        A[19] = 0.000000000000000;
        A[20] = 0.000000000000000;
        A[21] = 0.000000000000000;
        A[22] = 0.000000000000000;
        A[23] = 0.000000000000000;
        A[24] = 0.000000000000000;
        A[25] = 0.000000000000000;
        A[26] = 0.000000000000000;
        A[27] = 0.000000000000000;
        A[28] = 0.000000000000000;
        A[29] = 0.000000000000000;
        A[30] = 0.000000000000000;
        A[31] = 0.092857142857143*G1_1 - 0.007142857142857*G1_2 + 0.047619047619048*G1_3;
        A[32] = -0.007142857142857*G1_1 - 0.007142857142857*G1_2 - 0.019047619047619*G1_3;
        A[33] = 0.047619047619048*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[34] = 0.000000000000000;
        A[35] = 0.000000000000000;
        A[36] = 0.000000000000000;
        A[37] = 0.000000000000000;
        A[38] = 0.000000000000000;
        A[39] = 0.000000000000000;
        A[40] = 0.000000000000000;
        A[41] = 0.000000000000000;
        A[42] = 0.000000000000000;
        A[43] = 0.000000000000000;
        A[44] = 0.000000000000000;
        A[45] = 0.000000000000000;
        A[46] = 0.000000000000000;
        A[47] = 0.000000000000000;
        A[48] = 0.000000000000000;
        A[49] = 0.000000000000000;
        A[50] = 0.000000000000000;
        A[51] = 0.000000000000000;
        A[52] = 0.000000000000000;
        A[53] = 0.000000000000000;
        A[54] = 0.000000000000000;
        A[55] = 0.000000000000000;
        A[56] = 0.000000000000000;
        A[57] = 0.000000000000000;
        A[58] = 0.000000000000000;
        A[59] = 0.000000000000000;
        A[60] = 0.000000000000000;
        A[61] = -0.007142857142857*G1_1 - 0.007142857142857*G1_2 - 0.019047619047619*G1_3;
        A[62] = -0.007142857142857*G1_1 + 0.092857142857143*G1_2 + 0.047619047619048*G1_3;
        A[63] = -0.019047619047619*G1_1 + 0.047619047619048*G1_2 + 0.038095238095238*G1_3;
        A[64] = 0.000000000000000;
        A[65] = 0.000000000000000;
        A[66] = 0.000000000000000;
        A[67] = 0.000000000000000;
        A[68] = 0.000000000000000;
        A[69] = 0.000000000000000;
        A[70] = 0.000000000000000;
        A[71] = 0.000000000000000;
        A[72] = 0.000000000000000;
        A[73] = 0.000000000000000;
        A[74] = 0.000000000000000;
        A[75] = 0.000000000000000;
        A[76] = 0.000000000000000;
        A[77] = 0.000000000000000;
        A[78] = 0.000000000000000;
        A[79] = 0.000000000000000;
        A[80] = 0.000000000000000;
        A[81] = 0.000000000000000;
        A[82] = 0.000000000000000;
        A[83] = 0.000000000000000;
        A[84] = 0.000000000000000;
        A[85] = 0.000000000000000;
        A[86] = 0.000000000000000;
        A[87] = 0.000000000000000;
        A[88] = 0.000000000000000;
        A[89] = 0.000000000000000;
        A[90] = 0.000000000000000;
        A[91] = 0.047619047619048*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[92] = -0.019047619047619*G1_1 + 0.047619047619048*G1_2 + 0.038095238095238*G1_3;
        A[93] = 0.038095238095238*G1_1 + 0.038095238095238*G1_2 + 0.457142857142857*G1_3;
        A[94] = 0.000000000000000;
        A[95] = 0.000000000000000;
        A[96] = 0.000000000000000;
        A[97] = 0.000000000000000;
        A[98] = 0.000000000000000;
        A[99] = 0.000000000000000;
        A[100] = 0.000000000000000;
        A[101] = 0.000000000000000;
        A[102] = 0.000000000000000;
        A[103] = 0.000000000000000;
        A[104] = 0.000000000000000;
        A[105] = 0.000000000000000;
        A[106] = 0.000000000000000;
        A[107] = 0.000000000000000;
        A[108] = 0.000000000000000;
        A[109] = 0.000000000000000;
        A[110] = 0.000000000000000;
        A[111] = 0.000000000000000;
        A[112] = 0.000000000000000;
        A[113] = 0.000000000000000;
        A[114] = 0.000000000000000;
        A[115] = 0.000000000000000;
        A[116] = 0.000000000000000;
        A[117] = 0.000000000000000;
        A[118] = 0.000000000000000;
        A[119] = 0.000000000000000;
        A[120] = 0.000000000000000;
        A[121] = 0.000000000000000;
        A[122] = 0.000000000000000;
        A[123] = 0.000000000000000;
        A[124] = 0.000000000000000;
        A[125] = 0.000000000000000;
        A[126] = 0.000000000000000;
        A[127] = 0.000000000000000;
        A[128] = 0.000000000000000;
        A[129] = 0.000000000000000;
        A[130] = 0.000000000000000;
        A[131] = 0.000000000000000;
        A[132] = 0.000000000000000;
        A[133] = 0.000000000000000;
        A[134] = 0.000000000000000;
        A[135] = 0.000000000000000;
        A[136] = 0.000000000000000;
        A[137] = 0.000000000000000;
        A[138] = 0.000000000000000;
        A[139] = 0.000000000000000;
        A[140] = 0.000000000000000;
        A[141] = 0.000000000000000;
        A[142] = 0.000000000000000;
        A[143] = 0.000000000000000;
        A[144] = 0.000000000000000;
        A[145] = 0.000000000000000;
        A[146] = 0.000000000000000;
        A[147] = 0.000000000000000;
        A[148] = 0.000000000000000;
        A[149] = 0.000000000000000;
        A[150] = 0.000000000000000;
        A[151] = 0.000000000000000;
        A[152] = 0.000000000000000;
        A[153] = 0.000000000000000;
        A[154] = 0.000000000000000;
        A[155] = 0.000000000000000;
        A[156] = 0.000000000000000;
        A[157] = 0.000000000000000;
        A[158] = 0.000000000000000;
        A[159] = 0.000000000000000;
        A[160] = 0.000000000000000;
        A[161] = 0.000000000000000;
        A[162] = 0.000000000000000;
        A[163] = 0.000000000000000;
        A[164] = 0.000000000000000;
        A[165] = 0.000000000000000;
        A[166] = 0.000000000000000;
        A[167] = 0.000000000000000;
        A[168] = 0.000000000000000;
        A[169] = 0.000000000000000;
        A[170] = 0.000000000000000;
        A[171] = 0.000000000000000;
        A[172] = 0.000000000000000;
        A[173] = 0.000000000000000;
        A[174] = 0.000000000000000;
        A[175] = 0.000000000000000;
        A[176] = 0.000000000000000;
        A[177] = 0.000000000000000;
        A[178] = 0.000000000000000;
        A[179] = 0.000000000000000;
        A[180] = 0.000000000000000;
        A[181] = 0.000000000000000;
        A[182] = 0.000000000000000;
        A[183] = 0.000000000000000;
        A[184] = 0.000000000000000;
        A[185] = 0.000000000000000;
        A[186] = 0.000000000000000;
        A[187] = 0.000000000000000;
        A[188] = 0.000000000000000;
        A[189] = 0.000000000000000;
        A[190] = 0.000000000000000;
        A[191] = 0.000000000000000;
        A[192] = 0.000000000000000;
        A[193] = 0.000000000000000;
        A[194] = 0.000000000000000;
        A[195] = 0.000000000000000;
        A[196] = 0.000000000000000;
        A[197] = 0.000000000000000;
        A[198] = 0.000000000000000;
        A[199] = 0.000000000000000;
        A[200] = 0.000000000000000;
        A[201] = 0.000000000000000;
        A[202] = 0.000000000000000;
        A[203] = 0.000000000000000;
        A[204] = 0.000000000000000;
        A[205] = 0.000000000000000;
        A[206] = 0.000000000000000;
        A[207] = 0.000000000000000;
        A[208] = 0.000000000000000;
        A[209] = 0.000000000000000;
        A[210] = 0.000000000000000;
        A[211] = 0.000000000000000;
        A[212] = 0.000000000000000;
        A[213] = 0.000000000000000;
        A[214] = 0.000000000000000;
        A[215] = 0.000000000000000;
        A[216] = 0.000000000000000;
        A[217] = 0.092857142857143*G1_1 - 0.007142857142857*G1_2 + 0.047619047619048*G1_3;
        A[218] = -0.007142857142857*G1_1 - 0.007142857142857*G1_2 - 0.019047619047619*G1_3;
        A[219] = 0.047619047619048*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[220] = 0.000000000000000;
        A[221] = 0.000000000000000;
        A[222] = 0.000000000000000;
        A[223] = 0.000000000000000;
        A[224] = 0.000000000000000;
        A[225] = 0.000000000000000;
        A[226] = 0.000000000000000;
        A[227] = 0.000000000000000;
        A[228] = 0.000000000000000;
        A[229] = 0.000000000000000;
        A[230] = 0.000000000000000;
        A[231] = 0.000000000000000;
        A[232] = 0.000000000000000;
        A[233] = 0.000000000000000;
        A[234] = 0.000000000000000;
        A[235] = 0.000000000000000;
        A[236] = 0.000000000000000;
        A[237] = 0.000000000000000;
        A[238] = 0.000000000000000;
        A[239] = 0.000000000000000;
        A[240] = 0.000000000000000;
        A[241] = 0.000000000000000;
        A[242] = 0.000000000000000;
        A[243] = 0.000000000000000;
        A[244] = 0.000000000000000;
        A[245] = 0.000000000000000;
        A[246] = 0.000000000000000;
        A[247] = -0.007142857142857*G1_1 - 0.007142857142857*G1_2 - 0.019047619047619*G1_3;
        A[248] = -0.007142857142857*G1_1 + 0.092857142857143*G1_2 + 0.047619047619048*G1_3;
        A[249] = -0.019047619047619*G1_1 + 0.047619047619048*G1_2 + 0.038095238095238*G1_3;
        A[250] = 0.000000000000000;
        A[251] = 0.000000000000000;
        A[252] = 0.000000000000000;
        A[253] = 0.000000000000000;
        A[254] = 0.000000000000000;
        A[255] = 0.000000000000000;
        A[256] = 0.000000000000000;
        A[257] = 0.000000000000000;
        A[258] = 0.000000000000000;
        A[259] = 0.000000000000000;
        A[260] = 0.000000000000000;
        A[261] = 0.000000000000000;
        A[262] = 0.000000000000000;
        A[263] = 0.000000000000000;
        A[264] = 0.000000000000000;
        A[265] = 0.000000000000000;
        A[266] = 0.000000000000000;
        A[267] = 0.000000000000000;
        A[268] = 0.000000000000000;
        A[269] = 0.000000000000000;
        A[270] = 0.000000000000000;
        A[271] = 0.000000000000000;
        A[272] = 0.000000000000000;
        A[273] = 0.000000000000000;
        A[274] = 0.000000000000000;
        A[275] = 0.000000000000000;
        A[276] = 0.000000000000000;
        A[277] = 0.047619047619048*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[278] = -0.019047619047619*G1_1 + 0.047619047619048*G1_2 + 0.038095238095238*G1_3;
        A[279] = 0.038095238095238*G1_1 + 0.038095238095238*G1_2 + 0.457142857142857*G1_3;
        A[280] = 0.000000000000000;
        A[281] = 0.000000000000000;
        A[282] = 0.000000000000000;
        A[283] = 0.000000000000000;
        A[284] = 0.000000000000000;
        A[285] = 0.000000000000000;
        A[286] = 0.000000000000000;
        A[287] = 0.000000000000000;
        A[288] = 0.000000000000000;
        A[289] = 0.000000000000000;
        A[290] = 0.000000000000000;
        A[291] = 0.000000000000000;
        A[292] = 0.000000000000000;
        A[293] = 0.000000000000000;
        A[294] = 0.000000000000000;
        A[295] = 0.000000000000000;
        A[296] = 0.000000000000000;
        A[297] = 0.000000000000000;
        A[298] = 0.000000000000000;
        A[299] = 0.000000000000000;
        A[300] = 0.000000000000000;
        A[301] = 0.000000000000000;
        A[302] = 0.000000000000000;
        A[303] = 0.000000000000000;
        A[304] = 0.000000000000000;
        A[305] = 0.000000000000000;
        A[306] = 0.000000000000000;
        A[307] = 0.000000000000000;
        A[308] = 0.000000000000000;
        A[309] = 0.000000000000000;
        A[310] = 0.000000000000000;
        A[311] = 0.000000000000000;
        A[312] = 0.000000000000000;
        A[313] = 0.000000000000000;
        A[314] = 0.000000000000000;
        A[315] = 0.000000000000000;
        A[316] = 0.000000000000000;
        A[317] = 0.000000000000000;
        A[318] = 0.000000000000000;
        A[319] = 0.000000000000000;
        A[320] = 0.000000000000000;
        A[321] = 0.000000000000000;
        A[322] = 0.000000000000000;
        A[323] = 0.000000000000000;
        A[324] = 0.000000000000000;
        A[325] = 0.000000000000000;
        A[326] = 0.000000000000000;
        A[327] = 0.000000000000000;
        A[328] = 0.000000000000000;
        A[329] = 0.000000000000000;
        A[330] = 0.000000000000000;
        A[331] = 0.000000000000000;
        A[332] = 0.000000000000000;
        A[333] = 0.000000000000000;
        A[334] = 0.000000000000000;
        A[335] = 0.000000000000000;
        A[336] = 0.000000000000000;
        A[337] = 0.000000000000000;
        A[338] = 0.000000000000000;
        A[339] = 0.000000000000000;
        A[340] = 0.000000000000000;
        A[341] = 0.000000000000000;
        A[342] = 0.000000000000000;
        A[343] = 0.000000000000000;
        A[344] = 0.000000000000000;
        A[345] = 0.000000000000000;
        A[346] = 0.000000000000000;
        A[347] = 0.000000000000000;
        A[348] = 0.000000000000000;
        A[349] = 0.000000000000000;
        A[350] = 0.000000000000000;
        A[351] = 0.000000000000000;
        A[352] = 0.000000000000000;
        A[353] = 0.000000000000000;
        A[354] = 0.000000000000000;
        A[355] = 0.000000000000000;
        A[356] = 0.000000000000000;
        A[357] = 0.000000000000000;
        A[358] = 0.000000000000000;
        A[359] = 0.000000000000000;
        A[360] = 0.000000000000000;
        A[361] = 0.000000000000000;
        A[362] = 0.000000000000000;
        A[363] = 0.000000000000000;
        A[364] = 0.000000000000000;
        A[365] = 0.000000000000000;
        A[366] = 0.000000000000000;
        A[367] = 0.000000000000000;
        A[368] = 0.000000000000000;
        A[369] = 0.000000000000000;
        A[370] = 0.000000000000000;
        A[371] = 0.000000000000000;
        A[372] = 0.000000000000000;
        A[373] = 0.000000000000000;
        A[374] = 0.000000000000000;
        A[375] = 0.000000000000000;
        A[376] = 0.000000000000000;
        A[377] = 0.000000000000000;
        A[378] = 0.000000000000000;
        A[379] = 0.000000000000000;
        A[380] = 0.000000000000000;
        A[381] = 0.000000000000000;
        A[382] = 0.000000000000000;
        A[383] = 0.000000000000000;
        A[384] = 0.000000000000000;
        A[385] = 0.000000000000000;
        A[386] = 0.000000000000000;
        A[387] = 0.000000000000000;
        A[388] = 0.000000000000000;
        A[389] = 0.000000000000000;
        A[390] = 0.000000000000000;
        A[391] = 0.000000000000000;
        A[392] = 0.000000000000000;
        A[393] = 0.000000000000000;
        A[394] = 0.000000000000000;
        A[395] = 0.000000000000000;
        A[396] = 0.000000000000000;
        A[397] = 0.000000000000000;
        A[398] = 0.000000000000000;
        A[399] = 0.000000000000000;
        A[400] = 0.000000000000000;
        A[401] = 0.000000000000000;
        A[402] = 0.000000000000000;
        A[403] = 0.150000000000000*G1_1 - 0.016666666666667*G1_2 + 0.200000000000000*G1_3;
        A[404] = 0.016666666666667*G1_1 + 0.016666666666667*G1_2 + 0.133333333333333*G1_3;
        A[405] = 0.000000000000000;
        A[406] = 0.000000000000000;
        A[407] = 0.000000000000000;
        A[408] = 0.000000000000000;
        A[409] = 0.000000000000000;
        A[410] = 0.000000000000000;
        A[411] = 0.000000000000000;
        A[412] = 0.000000000000000;
        A[413] = 0.000000000000000;
        A[414] = 0.000000000000000;
        A[415] = 0.000000000000000;
        A[416] = 0.000000000000000;
        A[417] = 0.000000000000000;
        A[418] = 0.000000000000000;
        A[419] = 0.000000000000000;
        A[420] = 0.000000000000000;
        A[421] = 0.000000000000000;
        A[422] = 0.000000000000000;
        A[423] = 0.000000000000000;
        A[424] = 0.000000000000000;
        A[425] = 0.000000000000000;
        A[426] = 0.000000000000000;
        A[427] = 0.000000000000000;
        A[428] = 0.000000000000000;
        A[429] = 0.000000000000000;
        A[430] = 0.000000000000000;
        A[431] = 0.000000000000000;
        A[432] = 0.000000000000000;
        A[433] = 0.016666666666667*G1_1 + 0.016666666666667*G1_2 + 0.133333333333333*G1_3;
        A[434] = -0.016666666666667*G1_1 + 0.150000000000000*G1_2 + 0.200000000000000*G1_3;
        A[435] = 0.000000000000000;
        A[436] = 0.000000000000000;
        A[437] = 0.000000000000000;
        A[438] = 0.000000000000000;
        A[439] = 0.000000000000000;
        A[440] = 0.000000000000000;
        A[441] = 0.000000000000000;
        A[442] = 0.000000000000000;
        A[443] = 0.000000000000000;
        A[444] = 0.000000000000000;
        A[445] = 0.000000000000000;
        A[446] = 0.000000000000000;
        A[447] = 0.000000000000000;
        A[448] = 0.000000000000000;
        A[449] = 0.000000000000000;
        A[450] = 0.000000000000000;
        A[451] = 0.000000000000000;
        A[452] = 0.000000000000000;
        A[453] = 0.000000000000000;
        A[454] = 0.000000000000000;
        A[455] = 0.000000000000000;
        A[456] = 0.000000000000000;
        A[457] = 0.000000000000000;
        A[458] = 0.000000000000000;
        A[459] = 0.000000000000000;
        A[460] = 0.000000000000000;
        A[461] = 0.000000000000000;
        A[462] = 0.000000000000000;
        A[463] = 0.000000000000000;
        A[464] = 0.000000000000000;
        A[465] = 0.000000000000000;
        A[466] = 0.000000000000000;
        A[467] = 0.000000000000000;
        A[468] = 0.000000000000000;
        A[469] = 0.000000000000000;
        A[470] = 0.000000000000000;
        A[471] = 0.000000000000000;
        A[472] = 0.000000000000000;
        A[473] = 0.000000000000000;
        A[474] = 0.000000000000000;
        A[475] = 0.000000000000000;
        A[476] = 0.000000000000000;
        A[477] = 0.000000000000000;
        A[478] = 0.000000000000000;
        A[479] = 0.000000000000000;
        A[480] = 0.000000000000000;
        A[481] = 0.000000000000000;
        A[482] = 0.000000000000000;
        A[483] = 0.000000000000000;
        A[484] = 0.000000000000000;
        A[485] = 0.000000000000000;
        A[486] = 0.000000000000000;
        A[487] = 0.000000000000000;
        A[488] = 0.000000000000000;
        A[489] = 0.000000000000000;
        A[490] = 0.000000000000000;
        A[491] = 0.000000000000000;
        A[492] = 0.000000000000000;
        A[493] = 0.000000000000000;
        A[494] = 0.000000000000000;
        A[495] = 0.000000000000000;
        A[496] = 0.092857142857143*G0_7 - 0.007142857142857*G0_8 + 0.047619047619048*G0_9;
        A[497] = -0.007142857142857*G0_7 - 0.007142857142857*G0_8 - 0.019047619047619*G0_9;
        A[498] = 0.047619047619048*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[499] = 0.000000000000000;
        A[500] = 0.000000000000000;
        A[501] = 0.000000000000000;
        A[502] = 0.000000000000000;
        A[503] = 0.000000000000000;
        A[504] = 0.000000000000000;
        A[505] = 0.000000000000000;
        A[506] = 0.000000000000000;
        A[507] = 0.000000000000000;
        A[508] = 0.000000000000000;
        A[509] = 0.000000000000000;
        A[510] = 0.000000000000000;
        A[511] = 0.000000000000000;
        A[512] = 0.000000000000000;
        A[513] = 0.000000000000000;
        A[514] = 0.000000000000000;
        A[515] = 0.000000000000000;
        A[516] = 0.000000000000000;
        A[517] = 0.000000000000000;
        A[518] = 0.000000000000000;
        A[519] = 0.000000000000000;
        A[520] = 0.000000000000000;
        A[521] = 0.000000000000000;
        A[522] = 0.000000000000000;
        A[523] = 0.000000000000000;
        A[524] = 0.000000000000000;
        A[525] = 0.000000000000000;
        A[526] = -0.007142857142857*G0_7 - 0.007142857142857*G0_8 - 0.019047619047619*G0_9;
        A[527] = -0.007142857142857*G0_7 + 0.092857142857143*G0_8 + 0.047619047619048*G0_9;
        A[528] = -0.019047619047619*G0_7 + 0.047619047619048*G0_8 + 0.038095238095238*G0_9;
        A[529] = 0.000000000000000;
        A[530] = 0.000000000000000;
        A[531] = 0.000000000000000;
        A[532] = 0.000000000000000;
        A[533] = 0.000000000000000;
        A[534] = 0.000000000000000;
        A[535] = 0.000000000000000;
        A[536] = 0.000000000000000;
        A[537] = 0.000000000000000;
        A[538] = 0.000000000000000;
        A[539] = 0.000000000000000;
        A[540] = 0.000000000000000;
        A[541] = 0.000000000000000;
        A[542] = 0.000000000000000;
        A[543] = 0.000000000000000;
        A[544] = 0.000000000000000;
        A[545] = 0.000000000000000;
        A[546] = 0.000000000000000;
        A[547] = 0.000000000000000;
        A[548] = 0.000000000000000;
        A[549] = 0.000000000000000;
        A[550] = 0.000000000000000;
        A[551] = 0.000000000000000;
        A[552] = 0.000000000000000;
        A[553] = 0.000000000000000;
        A[554] = 0.000000000000000;
        A[555] = 0.000000000000000;
        A[556] = 0.047619047619048*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[557] = -0.019047619047619*G0_7 + 0.047619047619048*G0_8 + 0.038095238095238*G0_9;
        A[558] = 0.038095238095238*G0_7 + 0.038095238095238*G0_8 + 0.457142857142857*G0_9;
        A[559] = 0.000000000000000;
        A[560] = 0.000000000000000;
        A[561] = 0.000000000000000;
        A[562] = 0.000000000000000;
        A[563] = 0.000000000000000;
        A[564] = 0.000000000000000;
        A[565] = 0.000000000000000;
        A[566] = 0.000000000000000;
        A[567] = 0.000000000000000;
        A[568] = 0.000000000000000;
        A[569] = 0.000000000000000;
        A[570] = 0.000000000000000;
        A[571] = 0.000000000000000;
        A[572] = 0.000000000000000;
        A[573] = 0.000000000000000;
        A[574] = 0.000000000000000;
        A[575] = 0.000000000000000;
        A[576] = 0.000000000000000;
        A[577] = 0.000000000000000;
        A[578] = 0.000000000000000;
        A[579] = 0.000000000000000;
        A[580] = 0.000000000000000;
        A[581] = 0.000000000000000;
        A[582] = 0.000000000000000;
        A[583] = 0.000000000000000;
        A[584] = 0.000000000000000;
        A[585] = 0.000000000000000;
        A[586] = 0.000000000000000;
        A[587] = 0.000000000000000;
        A[588] = 0.000000000000000;
        A[589] = 0.000000000000000;
        A[590] = 0.000000000000000;
        A[591] = 0.000000000000000;
        A[592] = 0.000000000000000;
        A[593] = 0.000000000000000;
        A[594] = 0.000000000000000;
        A[595] = 0.000000000000000;
        A[596] = 0.000000000000000;
        A[597] = 0.000000000000000;
        A[598] = 0.000000000000000;
        A[599] = 0.000000000000000;
        A[600] = 0.000000000000000;
        A[601] = 0.000000000000000;
        A[602] = 0.000000000000000;
        A[603] = 0.000000000000000;
        A[604] = 0.000000000000000;
        A[605] = 0.000000000000000;
        A[606] = 0.000000000000000;
        A[607] = 0.000000000000000;
        A[608] = 0.000000000000000;
        A[609] = 0.000000000000000;
        A[610] = 0.000000000000000;
        A[611] = 0.000000000000000;
        A[612] = 0.000000000000000;
        A[613] = 0.000000000000000;
        A[614] = 0.000000000000000;
        A[615] = 0.000000000000000;
        A[616] = 0.000000000000000;
        A[617] = 0.000000000000000;
        A[618] = 0.000000000000000;
        A[619] = 0.000000000000000;
        A[620] = 0.000000000000000;
        A[621] = 0.000000000000000;
        A[622] = 0.000000000000000;
        A[623] = 0.000000000000000;
        A[624] = 0.000000000000000;
        A[625] = 0.000000000000000;
        A[626] = 0.000000000000000;
        A[627] = 0.000000000000000;
        A[628] = 0.000000000000000;
        A[629] = 0.000000000000000;
        A[630] = 0.000000000000000;
        A[631] = 0.000000000000000;
        A[632] = 0.000000000000000;
        A[633] = 0.000000000000000;
        A[634] = 0.000000000000000;
        A[635] = 0.000000000000000;
        A[636] = 0.000000000000000;
        A[637] = 0.000000000000000;
        A[638] = 0.000000000000000;
        A[639] = 0.000000000000000;
        A[640] = 0.000000000000000;
        A[641] = 0.000000000000000;
        A[642] = 0.000000000000000;
        A[643] = 0.000000000000000;
        A[644] = 0.000000000000000;
        A[645] = 0.000000000000000;
        A[646] = 0.000000000000000;
        A[647] = 0.000000000000000;
        A[648] = 0.000000000000000;
        A[649] = 0.000000000000000;
        A[650] = 0.000000000000000;
        A[651] = 0.000000000000000;
        A[652] = 0.000000000000000;
        A[653] = 0.000000000000000;
        A[654] = 0.000000000000000;
        A[655] = 0.000000000000000;
        A[656] = 0.000000000000000;
        A[657] = 0.000000000000000;
        A[658] = 0.000000000000000;
        A[659] = 0.000000000000000;
        A[660] = 0.000000000000000;
        A[661] = 0.000000000000000;
        A[662] = 0.000000000000000;
        A[663] = 0.000000000000000;
        A[664] = 0.000000000000000;
        A[665] = 0.000000000000000;
        A[666] = 0.000000000000000;
        A[667] = 0.000000000000000;
        A[668] = 0.000000000000000;
        A[669] = 0.000000000000000;
        A[670] = 0.000000000000000;
        A[671] = 0.000000000000000;
        A[672] = 0.000000000000000;
        A[673] = 0.000000000000000;
        A[674] = 0.000000000000000;
        A[675] = 0.000000000000000;
        A[676] = 0.000000000000000;
        A[677] = 0.000000000000000;
        A[678] = 0.000000000000000;
        A[679] = 0.000000000000000;
        A[680] = 0.000000000000000;
        A[681] = 0.000000000000000;
        A[682] = 0.092857142857143*G0_7 - 0.007142857142857*G0_8 + 0.047619047619048*G0_9;
        A[683] = -0.007142857142857*G0_7 - 0.007142857142857*G0_8 - 0.019047619047619*G0_9;
        A[684] = 0.047619047619048*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[685] = 0.000000000000000;
        A[686] = 0.000000000000000;
        A[687] = 0.000000000000000;
        A[688] = 0.000000000000000;
        A[689] = 0.000000000000000;
        A[690] = 0.000000000000000;
        A[691] = 0.000000000000000;
        A[692] = 0.000000000000000;
        A[693] = 0.000000000000000;
        A[694] = 0.000000000000000;
        A[695] = 0.000000000000000;
        A[696] = 0.000000000000000;
        A[697] = 0.000000000000000;
        A[698] = 0.000000000000000;
        A[699] = 0.000000000000000;
        A[700] = 0.000000000000000;
        A[701] = 0.000000000000000;
        A[702] = 0.000000000000000;
        A[703] = 0.000000000000000;
        A[704] = 0.000000000000000;
        A[705] = 0.000000000000000;
        A[706] = 0.000000000000000;
        A[707] = 0.000000000000000;
        A[708] = 0.000000000000000;
        A[709] = 0.000000000000000;
        A[710] = 0.000000000000000;
        A[711] = 0.000000000000000;
        A[712] = -0.007142857142857*G0_7 - 0.007142857142857*G0_8 - 0.019047619047619*G0_9;
        A[713] = -0.007142857142857*G0_7 + 0.092857142857143*G0_8 + 0.047619047619048*G0_9;
        A[714] = -0.019047619047619*G0_7 + 0.047619047619048*G0_8 + 0.038095238095238*G0_9;
        A[715] = 0.000000000000000;
        A[716] = 0.000000000000000;
        A[717] = 0.000000000000000;
        A[718] = 0.000000000000000;
        A[719] = 0.000000000000000;
        A[720] = 0.000000000000000;
        A[721] = 0.000000000000000;
        A[722] = 0.000000000000000;
        A[723] = 0.000000000000000;
        A[724] = 0.000000000000000;
        A[725] = 0.000000000000000;
        A[726] = 0.000000000000000;
        A[727] = 0.000000000000000;
        A[728] = 0.000000000000000;
        A[729] = 0.000000000000000;
        A[730] = 0.000000000000000;
        A[731] = 0.000000000000000;
        A[732] = 0.000000000000000;
        A[733] = 0.000000000000000;
        A[734] = 0.000000000000000;
        A[735] = 0.000000000000000;
        A[736] = 0.000000000000000;
        A[737] = 0.000000000000000;
        A[738] = 0.000000000000000;
        A[739] = 0.000000000000000;
        A[740] = 0.000000000000000;
        A[741] = 0.000000000000000;
        A[742] = 0.047619047619048*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[743] = -0.019047619047619*G0_7 + 0.047619047619048*G0_8 + 0.038095238095238*G0_9;
        A[744] = 0.038095238095238*G0_7 + 0.038095238095238*G0_8 + 0.457142857142857*G0_9;
        A[745] = 0.000000000000000;
        A[746] = 0.000000000000000;
        A[747] = 0.000000000000000;
        A[748] = 0.000000000000000;
        A[749] = 0.000000000000000;
        A[750] = 0.000000000000000;
        A[751] = 0.000000000000000;
        A[752] = 0.000000000000000;
        A[753] = 0.000000000000000;
        A[754] = 0.000000000000000;
        A[755] = 0.000000000000000;
        A[756] = 0.000000000000000;
        A[757] = 0.000000000000000;
        A[758] = 0.000000000000000;
        A[759] = 0.000000000000000;
        A[760] = 0.000000000000000;
        A[761] = 0.000000000000000;
        A[762] = 0.000000000000000;
        A[763] = 0.000000000000000;
        A[764] = 0.000000000000000;
        A[765] = 0.000000000000000;
        A[766] = 0.000000000000000;
        A[767] = 0.000000000000000;
        A[768] = 0.000000000000000;
        A[769] = 0.000000000000000;
        A[770] = 0.000000000000000;
        A[771] = 0.000000000000000;
        A[772] = 0.000000000000000;
        A[773] = 0.000000000000000;
        A[774] = 0.000000000000000;
        A[775] = 0.000000000000000;
        A[776] = 0.000000000000000;
        A[777] = 0.000000000000000;
        A[778] = 0.000000000000000;
        A[779] = 0.000000000000000;
        A[780] = 0.000000000000000;
        A[781] = 0.000000000000000;
        A[782] = 0.000000000000000;
        A[783] = 0.000000000000000;
        A[784] = 0.000000000000000;
        A[785] = 0.000000000000000;
        A[786] = 0.000000000000000;
        A[787] = 0.000000000000000;
        A[788] = 0.000000000000000;
        A[789] = 0.000000000000000;
        A[790] = 0.000000000000000;
        A[791] = 0.000000000000000;
        A[792] = 0.000000000000000;
        A[793] = 0.000000000000000;
        A[794] = 0.000000000000000;
        A[795] = 0.000000000000000;
        A[796] = 0.000000000000000;
        A[797] = 0.000000000000000;
        A[798] = 0.000000000000000;
        A[799] = 0.000000000000000;
        A[800] = 0.000000000000000;
        A[801] = 0.000000000000000;
        A[802] = 0.000000000000000;
        A[803] = 0.000000000000000;
        A[804] = 0.000000000000000;
        A[805] = 0.000000000000000;
        A[806] = 0.000000000000000;
        A[807] = 0.000000000000000;
        A[808] = 0.000000000000000;
        A[809] = 0.000000000000000;
        A[810] = 0.000000000000000;
        A[811] = 0.000000000000000;
        A[812] = 0.000000000000000;
        A[813] = 0.000000000000000;
        A[814] = 0.000000000000000;
        A[815] = 0.000000000000000;
        A[816] = 0.000000000000000;
        A[817] = 0.000000000000000;
        A[818] = 0.000000000000000;
        A[819] = 0.000000000000000;
        A[820] = 0.000000000000000;
        A[821] = 0.000000000000000;
        A[822] = 0.000000000000000;
        A[823] = 0.000000000000000;
        A[824] = 0.000000000000000;
        A[825] = 0.000000000000000;
        A[826] = 0.000000000000000;
        A[827] = 0.000000000000000;
        A[828] = 0.000000000000000;
        A[829] = 0.000000000000000;
        A[830] = 0.000000000000000;
        A[831] = 0.000000000000000;
        A[832] = 0.000000000000000;
        A[833] = 0.000000000000000;
        A[834] = 0.000000000000000;
        A[835] = 0.000000000000000;
        A[836] = 0.000000000000000;
        A[837] = 0.000000000000000;
        A[838] = 0.000000000000000;
        A[839] = 0.000000000000000;
        A[840] = 0.000000000000000;
        A[841] = 0.000000000000000;
        A[842] = 0.000000000000000;
        A[843] = 0.000000000000000;
        A[844] = 0.000000000000000;
        A[845] = 0.000000000000000;
        A[846] = 0.000000000000000;
        A[847] = 0.000000000000000;
        A[848] = 0.000000000000000;
        A[849] = 0.000000000000000;
        A[850] = 0.000000000000000;
        A[851] = 0.000000000000000;
        A[852] = 0.000000000000000;
        A[853] = 0.000000000000000;
        A[854] = 0.000000000000000;
        A[855] = 0.000000000000000;
        A[856] = 0.000000000000000;
        A[857] = 0.000000000000000;
        A[858] = 0.000000000000000;
        A[859] = 0.000000000000000;
        A[860] = 0.000000000000000;
        A[861] = 0.000000000000000;
        A[862] = 0.000000000000000;
        A[863] = 0.000000000000000;
        A[864] = 0.000000000000000;
        A[865] = 0.000000000000000;
        A[866] = 0.000000000000000;
        A[867] = 0.000000000000000;
        A[868] = 0.150000000000000*G0_7 - 0.016666666666667*G0_8 + 0.200000000000000*G0_9;
        A[869] = 0.016666666666667*G0_7 + 0.016666666666667*G0_8 + 0.133333333333333*G0_9;
        A[870] = 0.000000000000000;
        A[871] = 0.000000000000000;
        A[872] = 0.000000000000000;
        A[873] = 0.000000000000000;
        A[874] = 0.000000000000000;
        A[875] = 0.000000000000000;
        A[876] = 0.000000000000000;
        A[877] = 0.000000000000000;
        A[878] = 0.000000000000000;
        A[879] = 0.000000000000000;
        A[880] = 0.000000000000000;
        A[881] = 0.000000000000000;
        A[882] = 0.000000000000000;
        A[883] = 0.000000000000000;
        A[884] = 0.000000000000000;
        A[885] = 0.000000000000000;
        A[886] = 0.000000000000000;
        A[887] = 0.000000000000000;
        A[888] = 0.000000000000000;
        A[889] = 0.000000000000000;
        A[890] = 0.000000000000000;
        A[891] = 0.000000000000000;
        A[892] = 0.000000000000000;
        A[893] = 0.000000000000000;
        A[894] = 0.000000000000000;
        A[895] = 0.000000000000000;
        A[896] = 0.000000000000000;
        A[897] = 0.000000000000000;
        A[898] = 0.016666666666667*G0_7 + 0.016666666666667*G0_8 + 0.133333333333333*G0_9;
        A[899] = -0.016666666666667*G0_7 + 0.150000000000000*G0_8 + 0.200000000000000*G0_9;
          break;
        }
      case 1:
        {
          A[0] = 0.000000000000000;
        A[1] = 0.000000000000000;
        A[2] = 0.000000000000000;
        A[3] = 0.000000000000000;
        A[4] = 0.000000000000000;
        A[5] = 0.000000000000000;
        A[6] = 0.000000000000000;
        A[7] = 0.000000000000000;
        A[8] = 0.000000000000000;
        A[9] = 0.000000000000000;
        A[10] = 0.000000000000000;
        A[11] = 0.000000000000000;
        A[12] = 0.000000000000000;
        A[13] = 0.000000000000000;
        A[14] = 0.000000000000000;
        A[15] = 0.000000000000000;
        A[16] = 0.000000000000000;
        A[17] = 0.000000000000000;
        A[18] = 0.000000000000000;
        A[19] = 0.000000000000000;
        A[20] = 0.000000000000000;
        A[21] = 0.000000000000000;
        A[22] = 0.000000000000000;
        A[23] = 0.000000000000000;
        A[24] = 0.000000000000000;
        A[25] = 0.000000000000000;
        A[26] = 0.000000000000000;
        A[27] = 0.000000000000000;
        A[28] = 0.000000000000000;
        A[29] = 0.000000000000000;
        A[30] = 0.000000000000000;
        A[31] = 0.092857142857143*G1_1 - 0.007142857142857*G1_2 + 0.047619047619048*G1_3;
        A[32] = -0.007142857142857*G1_1 - 0.007142857142857*G1_2 - 0.019047619047619*G1_3;
        A[33] = 0.047619047619048*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[34] = 0.000000000000000;
        A[35] = 0.000000000000000;
        A[36] = 0.000000000000000;
        A[37] = 0.000000000000000;
        A[38] = 0.000000000000000;
        A[39] = 0.000000000000000;
        A[40] = 0.000000000000000;
        A[41] = 0.000000000000000;
        A[42] = 0.000000000000000;
        A[43] = 0.000000000000000;
        A[44] = 0.000000000000000;
        A[45] = 0.000000000000000;
        A[46] = 0.000000000000000;
        A[47] = 0.000000000000000;
        A[48] = 0.000000000000000;
        A[49] = 0.000000000000000;
        A[50] = 0.000000000000000;
        A[51] = 0.000000000000000;
        A[52] = 0.000000000000000;
        A[53] = 0.000000000000000;
        A[54] = 0.000000000000000;
        A[55] = 0.000000000000000;
        A[56] = 0.000000000000000;
        A[57] = 0.000000000000000;
        A[58] = 0.000000000000000;
        A[59] = 0.000000000000000;
        A[60] = 0.000000000000000;
        A[61] = -0.007142857142857*G1_1 - 0.007142857142857*G1_2 - 0.019047619047619*G1_3;
        A[62] = -0.007142857142857*G1_1 + 0.092857142857143*G1_2 + 0.047619047619048*G1_3;
        A[63] = -0.019047619047619*G1_1 + 0.047619047619048*G1_2 + 0.038095238095238*G1_3;
        A[64] = 0.000000000000000;
        A[65] = 0.000000000000000;
        A[66] = 0.000000000000000;
        A[67] = 0.000000000000000;
        A[68] = 0.000000000000000;
        A[69] = 0.000000000000000;
        A[70] = 0.000000000000000;
        A[71] = 0.000000000000000;
        A[72] = 0.000000000000000;
        A[73] = 0.000000000000000;
        A[74] = 0.000000000000000;
        A[75] = 0.000000000000000;
        A[76] = 0.000000000000000;
        A[77] = 0.000000000000000;
        A[78] = 0.000000000000000;
        A[79] = 0.000000000000000;
        A[80] = 0.000000000000000;
        A[81] = 0.000000000000000;
        A[82] = 0.000000000000000;
        A[83] = 0.000000000000000;
        A[84] = 0.000000000000000;
        A[85] = 0.000000000000000;
        A[86] = 0.000000000000000;
        A[87] = 0.000000000000000;
        A[88] = 0.000000000000000;
        A[89] = 0.000000000000000;
        A[90] = 0.000000000000000;
        A[91] = 0.047619047619048*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[92] = -0.019047619047619*G1_1 + 0.047619047619048*G1_2 + 0.038095238095238*G1_3;
        A[93] = 0.038095238095238*G1_1 + 0.038095238095238*G1_2 + 0.457142857142857*G1_3;
        A[94] = 0.000000000000000;
        A[95] = 0.000000000000000;
        A[96] = 0.000000000000000;
        A[97] = 0.000000000000000;
        A[98] = 0.000000000000000;
        A[99] = 0.000000000000000;
        A[100] = 0.000000000000000;
        A[101] = 0.000000000000000;
        A[102] = 0.000000000000000;
        A[103] = 0.000000000000000;
        A[104] = 0.000000000000000;
        A[105] = 0.000000000000000;
        A[106] = 0.000000000000000;
        A[107] = 0.000000000000000;
        A[108] = 0.000000000000000;
        A[109] = 0.000000000000000;
        A[110] = 0.000000000000000;
        A[111] = 0.000000000000000;
        A[112] = 0.000000000000000;
        A[113] = 0.000000000000000;
        A[114] = 0.000000000000000;
        A[115] = 0.000000000000000;
        A[116] = 0.000000000000000;
        A[117] = 0.000000000000000;
        A[118] = 0.000000000000000;
        A[119] = 0.000000000000000;
        A[120] = 0.000000000000000;
        A[121] = 0.000000000000000;
        A[122] = 0.000000000000000;
        A[123] = 0.000000000000000;
        A[124] = 0.000000000000000;
        A[125] = 0.000000000000000;
        A[126] = 0.000000000000000;
        A[127] = 0.000000000000000;
        A[128] = 0.000000000000000;
        A[129] = 0.000000000000000;
        A[130] = 0.000000000000000;
        A[131] = 0.000000000000000;
        A[132] = 0.000000000000000;
        A[133] = 0.000000000000000;
        A[134] = 0.000000000000000;
        A[135] = 0.000000000000000;
        A[136] = 0.000000000000000;
        A[137] = 0.000000000000000;
        A[138] = 0.000000000000000;
        A[139] = 0.000000000000000;
        A[140] = 0.000000000000000;
        A[141] = 0.000000000000000;
        A[142] = 0.000000000000000;
        A[143] = 0.000000000000000;
        A[144] = 0.000000000000000;
        A[145] = 0.000000000000000;
        A[146] = 0.000000000000000;
        A[147] = 0.000000000000000;
        A[148] = 0.000000000000000;
        A[149] = 0.000000000000000;
        A[150] = 0.000000000000000;
        A[151] = 0.000000000000000;
        A[152] = 0.000000000000000;
        A[153] = 0.000000000000000;
        A[154] = 0.000000000000000;
        A[155] = 0.000000000000000;
        A[156] = 0.000000000000000;
        A[157] = 0.000000000000000;
        A[158] = 0.000000000000000;
        A[159] = 0.000000000000000;
        A[160] = 0.000000000000000;
        A[161] = 0.000000000000000;
        A[162] = 0.000000000000000;
        A[163] = 0.000000000000000;
        A[164] = 0.000000000000000;
        A[165] = 0.000000000000000;
        A[166] = 0.000000000000000;
        A[167] = 0.000000000000000;
        A[168] = 0.000000000000000;
        A[169] = 0.000000000000000;
        A[170] = 0.000000000000000;
        A[171] = 0.000000000000000;
        A[172] = 0.000000000000000;
        A[173] = 0.000000000000000;
        A[174] = 0.000000000000000;
        A[175] = 0.000000000000000;
        A[176] = 0.000000000000000;
        A[177] = 0.000000000000000;
        A[178] = 0.000000000000000;
        A[179] = 0.000000000000000;
        A[180] = 0.000000000000000;
        A[181] = 0.000000000000000;
        A[182] = 0.000000000000000;
        A[183] = 0.000000000000000;
        A[184] = 0.000000000000000;
        A[185] = 0.000000000000000;
        A[186] = 0.000000000000000;
        A[187] = 0.000000000000000;
        A[188] = 0.000000000000000;
        A[189] = 0.000000000000000;
        A[190] = 0.000000000000000;
        A[191] = 0.000000000000000;
        A[192] = 0.000000000000000;
        A[193] = 0.000000000000000;
        A[194] = 0.000000000000000;
        A[195] = 0.000000000000000;
        A[196] = 0.000000000000000;
        A[197] = 0.000000000000000;
        A[198] = 0.000000000000000;
        A[199] = 0.000000000000000;
        A[200] = 0.000000000000000;
        A[201] = 0.000000000000000;
        A[202] = 0.000000000000000;
        A[203] = 0.000000000000000;
        A[204] = 0.000000000000000;
        A[205] = 0.000000000000000;
        A[206] = 0.000000000000000;
        A[207] = 0.000000000000000;
        A[208] = 0.000000000000000;
        A[209] = 0.000000000000000;
        A[210] = 0.000000000000000;
        A[211] = 0.000000000000000;
        A[212] = 0.000000000000000;
        A[213] = 0.000000000000000;
        A[214] = 0.000000000000000;
        A[215] = 0.000000000000000;
        A[216] = 0.000000000000000;
        A[217] = 0.092857142857143*G1_1 - 0.007142857142857*G1_2 + 0.047619047619048*G1_3;
        A[218] = -0.007142857142857*G1_1 - 0.007142857142857*G1_2 - 0.019047619047619*G1_3;
        A[219] = 0.047619047619048*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[220] = 0.000000000000000;
        A[221] = 0.000000000000000;
        A[222] = 0.000000000000000;
        A[223] = 0.000000000000000;
        A[224] = 0.000000000000000;
        A[225] = 0.000000000000000;
        A[226] = 0.000000000000000;
        A[227] = 0.000000000000000;
        A[228] = 0.000000000000000;
        A[229] = 0.000000000000000;
        A[230] = 0.000000000000000;
        A[231] = 0.000000000000000;
        A[232] = 0.000000000000000;
        A[233] = 0.000000000000000;
        A[234] = 0.000000000000000;
        A[235] = 0.000000000000000;
        A[236] = 0.000000000000000;
        A[237] = 0.000000000000000;
        A[238] = 0.000000000000000;
        A[239] = 0.000000000000000;
        A[240] = 0.000000000000000;
        A[241] = 0.000000000000000;
        A[242] = 0.000000000000000;
        A[243] = 0.000000000000000;
        A[244] = 0.000000000000000;
        A[245] = 0.000000000000000;
        A[246] = 0.000000000000000;
        A[247] = -0.007142857142857*G1_1 - 0.007142857142857*G1_2 - 0.019047619047619*G1_3;
        A[248] = -0.007142857142857*G1_1 + 0.092857142857143*G1_2 + 0.047619047619048*G1_3;
        A[249] = -0.019047619047619*G1_1 + 0.047619047619048*G1_2 + 0.038095238095238*G1_3;
        A[250] = 0.000000000000000;
        A[251] = 0.000000000000000;
        A[252] = 0.000000000000000;
        A[253] = 0.000000000000000;
        A[254] = 0.000000000000000;
        A[255] = 0.000000000000000;
        A[256] = 0.000000000000000;
        A[257] = 0.000000000000000;
        A[258] = 0.000000000000000;
        A[259] = 0.000000000000000;
        A[260] = 0.000000000000000;
        A[261] = 0.000000000000000;
        A[262] = 0.000000000000000;
        A[263] = 0.000000000000000;
        A[264] = 0.000000000000000;
        A[265] = 0.000000000000000;
        A[266] = 0.000000000000000;
        A[267] = 0.000000000000000;
        A[268] = 0.000000000000000;
        A[269] = 0.000000000000000;
        A[270] = 0.000000000000000;
        A[271] = 0.000000000000000;
        A[272] = 0.000000000000000;
        A[273] = 0.000000000000000;
        A[274] = 0.000000000000000;
        A[275] = 0.000000000000000;
        A[276] = 0.000000000000000;
        A[277] = 0.047619047619048*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[278] = -0.019047619047619*G1_1 + 0.047619047619048*G1_2 + 0.038095238095238*G1_3;
        A[279] = 0.038095238095238*G1_1 + 0.038095238095238*G1_2 + 0.457142857142857*G1_3;
        A[280] = 0.000000000000000;
        A[281] = 0.000000000000000;
        A[282] = 0.000000000000000;
        A[283] = 0.000000000000000;
        A[284] = 0.000000000000000;
        A[285] = 0.000000000000000;
        A[286] = 0.000000000000000;
        A[287] = 0.000000000000000;
        A[288] = 0.000000000000000;
        A[289] = 0.000000000000000;
        A[290] = 0.000000000000000;
        A[291] = 0.000000000000000;
        A[292] = 0.000000000000000;
        A[293] = 0.000000000000000;
        A[294] = 0.000000000000000;
        A[295] = 0.000000000000000;
        A[296] = 0.000000000000000;
        A[297] = 0.000000000000000;
        A[298] = 0.000000000000000;
        A[299] = 0.000000000000000;
        A[300] = 0.000000000000000;
        A[301] = 0.000000000000000;
        A[302] = 0.000000000000000;
        A[303] = 0.000000000000000;
        A[304] = 0.000000000000000;
        A[305] = 0.000000000000000;
        A[306] = 0.000000000000000;
        A[307] = 0.000000000000000;
        A[308] = 0.000000000000000;
        A[309] = 0.000000000000000;
        A[310] = 0.000000000000000;
        A[311] = 0.000000000000000;
        A[312] = 0.000000000000000;
        A[313] = 0.000000000000000;
        A[314] = 0.000000000000000;
        A[315] = 0.000000000000000;
        A[316] = 0.000000000000000;
        A[317] = 0.000000000000000;
        A[318] = 0.000000000000000;
        A[319] = 0.000000000000000;
        A[320] = 0.000000000000000;
        A[321] = 0.000000000000000;
        A[322] = 0.000000000000000;
        A[323] = 0.000000000000000;
        A[324] = 0.000000000000000;
        A[325] = 0.000000000000000;
        A[326] = 0.000000000000000;
        A[327] = 0.000000000000000;
        A[328] = 0.000000000000000;
        A[329] = 0.000000000000000;
        A[330] = 0.000000000000000;
        A[331] = 0.000000000000000;
        A[332] = 0.000000000000000;
        A[333] = 0.000000000000000;
        A[334] = 0.000000000000000;
        A[335] = 0.000000000000000;
        A[336] = 0.000000000000000;
        A[337] = 0.000000000000000;
        A[338] = 0.000000000000000;
        A[339] = 0.000000000000000;
        A[340] = 0.000000000000000;
        A[341] = 0.000000000000000;
        A[342] = 0.000000000000000;
        A[343] = 0.000000000000000;
        A[344] = 0.000000000000000;
        A[345] = 0.000000000000000;
        A[346] = 0.000000000000000;
        A[347] = 0.000000000000000;
        A[348] = 0.000000000000000;
        A[349] = 0.000000000000000;
        A[350] = 0.000000000000000;
        A[351] = 0.000000000000000;
        A[352] = 0.000000000000000;
        A[353] = 0.000000000000000;
        A[354] = 0.000000000000000;
        A[355] = 0.000000000000000;
        A[356] = 0.000000000000000;
        A[357] = 0.000000000000000;
        A[358] = 0.000000000000000;
        A[359] = 0.000000000000000;
        A[360] = 0.000000000000000;
        A[361] = 0.000000000000000;
        A[362] = 0.000000000000000;
        A[363] = 0.000000000000000;
        A[364] = 0.000000000000000;
        A[365] = 0.000000000000000;
        A[366] = 0.000000000000000;
        A[367] = 0.000000000000000;
        A[368] = 0.000000000000000;
        A[369] = 0.000000000000000;
        A[370] = 0.000000000000000;
        A[371] = 0.000000000000000;
        A[372] = 0.000000000000000;
        A[373] = 0.000000000000000;
        A[374] = 0.000000000000000;
        A[375] = 0.000000000000000;
        A[376] = 0.000000000000000;
        A[377] = 0.000000000000000;
        A[378] = 0.000000000000000;
        A[379] = 0.000000000000000;
        A[380] = 0.000000000000000;
        A[381] = 0.000000000000000;
        A[382] = 0.000000000000000;
        A[383] = 0.000000000000000;
        A[384] = 0.000000000000000;
        A[385] = 0.000000000000000;
        A[386] = 0.000000000000000;
        A[387] = 0.000000000000000;
        A[388] = 0.000000000000000;
        A[389] = 0.000000000000000;
        A[390] = 0.000000000000000;
        A[391] = 0.000000000000000;
        A[392] = 0.000000000000000;
        A[393] = 0.000000000000000;
        A[394] = 0.000000000000000;
        A[395] = 0.000000000000000;
        A[396] = 0.000000000000000;
        A[397] = 0.000000000000000;
        A[398] = 0.000000000000000;
        A[399] = 0.000000000000000;
        A[400] = 0.000000000000000;
        A[401] = 0.000000000000000;
        A[402] = 0.000000000000000;
        A[403] = 0.150000000000000*G1_1 - 0.016666666666667*G1_2 + 0.200000000000000*G1_3;
        A[404] = 0.016666666666667*G1_1 + 0.016666666666667*G1_2 + 0.133333333333333*G1_3;
        A[405] = 0.000000000000000;
        A[406] = 0.000000000000000;
        A[407] = 0.000000000000000;
        A[408] = 0.000000000000000;
        A[409] = 0.000000000000000;
        A[410] = 0.000000000000000;
        A[411] = 0.000000000000000;
        A[412] = 0.000000000000000;
        A[413] = 0.000000000000000;
        A[414] = 0.000000000000000;
        A[415] = 0.000000000000000;
        A[416] = 0.000000000000000;
        A[417] = 0.000000000000000;
        A[418] = 0.000000000000000;
        A[419] = 0.000000000000000;
        A[420] = 0.000000000000000;
        A[421] = 0.000000000000000;
        A[422] = 0.000000000000000;
        A[423] = 0.000000000000000;
        A[424] = 0.000000000000000;
        A[425] = 0.000000000000000;
        A[426] = 0.000000000000000;
        A[427] = 0.000000000000000;
        A[428] = 0.000000000000000;
        A[429] = 0.000000000000000;
        A[430] = 0.000000000000000;
        A[431] = 0.000000000000000;
        A[432] = 0.000000000000000;
        A[433] = 0.016666666666667*G1_1 + 0.016666666666667*G1_2 + 0.133333333333333*G1_3;
        A[434] = -0.016666666666667*G1_1 + 0.150000000000000*G1_2 + 0.200000000000000*G1_3;
        A[435] = 0.000000000000000;
        A[436] = 0.000000000000000;
        A[437] = 0.000000000000000;
        A[438] = 0.000000000000000;
        A[439] = 0.000000000000000;
        A[440] = 0.000000000000000;
        A[441] = 0.000000000000000;
        A[442] = 0.000000000000000;
        A[443] = 0.000000000000000;
        A[444] = 0.000000000000000;
        A[445] = 0.000000000000000;
        A[446] = 0.000000000000000;
        A[447] = 0.000000000000000;
        A[448] = 0.000000000000000;
        A[449] = 0.000000000000000;
        A[450] = 0.000000000000000;
        A[451] = 0.000000000000000;
        A[452] = 0.000000000000000;
        A[453] = 0.000000000000000;
        A[454] = 0.000000000000000;
        A[455] = 0.000000000000000;
        A[456] = 0.000000000000000;
        A[457] = 0.000000000000000;
        A[458] = 0.000000000000000;
        A[459] = 0.000000000000000;
        A[460] = 0.000000000000000;
        A[461] = 0.000000000000000;
        A[462] = 0.000000000000000;
        A[463] = 0.000000000000000;
        A[464] = 0.000000000000000;
        A[465] = 0.092857142857143*G0_6 - 0.007142857142857*G0_8 + 0.047619047619048*G0_10;
        A[466] = 0.000000000000000;
        A[467] = -0.007142857142857*G0_6 - 0.007142857142857*G0_8 - 0.019047619047619*G0_10;
        A[468] = 0.000000000000000;
        A[469] = 0.047619047619048*G0_6 - 0.019047619047619*G0_8 + 0.038095238095238*G0_10;
        A[470] = 0.000000000000000;
        A[471] = 0.000000000000000;
        A[472] = 0.000000000000000;
        A[473] = 0.000000000000000;
        A[474] = 0.000000000000000;
        A[475] = 0.000000000000000;
        A[476] = 0.000000000000000;
        A[477] = 0.000000000000000;
        A[478] = 0.000000000000000;
        A[479] = 0.000000000000000;
        A[480] = 0.000000000000000;
        A[481] = 0.000000000000000;
        A[482] = 0.000000000000000;
        A[483] = 0.000000000000000;
        A[484] = 0.000000000000000;
        A[485] = 0.000000000000000;
        A[486] = 0.000000000000000;
        A[487] = 0.000000000000000;
        A[488] = 0.000000000000000;
        A[489] = 0.000000000000000;
        A[490] = 0.000000000000000;
        A[491] = 0.000000000000000;
        A[492] = 0.000000000000000;
        A[493] = 0.000000000000000;
        A[494] = 0.000000000000000;
        A[495] = 0.000000000000000;
        A[496] = 0.000000000000000;
        A[497] = 0.000000000000000;
        A[498] = 0.000000000000000;
        A[499] = 0.000000000000000;
        A[500] = 0.000000000000000;
        A[501] = 0.000000000000000;
        A[502] = 0.000000000000000;
        A[503] = 0.000000000000000;
        A[504] = 0.000000000000000;
        A[505] = 0.000000000000000;
        A[506] = 0.000000000000000;
        A[507] = 0.000000000000000;
        A[508] = 0.000000000000000;
        A[509] = 0.000000000000000;
        A[510] = 0.000000000000000;
        A[511] = 0.000000000000000;
        A[512] = 0.000000000000000;
        A[513] = 0.000000000000000;
        A[514] = 0.000000000000000;
        A[515] = 0.000000000000000;
        A[516] = 0.000000000000000;
        A[517] = 0.000000000000000;
        A[518] = 0.000000000000000;
        A[519] = 0.000000000000000;
        A[520] = 0.000000000000000;
        A[521] = 0.000000000000000;
        A[522] = 0.000000000000000;
        A[523] = 0.000000000000000;
        A[524] = 0.000000000000000;
        A[525] = -0.007142857142857*G0_6 - 0.007142857142857*G0_8 - 0.019047619047619*G0_10;
        A[526] = 0.000000000000000;
        A[527] = -0.007142857142857*G0_6 + 0.092857142857143*G0_8 + 0.047619047619048*G0_10;
        A[528] = 0.000000000000000;
        A[529] = -0.019047619047619*G0_6 + 0.047619047619048*G0_8 + 0.038095238095238*G0_10;
        A[530] = 0.000000000000000;
        A[531] = 0.000000000000000;
        A[532] = 0.000000000000000;
        A[533] = 0.000000000000000;
        A[534] = 0.000000000000000;
        A[535] = 0.000000000000000;
        A[536] = 0.000000000000000;
        A[537] = 0.000000000000000;
        A[538] = 0.000000000000000;
        A[539] = 0.000000000000000;
        A[540] = 0.000000000000000;
        A[541] = 0.000000000000000;
        A[542] = 0.000000000000000;
        A[543] = 0.000000000000000;
        A[544] = 0.000000000000000;
        A[545] = 0.000000000000000;
        A[546] = 0.000000000000000;
        A[547] = 0.000000000000000;
        A[548] = 0.000000000000000;
        A[549] = 0.000000000000000;
        A[550] = 0.000000000000000;
        A[551] = 0.000000000000000;
        A[552] = 0.000000000000000;
        A[553] = 0.000000000000000;
        A[554] = 0.000000000000000;
        A[555] = 0.000000000000000;
        A[556] = 0.000000000000000;
        A[557] = 0.000000000000000;
        A[558] = 0.000000000000000;
        A[559] = 0.000000000000000;
        A[560] = 0.000000000000000;
        A[561] = 0.000000000000000;
        A[562] = 0.000000000000000;
        A[563] = 0.000000000000000;
        A[564] = 0.000000000000000;
        A[565] = 0.000000000000000;
        A[566] = 0.000000000000000;
        A[567] = 0.000000000000000;
        A[568] = 0.000000000000000;
        A[569] = 0.000000000000000;
        A[570] = 0.000000000000000;
        A[571] = 0.000000000000000;
        A[572] = 0.000000000000000;
        A[573] = 0.000000000000000;
        A[574] = 0.000000000000000;
        A[575] = 0.000000000000000;
        A[576] = 0.000000000000000;
        A[577] = 0.000000000000000;
        A[578] = 0.000000000000000;
        A[579] = 0.000000000000000;
        A[580] = 0.000000000000000;
        A[581] = 0.000000000000000;
        A[582] = 0.000000000000000;
        A[583] = 0.000000000000000;
        A[584] = 0.000000000000000;
        A[585] = 0.047619047619048*G0_6 - 0.019047619047619*G0_8 + 0.038095238095238*G0_10;
        A[586] = 0.000000000000000;
        A[587] = -0.019047619047619*G0_6 + 0.047619047619048*G0_8 + 0.038095238095238*G0_10;
        A[588] = 0.000000000000000;
        A[589] = 0.038095238095238*G0_6 + 0.038095238095238*G0_8 + 0.457142857142857*G0_10;
        A[590] = 0.000000000000000;
        A[591] = 0.000000000000000;
        A[592] = 0.000000000000000;
        A[593] = 0.000000000000000;
        A[594] = 0.000000000000000;
        A[595] = 0.000000000000000;
        A[596] = 0.000000000000000;
        A[597] = 0.000000000000000;
        A[598] = 0.000000000000000;
        A[599] = 0.000000000000000;
        A[600] = 0.000000000000000;
        A[601] = 0.000000000000000;
        A[602] = 0.000000000000000;
        A[603] = 0.000000000000000;
        A[604] = 0.000000000000000;
        A[605] = 0.000000000000000;
        A[606] = 0.000000000000000;
        A[607] = 0.000000000000000;
        A[608] = 0.000000000000000;
        A[609] = 0.000000000000000;
        A[610] = 0.000000000000000;
        A[611] = 0.000000000000000;
        A[612] = 0.000000000000000;
        A[613] = 0.000000000000000;
        A[614] = 0.000000000000000;
        A[615] = 0.000000000000000;
        A[616] = 0.000000000000000;
        A[617] = 0.000000000000000;
        A[618] = 0.000000000000000;
        A[619] = 0.000000000000000;
        A[620] = 0.000000000000000;
        A[621] = 0.000000000000000;
        A[622] = 0.000000000000000;
        A[623] = 0.000000000000000;
        A[624] = 0.000000000000000;
        A[625] = 0.000000000000000;
        A[626] = 0.000000000000000;
        A[627] = 0.000000000000000;
        A[628] = 0.000000000000000;
        A[629] = 0.000000000000000;
        A[630] = 0.000000000000000;
        A[631] = 0.000000000000000;
        A[632] = 0.000000000000000;
        A[633] = 0.000000000000000;
        A[634] = 0.000000000000000;
        A[635] = 0.000000000000000;
        A[636] = 0.000000000000000;
        A[637] = 0.000000000000000;
        A[638] = 0.000000000000000;
        A[639] = 0.000000000000000;
        A[640] = 0.000000000000000;
        A[641] = 0.000000000000000;
        A[642] = 0.000000000000000;
        A[643] = 0.000000000000000;
        A[644] = 0.000000000000000;
        A[645] = 0.000000000000000;
        A[646] = 0.000000000000000;
        A[647] = 0.000000000000000;
        A[648] = 0.000000000000000;
        A[649] = 0.000000000000000;
        A[650] = 0.000000000000000;
        A[651] = 0.092857142857143*G0_6 - 0.007142857142857*G0_8 + 0.047619047619048*G0_10;
        A[652] = 0.000000000000000;
        A[653] = -0.007142857142857*G0_6 - 0.007142857142857*G0_8 - 0.019047619047619*G0_10;
        A[654] = 0.000000000000000;
        A[655] = 0.047619047619048*G0_6 - 0.019047619047619*G0_8 + 0.038095238095238*G0_10;
        A[656] = 0.000000000000000;
        A[657] = 0.000000000000000;
        A[658] = 0.000000000000000;
        A[659] = 0.000000000000000;
        A[660] = 0.000000000000000;
        A[661] = 0.000000000000000;
        A[662] = 0.000000000000000;
        A[663] = 0.000000000000000;
        A[664] = 0.000000000000000;
        A[665] = 0.000000000000000;
        A[666] = 0.000000000000000;
        A[667] = 0.000000000000000;
        A[668] = 0.000000000000000;
        A[669] = 0.000000000000000;
        A[670] = 0.000000000000000;
        A[671] = 0.000000000000000;
        A[672] = 0.000000000000000;
        A[673] = 0.000000000000000;
        A[674] = 0.000000000000000;
        A[675] = 0.000000000000000;
        A[676] = 0.000000000000000;
        A[677] = 0.000000000000000;
        A[678] = 0.000000000000000;
        A[679] = 0.000000000000000;
        A[680] = 0.000000000000000;
        A[681] = 0.000000000000000;
        A[682] = 0.000000000000000;
        A[683] = 0.000000000000000;
        A[684] = 0.000000000000000;
        A[685] = 0.000000000000000;
        A[686] = 0.000000000000000;
        A[687] = 0.000000000000000;
        A[688] = 0.000000000000000;
        A[689] = 0.000000000000000;
        A[690] = 0.000000000000000;
        A[691] = 0.000000000000000;
        A[692] = 0.000000000000000;
        A[693] = 0.000000000000000;
        A[694] = 0.000000000000000;
        A[695] = 0.000000000000000;
        A[696] = 0.000000000000000;
        A[697] = 0.000000000000000;
        A[698] = 0.000000000000000;
        A[699] = 0.000000000000000;
        A[700] = 0.000000000000000;
        A[701] = 0.000000000000000;
        A[702] = 0.000000000000000;
        A[703] = 0.000000000000000;
        A[704] = 0.000000000000000;
        A[705] = 0.000000000000000;
        A[706] = 0.000000000000000;
        A[707] = 0.000000000000000;
        A[708] = 0.000000000000000;
        A[709] = 0.000000000000000;
        A[710] = 0.000000000000000;
        A[711] = -0.007142857142857*G0_6 - 0.007142857142857*G0_8 - 0.019047619047619*G0_10;
        A[712] = 0.000000000000000;
        A[713] = -0.007142857142857*G0_6 + 0.092857142857143*G0_8 + 0.047619047619048*G0_10;
        A[714] = 0.000000000000000;
        A[715] = -0.019047619047619*G0_6 + 0.047619047619048*G0_8 + 0.038095238095238*G0_10;
        A[716] = 0.000000000000000;
        A[717] = 0.000000000000000;
        A[718] = 0.000000000000000;
        A[719] = 0.000000000000000;
        A[720] = 0.000000000000000;
        A[721] = 0.000000000000000;
        A[722] = 0.000000000000000;
        A[723] = 0.000000000000000;
        A[724] = 0.000000000000000;
        A[725] = 0.000000000000000;
        A[726] = 0.000000000000000;
        A[727] = 0.000000000000000;
        A[728] = 0.000000000000000;
        A[729] = 0.000000000000000;
        A[730] = 0.000000000000000;
        A[731] = 0.000000000000000;
        A[732] = 0.000000000000000;
        A[733] = 0.000000000000000;
        A[734] = 0.000000000000000;
        A[735] = 0.000000000000000;
        A[736] = 0.000000000000000;
        A[737] = 0.000000000000000;
        A[738] = 0.000000000000000;
        A[739] = 0.000000000000000;
        A[740] = 0.000000000000000;
        A[741] = 0.000000000000000;
        A[742] = 0.000000000000000;
        A[743] = 0.000000000000000;
        A[744] = 0.000000000000000;
        A[745] = 0.000000000000000;
        A[746] = 0.000000000000000;
        A[747] = 0.000000000000000;
        A[748] = 0.000000000000000;
        A[749] = 0.000000000000000;
        A[750] = 0.000000000000000;
        A[751] = 0.000000000000000;
        A[752] = 0.000000000000000;
        A[753] = 0.000000000000000;
        A[754] = 0.000000000000000;
        A[755] = 0.000000000000000;
        A[756] = 0.000000000000000;
        A[757] = 0.000000000000000;
        A[758] = 0.000000000000000;
        A[759] = 0.000000000000000;
        A[760] = 0.000000000000000;
        A[761] = 0.000000000000000;
        A[762] = 0.000000000000000;
        A[763] = 0.000000000000000;
        A[764] = 0.000000000000000;
        A[765] = 0.000000000000000;
        A[766] = 0.000000000000000;
        A[767] = 0.000000000000000;
        A[768] = 0.000000000000000;
        A[769] = 0.000000000000000;
        A[770] = 0.000000000000000;
        A[771] = 0.047619047619048*G0_6 - 0.019047619047619*G0_8 + 0.038095238095238*G0_10;
        A[772] = 0.000000000000000;
        A[773] = -0.019047619047619*G0_6 + 0.047619047619048*G0_8 + 0.038095238095238*G0_10;
        A[774] = 0.000000000000000;
        A[775] = 0.038095238095238*G0_6 + 0.038095238095238*G0_8 + 0.457142857142857*G0_10;
        A[776] = 0.000000000000000;
        A[777] = 0.000000000000000;
        A[778] = 0.000000000000000;
        A[779] = 0.000000000000000;
        A[780] = 0.000000000000000;
        A[781] = 0.000000000000000;
        A[782] = 0.000000000000000;
        A[783] = 0.000000000000000;
        A[784] = 0.000000000000000;
        A[785] = 0.000000000000000;
        A[786] = 0.000000000000000;
        A[787] = 0.000000000000000;
        A[788] = 0.000000000000000;
        A[789] = 0.000000000000000;
        A[790] = 0.000000000000000;
        A[791] = 0.000000000000000;
        A[792] = 0.000000000000000;
        A[793] = 0.000000000000000;
        A[794] = 0.000000000000000;
        A[795] = 0.000000000000000;
        A[796] = 0.000000000000000;
        A[797] = 0.000000000000000;
        A[798] = 0.000000000000000;
        A[799] = 0.000000000000000;
        A[800] = 0.000000000000000;
        A[801] = 0.000000000000000;
        A[802] = 0.000000000000000;
        A[803] = 0.000000000000000;
        A[804] = 0.000000000000000;
        A[805] = 0.000000000000000;
        A[806] = 0.000000000000000;
        A[807] = 0.000000000000000;
        A[808] = 0.000000000000000;
        A[809] = 0.000000000000000;
        A[810] = 0.000000000000000;
        A[811] = 0.000000000000000;
        A[812] = 0.000000000000000;
        A[813] = 0.000000000000000;
        A[814] = 0.000000000000000;
        A[815] = 0.000000000000000;
        A[816] = 0.000000000000000;
        A[817] = 0.000000000000000;
        A[818] = 0.000000000000000;
        A[819] = 0.000000000000000;
        A[820] = 0.000000000000000;
        A[821] = 0.000000000000000;
        A[822] = 0.000000000000000;
        A[823] = 0.000000000000000;
        A[824] = 0.000000000000000;
        A[825] = 0.000000000000000;
        A[826] = 0.000000000000000;
        A[827] = 0.000000000000000;
        A[828] = 0.000000000000000;
        A[829] = 0.000000000000000;
        A[830] = 0.000000000000000;
        A[831] = 0.000000000000000;
        A[832] = 0.000000000000000;
        A[833] = 0.000000000000000;
        A[834] = 0.000000000000000;
        A[835] = 0.000000000000000;
        A[836] = 0.000000000000000;
        A[837] = 0.150000000000000*G0_6 - 0.016666666666667*G0_8 + 0.200000000000000*G0_10;
        A[838] = 0.000000000000000;
        A[839] = 0.016666666666667*G0_6 + 0.016666666666667*G0_8 + 0.133333333333333*G0_10;
        A[840] = 0.000000000000000;
        A[841] = 0.000000000000000;
        A[842] = 0.000000000000000;
        A[843] = 0.000000000000000;
        A[844] = 0.000000000000000;
        A[845] = 0.000000000000000;
        A[846] = 0.000000000000000;
        A[847] = 0.000000000000000;
        A[848] = 0.000000000000000;
        A[849] = 0.000000000000000;
        A[850] = 0.000000000000000;
        A[851] = 0.000000000000000;
        A[852] = 0.000000000000000;
        A[853] = 0.000000000000000;
        A[854] = 0.000000000000000;
        A[855] = 0.000000000000000;
        A[856] = 0.000000000000000;
        A[857] = 0.000000000000000;
        A[858] = 0.000000000000000;
        A[859] = 0.000000000000000;
        A[860] = 0.000000000000000;
        A[861] = 0.000000000000000;
        A[862] = 0.000000000000000;
        A[863] = 0.000000000000000;
        A[864] = 0.000000000000000;
        A[865] = 0.000000000000000;
        A[866] = 0.000000000000000;
        A[867] = 0.000000000000000;
        A[868] = 0.000000000000000;
        A[869] = 0.000000000000000;
        A[870] = 0.000000000000000;
        A[871] = 0.000000000000000;
        A[872] = 0.000000000000000;
        A[873] = 0.000000000000000;
        A[874] = 0.000000000000000;
        A[875] = 0.000000000000000;
        A[876] = 0.000000000000000;
        A[877] = 0.000000000000000;
        A[878] = 0.000000000000000;
        A[879] = 0.000000000000000;
        A[880] = 0.000000000000000;
        A[881] = 0.000000000000000;
        A[882] = 0.000000000000000;
        A[883] = 0.000000000000000;
        A[884] = 0.000000000000000;
        A[885] = 0.000000000000000;
        A[886] = 0.000000000000000;
        A[887] = 0.000000000000000;
        A[888] = 0.000000000000000;
        A[889] = 0.000000000000000;
        A[890] = 0.000000000000000;
        A[891] = 0.000000000000000;
        A[892] = 0.000000000000000;
        A[893] = 0.000000000000000;
        A[894] = 0.000000000000000;
        A[895] = 0.000000000000000;
        A[896] = 0.000000000000000;
        A[897] = 0.016666666666667*G0_6 + 0.016666666666667*G0_8 + 0.133333333333333*G0_10;
        A[898] = 0.000000000000000;
        A[899] = -0.016666666666667*G0_6 + 0.150000000000000*G0_8 + 0.200000000000000*G0_10;
          break;
        }
      case 2:
        {
          A[0] = 0.000000000000000;
        A[1] = 0.000000000000000;
        A[2] = 0.000000000000000;
        A[3] = 0.000000000000000;
        A[4] = 0.000000000000000;
        A[5] = 0.000000000000000;
        A[6] = 0.000000000000000;
        A[7] = 0.000000000000000;
        A[8] = 0.000000000000000;
        A[9] = 0.000000000000000;
        A[10] = 0.000000000000000;
        A[11] = 0.000000000000000;
        A[12] = 0.000000000000000;
        A[13] = 0.000000000000000;
        A[14] = 0.000000000000000;
        A[15] = 0.000000000000000;
        A[16] = 0.000000000000000;
        A[17] = 0.000000000000000;
        A[18] = 0.000000000000000;
        A[19] = 0.000000000000000;
        A[20] = 0.000000000000000;
        A[21] = 0.000000000000000;
        A[22] = 0.000000000000000;
        A[23] = 0.000000000000000;
        A[24] = 0.000000000000000;
        A[25] = 0.000000000000000;
        A[26] = 0.000000000000000;
        A[27] = 0.000000000000000;
        A[28] = 0.000000000000000;
        A[29] = 0.000000000000000;
        A[30] = 0.000000000000000;
        A[31] = 0.092857142857143*G1_1 - 0.007142857142857*G1_2 + 0.047619047619048*G1_3;
        A[32] = -0.007142857142857*G1_1 - 0.007142857142857*G1_2 - 0.019047619047619*G1_3;
        A[33] = 0.047619047619048*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[34] = 0.000000000000000;
        A[35] = 0.000000000000000;
        A[36] = 0.000000000000000;
        A[37] = 0.000000000000000;
        A[38] = 0.000000000000000;
        A[39] = 0.000000000000000;
        A[40] = 0.000000000000000;
        A[41] = 0.000000000000000;
        A[42] = 0.000000000000000;
        A[43] = 0.000000000000000;
        A[44] = 0.000000000000000;
        A[45] = 0.000000000000000;
        A[46] = 0.000000000000000;
        A[47] = 0.000000000000000;
        A[48] = 0.000000000000000;
        A[49] = 0.000000000000000;
        A[50] = 0.000000000000000;
        A[51] = 0.000000000000000;
        A[52] = 0.000000000000000;
        A[53] = 0.000000000000000;
        A[54] = 0.000000000000000;
        A[55] = 0.000000000000000;
        A[56] = 0.000000000000000;
        A[57] = 0.000000000000000;
        A[58] = 0.000000000000000;
        A[59] = 0.000000000000000;
        A[60] = 0.000000000000000;
        A[61] = -0.007142857142857*G1_1 - 0.007142857142857*G1_2 - 0.019047619047619*G1_3;
        A[62] = -0.007142857142857*G1_1 + 0.092857142857143*G1_2 + 0.047619047619048*G1_3;
        A[63] = -0.019047619047619*G1_1 + 0.047619047619048*G1_2 + 0.038095238095238*G1_3;
        A[64] = 0.000000000000000;
        A[65] = 0.000000000000000;
        A[66] = 0.000000000000000;
        A[67] = 0.000000000000000;
        A[68] = 0.000000000000000;
        A[69] = 0.000000000000000;
        A[70] = 0.000000000000000;
        A[71] = 0.000000000000000;
        A[72] = 0.000000000000000;
        A[73] = 0.000000000000000;
        A[74] = 0.000000000000000;
        A[75] = 0.000000000000000;
        A[76] = 0.000000000000000;
        A[77] = 0.000000000000000;
        A[78] = 0.000000000000000;
        A[79] = 0.000000000000000;
        A[80] = 0.000000000000000;
        A[81] = 0.000000000000000;
        A[82] = 0.000000000000000;
        A[83] = 0.000000000000000;
        A[84] = 0.000000000000000;
        A[85] = 0.000000000000000;
        A[86] = 0.000000000000000;
        A[87] = 0.000000000000000;
        A[88] = 0.000000000000000;
        A[89] = 0.000000000000000;
        A[90] = 0.000000000000000;
        A[91] = 0.047619047619048*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[92] = -0.019047619047619*G1_1 + 0.047619047619048*G1_2 + 0.038095238095238*G1_3;
        A[93] = 0.038095238095238*G1_1 + 0.038095238095238*G1_2 + 0.457142857142857*G1_3;
        A[94] = 0.000000000000000;
        A[95] = 0.000000000000000;
        A[96] = 0.000000000000000;
        A[97] = 0.000000000000000;
        A[98] = 0.000000000000000;
        A[99] = 0.000000000000000;
        A[100] = 0.000000000000000;
        A[101] = 0.000000000000000;
        A[102] = 0.000000000000000;
        A[103] = 0.000000000000000;
        A[104] = 0.000000000000000;
        A[105] = 0.000000000000000;
        A[106] = 0.000000000000000;
        A[107] = 0.000000000000000;
        A[108] = 0.000000000000000;
        A[109] = 0.000000000000000;
        A[110] = 0.000000000000000;
        A[111] = 0.000000000000000;
        A[112] = 0.000000000000000;
        A[113] = 0.000000000000000;
        A[114] = 0.000000000000000;
        A[115] = 0.000000000000000;
        A[116] = 0.000000000000000;
        A[117] = 0.000000000000000;
        A[118] = 0.000000000000000;
        A[119] = 0.000000000000000;
        A[120] = 0.000000000000000;
        A[121] = 0.000000000000000;
        A[122] = 0.000000000000000;
        A[123] = 0.000000000000000;
        A[124] = 0.000000000000000;
        A[125] = 0.000000000000000;
        A[126] = 0.000000000000000;
        A[127] = 0.000000000000000;
        A[128] = 0.000000000000000;
        A[129] = 0.000000000000000;
        A[130] = 0.000000000000000;
        A[131] = 0.000000000000000;
        A[132] = 0.000000000000000;
        A[133] = 0.000000000000000;
        A[134] = 0.000000000000000;
        A[135] = 0.000000000000000;
        A[136] = 0.000000000000000;
        A[137] = 0.000000000000000;
        A[138] = 0.000000000000000;
        A[139] = 0.000000000000000;
        A[140] = 0.000000000000000;
        A[141] = 0.000000000000000;
        A[142] = 0.000000000000000;
        A[143] = 0.000000000000000;
        A[144] = 0.000000000000000;
        A[145] = 0.000000000000000;
        A[146] = 0.000000000000000;
        A[147] = 0.000000000000000;
        A[148] = 0.000000000000000;
        A[149] = 0.000000000000000;
        A[150] = 0.000000000000000;
        A[151] = 0.000000000000000;
        A[152] = 0.000000000000000;
        A[153] = 0.000000000000000;
        A[154] = 0.000000000000000;
        A[155] = 0.000000000000000;
        A[156] = 0.000000000000000;
        A[157] = 0.000000000000000;
        A[158] = 0.000000000000000;
        A[159] = 0.000000000000000;
        A[160] = 0.000000000000000;
        A[161] = 0.000000000000000;
        A[162] = 0.000000000000000;
        A[163] = 0.000000000000000;
        A[164] = 0.000000000000000;
        A[165] = 0.000000000000000;
        A[166] = 0.000000000000000;
        A[167] = 0.000000000000000;
        A[168] = 0.000000000000000;
        A[169] = 0.000000000000000;
        A[170] = 0.000000000000000;
        A[171] = 0.000000000000000;
        A[172] = 0.000000000000000;
        A[173] = 0.000000000000000;
        A[174] = 0.000000000000000;
        A[175] = 0.000000000000000;
        A[176] = 0.000000000000000;
        A[177] = 0.000000000000000;
        A[178] = 0.000000000000000;
        A[179] = 0.000000000000000;
        A[180] = 0.000000000000000;
        A[181] = 0.000000000000000;
        A[182] = 0.000000000000000;
        A[183] = 0.000000000000000;
        A[184] = 0.000000000000000;
        A[185] = 0.000000000000000;
        A[186] = 0.000000000000000;
        A[187] = 0.000000000000000;
        A[188] = 0.000000000000000;
        A[189] = 0.000000000000000;
        A[190] = 0.000000000000000;
        A[191] = 0.000000000000000;
        A[192] = 0.000000000000000;
        A[193] = 0.000000000000000;
        A[194] = 0.000000000000000;
        A[195] = 0.000000000000000;
        A[196] = 0.000000000000000;
        A[197] = 0.000000000000000;
        A[198] = 0.000000000000000;
        A[199] = 0.000000000000000;
        A[200] = 0.000000000000000;
        A[201] = 0.000000000000000;
        A[202] = 0.000000000000000;
        A[203] = 0.000000000000000;
        A[204] = 0.000000000000000;
        A[205] = 0.000000000000000;
        A[206] = 0.000000000000000;
        A[207] = 0.000000000000000;
        A[208] = 0.000000000000000;
        A[209] = 0.000000000000000;
        A[210] = 0.000000000000000;
        A[211] = 0.000000000000000;
        A[212] = 0.000000000000000;
        A[213] = 0.000000000000000;
        A[214] = 0.000000000000000;
        A[215] = 0.000000000000000;
        A[216] = 0.000000000000000;
        A[217] = 0.092857142857143*G1_1 - 0.007142857142857*G1_2 + 0.047619047619048*G1_3;
        A[218] = -0.007142857142857*G1_1 - 0.007142857142857*G1_2 - 0.019047619047619*G1_3;
        A[219] = 0.047619047619048*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[220] = 0.000000000000000;
        A[221] = 0.000000000000000;
        A[222] = 0.000000000000000;
        A[223] = 0.000000000000000;
        A[224] = 0.000000000000000;
        A[225] = 0.000000000000000;
        A[226] = 0.000000000000000;
        A[227] = 0.000000000000000;
        A[228] = 0.000000000000000;
        A[229] = 0.000000000000000;
        A[230] = 0.000000000000000;
        A[231] = 0.000000000000000;
        A[232] = 0.000000000000000;
        A[233] = 0.000000000000000;
        A[234] = 0.000000000000000;
        A[235] = 0.000000000000000;
        A[236] = 0.000000000000000;
        A[237] = 0.000000000000000;
        A[238] = 0.000000000000000;
        A[239] = 0.000000000000000;
        A[240] = 0.000000000000000;
        A[241] = 0.000000000000000;
        A[242] = 0.000000000000000;
        A[243] = 0.000000000000000;
        A[244] = 0.000000000000000;
        A[245] = 0.000000000000000;
        A[246] = 0.000000000000000;
        A[247] = -0.007142857142857*G1_1 - 0.007142857142857*G1_2 - 0.019047619047619*G1_3;
        A[248] = -0.007142857142857*G1_1 + 0.092857142857143*G1_2 + 0.047619047619048*G1_3;
        A[249] = -0.019047619047619*G1_1 + 0.047619047619048*G1_2 + 0.038095238095238*G1_3;
        A[250] = 0.000000000000000;
        A[251] = 0.000000000000000;
        A[252] = 0.000000000000000;
        A[253] = 0.000000000000000;
        A[254] = 0.000000000000000;
        A[255] = 0.000000000000000;
        A[256] = 0.000000000000000;
        A[257] = 0.000000000000000;
        A[258] = 0.000000000000000;
        A[259] = 0.000000000000000;
        A[260] = 0.000000000000000;
        A[261] = 0.000000000000000;
        A[262] = 0.000000000000000;
        A[263] = 0.000000000000000;
        A[264] = 0.000000000000000;
        A[265] = 0.000000000000000;
        A[266] = 0.000000000000000;
        A[267] = 0.000000000000000;
        A[268] = 0.000000000000000;
        A[269] = 0.000000000000000;
        A[270] = 0.000000000000000;
        A[271] = 0.000000000000000;
        A[272] = 0.000000000000000;
        A[273] = 0.000000000000000;
        A[274] = 0.000000000000000;
        A[275] = 0.000000000000000;
        A[276] = 0.000000000000000;
        A[277] = 0.047619047619048*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[278] = -0.019047619047619*G1_1 + 0.047619047619048*G1_2 + 0.038095238095238*G1_3;
        A[279] = 0.038095238095238*G1_1 + 0.038095238095238*G1_2 + 0.457142857142857*G1_3;
        A[280] = 0.000000000000000;
        A[281] = 0.000000000000000;
        A[282] = 0.000000000000000;
        A[283] = 0.000000000000000;
        A[284] = 0.000000000000000;
        A[285] = 0.000000000000000;
        A[286] = 0.000000000000000;
        A[287] = 0.000000000000000;
        A[288] = 0.000000000000000;
        A[289] = 0.000000000000000;
        A[290] = 0.000000000000000;
        A[291] = 0.000000000000000;
        A[292] = 0.000000000000000;
        A[293] = 0.000000000000000;
        A[294] = 0.000000000000000;
        A[295] = 0.000000000000000;
        A[296] = 0.000000000000000;
        A[297] = 0.000000000000000;
        A[298] = 0.000000000000000;
        A[299] = 0.000000000000000;
        A[300] = 0.000000000000000;
        A[301] = 0.000000000000000;
        A[302] = 0.000000000000000;
        A[303] = 0.000000000000000;
        A[304] = 0.000000000000000;
        A[305] = 0.000000000000000;
        A[306] = 0.000000000000000;
        A[307] = 0.000000000000000;
        A[308] = 0.000000000000000;
        A[309] = 0.000000000000000;
        A[310] = 0.000000000000000;
        A[311] = 0.000000000000000;
        A[312] = 0.000000000000000;
        A[313] = 0.000000000000000;
        A[314] = 0.000000000000000;
        A[315] = 0.000000000000000;
        A[316] = 0.000000000000000;
        A[317] = 0.000000000000000;
        A[318] = 0.000000000000000;
        A[319] = 0.000000000000000;
        A[320] = 0.000000000000000;
        A[321] = 0.000000000000000;
        A[322] = 0.000000000000000;
        A[323] = 0.000000000000000;
        A[324] = 0.000000000000000;
        A[325] = 0.000000000000000;
        A[326] = 0.000000000000000;
        A[327] = 0.000000000000000;
        A[328] = 0.000000000000000;
        A[329] = 0.000000000000000;
        A[330] = 0.000000000000000;
        A[331] = 0.000000000000000;
        A[332] = 0.000000000000000;
        A[333] = 0.000000000000000;
        A[334] = 0.000000000000000;
        A[335] = 0.000000000000000;
        A[336] = 0.000000000000000;
        A[337] = 0.000000000000000;
        A[338] = 0.000000000000000;
        A[339] = 0.000000000000000;
        A[340] = 0.000000000000000;
        A[341] = 0.000000000000000;
        A[342] = 0.000000000000000;
        A[343] = 0.000000000000000;
        A[344] = 0.000000000000000;
        A[345] = 0.000000000000000;
        A[346] = 0.000000000000000;
        A[347] = 0.000000000000000;
        A[348] = 0.000000000000000;
        A[349] = 0.000000000000000;
        A[350] = 0.000000000000000;
        A[351] = 0.000000000000000;
        A[352] = 0.000000000000000;
        A[353] = 0.000000000000000;
        A[354] = 0.000000000000000;
        A[355] = 0.000000000000000;
        A[356] = 0.000000000000000;
        A[357] = 0.000000000000000;
        A[358] = 0.000000000000000;
        A[359] = 0.000000000000000;
        A[360] = 0.000000000000000;
        A[361] = 0.000000000000000;
        A[362] = 0.000000000000000;
        A[363] = 0.000000000000000;
        A[364] = 0.000000000000000;
        A[365] = 0.000000000000000;
        A[366] = 0.000000000000000;
        A[367] = 0.000000000000000;
        A[368] = 0.000000000000000;
        A[369] = 0.000000000000000;
        A[370] = 0.000000000000000;
        A[371] = 0.000000000000000;
        A[372] = 0.000000000000000;
        A[373] = 0.000000000000000;
        A[374] = 0.000000000000000;
        A[375] = 0.000000000000000;
        A[376] = 0.000000000000000;
        A[377] = 0.000000000000000;
        A[378] = 0.000000000000000;
        A[379] = 0.000000000000000;
        A[380] = 0.000000000000000;
        A[381] = 0.000000000000000;
        A[382] = 0.000000000000000;
        A[383] = 0.000000000000000;
        A[384] = 0.000000000000000;
        A[385] = 0.000000000000000;
        A[386] = 0.000000000000000;
        A[387] = 0.000000000000000;
        A[388] = 0.000000000000000;
        A[389] = 0.000000000000000;
        A[390] = 0.000000000000000;
        A[391] = 0.000000000000000;
        A[392] = 0.000000000000000;
        A[393] = 0.000000000000000;
        A[394] = 0.000000000000000;
        A[395] = 0.000000000000000;
        A[396] = 0.000000000000000;
        A[397] = 0.000000000000000;
        A[398] = 0.000000000000000;
        A[399] = 0.000000000000000;
        A[400] = 0.000000000000000;
        A[401] = 0.000000000000000;
        A[402] = 0.000000000000000;
        A[403] = 0.150000000000000*G1_1 - 0.016666666666667*G1_2 + 0.200000000000000*G1_3;
        A[404] = 0.016666666666667*G1_1 + 0.016666666666667*G1_2 + 0.133333333333333*G1_3;
        A[405] = 0.000000000000000;
        A[406] = 0.000000000000000;
        A[407] = 0.000000000000000;
        A[408] = 0.000000000000000;
        A[409] = 0.000000000000000;
        A[410] = 0.000000000000000;
        A[411] = 0.000000000000000;
        A[412] = 0.000000000000000;
        A[413] = 0.000000000000000;
        A[414] = 0.000000000000000;
        A[415] = 0.000000000000000;
        A[416] = 0.000000000000000;
        A[417] = 0.000000000000000;
        A[418] = 0.000000000000000;
        A[419] = 0.000000000000000;
        A[420] = 0.000000000000000;
        A[421] = 0.000000000000000;
        A[422] = 0.000000000000000;
        A[423] = 0.000000000000000;
        A[424] = 0.000000000000000;
        A[425] = 0.000000000000000;
        A[426] = 0.000000000000000;
        A[427] = 0.000000000000000;
        A[428] = 0.000000000000000;
        A[429] = 0.000000000000000;
        A[430] = 0.000000000000000;
        A[431] = 0.000000000000000;
        A[432] = 0.000000000000000;
        A[433] = 0.016666666666667*G1_1 + 0.016666666666667*G1_2 + 0.133333333333333*G1_3;
        A[434] = -0.016666666666667*G1_1 + 0.150000000000000*G1_2 + 0.200000000000000*G1_3;
        A[435] = 0.000000000000000;
        A[436] = 0.000000000000000;
        A[437] = 0.000000000000000;
        A[438] = 0.000000000000000;
        A[439] = 0.000000000000000;
        A[440] = 0.000000000000000;
        A[441] = 0.000000000000000;
        A[442] = 0.000000000000000;
        A[443] = 0.000000000000000;
        A[444] = 0.000000000000000;
        A[445] = 0.000000000000000;
        A[446] = 0.000000000000000;
        A[447] = 0.000000000000000;
        A[448] = 0.000000000000000;
        A[449] = 0.000000000000000;
        A[450] = 0.000000000000000;
        A[451] = 0.000000000000000;
        A[452] = 0.000000000000000;
        A[453] = 0.000000000000000;
        A[454] = 0.000000000000000;
        A[455] = 0.000000000000000;
        A[456] = 0.000000000000000;
        A[457] = 0.000000000000000;
        A[458] = 0.000000000000000;
        A[459] = 0.000000000000000;
        A[460] = 0.000000000000000;
        A[461] = 0.000000000000000;
        A[462] = 0.000000000000000;
        A[463] = 0.000000000000000;
        A[464] = 0.000000000000000;
        A[465] = 0.092857142857143*G0_6 - 0.007142857142857*G0_7 + 0.047619047619048*G0_11;
        A[466] = -0.007142857142857*G0_6 - 0.007142857142857*G0_7 - 0.019047619047619*G0_11;
        A[467] = 0.000000000000000;
        A[468] = 0.000000000000000;
        A[469] = 0.000000000000000;
        A[470] = 0.047619047619048*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[471] = 0.000000000000000;
        A[472] = 0.000000000000000;
        A[473] = 0.000000000000000;
        A[474] = 0.000000000000000;
        A[475] = 0.000000000000000;
        A[476] = 0.000000000000000;
        A[477] = 0.000000000000000;
        A[478] = 0.000000000000000;
        A[479] = 0.000000000000000;
        A[480] = 0.000000000000000;
        A[481] = 0.000000000000000;
        A[482] = 0.000000000000000;
        A[483] = 0.000000000000000;
        A[484] = 0.000000000000000;
        A[485] = 0.000000000000000;
        A[486] = 0.000000000000000;
        A[487] = 0.000000000000000;
        A[488] = 0.000000000000000;
        A[489] = 0.000000000000000;
        A[490] = 0.000000000000000;
        A[491] = 0.000000000000000;
        A[492] = 0.000000000000000;
        A[493] = 0.000000000000000;
        A[494] = 0.000000000000000;
        A[495] = -0.007142857142857*G0_6 - 0.007142857142857*G0_7 - 0.019047619047619*G0_11;
        A[496] = -0.007142857142857*G0_6 + 0.092857142857143*G0_7 + 0.047619047619048*G0_11;
        A[497] = 0.000000000000000;
        A[498] = 0.000000000000000;
        A[499] = 0.000000000000000;
        A[500] = -0.019047619047619*G0_6 + 0.047619047619048*G0_7 + 0.038095238095238*G0_11;
        A[501] = 0.000000000000000;
        A[502] = 0.000000000000000;
        A[503] = 0.000000000000000;
        A[504] = 0.000000000000000;
        A[505] = 0.000000000000000;
        A[506] = 0.000000000000000;
        A[507] = 0.000000000000000;
        A[508] = 0.000000000000000;
        A[509] = 0.000000000000000;
        A[510] = 0.000000000000000;
        A[511] = 0.000000000000000;
        A[512] = 0.000000000000000;
        A[513] = 0.000000000000000;
        A[514] = 0.000000000000000;
        A[515] = 0.000000000000000;
        A[516] = 0.000000000000000;
        A[517] = 0.000000000000000;
        A[518] = 0.000000000000000;
        A[519] = 0.000000000000000;
        A[520] = 0.000000000000000;
        A[521] = 0.000000000000000;
        A[522] = 0.000000000000000;
        A[523] = 0.000000000000000;
        A[524] = 0.000000000000000;
        A[525] = 0.000000000000000;
        A[526] = 0.000000000000000;
        A[527] = 0.000000000000000;
        A[528] = 0.000000000000000;
        A[529] = 0.000000000000000;
        A[530] = 0.000000000000000;
        A[531] = 0.000000000000000;
        A[532] = 0.000000000000000;
        A[533] = 0.000000000000000;
        A[534] = 0.000000000000000;
        A[535] = 0.000000000000000;
        A[536] = 0.000000000000000;
        A[537] = 0.000000000000000;
        A[538] = 0.000000000000000;
        A[539] = 0.000000000000000;
        A[540] = 0.000000000000000;
        A[541] = 0.000000000000000;
        A[542] = 0.000000000000000;
        A[543] = 0.000000000000000;
        A[544] = 0.000000000000000;
        A[545] = 0.000000000000000;
        A[546] = 0.000000000000000;
        A[547] = 0.000000000000000;
        A[548] = 0.000000000000000;
        A[549] = 0.000000000000000;
        A[550] = 0.000000000000000;
        A[551] = 0.000000000000000;
        A[552] = 0.000000000000000;
        A[553] = 0.000000000000000;
        A[554] = 0.000000000000000;
        A[555] = 0.000000000000000;
        A[556] = 0.000000000000000;
        A[557] = 0.000000000000000;
        A[558] = 0.000000000000000;
        A[559] = 0.000000000000000;
        A[560] = 0.000000000000000;
        A[561] = 0.000000000000000;
        A[562] = 0.000000000000000;
        A[563] = 0.000000000000000;
        A[564] = 0.000000000000000;
        A[565] = 0.000000000000000;
        A[566] = 0.000000000000000;
        A[567] = 0.000000000000000;
        A[568] = 0.000000000000000;
        A[569] = 0.000000000000000;
        A[570] = 0.000000000000000;
        A[571] = 0.000000000000000;
        A[572] = 0.000000000000000;
        A[573] = 0.000000000000000;
        A[574] = 0.000000000000000;
        A[575] = 0.000000000000000;
        A[576] = 0.000000000000000;
        A[577] = 0.000000000000000;
        A[578] = 0.000000000000000;
        A[579] = 0.000000000000000;
        A[580] = 0.000000000000000;
        A[581] = 0.000000000000000;
        A[582] = 0.000000000000000;
        A[583] = 0.000000000000000;
        A[584] = 0.000000000000000;
        A[585] = 0.000000000000000;
        A[586] = 0.000000000000000;
        A[587] = 0.000000000000000;
        A[588] = 0.000000000000000;
        A[589] = 0.000000000000000;
        A[590] = 0.000000000000000;
        A[591] = 0.000000000000000;
        A[592] = 0.000000000000000;
        A[593] = 0.000000000000000;
        A[594] = 0.000000000000000;
        A[595] = 0.000000000000000;
        A[596] = 0.000000000000000;
        A[597] = 0.000000000000000;
        A[598] = 0.000000000000000;
        A[599] = 0.000000000000000;
        A[600] = 0.000000000000000;
        A[601] = 0.000000000000000;
        A[602] = 0.000000000000000;
        A[603] = 0.000000000000000;
        A[604] = 0.000000000000000;
        A[605] = 0.000000000000000;
        A[606] = 0.000000000000000;
        A[607] = 0.000000000000000;
        A[608] = 0.000000000000000;
        A[609] = 0.000000000000000;
        A[610] = 0.000000000000000;
        A[611] = 0.000000000000000;
        A[612] = 0.000000000000000;
        A[613] = 0.000000000000000;
        A[614] = 0.000000000000000;
        A[615] = 0.047619047619048*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[616] = -0.019047619047619*G0_6 + 0.047619047619048*G0_7 + 0.038095238095238*G0_11;
        A[617] = 0.000000000000000;
        A[618] = 0.000000000000000;
        A[619] = 0.000000000000000;
        A[620] = 0.038095238095238*G0_6 + 0.038095238095238*G0_7 + 0.457142857142857*G0_11;
        A[621] = 0.000000000000000;
        A[622] = 0.000000000000000;
        A[623] = 0.000000000000000;
        A[624] = 0.000000000000000;
        A[625] = 0.000000000000000;
        A[626] = 0.000000000000000;
        A[627] = 0.000000000000000;
        A[628] = 0.000000000000000;
        A[629] = 0.000000000000000;
        A[630] = 0.000000000000000;
        A[631] = 0.000000000000000;
        A[632] = 0.000000000000000;
        A[633] = 0.000000000000000;
        A[634] = 0.000000000000000;
        A[635] = 0.000000000000000;
        A[636] = 0.000000000000000;
        A[637] = 0.000000000000000;
        A[638] = 0.000000000000000;
        A[639] = 0.000000000000000;
        A[640] = 0.000000000000000;
        A[641] = 0.000000000000000;
        A[642] = 0.000000000000000;
        A[643] = 0.000000000000000;
        A[644] = 0.000000000000000;
        A[645] = 0.000000000000000;
        A[646] = 0.000000000000000;
        A[647] = 0.000000000000000;
        A[648] = 0.000000000000000;
        A[649] = 0.000000000000000;
        A[650] = 0.000000000000000;
        A[651] = 0.092857142857143*G0_6 - 0.007142857142857*G0_7 + 0.047619047619048*G0_11;
        A[652] = -0.007142857142857*G0_6 - 0.007142857142857*G0_7 - 0.019047619047619*G0_11;
        A[653] = 0.000000000000000;
        A[654] = 0.000000000000000;
        A[655] = 0.000000000000000;
        A[656] = 0.047619047619048*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[657] = 0.000000000000000;
        A[658] = 0.000000000000000;
        A[659] = 0.000000000000000;
        A[660] = 0.000000000000000;
        A[661] = 0.000000000000000;
        A[662] = 0.000000000000000;
        A[663] = 0.000000000000000;
        A[664] = 0.000000000000000;
        A[665] = 0.000000000000000;
        A[666] = 0.000000000000000;
        A[667] = 0.000000000000000;
        A[668] = 0.000000000000000;
        A[669] = 0.000000000000000;
        A[670] = 0.000000000000000;
        A[671] = 0.000000000000000;
        A[672] = 0.000000000000000;
        A[673] = 0.000000000000000;
        A[674] = 0.000000000000000;
        A[675] = 0.000000000000000;
        A[676] = 0.000000000000000;
        A[677] = 0.000000000000000;
        A[678] = 0.000000000000000;
        A[679] = 0.000000000000000;
        A[680] = 0.000000000000000;
        A[681] = -0.007142857142857*G0_6 - 0.007142857142857*G0_7 - 0.019047619047619*G0_11;
        A[682] = -0.007142857142857*G0_6 + 0.092857142857143*G0_7 + 0.047619047619048*G0_11;
        A[683] = 0.000000000000000;
        A[684] = 0.000000000000000;
        A[685] = 0.000000000000000;
        A[686] = -0.019047619047619*G0_6 + 0.047619047619048*G0_7 + 0.038095238095238*G0_11;
        A[687] = 0.000000000000000;
        A[688] = 0.000000000000000;
        A[689] = 0.000000000000000;
        A[690] = 0.000000000000000;
        A[691] = 0.000000000000000;
        A[692] = 0.000000000000000;
        A[693] = 0.000000000000000;
        A[694] = 0.000000000000000;
        A[695] = 0.000000000000000;
        A[696] = 0.000000000000000;
        A[697] = 0.000000000000000;
        A[698] = 0.000000000000000;
        A[699] = 0.000000000000000;
        A[700] = 0.000000000000000;
        A[701] = 0.000000000000000;
        A[702] = 0.000000000000000;
        A[703] = 0.000000000000000;
        A[704] = 0.000000000000000;
        A[705] = 0.000000000000000;
        A[706] = 0.000000000000000;
        A[707] = 0.000000000000000;
        A[708] = 0.000000000000000;
        A[709] = 0.000000000000000;
        A[710] = 0.000000000000000;
        A[711] = 0.000000000000000;
        A[712] = 0.000000000000000;
        A[713] = 0.000000000000000;
        A[714] = 0.000000000000000;
        A[715] = 0.000000000000000;
        A[716] = 0.000000000000000;
        A[717] = 0.000000000000000;
        A[718] = 0.000000000000000;
        A[719] = 0.000000000000000;
        A[720] = 0.000000000000000;
        A[721] = 0.000000000000000;
        A[722] = 0.000000000000000;
        A[723] = 0.000000000000000;
        A[724] = 0.000000000000000;
        A[725] = 0.000000000000000;
        A[726] = 0.000000000000000;
        A[727] = 0.000000000000000;
        A[728] = 0.000000000000000;
        A[729] = 0.000000000000000;
        A[730] = 0.000000000000000;
        A[731] = 0.000000000000000;
        A[732] = 0.000000000000000;
        A[733] = 0.000000000000000;
        A[734] = 0.000000000000000;
        A[735] = 0.000000000000000;
        A[736] = 0.000000000000000;
        A[737] = 0.000000000000000;
        A[738] = 0.000000000000000;
        A[739] = 0.000000000000000;
        A[740] = 0.000000000000000;
        A[741] = 0.000000000000000;
        A[742] = 0.000000000000000;
        A[743] = 0.000000000000000;
        A[744] = 0.000000000000000;
        A[745] = 0.000000000000000;
        A[746] = 0.000000000000000;
        A[747] = 0.000000000000000;
        A[748] = 0.000000000000000;
        A[749] = 0.000000000000000;
        A[750] = 0.000000000000000;
        A[751] = 0.000000000000000;
        A[752] = 0.000000000000000;
        A[753] = 0.000000000000000;
        A[754] = 0.000000000000000;
        A[755] = 0.000000000000000;
        A[756] = 0.000000000000000;
        A[757] = 0.000000000000000;
        A[758] = 0.000000000000000;
        A[759] = 0.000000000000000;
        A[760] = 0.000000000000000;
        A[761] = 0.000000000000000;
        A[762] = 0.000000000000000;
        A[763] = 0.000000000000000;
        A[764] = 0.000000000000000;
        A[765] = 0.000000000000000;
        A[766] = 0.000000000000000;
        A[767] = 0.000000000000000;
        A[768] = 0.000000000000000;
        A[769] = 0.000000000000000;
        A[770] = 0.000000000000000;
        A[771] = 0.000000000000000;
        A[772] = 0.000000000000000;
        A[773] = 0.000000000000000;
        A[774] = 0.000000000000000;
        A[775] = 0.000000000000000;
        A[776] = 0.000000000000000;
        A[777] = 0.000000000000000;
        A[778] = 0.000000000000000;
        A[779] = 0.000000000000000;
        A[780] = 0.000000000000000;
        A[781] = 0.000000000000000;
        A[782] = 0.000000000000000;
        A[783] = 0.000000000000000;
        A[784] = 0.000000000000000;
        A[785] = 0.000000000000000;
        A[786] = 0.000000000000000;
        A[787] = 0.000000000000000;
        A[788] = 0.000000000000000;
        A[789] = 0.000000000000000;
        A[790] = 0.000000000000000;
        A[791] = 0.000000000000000;
        A[792] = 0.000000000000000;
        A[793] = 0.000000000000000;
        A[794] = 0.000000000000000;
        A[795] = 0.000000000000000;
        A[796] = 0.000000000000000;
        A[797] = 0.000000000000000;
        A[798] = 0.000000000000000;
        A[799] = 0.000000000000000;
        A[800] = 0.000000000000000;
        A[801] = 0.047619047619048*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[802] = -0.019047619047619*G0_6 + 0.047619047619048*G0_7 + 0.038095238095238*G0_11;
        A[803] = 0.000000000000000;
        A[804] = 0.000000000000000;
        A[805] = 0.000000000000000;
        A[806] = 0.038095238095238*G0_6 + 0.038095238095238*G0_7 + 0.457142857142857*G0_11;
        A[807] = 0.000000000000000;
        A[808] = 0.000000000000000;
        A[809] = 0.000000000000000;
        A[810] = 0.000000000000000;
        A[811] = 0.000000000000000;
        A[812] = 0.000000000000000;
        A[813] = 0.000000000000000;
        A[814] = 0.000000000000000;
        A[815] = 0.000000000000000;
        A[816] = 0.000000000000000;
        A[817] = 0.000000000000000;
        A[818] = 0.000000000000000;
        A[819] = 0.000000000000000;
        A[820] = 0.000000000000000;
        A[821] = 0.000000000000000;
        A[822] = 0.000000000000000;
        A[823] = 0.000000000000000;
        A[824] = 0.000000000000000;
        A[825] = 0.000000000000000;
        A[826] = 0.000000000000000;
        A[827] = 0.000000000000000;
        A[828] = 0.000000000000000;
        A[829] = 0.000000000000000;
        A[830] = 0.000000000000000;
        A[831] = 0.000000000000000;
        A[832] = 0.000000000000000;
        A[833] = 0.000000000000000;
        A[834] = 0.000000000000000;
        A[835] = 0.000000000000000;
        A[836] = 0.000000000000000;
        A[837] = 0.150000000000000*G0_6 - 0.016666666666667*G0_7 + 0.200000000000000*G0_11;
        A[838] = 0.016666666666667*G0_6 + 0.016666666666667*G0_7 + 0.133333333333333*G0_11;
        A[839] = 0.000000000000000;
        A[840] = 0.000000000000000;
        A[841] = 0.000000000000000;
        A[842] = 0.000000000000000;
        A[843] = 0.000000000000000;
        A[844] = 0.000000000000000;
        A[845] = 0.000000000000000;
        A[846] = 0.000000000000000;
        A[847] = 0.000000000000000;
        A[848] = 0.000000000000000;
        A[849] = 0.000000000000000;
        A[850] = 0.000000000000000;
        A[851] = 0.000000000000000;
        A[852] = 0.000000000000000;
        A[853] = 0.000000000000000;
        A[854] = 0.000000000000000;
        A[855] = 0.000000000000000;
        A[856] = 0.000000000000000;
        A[857] = 0.000000000000000;
        A[858] = 0.000000000000000;
        A[859] = 0.000000000000000;
        A[860] = 0.000000000000000;
        A[861] = 0.000000000000000;
        A[862] = 0.000000000000000;
        A[863] = 0.000000000000000;
        A[864] = 0.000000000000000;
        A[865] = 0.000000000000000;
        A[866] = 0.000000000000000;
        A[867] = 0.016666666666667*G0_6 + 0.016666666666667*G0_7 + 0.133333333333333*G0_11;
        A[868] = -0.016666666666667*G0_6 + 0.150000000000000*G0_7 + 0.200000000000000*G0_11;
        A[869] = 0.000000000000000;
        A[870] = 0.000000000000000;
        A[871] = 0.000000000000000;
        A[872] = 0.000000000000000;
        A[873] = 0.000000000000000;
        A[874] = 0.000000000000000;
        A[875] = 0.000000000000000;
        A[876] = 0.000000000000000;
        A[877] = 0.000000000000000;
        A[878] = 0.000000000000000;
        A[879] = 0.000000000000000;
        A[880] = 0.000000000000000;
        A[881] = 0.000000000000000;
        A[882] = 0.000000000000000;
        A[883] = 0.000000000000000;
        A[884] = 0.000000000000000;
        A[885] = 0.000000000000000;
        A[886] = 0.000000000000000;
        A[887] = 0.000000000000000;
        A[888] = 0.000000000000000;
        A[889] = 0.000000000000000;
        A[890] = 0.000000000000000;
        A[891] = 0.000000000000000;
        A[892] = 0.000000000000000;
        A[893] = 0.000000000000000;
        A[894] = 0.000000000000000;
        A[895] = 0.000000000000000;
        A[896] = 0.000000000000000;
        A[897] = 0.000000000000000;
        A[898] = 0.000000000000000;
        A[899] = 0.000000000000000;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        switch (facet1)
      {
      case 0:
        {
          A[0] = 0.092857142857143*G1_0 - 0.007142857142857*G1_2 + 0.047619047619048*G1_4;
        A[1] = 0.000000000000000;
        A[2] = -0.007142857142857*G1_0 - 0.007142857142857*G1_2 - 0.019047619047619*G1_4;
        A[3] = 0.000000000000000;
        A[4] = 0.047619047619048*G1_0 - 0.019047619047619*G1_2 + 0.038095238095238*G1_4;
        A[5] = 0.000000000000000;
        A[6] = 0.000000000000000;
        A[7] = 0.000000000000000;
        A[8] = 0.000000000000000;
        A[9] = 0.000000000000000;
        A[10] = 0.000000000000000;
        A[11] = 0.000000000000000;
        A[12] = 0.000000000000000;
        A[13] = 0.000000000000000;
        A[14] = 0.000000000000000;
        A[15] = 0.000000000000000;
        A[16] = 0.000000000000000;
        A[17] = 0.000000000000000;
        A[18] = 0.000000000000000;
        A[19] = 0.000000000000000;
        A[20] = 0.000000000000000;
        A[21] = 0.000000000000000;
        A[22] = 0.000000000000000;
        A[23] = 0.000000000000000;
        A[24] = 0.000000000000000;
        A[25] = 0.000000000000000;
        A[26] = 0.000000000000000;
        A[27] = 0.000000000000000;
        A[28] = 0.000000000000000;
        A[29] = 0.000000000000000;
        A[30] = 0.000000000000000;
        A[31] = 0.000000000000000;
        A[32] = 0.000000000000000;
        A[33] = 0.000000000000000;
        A[34] = 0.000000000000000;
        A[35] = 0.000000000000000;
        A[36] = 0.000000000000000;
        A[37] = 0.000000000000000;
        A[38] = 0.000000000000000;
        A[39] = 0.000000000000000;
        A[40] = 0.000000000000000;
        A[41] = 0.000000000000000;
        A[42] = 0.000000000000000;
        A[43] = 0.000000000000000;
        A[44] = 0.000000000000000;
        A[45] = 0.000000000000000;
        A[46] = 0.000000000000000;
        A[47] = 0.000000000000000;
        A[48] = 0.000000000000000;
        A[49] = 0.000000000000000;
        A[50] = 0.000000000000000;
        A[51] = 0.000000000000000;
        A[52] = 0.000000000000000;
        A[53] = 0.000000000000000;
        A[54] = 0.000000000000000;
        A[55] = 0.000000000000000;
        A[56] = 0.000000000000000;
        A[57] = 0.000000000000000;
        A[58] = 0.000000000000000;
        A[59] = 0.000000000000000;
        A[60] = -0.007142857142857*G1_0 - 0.007142857142857*G1_2 - 0.019047619047619*G1_4;
        A[61] = 0.000000000000000;
        A[62] = -0.007142857142857*G1_0 + 0.092857142857143*G1_2 + 0.047619047619048*G1_4;
        A[63] = 0.000000000000000;
        A[64] = -0.019047619047619*G1_0 + 0.047619047619048*G1_2 + 0.038095238095238*G1_4;
        A[65] = 0.000000000000000;
        A[66] = 0.000000000000000;
        A[67] = 0.000000000000000;
        A[68] = 0.000000000000000;
        A[69] = 0.000000000000000;
        A[70] = 0.000000000000000;
        A[71] = 0.000000000000000;
        A[72] = 0.000000000000000;
        A[73] = 0.000000000000000;
        A[74] = 0.000000000000000;
        A[75] = 0.000000000000000;
        A[76] = 0.000000000000000;
        A[77] = 0.000000000000000;
        A[78] = 0.000000000000000;
        A[79] = 0.000000000000000;
        A[80] = 0.000000000000000;
        A[81] = 0.000000000000000;
        A[82] = 0.000000000000000;
        A[83] = 0.000000000000000;
        A[84] = 0.000000000000000;
        A[85] = 0.000000000000000;
        A[86] = 0.000000000000000;
        A[87] = 0.000000000000000;
        A[88] = 0.000000000000000;
        A[89] = 0.000000000000000;
        A[90] = 0.000000000000000;
        A[91] = 0.000000000000000;
        A[92] = 0.000000000000000;
        A[93] = 0.000000000000000;
        A[94] = 0.000000000000000;
        A[95] = 0.000000000000000;
        A[96] = 0.000000000000000;
        A[97] = 0.000000000000000;
        A[98] = 0.000000000000000;
        A[99] = 0.000000000000000;
        A[100] = 0.000000000000000;
        A[101] = 0.000000000000000;
        A[102] = 0.000000000000000;
        A[103] = 0.000000000000000;
        A[104] = 0.000000000000000;
        A[105] = 0.000000000000000;
        A[106] = 0.000000000000000;
        A[107] = 0.000000000000000;
        A[108] = 0.000000000000000;
        A[109] = 0.000000000000000;
        A[110] = 0.000000000000000;
        A[111] = 0.000000000000000;
        A[112] = 0.000000000000000;
        A[113] = 0.000000000000000;
        A[114] = 0.000000000000000;
        A[115] = 0.000000000000000;
        A[116] = 0.000000000000000;
        A[117] = 0.000000000000000;
        A[118] = 0.000000000000000;
        A[119] = 0.000000000000000;
        A[120] = 0.047619047619048*G1_0 - 0.019047619047619*G1_2 + 0.038095238095238*G1_4;
        A[121] = 0.000000000000000;
        A[122] = -0.019047619047619*G1_0 + 0.047619047619048*G1_2 + 0.038095238095238*G1_4;
        A[123] = 0.000000000000000;
        A[124] = 0.038095238095238*G1_0 + 0.038095238095238*G1_2 + 0.457142857142857*G1_4;
        A[125] = 0.000000000000000;
        A[126] = 0.000000000000000;
        A[127] = 0.000000000000000;
        A[128] = 0.000000000000000;
        A[129] = 0.000000000000000;
        A[130] = 0.000000000000000;
        A[131] = 0.000000000000000;
        A[132] = 0.000000000000000;
        A[133] = 0.000000000000000;
        A[134] = 0.000000000000000;
        A[135] = 0.000000000000000;
        A[136] = 0.000000000000000;
        A[137] = 0.000000000000000;
        A[138] = 0.000000000000000;
        A[139] = 0.000000000000000;
        A[140] = 0.000000000000000;
        A[141] = 0.000000000000000;
        A[142] = 0.000000000000000;
        A[143] = 0.000000000000000;
        A[144] = 0.000000000000000;
        A[145] = 0.000000000000000;
        A[146] = 0.000000000000000;
        A[147] = 0.000000000000000;
        A[148] = 0.000000000000000;
        A[149] = 0.000000000000000;
        A[150] = 0.000000000000000;
        A[151] = 0.000000000000000;
        A[152] = 0.000000000000000;
        A[153] = 0.000000000000000;
        A[154] = 0.000000000000000;
        A[155] = 0.000000000000000;
        A[156] = 0.000000000000000;
        A[157] = 0.000000000000000;
        A[158] = 0.000000000000000;
        A[159] = 0.000000000000000;
        A[160] = 0.000000000000000;
        A[161] = 0.000000000000000;
        A[162] = 0.000000000000000;
        A[163] = 0.000000000000000;
        A[164] = 0.000000000000000;
        A[165] = 0.000000000000000;
        A[166] = 0.000000000000000;
        A[167] = 0.000000000000000;
        A[168] = 0.000000000000000;
        A[169] = 0.000000000000000;
        A[170] = 0.000000000000000;
        A[171] = 0.000000000000000;
        A[172] = 0.000000000000000;
        A[173] = 0.000000000000000;
        A[174] = 0.000000000000000;
        A[175] = 0.000000000000000;
        A[176] = 0.000000000000000;
        A[177] = 0.000000000000000;
        A[178] = 0.000000000000000;
        A[179] = 0.000000000000000;
        A[180] = 0.000000000000000;
        A[181] = 0.000000000000000;
        A[182] = 0.000000000000000;
        A[183] = 0.000000000000000;
        A[184] = 0.000000000000000;
        A[185] = 0.000000000000000;
        A[186] = 0.092857142857143*G1_0 - 0.007142857142857*G1_2 + 0.047619047619048*G1_4;
        A[187] = 0.000000000000000;
        A[188] = -0.007142857142857*G1_0 - 0.007142857142857*G1_2 - 0.019047619047619*G1_4;
        A[189] = 0.000000000000000;
        A[190] = 0.047619047619048*G1_0 - 0.019047619047619*G1_2 + 0.038095238095238*G1_4;
        A[191] = 0.000000000000000;
        A[192] = 0.000000000000000;
        A[193] = 0.000000000000000;
        A[194] = 0.000000000000000;
        A[195] = 0.000000000000000;
        A[196] = 0.000000000000000;
        A[197] = 0.000000000000000;
        A[198] = 0.000000000000000;
        A[199] = 0.000000000000000;
        A[200] = 0.000000000000000;
        A[201] = 0.000000000000000;
        A[202] = 0.000000000000000;
        A[203] = 0.000000000000000;
        A[204] = 0.000000000000000;
        A[205] = 0.000000000000000;
        A[206] = 0.000000000000000;
        A[207] = 0.000000000000000;
        A[208] = 0.000000000000000;
        A[209] = 0.000000000000000;
        A[210] = 0.000000000000000;
        A[211] = 0.000000000000000;
        A[212] = 0.000000000000000;
        A[213] = 0.000000000000000;
        A[214] = 0.000000000000000;
        A[215] = 0.000000000000000;
        A[216] = 0.000000000000000;
        A[217] = 0.000000000000000;
        A[218] = 0.000000000000000;
        A[219] = 0.000000000000000;
        A[220] = 0.000000000000000;
        A[221] = 0.000000000000000;
        A[222] = 0.000000000000000;
        A[223] = 0.000000000000000;
        A[224] = 0.000000000000000;
        A[225] = 0.000000000000000;
        A[226] = 0.000000000000000;
        A[227] = 0.000000000000000;
        A[228] = 0.000000000000000;
        A[229] = 0.000000000000000;
        A[230] = 0.000000000000000;
        A[231] = 0.000000000000000;
        A[232] = 0.000000000000000;
        A[233] = 0.000000000000000;
        A[234] = 0.000000000000000;
        A[235] = 0.000000000000000;
        A[236] = 0.000000000000000;
        A[237] = 0.000000000000000;
        A[238] = 0.000000000000000;
        A[239] = 0.000000000000000;
        A[240] = 0.000000000000000;
        A[241] = 0.000000000000000;
        A[242] = 0.000000000000000;
        A[243] = 0.000000000000000;
        A[244] = 0.000000000000000;
        A[245] = 0.000000000000000;
        A[246] = -0.007142857142857*G1_0 - 0.007142857142857*G1_2 - 0.019047619047619*G1_4;
        A[247] = 0.000000000000000;
        A[248] = -0.007142857142857*G1_0 + 0.092857142857143*G1_2 + 0.047619047619048*G1_4;
        A[249] = 0.000000000000000;
        A[250] = -0.019047619047619*G1_0 + 0.047619047619048*G1_2 + 0.038095238095238*G1_4;
        A[251] = 0.000000000000000;
        A[252] = 0.000000000000000;
        A[253] = 0.000000000000000;
        A[254] = 0.000000000000000;
        A[255] = 0.000000000000000;
        A[256] = 0.000000000000000;
        A[257] = 0.000000000000000;
        A[258] = 0.000000000000000;
        A[259] = 0.000000000000000;
        A[260] = 0.000000000000000;
        A[261] = 0.000000000000000;
        A[262] = 0.000000000000000;
        A[263] = 0.000000000000000;
        A[264] = 0.000000000000000;
        A[265] = 0.000000000000000;
        A[266] = 0.000000000000000;
        A[267] = 0.000000000000000;
        A[268] = 0.000000000000000;
        A[269] = 0.000000000000000;
        A[270] = 0.000000000000000;
        A[271] = 0.000000000000000;
        A[272] = 0.000000000000000;
        A[273] = 0.000000000000000;
        A[274] = 0.000000000000000;
        A[275] = 0.000000000000000;
        A[276] = 0.000000000000000;
        A[277] = 0.000000000000000;
        A[278] = 0.000000000000000;
        A[279] = 0.000000000000000;
        A[280] = 0.000000000000000;
        A[281] = 0.000000000000000;
        A[282] = 0.000000000000000;
        A[283] = 0.000000000000000;
        A[284] = 0.000000000000000;
        A[285] = 0.000000000000000;
        A[286] = 0.000000000000000;
        A[287] = 0.000000000000000;
        A[288] = 0.000000000000000;
        A[289] = 0.000000000000000;
        A[290] = 0.000000000000000;
        A[291] = 0.000000000000000;
        A[292] = 0.000000000000000;
        A[293] = 0.000000000000000;
        A[294] = 0.000000000000000;
        A[295] = 0.000000000000000;
        A[296] = 0.000000000000000;
        A[297] = 0.000000000000000;
        A[298] = 0.000000000000000;
        A[299] = 0.000000000000000;
        A[300] = 0.000000000000000;
        A[301] = 0.000000000000000;
        A[302] = 0.000000000000000;
        A[303] = 0.000000000000000;
        A[304] = 0.000000000000000;
        A[305] = 0.000000000000000;
        A[306] = 0.047619047619048*G1_0 - 0.019047619047619*G1_2 + 0.038095238095238*G1_4;
        A[307] = 0.000000000000000;
        A[308] = -0.019047619047619*G1_0 + 0.047619047619048*G1_2 + 0.038095238095238*G1_4;
        A[309] = 0.000000000000000;
        A[310] = 0.038095238095238*G1_0 + 0.038095238095238*G1_2 + 0.457142857142857*G1_4;
        A[311] = 0.000000000000000;
        A[312] = 0.000000000000000;
        A[313] = 0.000000000000000;
        A[314] = 0.000000000000000;
        A[315] = 0.000000000000000;
        A[316] = 0.000000000000000;
        A[317] = 0.000000000000000;
        A[318] = 0.000000000000000;
        A[319] = 0.000000000000000;
        A[320] = 0.000000000000000;
        A[321] = 0.000000000000000;
        A[322] = 0.000000000000000;
        A[323] = 0.000000000000000;
        A[324] = 0.000000000000000;
        A[325] = 0.000000000000000;
        A[326] = 0.000000000000000;
        A[327] = 0.000000000000000;
        A[328] = 0.000000000000000;
        A[329] = 0.000000000000000;
        A[330] = 0.000000000000000;
        A[331] = 0.000000000000000;
        A[332] = 0.000000000000000;
        A[333] = 0.000000000000000;
        A[334] = 0.000000000000000;
        A[335] = 0.000000000000000;
        A[336] = 0.000000000000000;
        A[337] = 0.000000000000000;
        A[338] = 0.000000000000000;
        A[339] = 0.000000000000000;
        A[340] = 0.000000000000000;
        A[341] = 0.000000000000000;
        A[342] = 0.000000000000000;
        A[343] = 0.000000000000000;
        A[344] = 0.000000000000000;
        A[345] = 0.000000000000000;
        A[346] = 0.000000000000000;
        A[347] = 0.000000000000000;
        A[348] = 0.000000000000000;
        A[349] = 0.000000000000000;
        A[350] = 0.000000000000000;
        A[351] = 0.000000000000000;
        A[352] = 0.000000000000000;
        A[353] = 0.000000000000000;
        A[354] = 0.000000000000000;
        A[355] = 0.000000000000000;
        A[356] = 0.000000000000000;
        A[357] = 0.000000000000000;
        A[358] = 0.000000000000000;
        A[359] = 0.000000000000000;
        A[360] = 0.000000000000000;
        A[361] = 0.000000000000000;
        A[362] = 0.000000000000000;
        A[363] = 0.000000000000000;
        A[364] = 0.000000000000000;
        A[365] = 0.000000000000000;
        A[366] = 0.000000000000000;
        A[367] = 0.000000000000000;
        A[368] = 0.000000000000000;
        A[369] = 0.000000000000000;
        A[370] = 0.000000000000000;
        A[371] = 0.000000000000000;
        A[372] = 0.150000000000000*G1_0 - 0.016666666666667*G1_2 + 0.200000000000000*G1_4;
        A[373] = 0.000000000000000;
        A[374] = 0.016666666666667*G1_0 + 0.016666666666667*G1_2 + 0.133333333333333*G1_4;
        A[375] = 0.000000000000000;
        A[376] = 0.000000000000000;
        A[377] = 0.000000000000000;
        A[378] = 0.000000000000000;
        A[379] = 0.000000000000000;
        A[380] = 0.000000000000000;
        A[381] = 0.000000000000000;
        A[382] = 0.000000000000000;
        A[383] = 0.000000000000000;
        A[384] = 0.000000000000000;
        A[385] = 0.000000000000000;
        A[386] = 0.000000000000000;
        A[387] = 0.000000000000000;
        A[388] = 0.000000000000000;
        A[389] = 0.000000000000000;
        A[390] = 0.000000000000000;
        A[391] = 0.000000000000000;
        A[392] = 0.000000000000000;
        A[393] = 0.000000000000000;
        A[394] = 0.000000000000000;
        A[395] = 0.000000000000000;
        A[396] = 0.000000000000000;
        A[397] = 0.000000000000000;
        A[398] = 0.000000000000000;
        A[399] = 0.000000000000000;
        A[400] = 0.000000000000000;
        A[401] = 0.000000000000000;
        A[402] = 0.000000000000000;
        A[403] = 0.000000000000000;
        A[404] = 0.000000000000000;
        A[405] = 0.000000000000000;
        A[406] = 0.000000000000000;
        A[407] = 0.000000000000000;
        A[408] = 0.000000000000000;
        A[409] = 0.000000000000000;
        A[410] = 0.000000000000000;
        A[411] = 0.000000000000000;
        A[412] = 0.000000000000000;
        A[413] = 0.000000000000000;
        A[414] = 0.000000000000000;
        A[415] = 0.000000000000000;
        A[416] = 0.000000000000000;
        A[417] = 0.000000000000000;
        A[418] = 0.000000000000000;
        A[419] = 0.000000000000000;
        A[420] = 0.000000000000000;
        A[421] = 0.000000000000000;
        A[422] = 0.000000000000000;
        A[423] = 0.000000000000000;
        A[424] = 0.000000000000000;
        A[425] = 0.000000000000000;
        A[426] = 0.000000000000000;
        A[427] = 0.000000000000000;
        A[428] = 0.000000000000000;
        A[429] = 0.000000000000000;
        A[430] = 0.000000000000000;
        A[431] = 0.000000000000000;
        A[432] = 0.016666666666667*G1_0 + 0.016666666666667*G1_2 + 0.133333333333333*G1_4;
        A[433] = 0.000000000000000;
        A[434] = -0.016666666666667*G1_0 + 0.150000000000000*G1_2 + 0.200000000000000*G1_4;
        A[435] = 0.000000000000000;
        A[436] = 0.000000000000000;
        A[437] = 0.000000000000000;
        A[438] = 0.000000000000000;
        A[439] = 0.000000000000000;
        A[440] = 0.000000000000000;
        A[441] = 0.000000000000000;
        A[442] = 0.000000000000000;
        A[443] = 0.000000000000000;
        A[444] = 0.000000000000000;
        A[445] = 0.000000000000000;
        A[446] = 0.000000000000000;
        A[447] = 0.000000000000000;
        A[448] = 0.000000000000000;
        A[449] = 0.000000000000000;
        A[450] = 0.000000000000000;
        A[451] = 0.000000000000000;
        A[452] = 0.000000000000000;
        A[453] = 0.000000000000000;
        A[454] = 0.000000000000000;
        A[455] = 0.000000000000000;
        A[456] = 0.000000000000000;
        A[457] = 0.000000000000000;
        A[458] = 0.000000000000000;
        A[459] = 0.000000000000000;
        A[460] = 0.000000000000000;
        A[461] = 0.000000000000000;
        A[462] = 0.000000000000000;
        A[463] = 0.000000000000000;
        A[464] = 0.000000000000000;
        A[465] = 0.000000000000000;
        A[466] = 0.000000000000000;
        A[467] = 0.000000000000000;
        A[468] = 0.000000000000000;
        A[469] = 0.000000000000000;
        A[470] = 0.000000000000000;
        A[471] = 0.000000000000000;
        A[472] = 0.000000000000000;
        A[473] = 0.000000000000000;
        A[474] = 0.000000000000000;
        A[475] = 0.000000000000000;
        A[476] = 0.000000000000000;
        A[477] = 0.000000000000000;
        A[478] = 0.000000000000000;
        A[479] = 0.000000000000000;
        A[480] = 0.000000000000000;
        A[481] = 0.000000000000000;
        A[482] = 0.000000000000000;
        A[483] = 0.000000000000000;
        A[484] = 0.000000000000000;
        A[485] = 0.000000000000000;
        A[486] = 0.000000000000000;
        A[487] = 0.000000000000000;
        A[488] = 0.000000000000000;
        A[489] = 0.000000000000000;
        A[490] = 0.000000000000000;
        A[491] = 0.000000000000000;
        A[492] = 0.000000000000000;
        A[493] = 0.000000000000000;
        A[494] = 0.000000000000000;
        A[495] = 0.000000000000000;
        A[496] = 0.092857142857143*G0_7 - 0.007142857142857*G0_8 + 0.047619047619048*G0_9;
        A[497] = -0.007142857142857*G0_7 - 0.007142857142857*G0_8 - 0.019047619047619*G0_9;
        A[498] = 0.047619047619048*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[499] = 0.000000000000000;
        A[500] = 0.000000000000000;
        A[501] = 0.000000000000000;
        A[502] = 0.000000000000000;
        A[503] = 0.000000000000000;
        A[504] = 0.000000000000000;
        A[505] = 0.000000000000000;
        A[506] = 0.000000000000000;
        A[507] = 0.000000000000000;
        A[508] = 0.000000000000000;
        A[509] = 0.000000000000000;
        A[510] = 0.000000000000000;
        A[511] = 0.000000000000000;
        A[512] = 0.000000000000000;
        A[513] = 0.000000000000000;
        A[514] = 0.000000000000000;
        A[515] = 0.000000000000000;
        A[516] = 0.000000000000000;
        A[517] = 0.000000000000000;
        A[518] = 0.000000000000000;
        A[519] = 0.000000000000000;
        A[520] = 0.000000000000000;
        A[521] = 0.000000000000000;
        A[522] = 0.000000000000000;
        A[523] = 0.000000000000000;
        A[524] = 0.000000000000000;
        A[525] = 0.000000000000000;
        A[526] = -0.007142857142857*G0_7 - 0.007142857142857*G0_8 - 0.019047619047619*G0_9;
        A[527] = -0.007142857142857*G0_7 + 0.092857142857143*G0_8 + 0.047619047619048*G0_9;
        A[528] = -0.019047619047619*G0_7 + 0.047619047619048*G0_8 + 0.038095238095238*G0_9;
        A[529] = 0.000000000000000;
        A[530] = 0.000000000000000;
        A[531] = 0.000000000000000;
        A[532] = 0.000000000000000;
        A[533] = 0.000000000000000;
        A[534] = 0.000000000000000;
        A[535] = 0.000000000000000;
        A[536] = 0.000000000000000;
        A[537] = 0.000000000000000;
        A[538] = 0.000000000000000;
        A[539] = 0.000000000000000;
        A[540] = 0.000000000000000;
        A[541] = 0.000000000000000;
        A[542] = 0.000000000000000;
        A[543] = 0.000000000000000;
        A[544] = 0.000000000000000;
        A[545] = 0.000000000000000;
        A[546] = 0.000000000000000;
        A[547] = 0.000000000000000;
        A[548] = 0.000000000000000;
        A[549] = 0.000000000000000;
        A[550] = 0.000000000000000;
        A[551] = 0.000000000000000;
        A[552] = 0.000000000000000;
        A[553] = 0.000000000000000;
        A[554] = 0.000000000000000;
        A[555] = 0.000000000000000;
        A[556] = 0.047619047619048*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[557] = -0.019047619047619*G0_7 + 0.047619047619048*G0_8 + 0.038095238095238*G0_9;
        A[558] = 0.038095238095238*G0_7 + 0.038095238095238*G0_8 + 0.457142857142857*G0_9;
        A[559] = 0.000000000000000;
        A[560] = 0.000000000000000;
        A[561] = 0.000000000000000;
        A[562] = 0.000000000000000;
        A[563] = 0.000000000000000;
        A[564] = 0.000000000000000;
        A[565] = 0.000000000000000;
        A[566] = 0.000000000000000;
        A[567] = 0.000000000000000;
        A[568] = 0.000000000000000;
        A[569] = 0.000000000000000;
        A[570] = 0.000000000000000;
        A[571] = 0.000000000000000;
        A[572] = 0.000000000000000;
        A[573] = 0.000000000000000;
        A[574] = 0.000000000000000;
        A[575] = 0.000000000000000;
        A[576] = 0.000000000000000;
        A[577] = 0.000000000000000;
        A[578] = 0.000000000000000;
        A[579] = 0.000000000000000;
        A[580] = 0.000000000000000;
        A[581] = 0.000000000000000;
        A[582] = 0.000000000000000;
        A[583] = 0.000000000000000;
        A[584] = 0.000000000000000;
        A[585] = 0.000000000000000;
        A[586] = 0.000000000000000;
        A[587] = 0.000000000000000;
        A[588] = 0.000000000000000;
        A[589] = 0.000000000000000;
        A[590] = 0.000000000000000;
        A[591] = 0.000000000000000;
        A[592] = 0.000000000000000;
        A[593] = 0.000000000000000;
        A[594] = 0.000000000000000;
        A[595] = 0.000000000000000;
        A[596] = 0.000000000000000;
        A[597] = 0.000000000000000;
        A[598] = 0.000000000000000;
        A[599] = 0.000000000000000;
        A[600] = 0.000000000000000;
        A[601] = 0.000000000000000;
        A[602] = 0.000000000000000;
        A[603] = 0.000000000000000;
        A[604] = 0.000000000000000;
        A[605] = 0.000000000000000;
        A[606] = 0.000000000000000;
        A[607] = 0.000000000000000;
        A[608] = 0.000000000000000;
        A[609] = 0.000000000000000;
        A[610] = 0.000000000000000;
        A[611] = 0.000000000000000;
        A[612] = 0.000000000000000;
        A[613] = 0.000000000000000;
        A[614] = 0.000000000000000;
        A[615] = 0.000000000000000;
        A[616] = 0.000000000000000;
        A[617] = 0.000000000000000;
        A[618] = 0.000000000000000;
        A[619] = 0.000000000000000;
        A[620] = 0.000000000000000;
        A[621] = 0.000000000000000;
        A[622] = 0.000000000000000;
        A[623] = 0.000000000000000;
        A[624] = 0.000000000000000;
        A[625] = 0.000000000000000;
        A[626] = 0.000000000000000;
        A[627] = 0.000000000000000;
        A[628] = 0.000000000000000;
        A[629] = 0.000000000000000;
        A[630] = 0.000000000000000;
        A[631] = 0.000000000000000;
        A[632] = 0.000000000000000;
        A[633] = 0.000000000000000;
        A[634] = 0.000000000000000;
        A[635] = 0.000000000000000;
        A[636] = 0.000000000000000;
        A[637] = 0.000000000000000;
        A[638] = 0.000000000000000;
        A[639] = 0.000000000000000;
        A[640] = 0.000000000000000;
        A[641] = 0.000000000000000;
        A[642] = 0.000000000000000;
        A[643] = 0.000000000000000;
        A[644] = 0.000000000000000;
        A[645] = 0.000000000000000;
        A[646] = 0.000000000000000;
        A[647] = 0.000000000000000;
        A[648] = 0.000000000000000;
        A[649] = 0.000000000000000;
        A[650] = 0.000000000000000;
        A[651] = 0.000000000000000;
        A[652] = 0.000000000000000;
        A[653] = 0.000000000000000;
        A[654] = 0.000000000000000;
        A[655] = 0.000000000000000;
        A[656] = 0.000000000000000;
        A[657] = 0.000000000000000;
        A[658] = 0.000000000000000;
        A[659] = 0.000000000000000;
        A[660] = 0.000000000000000;
        A[661] = 0.000000000000000;
        A[662] = 0.000000000000000;
        A[663] = 0.000000000000000;
        A[664] = 0.000000000000000;
        A[665] = 0.000000000000000;
        A[666] = 0.000000000000000;
        A[667] = 0.000000000000000;
        A[668] = 0.000000000000000;
        A[669] = 0.000000000000000;
        A[670] = 0.000000000000000;
        A[671] = 0.000000000000000;
        A[672] = 0.000000000000000;
        A[673] = 0.000000000000000;
        A[674] = 0.000000000000000;
        A[675] = 0.000000000000000;
        A[676] = 0.000000000000000;
        A[677] = 0.000000000000000;
        A[678] = 0.000000000000000;
        A[679] = 0.000000000000000;
        A[680] = 0.000000000000000;
        A[681] = 0.000000000000000;
        A[682] = 0.092857142857143*G0_7 - 0.007142857142857*G0_8 + 0.047619047619048*G0_9;
        A[683] = -0.007142857142857*G0_7 - 0.007142857142857*G0_8 - 0.019047619047619*G0_9;
        A[684] = 0.047619047619048*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[685] = 0.000000000000000;
        A[686] = 0.000000000000000;
        A[687] = 0.000000000000000;
        A[688] = 0.000000000000000;
        A[689] = 0.000000000000000;
        A[690] = 0.000000000000000;
        A[691] = 0.000000000000000;
        A[692] = 0.000000000000000;
        A[693] = 0.000000000000000;
        A[694] = 0.000000000000000;
        A[695] = 0.000000000000000;
        A[696] = 0.000000000000000;
        A[697] = 0.000000000000000;
        A[698] = 0.000000000000000;
        A[699] = 0.000000000000000;
        A[700] = 0.000000000000000;
        A[701] = 0.000000000000000;
        A[702] = 0.000000000000000;
        A[703] = 0.000000000000000;
        A[704] = 0.000000000000000;
        A[705] = 0.000000000000000;
        A[706] = 0.000000000000000;
        A[707] = 0.000000000000000;
        A[708] = 0.000000000000000;
        A[709] = 0.000000000000000;
        A[710] = 0.000000000000000;
        A[711] = 0.000000000000000;
        A[712] = -0.007142857142857*G0_7 - 0.007142857142857*G0_8 - 0.019047619047619*G0_9;
        A[713] = -0.007142857142857*G0_7 + 0.092857142857143*G0_8 + 0.047619047619048*G0_9;
        A[714] = -0.019047619047619*G0_7 + 0.047619047619048*G0_8 + 0.038095238095238*G0_9;
        A[715] = 0.000000000000000;
        A[716] = 0.000000000000000;
        A[717] = 0.000000000000000;
        A[718] = 0.000000000000000;
        A[719] = 0.000000000000000;
        A[720] = 0.000000000000000;
        A[721] = 0.000000000000000;
        A[722] = 0.000000000000000;
        A[723] = 0.000000000000000;
        A[724] = 0.000000000000000;
        A[725] = 0.000000000000000;
        A[726] = 0.000000000000000;
        A[727] = 0.000000000000000;
        A[728] = 0.000000000000000;
        A[729] = 0.000000000000000;
        A[730] = 0.000000000000000;
        A[731] = 0.000000000000000;
        A[732] = 0.000000000000000;
        A[733] = 0.000000000000000;
        A[734] = 0.000000000000000;
        A[735] = 0.000000000000000;
        A[736] = 0.000000000000000;
        A[737] = 0.000000000000000;
        A[738] = 0.000000000000000;
        A[739] = 0.000000000000000;
        A[740] = 0.000000000000000;
        A[741] = 0.000000000000000;
        A[742] = 0.047619047619048*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[743] = -0.019047619047619*G0_7 + 0.047619047619048*G0_8 + 0.038095238095238*G0_9;
        A[744] = 0.038095238095238*G0_7 + 0.038095238095238*G0_8 + 0.457142857142857*G0_9;
        A[745] = 0.000000000000000;
        A[746] = 0.000000000000000;
        A[747] = 0.000000000000000;
        A[748] = 0.000000000000000;
        A[749] = 0.000000000000000;
        A[750] = 0.000000000000000;
        A[751] = 0.000000000000000;
        A[752] = 0.000000000000000;
        A[753] = 0.000000000000000;
        A[754] = 0.000000000000000;
        A[755] = 0.000000000000000;
        A[756] = 0.000000000000000;
        A[757] = 0.000000000000000;
        A[758] = 0.000000000000000;
        A[759] = 0.000000000000000;
        A[760] = 0.000000000000000;
        A[761] = 0.000000000000000;
        A[762] = 0.000000000000000;
        A[763] = 0.000000000000000;
        A[764] = 0.000000000000000;
        A[765] = 0.000000000000000;
        A[766] = 0.000000000000000;
        A[767] = 0.000000000000000;
        A[768] = 0.000000000000000;
        A[769] = 0.000000000000000;
        A[770] = 0.000000000000000;
        A[771] = 0.000000000000000;
        A[772] = 0.000000000000000;
        A[773] = 0.000000000000000;
        A[774] = 0.000000000000000;
        A[775] = 0.000000000000000;
        A[776] = 0.000000000000000;
        A[777] = 0.000000000000000;
        A[778] = 0.000000000000000;
        A[779] = 0.000000000000000;
        A[780] = 0.000000000000000;
        A[781] = 0.000000000000000;
        A[782] = 0.000000000000000;
        A[783] = 0.000000000000000;
        A[784] = 0.000000000000000;
        A[785] = 0.000000000000000;
        A[786] = 0.000000000000000;
        A[787] = 0.000000000000000;
        A[788] = 0.000000000000000;
        A[789] = 0.000000000000000;
        A[790] = 0.000000000000000;
        A[791] = 0.000000000000000;
        A[792] = 0.000000000000000;
        A[793] = 0.000000000000000;
        A[794] = 0.000000000000000;
        A[795] = 0.000000000000000;
        A[796] = 0.000000000000000;
        A[797] = 0.000000000000000;
        A[798] = 0.000000000000000;
        A[799] = 0.000000000000000;
        A[800] = 0.000000000000000;
        A[801] = 0.000000000000000;
        A[802] = 0.000000000000000;
        A[803] = 0.000000000000000;
        A[804] = 0.000000000000000;
        A[805] = 0.000000000000000;
        A[806] = 0.000000000000000;
        A[807] = 0.000000000000000;
        A[808] = 0.000000000000000;
        A[809] = 0.000000000000000;
        A[810] = 0.000000000000000;
        A[811] = 0.000000000000000;
        A[812] = 0.000000000000000;
        A[813] = 0.000000000000000;
        A[814] = 0.000000000000000;
        A[815] = 0.000000000000000;
        A[816] = 0.000000000000000;
        A[817] = 0.000000000000000;
        A[818] = 0.000000000000000;
        A[819] = 0.000000000000000;
        A[820] = 0.000000000000000;
        A[821] = 0.000000000000000;
        A[822] = 0.000000000000000;
        A[823] = 0.000000000000000;
        A[824] = 0.000000000000000;
        A[825] = 0.000000000000000;
        A[826] = 0.000000000000000;
        A[827] = 0.000000000000000;
        A[828] = 0.000000000000000;
        A[829] = 0.000000000000000;
        A[830] = 0.000000000000000;
        A[831] = 0.000000000000000;
        A[832] = 0.000000000000000;
        A[833] = 0.000000000000000;
        A[834] = 0.000000000000000;
        A[835] = 0.000000000000000;
        A[836] = 0.000000000000000;
        A[837] = 0.000000000000000;
        A[838] = 0.000000000000000;
        A[839] = 0.000000000000000;
        A[840] = 0.000000000000000;
        A[841] = 0.000000000000000;
        A[842] = 0.000000000000000;
        A[843] = 0.000000000000000;
        A[844] = 0.000000000000000;
        A[845] = 0.000000000000000;
        A[846] = 0.000000000000000;
        A[847] = 0.000000000000000;
        A[848] = 0.000000000000000;
        A[849] = 0.000000000000000;
        A[850] = 0.000000000000000;
        A[851] = 0.000000000000000;
        A[852] = 0.000000000000000;
        A[853] = 0.000000000000000;
        A[854] = 0.000000000000000;
        A[855] = 0.000000000000000;
        A[856] = 0.000000000000000;
        A[857] = 0.000000000000000;
        A[858] = 0.000000000000000;
        A[859] = 0.000000000000000;
        A[860] = 0.000000000000000;
        A[861] = 0.000000000000000;
        A[862] = 0.000000000000000;
        A[863] = 0.000000000000000;
        A[864] = 0.000000000000000;
        A[865] = 0.000000000000000;
        A[866] = 0.000000000000000;
        A[867] = 0.000000000000000;
        A[868] = 0.150000000000000*G0_7 - 0.016666666666667*G0_8 + 0.200000000000000*G0_9;
        A[869] = 0.016666666666667*G0_7 + 0.016666666666667*G0_8 + 0.133333333333333*G0_9;
        A[870] = 0.000000000000000;
        A[871] = 0.000000000000000;
        A[872] = 0.000000000000000;
        A[873] = 0.000000000000000;
        A[874] = 0.000000000000000;
        A[875] = 0.000000000000000;
        A[876] = 0.000000000000000;
        A[877] = 0.000000000000000;
        A[878] = 0.000000000000000;
        A[879] = 0.000000000000000;
        A[880] = 0.000000000000000;
        A[881] = 0.000000000000000;
        A[882] = 0.000000000000000;
        A[883] = 0.000000000000000;
        A[884] = 0.000000000000000;
        A[885] = 0.000000000000000;
        A[886] = 0.000000000000000;
        A[887] = 0.000000000000000;
        A[888] = 0.000000000000000;
        A[889] = 0.000000000000000;
        A[890] = 0.000000000000000;
        A[891] = 0.000000000000000;
        A[892] = 0.000000000000000;
        A[893] = 0.000000000000000;
        A[894] = 0.000000000000000;
        A[895] = 0.000000000000000;
        A[896] = 0.000000000000000;
        A[897] = 0.000000000000000;
        A[898] = 0.016666666666667*G0_7 + 0.016666666666667*G0_8 + 0.133333333333333*G0_9;
        A[899] = -0.016666666666667*G0_7 + 0.150000000000000*G0_8 + 0.200000000000000*G0_9;
          break;
        }
      case 1:
        {
          A[0] = 0.092857142857143*G1_0 - 0.007142857142857*G1_2 + 0.047619047619048*G1_4;
        A[1] = 0.000000000000000;
        A[2] = -0.007142857142857*G1_0 - 0.007142857142857*G1_2 - 0.019047619047619*G1_4;
        A[3] = 0.000000000000000;
        A[4] = 0.047619047619048*G1_0 - 0.019047619047619*G1_2 + 0.038095238095238*G1_4;
        A[5] = 0.000000000000000;
        A[6] = 0.000000000000000;
        A[7] = 0.000000000000000;
        A[8] = 0.000000000000000;
        A[9] = 0.000000000000000;
        A[10] = 0.000000000000000;
        A[11] = 0.000000000000000;
        A[12] = 0.000000000000000;
        A[13] = 0.000000000000000;
        A[14] = 0.000000000000000;
        A[15] = 0.000000000000000;
        A[16] = 0.000000000000000;
        A[17] = 0.000000000000000;
        A[18] = 0.000000000000000;
        A[19] = 0.000000000000000;
        A[20] = 0.000000000000000;
        A[21] = 0.000000000000000;
        A[22] = 0.000000000000000;
        A[23] = 0.000000000000000;
        A[24] = 0.000000000000000;
        A[25] = 0.000000000000000;
        A[26] = 0.000000000000000;
        A[27] = 0.000000000000000;
        A[28] = 0.000000000000000;
        A[29] = 0.000000000000000;
        A[30] = 0.000000000000000;
        A[31] = 0.000000000000000;
        A[32] = 0.000000000000000;
        A[33] = 0.000000000000000;
        A[34] = 0.000000000000000;
        A[35] = 0.000000000000000;
        A[36] = 0.000000000000000;
        A[37] = 0.000000000000000;
        A[38] = 0.000000000000000;
        A[39] = 0.000000000000000;
        A[40] = 0.000000000000000;
        A[41] = 0.000000000000000;
        A[42] = 0.000000000000000;
        A[43] = 0.000000000000000;
        A[44] = 0.000000000000000;
        A[45] = 0.000000000000000;
        A[46] = 0.000000000000000;
        A[47] = 0.000000000000000;
        A[48] = 0.000000000000000;
        A[49] = 0.000000000000000;
        A[50] = 0.000000000000000;
        A[51] = 0.000000000000000;
        A[52] = 0.000000000000000;
        A[53] = 0.000000000000000;
        A[54] = 0.000000000000000;
        A[55] = 0.000000000000000;
        A[56] = 0.000000000000000;
        A[57] = 0.000000000000000;
        A[58] = 0.000000000000000;
        A[59] = 0.000000000000000;
        A[60] = -0.007142857142857*G1_0 - 0.007142857142857*G1_2 - 0.019047619047619*G1_4;
        A[61] = 0.000000000000000;
        A[62] = -0.007142857142857*G1_0 + 0.092857142857143*G1_2 + 0.047619047619048*G1_4;
        A[63] = 0.000000000000000;
        A[64] = -0.019047619047619*G1_0 + 0.047619047619048*G1_2 + 0.038095238095238*G1_4;
        A[65] = 0.000000000000000;
        A[66] = 0.000000000000000;
        A[67] = 0.000000000000000;
        A[68] = 0.000000000000000;
        A[69] = 0.000000000000000;
        A[70] = 0.000000000000000;
        A[71] = 0.000000000000000;
        A[72] = 0.000000000000000;
        A[73] = 0.000000000000000;
        A[74] = 0.000000000000000;
        A[75] = 0.000000000000000;
        A[76] = 0.000000000000000;
        A[77] = 0.000000000000000;
        A[78] = 0.000000000000000;
        A[79] = 0.000000000000000;
        A[80] = 0.000000000000000;
        A[81] = 0.000000000000000;
        A[82] = 0.000000000000000;
        A[83] = 0.000000000000000;
        A[84] = 0.000000000000000;
        A[85] = 0.000000000000000;
        A[86] = 0.000000000000000;
        A[87] = 0.000000000000000;
        A[88] = 0.000000000000000;
        A[89] = 0.000000000000000;
        A[90] = 0.000000000000000;
        A[91] = 0.000000000000000;
        A[92] = 0.000000000000000;
        A[93] = 0.000000000000000;
        A[94] = 0.000000000000000;
        A[95] = 0.000000000000000;
        A[96] = 0.000000000000000;
        A[97] = 0.000000000000000;
        A[98] = 0.000000000000000;
        A[99] = 0.000000000000000;
        A[100] = 0.000000000000000;
        A[101] = 0.000000000000000;
        A[102] = 0.000000000000000;
        A[103] = 0.000000000000000;
        A[104] = 0.000000000000000;
        A[105] = 0.000000000000000;
        A[106] = 0.000000000000000;
        A[107] = 0.000000000000000;
        A[108] = 0.000000000000000;
        A[109] = 0.000000000000000;
        A[110] = 0.000000000000000;
        A[111] = 0.000000000000000;
        A[112] = 0.000000000000000;
        A[113] = 0.000000000000000;
        A[114] = 0.000000000000000;
        A[115] = 0.000000000000000;
        A[116] = 0.000000000000000;
        A[117] = 0.000000000000000;
        A[118] = 0.000000000000000;
        A[119] = 0.000000000000000;
        A[120] = 0.047619047619048*G1_0 - 0.019047619047619*G1_2 + 0.038095238095238*G1_4;
        A[121] = 0.000000000000000;
        A[122] = -0.019047619047619*G1_0 + 0.047619047619048*G1_2 + 0.038095238095238*G1_4;
        A[123] = 0.000000000000000;
        A[124] = 0.038095238095238*G1_0 + 0.038095238095238*G1_2 + 0.457142857142857*G1_4;
        A[125] = 0.000000000000000;
        A[126] = 0.000000000000000;
        A[127] = 0.000000000000000;
        A[128] = 0.000000000000000;
        A[129] = 0.000000000000000;
        A[130] = 0.000000000000000;
        A[131] = 0.000000000000000;
        A[132] = 0.000000000000000;
        A[133] = 0.000000000000000;
        A[134] = 0.000000000000000;
        A[135] = 0.000000000000000;
        A[136] = 0.000000000000000;
        A[137] = 0.000000000000000;
        A[138] = 0.000000000000000;
        A[139] = 0.000000000000000;
        A[140] = 0.000000000000000;
        A[141] = 0.000000000000000;
        A[142] = 0.000000000000000;
        A[143] = 0.000000000000000;
        A[144] = 0.000000000000000;
        A[145] = 0.000000000000000;
        A[146] = 0.000000000000000;
        A[147] = 0.000000000000000;
        A[148] = 0.000000000000000;
        A[149] = 0.000000000000000;
        A[150] = 0.000000000000000;
        A[151] = 0.000000000000000;
        A[152] = 0.000000000000000;
        A[153] = 0.000000000000000;
        A[154] = 0.000000000000000;
        A[155] = 0.000000000000000;
        A[156] = 0.000000000000000;
        A[157] = 0.000000000000000;
        A[158] = 0.000000000000000;
        A[159] = 0.000000000000000;
        A[160] = 0.000000000000000;
        A[161] = 0.000000000000000;
        A[162] = 0.000000000000000;
        A[163] = 0.000000000000000;
        A[164] = 0.000000000000000;
        A[165] = 0.000000000000000;
        A[166] = 0.000000000000000;
        A[167] = 0.000000000000000;
        A[168] = 0.000000000000000;
        A[169] = 0.000000000000000;
        A[170] = 0.000000000000000;
        A[171] = 0.000000000000000;
        A[172] = 0.000000000000000;
        A[173] = 0.000000000000000;
        A[174] = 0.000000000000000;
        A[175] = 0.000000000000000;
        A[176] = 0.000000000000000;
        A[177] = 0.000000000000000;
        A[178] = 0.000000000000000;
        A[179] = 0.000000000000000;
        A[180] = 0.000000000000000;
        A[181] = 0.000000000000000;
        A[182] = 0.000000000000000;
        A[183] = 0.000000000000000;
        A[184] = 0.000000000000000;
        A[185] = 0.000000000000000;
        A[186] = 0.092857142857143*G1_0 - 0.007142857142857*G1_2 + 0.047619047619048*G1_4;
        A[187] = 0.000000000000000;
        A[188] = -0.007142857142857*G1_0 - 0.007142857142857*G1_2 - 0.019047619047619*G1_4;
        A[189] = 0.000000000000000;
        A[190] = 0.047619047619048*G1_0 - 0.019047619047619*G1_2 + 0.038095238095238*G1_4;
        A[191] = 0.000000000000000;
        A[192] = 0.000000000000000;
        A[193] = 0.000000000000000;
        A[194] = 0.000000000000000;
        A[195] = 0.000000000000000;
        A[196] = 0.000000000000000;
        A[197] = 0.000000000000000;
        A[198] = 0.000000000000000;
        A[199] = 0.000000000000000;
        A[200] = 0.000000000000000;
        A[201] = 0.000000000000000;
        A[202] = 0.000000000000000;
        A[203] = 0.000000000000000;
        A[204] = 0.000000000000000;
        A[205] = 0.000000000000000;
        A[206] = 0.000000000000000;
        A[207] = 0.000000000000000;
        A[208] = 0.000000000000000;
        A[209] = 0.000000000000000;
        A[210] = 0.000000000000000;
        A[211] = 0.000000000000000;
        A[212] = 0.000000000000000;
        A[213] = 0.000000000000000;
        A[214] = 0.000000000000000;
        A[215] = 0.000000000000000;
        A[216] = 0.000000000000000;
        A[217] = 0.000000000000000;
        A[218] = 0.000000000000000;
        A[219] = 0.000000000000000;
        A[220] = 0.000000000000000;
        A[221] = 0.000000000000000;
        A[222] = 0.000000000000000;
        A[223] = 0.000000000000000;
        A[224] = 0.000000000000000;
        A[225] = 0.000000000000000;
        A[226] = 0.000000000000000;
        A[227] = 0.000000000000000;
        A[228] = 0.000000000000000;
        A[229] = 0.000000000000000;
        A[230] = 0.000000000000000;
        A[231] = 0.000000000000000;
        A[232] = 0.000000000000000;
        A[233] = 0.000000000000000;
        A[234] = 0.000000000000000;
        A[235] = 0.000000000000000;
        A[236] = 0.000000000000000;
        A[237] = 0.000000000000000;
        A[238] = 0.000000000000000;
        A[239] = 0.000000000000000;
        A[240] = 0.000000000000000;
        A[241] = 0.000000000000000;
        A[242] = 0.000000000000000;
        A[243] = 0.000000000000000;
        A[244] = 0.000000000000000;
        A[245] = 0.000000000000000;
        A[246] = -0.007142857142857*G1_0 - 0.007142857142857*G1_2 - 0.019047619047619*G1_4;
        A[247] = 0.000000000000000;
        A[248] = -0.007142857142857*G1_0 + 0.092857142857143*G1_2 + 0.047619047619048*G1_4;
        A[249] = 0.000000000000000;
        A[250] = -0.019047619047619*G1_0 + 0.047619047619048*G1_2 + 0.038095238095238*G1_4;
        A[251] = 0.000000000000000;
        A[252] = 0.000000000000000;
        A[253] = 0.000000000000000;
        A[254] = 0.000000000000000;
        A[255] = 0.000000000000000;
        A[256] = 0.000000000000000;
        A[257] = 0.000000000000000;
        A[258] = 0.000000000000000;
        A[259] = 0.000000000000000;
        A[260] = 0.000000000000000;
        A[261] = 0.000000000000000;
        A[262] = 0.000000000000000;
        A[263] = 0.000000000000000;
        A[264] = 0.000000000000000;
        A[265] = 0.000000000000000;
        A[266] = 0.000000000000000;
        A[267] = 0.000000000000000;
        A[268] = 0.000000000000000;
        A[269] = 0.000000000000000;
        A[270] = 0.000000000000000;
        A[271] = 0.000000000000000;
        A[272] = 0.000000000000000;
        A[273] = 0.000000000000000;
        A[274] = 0.000000000000000;
        A[275] = 0.000000000000000;
        A[276] = 0.000000000000000;
        A[277] = 0.000000000000000;
        A[278] = 0.000000000000000;
        A[279] = 0.000000000000000;
        A[280] = 0.000000000000000;
        A[281] = 0.000000000000000;
        A[282] = 0.000000000000000;
        A[283] = 0.000000000000000;
        A[284] = 0.000000000000000;
        A[285] = 0.000000000000000;
        A[286] = 0.000000000000000;
        A[287] = 0.000000000000000;
        A[288] = 0.000000000000000;
        A[289] = 0.000000000000000;
        A[290] = 0.000000000000000;
        A[291] = 0.000000000000000;
        A[292] = 0.000000000000000;
        A[293] = 0.000000000000000;
        A[294] = 0.000000000000000;
        A[295] = 0.000000000000000;
        A[296] = 0.000000000000000;
        A[297] = 0.000000000000000;
        A[298] = 0.000000000000000;
        A[299] = 0.000000000000000;
        A[300] = 0.000000000000000;
        A[301] = 0.000000000000000;
        A[302] = 0.000000000000000;
        A[303] = 0.000000000000000;
        A[304] = 0.000000000000000;
        A[305] = 0.000000000000000;
        A[306] = 0.047619047619048*G1_0 - 0.019047619047619*G1_2 + 0.038095238095238*G1_4;
        A[307] = 0.000000000000000;
        A[308] = -0.019047619047619*G1_0 + 0.047619047619048*G1_2 + 0.038095238095238*G1_4;
        A[309] = 0.000000000000000;
        A[310] = 0.038095238095238*G1_0 + 0.038095238095238*G1_2 + 0.457142857142857*G1_4;
        A[311] = 0.000000000000000;
        A[312] = 0.000000000000000;
        A[313] = 0.000000000000000;
        A[314] = 0.000000000000000;
        A[315] = 0.000000000000000;
        A[316] = 0.000000000000000;
        A[317] = 0.000000000000000;
        A[318] = 0.000000000000000;
        A[319] = 0.000000000000000;
        A[320] = 0.000000000000000;
        A[321] = 0.000000000000000;
        A[322] = 0.000000000000000;
        A[323] = 0.000000000000000;
        A[324] = 0.000000000000000;
        A[325] = 0.000000000000000;
        A[326] = 0.000000000000000;
        A[327] = 0.000000000000000;
        A[328] = 0.000000000000000;
        A[329] = 0.000000000000000;
        A[330] = 0.000000000000000;
        A[331] = 0.000000000000000;
        A[332] = 0.000000000000000;
        A[333] = 0.000000000000000;
        A[334] = 0.000000000000000;
        A[335] = 0.000000000000000;
        A[336] = 0.000000000000000;
        A[337] = 0.000000000000000;
        A[338] = 0.000000000000000;
        A[339] = 0.000000000000000;
        A[340] = 0.000000000000000;
        A[341] = 0.000000000000000;
        A[342] = 0.000000000000000;
        A[343] = 0.000000000000000;
        A[344] = 0.000000000000000;
        A[345] = 0.000000000000000;
        A[346] = 0.000000000000000;
        A[347] = 0.000000000000000;
        A[348] = 0.000000000000000;
        A[349] = 0.000000000000000;
        A[350] = 0.000000000000000;
        A[351] = 0.000000000000000;
        A[352] = 0.000000000000000;
        A[353] = 0.000000000000000;
        A[354] = 0.000000000000000;
        A[355] = 0.000000000000000;
        A[356] = 0.000000000000000;
        A[357] = 0.000000000000000;
        A[358] = 0.000000000000000;
        A[359] = 0.000000000000000;
        A[360] = 0.000000000000000;
        A[361] = 0.000000000000000;
        A[362] = 0.000000000000000;
        A[363] = 0.000000000000000;
        A[364] = 0.000000000000000;
        A[365] = 0.000000000000000;
        A[366] = 0.000000000000000;
        A[367] = 0.000000000000000;
        A[368] = 0.000000000000000;
        A[369] = 0.000000000000000;
        A[370] = 0.000000000000000;
        A[371] = 0.000000000000000;
        A[372] = 0.150000000000000*G1_0 - 0.016666666666667*G1_2 + 0.200000000000000*G1_4;
        A[373] = 0.000000000000000;
        A[374] = 0.016666666666667*G1_0 + 0.016666666666667*G1_2 + 0.133333333333333*G1_4;
        A[375] = 0.000000000000000;
        A[376] = 0.000000000000000;
        A[377] = 0.000000000000000;
        A[378] = 0.000000000000000;
        A[379] = 0.000000000000000;
        A[380] = 0.000000000000000;
        A[381] = 0.000000000000000;
        A[382] = 0.000000000000000;
        A[383] = 0.000000000000000;
        A[384] = 0.000000000000000;
        A[385] = 0.000000000000000;
        A[386] = 0.000000000000000;
        A[387] = 0.000000000000000;
        A[388] = 0.000000000000000;
        A[389] = 0.000000000000000;
        A[390] = 0.000000000000000;
        A[391] = 0.000000000000000;
        A[392] = 0.000000000000000;
        A[393] = 0.000000000000000;
        A[394] = 0.000000000000000;
        A[395] = 0.000000000000000;
        A[396] = 0.000000000000000;
        A[397] = 0.000000000000000;
        A[398] = 0.000000000000000;
        A[399] = 0.000000000000000;
        A[400] = 0.000000000000000;
        A[401] = 0.000000000000000;
        A[402] = 0.000000000000000;
        A[403] = 0.000000000000000;
        A[404] = 0.000000000000000;
        A[405] = 0.000000000000000;
        A[406] = 0.000000000000000;
        A[407] = 0.000000000000000;
        A[408] = 0.000000000000000;
        A[409] = 0.000000000000000;
        A[410] = 0.000000000000000;
        A[411] = 0.000000000000000;
        A[412] = 0.000000000000000;
        A[413] = 0.000000000000000;
        A[414] = 0.000000000000000;
        A[415] = 0.000000000000000;
        A[416] = 0.000000000000000;
        A[417] = 0.000000000000000;
        A[418] = 0.000000000000000;
        A[419] = 0.000000000000000;
        A[420] = 0.000000000000000;
        A[421] = 0.000000000000000;
        A[422] = 0.000000000000000;
        A[423] = 0.000000000000000;
        A[424] = 0.000000000000000;
        A[425] = 0.000000000000000;
        A[426] = 0.000000000000000;
        A[427] = 0.000000000000000;
        A[428] = 0.000000000000000;
        A[429] = 0.000000000000000;
        A[430] = 0.000000000000000;
        A[431] = 0.000000000000000;
        A[432] = 0.016666666666667*G1_0 + 0.016666666666667*G1_2 + 0.133333333333333*G1_4;
        A[433] = 0.000000000000000;
        A[434] = -0.016666666666667*G1_0 + 0.150000000000000*G1_2 + 0.200000000000000*G1_4;
        A[435] = 0.000000000000000;
        A[436] = 0.000000000000000;
        A[437] = 0.000000000000000;
        A[438] = 0.000000000000000;
        A[439] = 0.000000000000000;
        A[440] = 0.000000000000000;
        A[441] = 0.000000000000000;
        A[442] = 0.000000000000000;
        A[443] = 0.000000000000000;
        A[444] = 0.000000000000000;
        A[445] = 0.000000000000000;
        A[446] = 0.000000000000000;
        A[447] = 0.000000000000000;
        A[448] = 0.000000000000000;
        A[449] = 0.000000000000000;
        A[450] = 0.000000000000000;
        A[451] = 0.000000000000000;
        A[452] = 0.000000000000000;
        A[453] = 0.000000000000000;
        A[454] = 0.000000000000000;
        A[455] = 0.000000000000000;
        A[456] = 0.000000000000000;
        A[457] = 0.000000000000000;
        A[458] = 0.000000000000000;
        A[459] = 0.000000000000000;
        A[460] = 0.000000000000000;
        A[461] = 0.000000000000000;
        A[462] = 0.000000000000000;
        A[463] = 0.000000000000000;
        A[464] = 0.000000000000000;
        A[465] = 0.092857142857143*G0_6 - 0.007142857142857*G0_8 + 0.047619047619048*G0_10;
        A[466] = 0.000000000000000;
        A[467] = -0.007142857142857*G0_6 - 0.007142857142857*G0_8 - 0.019047619047619*G0_10;
        A[468] = 0.000000000000000;
        A[469] = 0.047619047619048*G0_6 - 0.019047619047619*G0_8 + 0.038095238095238*G0_10;
        A[470] = 0.000000000000000;
        A[471] = 0.000000000000000;
        A[472] = 0.000000000000000;
        A[473] = 0.000000000000000;
        A[474] = 0.000000000000000;
        A[475] = 0.000000000000000;
        A[476] = 0.000000000000000;
        A[477] = 0.000000000000000;
        A[478] = 0.000000000000000;
        A[479] = 0.000000000000000;
        A[480] = 0.000000000000000;
        A[481] = 0.000000000000000;
        A[482] = 0.000000000000000;
        A[483] = 0.000000000000000;
        A[484] = 0.000000000000000;
        A[485] = 0.000000000000000;
        A[486] = 0.000000000000000;
        A[487] = 0.000000000000000;
        A[488] = 0.000000000000000;
        A[489] = 0.000000000000000;
        A[490] = 0.000000000000000;
        A[491] = 0.000000000000000;
        A[492] = 0.000000000000000;
        A[493] = 0.000000000000000;
        A[494] = 0.000000000000000;
        A[495] = 0.000000000000000;
        A[496] = 0.000000000000000;
        A[497] = 0.000000000000000;
        A[498] = 0.000000000000000;
        A[499] = 0.000000000000000;
        A[500] = 0.000000000000000;
        A[501] = 0.000000000000000;
        A[502] = 0.000000000000000;
        A[503] = 0.000000000000000;
        A[504] = 0.000000000000000;
        A[505] = 0.000000000000000;
        A[506] = 0.000000000000000;
        A[507] = 0.000000000000000;
        A[508] = 0.000000000000000;
        A[509] = 0.000000000000000;
        A[510] = 0.000000000000000;
        A[511] = 0.000000000000000;
        A[512] = 0.000000000000000;
        A[513] = 0.000000000000000;
        A[514] = 0.000000000000000;
        A[515] = 0.000000000000000;
        A[516] = 0.000000000000000;
        A[517] = 0.000000000000000;
        A[518] = 0.000000000000000;
        A[519] = 0.000000000000000;
        A[520] = 0.000000000000000;
        A[521] = 0.000000000000000;
        A[522] = 0.000000000000000;
        A[523] = 0.000000000000000;
        A[524] = 0.000000000000000;
        A[525] = -0.007142857142857*G0_6 - 0.007142857142857*G0_8 - 0.019047619047619*G0_10;
        A[526] = 0.000000000000000;
        A[527] = -0.007142857142857*G0_6 + 0.092857142857143*G0_8 + 0.047619047619048*G0_10;
        A[528] = 0.000000000000000;
        A[529] = -0.019047619047619*G0_6 + 0.047619047619048*G0_8 + 0.038095238095238*G0_10;
        A[530] = 0.000000000000000;
        A[531] = 0.000000000000000;
        A[532] = 0.000000000000000;
        A[533] = 0.000000000000000;
        A[534] = 0.000000000000000;
        A[535] = 0.000000000000000;
        A[536] = 0.000000000000000;
        A[537] = 0.000000000000000;
        A[538] = 0.000000000000000;
        A[539] = 0.000000000000000;
        A[540] = 0.000000000000000;
        A[541] = 0.000000000000000;
        A[542] = 0.000000000000000;
        A[543] = 0.000000000000000;
        A[544] = 0.000000000000000;
        A[545] = 0.000000000000000;
        A[546] = 0.000000000000000;
        A[547] = 0.000000000000000;
        A[548] = 0.000000000000000;
        A[549] = 0.000000000000000;
        A[550] = 0.000000000000000;
        A[551] = 0.000000000000000;
        A[552] = 0.000000000000000;
        A[553] = 0.000000000000000;
        A[554] = 0.000000000000000;
        A[555] = 0.000000000000000;
        A[556] = 0.000000000000000;
        A[557] = 0.000000000000000;
        A[558] = 0.000000000000000;
        A[559] = 0.000000000000000;
        A[560] = 0.000000000000000;
        A[561] = 0.000000000000000;
        A[562] = 0.000000000000000;
        A[563] = 0.000000000000000;
        A[564] = 0.000000000000000;
        A[565] = 0.000000000000000;
        A[566] = 0.000000000000000;
        A[567] = 0.000000000000000;
        A[568] = 0.000000000000000;
        A[569] = 0.000000000000000;
        A[570] = 0.000000000000000;
        A[571] = 0.000000000000000;
        A[572] = 0.000000000000000;
        A[573] = 0.000000000000000;
        A[574] = 0.000000000000000;
        A[575] = 0.000000000000000;
        A[576] = 0.000000000000000;
        A[577] = 0.000000000000000;
        A[578] = 0.000000000000000;
        A[579] = 0.000000000000000;
        A[580] = 0.000000000000000;
        A[581] = 0.000000000000000;
        A[582] = 0.000000000000000;
        A[583] = 0.000000000000000;
        A[584] = 0.000000000000000;
        A[585] = 0.047619047619048*G0_6 - 0.019047619047619*G0_8 + 0.038095238095238*G0_10;
        A[586] = 0.000000000000000;
        A[587] = -0.019047619047619*G0_6 + 0.047619047619048*G0_8 + 0.038095238095238*G0_10;
        A[588] = 0.000000000000000;
        A[589] = 0.038095238095238*G0_6 + 0.038095238095238*G0_8 + 0.457142857142857*G0_10;
        A[590] = 0.000000000000000;
        A[591] = 0.000000000000000;
        A[592] = 0.000000000000000;
        A[593] = 0.000000000000000;
        A[594] = 0.000000000000000;
        A[595] = 0.000000000000000;
        A[596] = 0.000000000000000;
        A[597] = 0.000000000000000;
        A[598] = 0.000000000000000;
        A[599] = 0.000000000000000;
        A[600] = 0.000000000000000;
        A[601] = 0.000000000000000;
        A[602] = 0.000000000000000;
        A[603] = 0.000000000000000;
        A[604] = 0.000000000000000;
        A[605] = 0.000000000000000;
        A[606] = 0.000000000000000;
        A[607] = 0.000000000000000;
        A[608] = 0.000000000000000;
        A[609] = 0.000000000000000;
        A[610] = 0.000000000000000;
        A[611] = 0.000000000000000;
        A[612] = 0.000000000000000;
        A[613] = 0.000000000000000;
        A[614] = 0.000000000000000;
        A[615] = 0.000000000000000;
        A[616] = 0.000000000000000;
        A[617] = 0.000000000000000;
        A[618] = 0.000000000000000;
        A[619] = 0.000000000000000;
        A[620] = 0.000000000000000;
        A[621] = 0.000000000000000;
        A[622] = 0.000000000000000;
        A[623] = 0.000000000000000;
        A[624] = 0.000000000000000;
        A[625] = 0.000000000000000;
        A[626] = 0.000000000000000;
        A[627] = 0.000000000000000;
        A[628] = 0.000000000000000;
        A[629] = 0.000000000000000;
        A[630] = 0.000000000000000;
        A[631] = 0.000000000000000;
        A[632] = 0.000000000000000;
        A[633] = 0.000000000000000;
        A[634] = 0.000000000000000;
        A[635] = 0.000000000000000;
        A[636] = 0.000000000000000;
        A[637] = 0.000000000000000;
        A[638] = 0.000000000000000;
        A[639] = 0.000000000000000;
        A[640] = 0.000000000000000;
        A[641] = 0.000000000000000;
        A[642] = 0.000000000000000;
        A[643] = 0.000000000000000;
        A[644] = 0.000000000000000;
        A[645] = 0.000000000000000;
        A[646] = 0.000000000000000;
        A[647] = 0.000000000000000;
        A[648] = 0.000000000000000;
        A[649] = 0.000000000000000;
        A[650] = 0.000000000000000;
        A[651] = 0.092857142857143*G0_6 - 0.007142857142857*G0_8 + 0.047619047619048*G0_10;
        A[652] = 0.000000000000000;
        A[653] = -0.007142857142857*G0_6 - 0.007142857142857*G0_8 - 0.019047619047619*G0_10;
        A[654] = 0.000000000000000;
        A[655] = 0.047619047619048*G0_6 - 0.019047619047619*G0_8 + 0.038095238095238*G0_10;
        A[656] = 0.000000000000000;
        A[657] = 0.000000000000000;
        A[658] = 0.000000000000000;
        A[659] = 0.000000000000000;
        A[660] = 0.000000000000000;
        A[661] = 0.000000000000000;
        A[662] = 0.000000000000000;
        A[663] = 0.000000000000000;
        A[664] = 0.000000000000000;
        A[665] = 0.000000000000000;
        A[666] = 0.000000000000000;
        A[667] = 0.000000000000000;
        A[668] = 0.000000000000000;
        A[669] = 0.000000000000000;
        A[670] = 0.000000000000000;
        A[671] = 0.000000000000000;
        A[672] = 0.000000000000000;
        A[673] = 0.000000000000000;
        A[674] = 0.000000000000000;
        A[675] = 0.000000000000000;
        A[676] = 0.000000000000000;
        A[677] = 0.000000000000000;
        A[678] = 0.000000000000000;
        A[679] = 0.000000000000000;
        A[680] = 0.000000000000000;
        A[681] = 0.000000000000000;
        A[682] = 0.000000000000000;
        A[683] = 0.000000000000000;
        A[684] = 0.000000000000000;
        A[685] = 0.000000000000000;
        A[686] = 0.000000000000000;
        A[687] = 0.000000000000000;
        A[688] = 0.000000000000000;
        A[689] = 0.000000000000000;
        A[690] = 0.000000000000000;
        A[691] = 0.000000000000000;
        A[692] = 0.000000000000000;
        A[693] = 0.000000000000000;
        A[694] = 0.000000000000000;
        A[695] = 0.000000000000000;
        A[696] = 0.000000000000000;
        A[697] = 0.000000000000000;
        A[698] = 0.000000000000000;
        A[699] = 0.000000000000000;
        A[700] = 0.000000000000000;
        A[701] = 0.000000000000000;
        A[702] = 0.000000000000000;
        A[703] = 0.000000000000000;
        A[704] = 0.000000000000000;
        A[705] = 0.000000000000000;
        A[706] = 0.000000000000000;
        A[707] = 0.000000000000000;
        A[708] = 0.000000000000000;
        A[709] = 0.000000000000000;
        A[710] = 0.000000000000000;
        A[711] = -0.007142857142857*G0_6 - 0.007142857142857*G0_8 - 0.019047619047619*G0_10;
        A[712] = 0.000000000000000;
        A[713] = -0.007142857142857*G0_6 + 0.092857142857143*G0_8 + 0.047619047619048*G0_10;
        A[714] = 0.000000000000000;
        A[715] = -0.019047619047619*G0_6 + 0.047619047619048*G0_8 + 0.038095238095238*G0_10;
        A[716] = 0.000000000000000;
        A[717] = 0.000000000000000;
        A[718] = 0.000000000000000;
        A[719] = 0.000000000000000;
        A[720] = 0.000000000000000;
        A[721] = 0.000000000000000;
        A[722] = 0.000000000000000;
        A[723] = 0.000000000000000;
        A[724] = 0.000000000000000;
        A[725] = 0.000000000000000;
        A[726] = 0.000000000000000;
        A[727] = 0.000000000000000;
        A[728] = 0.000000000000000;
        A[729] = 0.000000000000000;
        A[730] = 0.000000000000000;
        A[731] = 0.000000000000000;
        A[732] = 0.000000000000000;
        A[733] = 0.000000000000000;
        A[734] = 0.000000000000000;
        A[735] = 0.000000000000000;
        A[736] = 0.000000000000000;
        A[737] = 0.000000000000000;
        A[738] = 0.000000000000000;
        A[739] = 0.000000000000000;
        A[740] = 0.000000000000000;
        A[741] = 0.000000000000000;
        A[742] = 0.000000000000000;
        A[743] = 0.000000000000000;
        A[744] = 0.000000000000000;
        A[745] = 0.000000000000000;
        A[746] = 0.000000000000000;
        A[747] = 0.000000000000000;
        A[748] = 0.000000000000000;
        A[749] = 0.000000000000000;
        A[750] = 0.000000000000000;
        A[751] = 0.000000000000000;
        A[752] = 0.000000000000000;
        A[753] = 0.000000000000000;
        A[754] = 0.000000000000000;
        A[755] = 0.000000000000000;
        A[756] = 0.000000000000000;
        A[757] = 0.000000000000000;
        A[758] = 0.000000000000000;
        A[759] = 0.000000000000000;
        A[760] = 0.000000000000000;
        A[761] = 0.000000000000000;
        A[762] = 0.000000000000000;
        A[763] = 0.000000000000000;
        A[764] = 0.000000000000000;
        A[765] = 0.000000000000000;
        A[766] = 0.000000000000000;
        A[767] = 0.000000000000000;
        A[768] = 0.000000000000000;
        A[769] = 0.000000000000000;
        A[770] = 0.000000000000000;
        A[771] = 0.047619047619048*G0_6 - 0.019047619047619*G0_8 + 0.038095238095238*G0_10;
        A[772] = 0.000000000000000;
        A[773] = -0.019047619047619*G0_6 + 0.047619047619048*G0_8 + 0.038095238095238*G0_10;
        A[774] = 0.000000000000000;
        A[775] = 0.038095238095238*G0_6 + 0.038095238095238*G0_8 + 0.457142857142857*G0_10;
        A[776] = 0.000000000000000;
        A[777] = 0.000000000000000;
        A[778] = 0.000000000000000;
        A[779] = 0.000000000000000;
        A[780] = 0.000000000000000;
        A[781] = 0.000000000000000;
        A[782] = 0.000000000000000;
        A[783] = 0.000000000000000;
        A[784] = 0.000000000000000;
        A[785] = 0.000000000000000;
        A[786] = 0.000000000000000;
        A[787] = 0.000000000000000;
        A[788] = 0.000000000000000;
        A[789] = 0.000000000000000;
        A[790] = 0.000000000000000;
        A[791] = 0.000000000000000;
        A[792] = 0.000000000000000;
        A[793] = 0.000000000000000;
        A[794] = 0.000000000000000;
        A[795] = 0.000000000000000;
        A[796] = 0.000000000000000;
        A[797] = 0.000000000000000;
        A[798] = 0.000000000000000;
        A[799] = 0.000000000000000;
        A[800] = 0.000000000000000;
        A[801] = 0.000000000000000;
        A[802] = 0.000000000000000;
        A[803] = 0.000000000000000;
        A[804] = 0.000000000000000;
        A[805] = 0.000000000000000;
        A[806] = 0.000000000000000;
        A[807] = 0.000000000000000;
        A[808] = 0.000000000000000;
        A[809] = 0.000000000000000;
        A[810] = 0.000000000000000;
        A[811] = 0.000000000000000;
        A[812] = 0.000000000000000;
        A[813] = 0.000000000000000;
        A[814] = 0.000000000000000;
        A[815] = 0.000000000000000;
        A[816] = 0.000000000000000;
        A[817] = 0.000000000000000;
        A[818] = 0.000000000000000;
        A[819] = 0.000000000000000;
        A[820] = 0.000000000000000;
        A[821] = 0.000000000000000;
        A[822] = 0.000000000000000;
        A[823] = 0.000000000000000;
        A[824] = 0.000000000000000;
        A[825] = 0.000000000000000;
        A[826] = 0.000000000000000;
        A[827] = 0.000000000000000;
        A[828] = 0.000000000000000;
        A[829] = 0.000000000000000;
        A[830] = 0.000000000000000;
        A[831] = 0.000000000000000;
        A[832] = 0.000000000000000;
        A[833] = 0.000000000000000;
        A[834] = 0.000000000000000;
        A[835] = 0.000000000000000;
        A[836] = 0.000000000000000;
        A[837] = 0.150000000000000*G0_6 - 0.016666666666667*G0_8 + 0.200000000000000*G0_10;
        A[838] = 0.000000000000000;
        A[839] = 0.016666666666667*G0_6 + 0.016666666666667*G0_8 + 0.133333333333333*G0_10;
        A[840] = 0.000000000000000;
        A[841] = 0.000000000000000;
        A[842] = 0.000000000000000;
        A[843] = 0.000000000000000;
        A[844] = 0.000000000000000;
        A[845] = 0.000000000000000;
        A[846] = 0.000000000000000;
        A[847] = 0.000000000000000;
        A[848] = 0.000000000000000;
        A[849] = 0.000000000000000;
        A[850] = 0.000000000000000;
        A[851] = 0.000000000000000;
        A[852] = 0.000000000000000;
        A[853] = 0.000000000000000;
        A[854] = 0.000000000000000;
        A[855] = 0.000000000000000;
        A[856] = 0.000000000000000;
        A[857] = 0.000000000000000;
        A[858] = 0.000000000000000;
        A[859] = 0.000000000000000;
        A[860] = 0.000000000000000;
        A[861] = 0.000000000000000;
        A[862] = 0.000000000000000;
        A[863] = 0.000000000000000;
        A[864] = 0.000000000000000;
        A[865] = 0.000000000000000;
        A[866] = 0.000000000000000;
        A[867] = 0.000000000000000;
        A[868] = 0.000000000000000;
        A[869] = 0.000000000000000;
        A[870] = 0.000000000000000;
        A[871] = 0.000000000000000;
        A[872] = 0.000000000000000;
        A[873] = 0.000000000000000;
        A[874] = 0.000000000000000;
        A[875] = 0.000000000000000;
        A[876] = 0.000000000000000;
        A[877] = 0.000000000000000;
        A[878] = 0.000000000000000;
        A[879] = 0.000000000000000;
        A[880] = 0.000000000000000;
        A[881] = 0.000000000000000;
        A[882] = 0.000000000000000;
        A[883] = 0.000000000000000;
        A[884] = 0.000000000000000;
        A[885] = 0.000000000000000;
        A[886] = 0.000000000000000;
        A[887] = 0.000000000000000;
        A[888] = 0.000000000000000;
        A[889] = 0.000000000000000;
        A[890] = 0.000000000000000;
        A[891] = 0.000000000000000;
        A[892] = 0.000000000000000;
        A[893] = 0.000000000000000;
        A[894] = 0.000000000000000;
        A[895] = 0.000000000000000;
        A[896] = 0.000000000000000;
        A[897] = 0.016666666666667*G0_6 + 0.016666666666667*G0_8 + 0.133333333333333*G0_10;
        A[898] = 0.000000000000000;
        A[899] = -0.016666666666667*G0_6 + 0.150000000000000*G0_8 + 0.200000000000000*G0_10;
          break;
        }
      case 2:
        {
          A[0] = 0.092857142857143*G1_0 - 0.007142857142857*G1_2 + 0.047619047619048*G1_4;
        A[1] = 0.000000000000000;
        A[2] = -0.007142857142857*G1_0 - 0.007142857142857*G1_2 - 0.019047619047619*G1_4;
        A[3] = 0.000000000000000;
        A[4] = 0.047619047619048*G1_0 - 0.019047619047619*G1_2 + 0.038095238095238*G1_4;
        A[5] = 0.000000000000000;
        A[6] = 0.000000000000000;
        A[7] = 0.000000000000000;
        A[8] = 0.000000000000000;
        A[9] = 0.000000000000000;
        A[10] = 0.000000000000000;
        A[11] = 0.000000000000000;
        A[12] = 0.000000000000000;
        A[13] = 0.000000000000000;
        A[14] = 0.000000000000000;
        A[15] = 0.000000000000000;
        A[16] = 0.000000000000000;
        A[17] = 0.000000000000000;
        A[18] = 0.000000000000000;
        A[19] = 0.000000000000000;
        A[20] = 0.000000000000000;
        A[21] = 0.000000000000000;
        A[22] = 0.000000000000000;
        A[23] = 0.000000000000000;
        A[24] = 0.000000000000000;
        A[25] = 0.000000000000000;
        A[26] = 0.000000000000000;
        A[27] = 0.000000000000000;
        A[28] = 0.000000000000000;
        A[29] = 0.000000000000000;
        A[30] = 0.000000000000000;
        A[31] = 0.000000000000000;
        A[32] = 0.000000000000000;
        A[33] = 0.000000000000000;
        A[34] = 0.000000000000000;
        A[35] = 0.000000000000000;
        A[36] = 0.000000000000000;
        A[37] = 0.000000000000000;
        A[38] = 0.000000000000000;
        A[39] = 0.000000000000000;
        A[40] = 0.000000000000000;
        A[41] = 0.000000000000000;
        A[42] = 0.000000000000000;
        A[43] = 0.000000000000000;
        A[44] = 0.000000000000000;
        A[45] = 0.000000000000000;
        A[46] = 0.000000000000000;
        A[47] = 0.000000000000000;
        A[48] = 0.000000000000000;
        A[49] = 0.000000000000000;
        A[50] = 0.000000000000000;
        A[51] = 0.000000000000000;
        A[52] = 0.000000000000000;
        A[53] = 0.000000000000000;
        A[54] = 0.000000000000000;
        A[55] = 0.000000000000000;
        A[56] = 0.000000000000000;
        A[57] = 0.000000000000000;
        A[58] = 0.000000000000000;
        A[59] = 0.000000000000000;
        A[60] = -0.007142857142857*G1_0 - 0.007142857142857*G1_2 - 0.019047619047619*G1_4;
        A[61] = 0.000000000000000;
        A[62] = -0.007142857142857*G1_0 + 0.092857142857143*G1_2 + 0.047619047619048*G1_4;
        A[63] = 0.000000000000000;
        A[64] = -0.019047619047619*G1_0 + 0.047619047619048*G1_2 + 0.038095238095238*G1_4;
        A[65] = 0.000000000000000;
        A[66] = 0.000000000000000;
        A[67] = 0.000000000000000;
        A[68] = 0.000000000000000;
        A[69] = 0.000000000000000;
        A[70] = 0.000000000000000;
        A[71] = 0.000000000000000;
        A[72] = 0.000000000000000;
        A[73] = 0.000000000000000;
        A[74] = 0.000000000000000;
        A[75] = 0.000000000000000;
        A[76] = 0.000000000000000;
        A[77] = 0.000000000000000;
        A[78] = 0.000000000000000;
        A[79] = 0.000000000000000;
        A[80] = 0.000000000000000;
        A[81] = 0.000000000000000;
        A[82] = 0.000000000000000;
        A[83] = 0.000000000000000;
        A[84] = 0.000000000000000;
        A[85] = 0.000000000000000;
        A[86] = 0.000000000000000;
        A[87] = 0.000000000000000;
        A[88] = 0.000000000000000;
        A[89] = 0.000000000000000;
        A[90] = 0.000000000000000;
        A[91] = 0.000000000000000;
        A[92] = 0.000000000000000;
        A[93] = 0.000000000000000;
        A[94] = 0.000000000000000;
        A[95] = 0.000000000000000;
        A[96] = 0.000000000000000;
        A[97] = 0.000000000000000;
        A[98] = 0.000000000000000;
        A[99] = 0.000000000000000;
        A[100] = 0.000000000000000;
        A[101] = 0.000000000000000;
        A[102] = 0.000000000000000;
        A[103] = 0.000000000000000;
        A[104] = 0.000000000000000;
        A[105] = 0.000000000000000;
        A[106] = 0.000000000000000;
        A[107] = 0.000000000000000;
        A[108] = 0.000000000000000;
        A[109] = 0.000000000000000;
        A[110] = 0.000000000000000;
        A[111] = 0.000000000000000;
        A[112] = 0.000000000000000;
        A[113] = 0.000000000000000;
        A[114] = 0.000000000000000;
        A[115] = 0.000000000000000;
        A[116] = 0.000000000000000;
        A[117] = 0.000000000000000;
        A[118] = 0.000000000000000;
        A[119] = 0.000000000000000;
        A[120] = 0.047619047619048*G1_0 - 0.019047619047619*G1_2 + 0.038095238095238*G1_4;
        A[121] = 0.000000000000000;
        A[122] = -0.019047619047619*G1_0 + 0.047619047619048*G1_2 + 0.038095238095238*G1_4;
        A[123] = 0.000000000000000;
        A[124] = 0.038095238095238*G1_0 + 0.038095238095238*G1_2 + 0.457142857142857*G1_4;
        A[125] = 0.000000000000000;
        A[126] = 0.000000000000000;
        A[127] = 0.000000000000000;
        A[128] = 0.000000000000000;
        A[129] = 0.000000000000000;
        A[130] = 0.000000000000000;
        A[131] = 0.000000000000000;
        A[132] = 0.000000000000000;
        A[133] = 0.000000000000000;
        A[134] = 0.000000000000000;
        A[135] = 0.000000000000000;
        A[136] = 0.000000000000000;
        A[137] = 0.000000000000000;
        A[138] = 0.000000000000000;
        A[139] = 0.000000000000000;
        A[140] = 0.000000000000000;
        A[141] = 0.000000000000000;
        A[142] = 0.000000000000000;
        A[143] = 0.000000000000000;
        A[144] = 0.000000000000000;
        A[145] = 0.000000000000000;
        A[146] = 0.000000000000000;
        A[147] = 0.000000000000000;
        A[148] = 0.000000000000000;
        A[149] = 0.000000000000000;
        A[150] = 0.000000000000000;
        A[151] = 0.000000000000000;
        A[152] = 0.000000000000000;
        A[153] = 0.000000000000000;
        A[154] = 0.000000000000000;
        A[155] = 0.000000000000000;
        A[156] = 0.000000000000000;
        A[157] = 0.000000000000000;
        A[158] = 0.000000000000000;
        A[159] = 0.000000000000000;
        A[160] = 0.000000000000000;
        A[161] = 0.000000000000000;
        A[162] = 0.000000000000000;
        A[163] = 0.000000000000000;
        A[164] = 0.000000000000000;
        A[165] = 0.000000000000000;
        A[166] = 0.000000000000000;
        A[167] = 0.000000000000000;
        A[168] = 0.000000000000000;
        A[169] = 0.000000000000000;
        A[170] = 0.000000000000000;
        A[171] = 0.000000000000000;
        A[172] = 0.000000000000000;
        A[173] = 0.000000000000000;
        A[174] = 0.000000000000000;
        A[175] = 0.000000000000000;
        A[176] = 0.000000000000000;
        A[177] = 0.000000000000000;
        A[178] = 0.000000000000000;
        A[179] = 0.000000000000000;
        A[180] = 0.000000000000000;
        A[181] = 0.000000000000000;
        A[182] = 0.000000000000000;
        A[183] = 0.000000000000000;
        A[184] = 0.000000000000000;
        A[185] = 0.000000000000000;
        A[186] = 0.092857142857143*G1_0 - 0.007142857142857*G1_2 + 0.047619047619048*G1_4;
        A[187] = 0.000000000000000;
        A[188] = -0.007142857142857*G1_0 - 0.007142857142857*G1_2 - 0.019047619047619*G1_4;
        A[189] = 0.000000000000000;
        A[190] = 0.047619047619048*G1_0 - 0.019047619047619*G1_2 + 0.038095238095238*G1_4;
        A[191] = 0.000000000000000;
        A[192] = 0.000000000000000;
        A[193] = 0.000000000000000;
        A[194] = 0.000000000000000;
        A[195] = 0.000000000000000;
        A[196] = 0.000000000000000;
        A[197] = 0.000000000000000;
        A[198] = 0.000000000000000;
        A[199] = 0.000000000000000;
        A[200] = 0.000000000000000;
        A[201] = 0.000000000000000;
        A[202] = 0.000000000000000;
        A[203] = 0.000000000000000;
        A[204] = 0.000000000000000;
        A[205] = 0.000000000000000;
        A[206] = 0.000000000000000;
        A[207] = 0.000000000000000;
        A[208] = 0.000000000000000;
        A[209] = 0.000000000000000;
        A[210] = 0.000000000000000;
        A[211] = 0.000000000000000;
        A[212] = 0.000000000000000;
        A[213] = 0.000000000000000;
        A[214] = 0.000000000000000;
        A[215] = 0.000000000000000;
        A[216] = 0.000000000000000;
        A[217] = 0.000000000000000;
        A[218] = 0.000000000000000;
        A[219] = 0.000000000000000;
        A[220] = 0.000000000000000;
        A[221] = 0.000000000000000;
        A[222] = 0.000000000000000;
        A[223] = 0.000000000000000;
        A[224] = 0.000000000000000;
        A[225] = 0.000000000000000;
        A[226] = 0.000000000000000;
        A[227] = 0.000000000000000;
        A[228] = 0.000000000000000;
        A[229] = 0.000000000000000;
        A[230] = 0.000000000000000;
        A[231] = 0.000000000000000;
        A[232] = 0.000000000000000;
        A[233] = 0.000000000000000;
        A[234] = 0.000000000000000;
        A[235] = 0.000000000000000;
        A[236] = 0.000000000000000;
        A[237] = 0.000000000000000;
        A[238] = 0.000000000000000;
        A[239] = 0.000000000000000;
        A[240] = 0.000000000000000;
        A[241] = 0.000000000000000;
        A[242] = 0.000000000000000;
        A[243] = 0.000000000000000;
        A[244] = 0.000000000000000;
        A[245] = 0.000000000000000;
        A[246] = -0.007142857142857*G1_0 - 0.007142857142857*G1_2 - 0.019047619047619*G1_4;
        A[247] = 0.000000000000000;
        A[248] = -0.007142857142857*G1_0 + 0.092857142857143*G1_2 + 0.047619047619048*G1_4;
        A[249] = 0.000000000000000;
        A[250] = -0.019047619047619*G1_0 + 0.047619047619048*G1_2 + 0.038095238095238*G1_4;
        A[251] = 0.000000000000000;
        A[252] = 0.000000000000000;
        A[253] = 0.000000000000000;
        A[254] = 0.000000000000000;
        A[255] = 0.000000000000000;
        A[256] = 0.000000000000000;
        A[257] = 0.000000000000000;
        A[258] = 0.000000000000000;
        A[259] = 0.000000000000000;
        A[260] = 0.000000000000000;
        A[261] = 0.000000000000000;
        A[262] = 0.000000000000000;
        A[263] = 0.000000000000000;
        A[264] = 0.000000000000000;
        A[265] = 0.000000000000000;
        A[266] = 0.000000000000000;
        A[267] = 0.000000000000000;
        A[268] = 0.000000000000000;
        A[269] = 0.000000000000000;
        A[270] = 0.000000000000000;
        A[271] = 0.000000000000000;
        A[272] = 0.000000000000000;
        A[273] = 0.000000000000000;
        A[274] = 0.000000000000000;
        A[275] = 0.000000000000000;
        A[276] = 0.000000000000000;
        A[277] = 0.000000000000000;
        A[278] = 0.000000000000000;
        A[279] = 0.000000000000000;
        A[280] = 0.000000000000000;
        A[281] = 0.000000000000000;
        A[282] = 0.000000000000000;
        A[283] = 0.000000000000000;
        A[284] = 0.000000000000000;
        A[285] = 0.000000000000000;
        A[286] = 0.000000000000000;
        A[287] = 0.000000000000000;
        A[288] = 0.000000000000000;
        A[289] = 0.000000000000000;
        A[290] = 0.000000000000000;
        A[291] = 0.000000000000000;
        A[292] = 0.000000000000000;
        A[293] = 0.000000000000000;
        A[294] = 0.000000000000000;
        A[295] = 0.000000000000000;
        A[296] = 0.000000000000000;
        A[297] = 0.000000000000000;
        A[298] = 0.000000000000000;
        A[299] = 0.000000000000000;
        A[300] = 0.000000000000000;
        A[301] = 0.000000000000000;
        A[302] = 0.000000000000000;
        A[303] = 0.000000000000000;
        A[304] = 0.000000000000000;
        A[305] = 0.000000000000000;
        A[306] = 0.047619047619048*G1_0 - 0.019047619047619*G1_2 + 0.038095238095238*G1_4;
        A[307] = 0.000000000000000;
        A[308] = -0.019047619047619*G1_0 + 0.047619047619048*G1_2 + 0.038095238095238*G1_4;
        A[309] = 0.000000000000000;
        A[310] = 0.038095238095238*G1_0 + 0.038095238095238*G1_2 + 0.457142857142857*G1_4;
        A[311] = 0.000000000000000;
        A[312] = 0.000000000000000;
        A[313] = 0.000000000000000;
        A[314] = 0.000000000000000;
        A[315] = 0.000000000000000;
        A[316] = 0.000000000000000;
        A[317] = 0.000000000000000;
        A[318] = 0.000000000000000;
        A[319] = 0.000000000000000;
        A[320] = 0.000000000000000;
        A[321] = 0.000000000000000;
        A[322] = 0.000000000000000;
        A[323] = 0.000000000000000;
        A[324] = 0.000000000000000;
        A[325] = 0.000000000000000;
        A[326] = 0.000000000000000;
        A[327] = 0.000000000000000;
        A[328] = 0.000000000000000;
        A[329] = 0.000000000000000;
        A[330] = 0.000000000000000;
        A[331] = 0.000000000000000;
        A[332] = 0.000000000000000;
        A[333] = 0.000000000000000;
        A[334] = 0.000000000000000;
        A[335] = 0.000000000000000;
        A[336] = 0.000000000000000;
        A[337] = 0.000000000000000;
        A[338] = 0.000000000000000;
        A[339] = 0.000000000000000;
        A[340] = 0.000000000000000;
        A[341] = 0.000000000000000;
        A[342] = 0.000000000000000;
        A[343] = 0.000000000000000;
        A[344] = 0.000000000000000;
        A[345] = 0.000000000000000;
        A[346] = 0.000000000000000;
        A[347] = 0.000000000000000;
        A[348] = 0.000000000000000;
        A[349] = 0.000000000000000;
        A[350] = 0.000000000000000;
        A[351] = 0.000000000000000;
        A[352] = 0.000000000000000;
        A[353] = 0.000000000000000;
        A[354] = 0.000000000000000;
        A[355] = 0.000000000000000;
        A[356] = 0.000000000000000;
        A[357] = 0.000000000000000;
        A[358] = 0.000000000000000;
        A[359] = 0.000000000000000;
        A[360] = 0.000000000000000;
        A[361] = 0.000000000000000;
        A[362] = 0.000000000000000;
        A[363] = 0.000000000000000;
        A[364] = 0.000000000000000;
        A[365] = 0.000000000000000;
        A[366] = 0.000000000000000;
        A[367] = 0.000000000000000;
        A[368] = 0.000000000000000;
        A[369] = 0.000000000000000;
        A[370] = 0.000000000000000;
        A[371] = 0.000000000000000;
        A[372] = 0.150000000000000*G1_0 - 0.016666666666667*G1_2 + 0.200000000000000*G1_4;
        A[373] = 0.000000000000000;
        A[374] = 0.016666666666667*G1_0 + 0.016666666666667*G1_2 + 0.133333333333333*G1_4;
        A[375] = 0.000000000000000;
        A[376] = 0.000000000000000;
        A[377] = 0.000000000000000;
        A[378] = 0.000000000000000;
        A[379] = 0.000000000000000;
        A[380] = 0.000000000000000;
        A[381] = 0.000000000000000;
        A[382] = 0.000000000000000;
        A[383] = 0.000000000000000;
        A[384] = 0.000000000000000;
        A[385] = 0.000000000000000;
        A[386] = 0.000000000000000;
        A[387] = 0.000000000000000;
        A[388] = 0.000000000000000;
        A[389] = 0.000000000000000;
        A[390] = 0.000000000000000;
        A[391] = 0.000000000000000;
        A[392] = 0.000000000000000;
        A[393] = 0.000000000000000;
        A[394] = 0.000000000000000;
        A[395] = 0.000000000000000;
        A[396] = 0.000000000000000;
        A[397] = 0.000000000000000;
        A[398] = 0.000000000000000;
        A[399] = 0.000000000000000;
        A[400] = 0.000000000000000;
        A[401] = 0.000000000000000;
        A[402] = 0.000000000000000;
        A[403] = 0.000000000000000;
        A[404] = 0.000000000000000;
        A[405] = 0.000000000000000;
        A[406] = 0.000000000000000;
        A[407] = 0.000000000000000;
        A[408] = 0.000000000000000;
        A[409] = 0.000000000000000;
        A[410] = 0.000000000000000;
        A[411] = 0.000000000000000;
        A[412] = 0.000000000000000;
        A[413] = 0.000000000000000;
        A[414] = 0.000000000000000;
        A[415] = 0.000000000000000;
        A[416] = 0.000000000000000;
        A[417] = 0.000000000000000;
        A[418] = 0.000000000000000;
        A[419] = 0.000000000000000;
        A[420] = 0.000000000000000;
        A[421] = 0.000000000000000;
        A[422] = 0.000000000000000;
        A[423] = 0.000000000000000;
        A[424] = 0.000000000000000;
        A[425] = 0.000000000000000;
        A[426] = 0.000000000000000;
        A[427] = 0.000000000000000;
        A[428] = 0.000000000000000;
        A[429] = 0.000000000000000;
        A[430] = 0.000000000000000;
        A[431] = 0.000000000000000;
        A[432] = 0.016666666666667*G1_0 + 0.016666666666667*G1_2 + 0.133333333333333*G1_4;
        A[433] = 0.000000000000000;
        A[434] = -0.016666666666667*G1_0 + 0.150000000000000*G1_2 + 0.200000000000000*G1_4;
        A[435] = 0.000000000000000;
        A[436] = 0.000000000000000;
        A[437] = 0.000000000000000;
        A[438] = 0.000000000000000;
        A[439] = 0.000000000000000;
        A[440] = 0.000000000000000;
        A[441] = 0.000000000000000;
        A[442] = 0.000000000000000;
        A[443] = 0.000000000000000;
        A[444] = 0.000000000000000;
        A[445] = 0.000000000000000;
        A[446] = 0.000000000000000;
        A[447] = 0.000000000000000;
        A[448] = 0.000000000000000;
        A[449] = 0.000000000000000;
        A[450] = 0.000000000000000;
        A[451] = 0.000000000000000;
        A[452] = 0.000000000000000;
        A[453] = 0.000000000000000;
        A[454] = 0.000000000000000;
        A[455] = 0.000000000000000;
        A[456] = 0.000000000000000;
        A[457] = 0.000000000000000;
        A[458] = 0.000000000000000;
        A[459] = 0.000000000000000;
        A[460] = 0.000000000000000;
        A[461] = 0.000000000000000;
        A[462] = 0.000000000000000;
        A[463] = 0.000000000000000;
        A[464] = 0.000000000000000;
        A[465] = 0.092857142857143*G0_6 - 0.007142857142857*G0_7 + 0.047619047619048*G0_11;
        A[466] = -0.007142857142857*G0_6 - 0.007142857142857*G0_7 - 0.019047619047619*G0_11;
        A[467] = 0.000000000000000;
        A[468] = 0.000000000000000;
        A[469] = 0.000000000000000;
        A[470] = 0.047619047619048*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[471] = 0.000000000000000;
        A[472] = 0.000000000000000;
        A[473] = 0.000000000000000;
        A[474] = 0.000000000000000;
        A[475] = 0.000000000000000;
        A[476] = 0.000000000000000;
        A[477] = 0.000000000000000;
        A[478] = 0.000000000000000;
        A[479] = 0.000000000000000;
        A[480] = 0.000000000000000;
        A[481] = 0.000000000000000;
        A[482] = 0.000000000000000;
        A[483] = 0.000000000000000;
        A[484] = 0.000000000000000;
        A[485] = 0.000000000000000;
        A[486] = 0.000000000000000;
        A[487] = 0.000000000000000;
        A[488] = 0.000000000000000;
        A[489] = 0.000000000000000;
        A[490] = 0.000000000000000;
        A[491] = 0.000000000000000;
        A[492] = 0.000000000000000;
        A[493] = 0.000000000000000;
        A[494] = 0.000000000000000;
        A[495] = -0.007142857142857*G0_6 - 0.007142857142857*G0_7 - 0.019047619047619*G0_11;
        A[496] = -0.007142857142857*G0_6 + 0.092857142857143*G0_7 + 0.047619047619048*G0_11;
        A[497] = 0.000000000000000;
        A[498] = 0.000000000000000;
        A[499] = 0.000000000000000;
        A[500] = -0.019047619047619*G0_6 + 0.047619047619048*G0_7 + 0.038095238095238*G0_11;
        A[501] = 0.000000000000000;
        A[502] = 0.000000000000000;
        A[503] = 0.000000000000000;
        A[504] = 0.000000000000000;
        A[505] = 0.000000000000000;
        A[506] = 0.000000000000000;
        A[507] = 0.000000000000000;
        A[508] = 0.000000000000000;
        A[509] = 0.000000000000000;
        A[510] = 0.000000000000000;
        A[511] = 0.000000000000000;
        A[512] = 0.000000000000000;
        A[513] = 0.000000000000000;
        A[514] = 0.000000000000000;
        A[515] = 0.000000000000000;
        A[516] = 0.000000000000000;
        A[517] = 0.000000000000000;
        A[518] = 0.000000000000000;
        A[519] = 0.000000000000000;
        A[520] = 0.000000000000000;
        A[521] = 0.000000000000000;
        A[522] = 0.000000000000000;
        A[523] = 0.000000000000000;
        A[524] = 0.000000000000000;
        A[525] = 0.000000000000000;
        A[526] = 0.000000000000000;
        A[527] = 0.000000000000000;
        A[528] = 0.000000000000000;
        A[529] = 0.000000000000000;
        A[530] = 0.000000000000000;
        A[531] = 0.000000000000000;
        A[532] = 0.000000000000000;
        A[533] = 0.000000000000000;
        A[534] = 0.000000000000000;
        A[535] = 0.000000000000000;
        A[536] = 0.000000000000000;
        A[537] = 0.000000000000000;
        A[538] = 0.000000000000000;
        A[539] = 0.000000000000000;
        A[540] = 0.000000000000000;
        A[541] = 0.000000000000000;
        A[542] = 0.000000000000000;
        A[543] = 0.000000000000000;
        A[544] = 0.000000000000000;
        A[545] = 0.000000000000000;
        A[546] = 0.000000000000000;
        A[547] = 0.000000000000000;
        A[548] = 0.000000000000000;
        A[549] = 0.000000000000000;
        A[550] = 0.000000000000000;
        A[551] = 0.000000000000000;
        A[552] = 0.000000000000000;
        A[553] = 0.000000000000000;
        A[554] = 0.000000000000000;
        A[555] = 0.000000000000000;
        A[556] = 0.000000000000000;
        A[557] = 0.000000000000000;
        A[558] = 0.000000000000000;
        A[559] = 0.000000000000000;
        A[560] = 0.000000000000000;
        A[561] = 0.000000000000000;
        A[562] = 0.000000000000000;
        A[563] = 0.000000000000000;
        A[564] = 0.000000000000000;
        A[565] = 0.000000000000000;
        A[566] = 0.000000000000000;
        A[567] = 0.000000000000000;
        A[568] = 0.000000000000000;
        A[569] = 0.000000000000000;
        A[570] = 0.000000000000000;
        A[571] = 0.000000000000000;
        A[572] = 0.000000000000000;
        A[573] = 0.000000000000000;
        A[574] = 0.000000000000000;
        A[575] = 0.000000000000000;
        A[576] = 0.000000000000000;
        A[577] = 0.000000000000000;
        A[578] = 0.000000000000000;
        A[579] = 0.000000000000000;
        A[580] = 0.000000000000000;
        A[581] = 0.000000000000000;
        A[582] = 0.000000000000000;
        A[583] = 0.000000000000000;
        A[584] = 0.000000000000000;
        A[585] = 0.000000000000000;
        A[586] = 0.000000000000000;
        A[587] = 0.000000000000000;
        A[588] = 0.000000000000000;
        A[589] = 0.000000000000000;
        A[590] = 0.000000000000000;
        A[591] = 0.000000000000000;
        A[592] = 0.000000000000000;
        A[593] = 0.000000000000000;
        A[594] = 0.000000000000000;
        A[595] = 0.000000000000000;
        A[596] = 0.000000000000000;
        A[597] = 0.000000000000000;
        A[598] = 0.000000000000000;
        A[599] = 0.000000000000000;
        A[600] = 0.000000000000000;
        A[601] = 0.000000000000000;
        A[602] = 0.000000000000000;
        A[603] = 0.000000000000000;
        A[604] = 0.000000000000000;
        A[605] = 0.000000000000000;
        A[606] = 0.000000000000000;
        A[607] = 0.000000000000000;
        A[608] = 0.000000000000000;
        A[609] = 0.000000000000000;
        A[610] = 0.000000000000000;
        A[611] = 0.000000000000000;
        A[612] = 0.000000000000000;
        A[613] = 0.000000000000000;
        A[614] = 0.000000000000000;
        A[615] = 0.047619047619048*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[616] = -0.019047619047619*G0_6 + 0.047619047619048*G0_7 + 0.038095238095238*G0_11;
        A[617] = 0.000000000000000;
        A[618] = 0.000000000000000;
        A[619] = 0.000000000000000;
        A[620] = 0.038095238095238*G0_6 + 0.038095238095238*G0_7 + 0.457142857142857*G0_11;
        A[621] = 0.000000000000000;
        A[622] = 0.000000000000000;
        A[623] = 0.000000000000000;
        A[624] = 0.000000000000000;
        A[625] = 0.000000000000000;
        A[626] = 0.000000000000000;
        A[627] = 0.000000000000000;
        A[628] = 0.000000000000000;
        A[629] = 0.000000000000000;
        A[630] = 0.000000000000000;
        A[631] = 0.000000000000000;
        A[632] = 0.000000000000000;
        A[633] = 0.000000000000000;
        A[634] = 0.000000000000000;
        A[635] = 0.000000000000000;
        A[636] = 0.000000000000000;
        A[637] = 0.000000000000000;
        A[638] = 0.000000000000000;
        A[639] = 0.000000000000000;
        A[640] = 0.000000000000000;
        A[641] = 0.000000000000000;
        A[642] = 0.000000000000000;
        A[643] = 0.000000000000000;
        A[644] = 0.000000000000000;
        A[645] = 0.000000000000000;
        A[646] = 0.000000000000000;
        A[647] = 0.000000000000000;
        A[648] = 0.000000000000000;
        A[649] = 0.000000000000000;
        A[650] = 0.000000000000000;
        A[651] = 0.092857142857143*G0_6 - 0.007142857142857*G0_7 + 0.047619047619048*G0_11;
        A[652] = -0.007142857142857*G0_6 - 0.007142857142857*G0_7 - 0.019047619047619*G0_11;
        A[653] = 0.000000000000000;
        A[654] = 0.000000000000000;
        A[655] = 0.000000000000000;
        A[656] = 0.047619047619048*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[657] = 0.000000000000000;
        A[658] = 0.000000000000000;
        A[659] = 0.000000000000000;
        A[660] = 0.000000000000000;
        A[661] = 0.000000000000000;
        A[662] = 0.000000000000000;
        A[663] = 0.000000000000000;
        A[664] = 0.000000000000000;
        A[665] = 0.000000000000000;
        A[666] = 0.000000000000000;
        A[667] = 0.000000000000000;
        A[668] = 0.000000000000000;
        A[669] = 0.000000000000000;
        A[670] = 0.000000000000000;
        A[671] = 0.000000000000000;
        A[672] = 0.000000000000000;
        A[673] = 0.000000000000000;
        A[674] = 0.000000000000000;
        A[675] = 0.000000000000000;
        A[676] = 0.000000000000000;
        A[677] = 0.000000000000000;
        A[678] = 0.000000000000000;
        A[679] = 0.000000000000000;
        A[680] = 0.000000000000000;
        A[681] = -0.007142857142857*G0_6 - 0.007142857142857*G0_7 - 0.019047619047619*G0_11;
        A[682] = -0.007142857142857*G0_6 + 0.092857142857143*G0_7 + 0.047619047619048*G0_11;
        A[683] = 0.000000000000000;
        A[684] = 0.000000000000000;
        A[685] = 0.000000000000000;
        A[686] = -0.019047619047619*G0_6 + 0.047619047619048*G0_7 + 0.038095238095238*G0_11;
        A[687] = 0.000000000000000;
        A[688] = 0.000000000000000;
        A[689] = 0.000000000000000;
        A[690] = 0.000000000000000;
        A[691] = 0.000000000000000;
        A[692] = 0.000000000000000;
        A[693] = 0.000000000000000;
        A[694] = 0.000000000000000;
        A[695] = 0.000000000000000;
        A[696] = 0.000000000000000;
        A[697] = 0.000000000000000;
        A[698] = 0.000000000000000;
        A[699] = 0.000000000000000;
        A[700] = 0.000000000000000;
        A[701] = 0.000000000000000;
        A[702] = 0.000000000000000;
        A[703] = 0.000000000000000;
        A[704] = 0.000000000000000;
        A[705] = 0.000000000000000;
        A[706] = 0.000000000000000;
        A[707] = 0.000000000000000;
        A[708] = 0.000000000000000;
        A[709] = 0.000000000000000;
        A[710] = 0.000000000000000;
        A[711] = 0.000000000000000;
        A[712] = 0.000000000000000;
        A[713] = 0.000000000000000;
        A[714] = 0.000000000000000;
        A[715] = 0.000000000000000;
        A[716] = 0.000000000000000;
        A[717] = 0.000000000000000;
        A[718] = 0.000000000000000;
        A[719] = 0.000000000000000;
        A[720] = 0.000000000000000;
        A[721] = 0.000000000000000;
        A[722] = 0.000000000000000;
        A[723] = 0.000000000000000;
        A[724] = 0.000000000000000;
        A[725] = 0.000000000000000;
        A[726] = 0.000000000000000;
        A[727] = 0.000000000000000;
        A[728] = 0.000000000000000;
        A[729] = 0.000000000000000;
        A[730] = 0.000000000000000;
        A[731] = 0.000000000000000;
        A[732] = 0.000000000000000;
        A[733] = 0.000000000000000;
        A[734] = 0.000000000000000;
        A[735] = 0.000000000000000;
        A[736] = 0.000000000000000;
        A[737] = 0.000000000000000;
        A[738] = 0.000000000000000;
        A[739] = 0.000000000000000;
        A[740] = 0.000000000000000;
        A[741] = 0.000000000000000;
        A[742] = 0.000000000000000;
        A[743] = 0.000000000000000;
        A[744] = 0.000000000000000;
        A[745] = 0.000000000000000;
        A[746] = 0.000000000000000;
        A[747] = 0.000000000000000;
        A[748] = 0.000000000000000;
        A[749] = 0.000000000000000;
        A[750] = 0.000000000000000;
        A[751] = 0.000000000000000;
        A[752] = 0.000000000000000;
        A[753] = 0.000000000000000;
        A[754] = 0.000000000000000;
        A[755] = 0.000000000000000;
        A[756] = 0.000000000000000;
        A[757] = 0.000000000000000;
        A[758] = 0.000000000000000;
        A[759] = 0.000000000000000;
        A[760] = 0.000000000000000;
        A[761] = 0.000000000000000;
        A[762] = 0.000000000000000;
        A[763] = 0.000000000000000;
        A[764] = 0.000000000000000;
        A[765] = 0.000000000000000;
        A[766] = 0.000000000000000;
        A[767] = 0.000000000000000;
        A[768] = 0.000000000000000;
        A[769] = 0.000000000000000;
        A[770] = 0.000000000000000;
        A[771] = 0.000000000000000;
        A[772] = 0.000000000000000;
        A[773] = 0.000000000000000;
        A[774] = 0.000000000000000;
        A[775] = 0.000000000000000;
        A[776] = 0.000000000000000;
        A[777] = 0.000000000000000;
        A[778] = 0.000000000000000;
        A[779] = 0.000000000000000;
        A[780] = 0.000000000000000;
        A[781] = 0.000000000000000;
        A[782] = 0.000000000000000;
        A[783] = 0.000000000000000;
        A[784] = 0.000000000000000;
        A[785] = 0.000000000000000;
        A[786] = 0.000000000000000;
        A[787] = 0.000000000000000;
        A[788] = 0.000000000000000;
        A[789] = 0.000000000000000;
        A[790] = 0.000000000000000;
        A[791] = 0.000000000000000;
        A[792] = 0.000000000000000;
        A[793] = 0.000000000000000;
        A[794] = 0.000000000000000;
        A[795] = 0.000000000000000;
        A[796] = 0.000000000000000;
        A[797] = 0.000000000000000;
        A[798] = 0.000000000000000;
        A[799] = 0.000000000000000;
        A[800] = 0.000000000000000;
        A[801] = 0.047619047619048*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[802] = -0.019047619047619*G0_6 + 0.047619047619048*G0_7 + 0.038095238095238*G0_11;
        A[803] = 0.000000000000000;
        A[804] = 0.000000000000000;
        A[805] = 0.000000000000000;
        A[806] = 0.038095238095238*G0_6 + 0.038095238095238*G0_7 + 0.457142857142857*G0_11;
        A[807] = 0.000000000000000;
        A[808] = 0.000000000000000;
        A[809] = 0.000000000000000;
        A[810] = 0.000000000000000;
        A[811] = 0.000000000000000;
        A[812] = 0.000000000000000;
        A[813] = 0.000000000000000;
        A[814] = 0.000000000000000;
        A[815] = 0.000000000000000;
        A[816] = 0.000000000000000;
        A[817] = 0.000000000000000;
        A[818] = 0.000000000000000;
        A[819] = 0.000000000000000;
        A[820] = 0.000000000000000;
        A[821] = 0.000000000000000;
        A[822] = 0.000000000000000;
        A[823] = 0.000000000000000;
        A[824] = 0.000000000000000;
        A[825] = 0.000000000000000;
        A[826] = 0.000000000000000;
        A[827] = 0.000000000000000;
        A[828] = 0.000000000000000;
        A[829] = 0.000000000000000;
        A[830] = 0.000000000000000;
        A[831] = 0.000000000000000;
        A[832] = 0.000000000000000;
        A[833] = 0.000000000000000;
        A[834] = 0.000000000000000;
        A[835] = 0.000000000000000;
        A[836] = 0.000000000000000;
        A[837] = 0.150000000000000*G0_6 - 0.016666666666667*G0_7 + 0.200000000000000*G0_11;
        A[838] = 0.016666666666667*G0_6 + 0.016666666666667*G0_7 + 0.133333333333333*G0_11;
        A[839] = 0.000000000000000;
        A[840] = 0.000000000000000;
        A[841] = 0.000000000000000;
        A[842] = 0.000000000000000;
        A[843] = 0.000000000000000;
        A[844] = 0.000000000000000;
        A[845] = 0.000000000000000;
        A[846] = 0.000000000000000;
        A[847] = 0.000000000000000;
        A[848] = 0.000000000000000;
        A[849] = 0.000000000000000;
        A[850] = 0.000000000000000;
        A[851] = 0.000000000000000;
        A[852] = 0.000000000000000;
        A[853] = 0.000000000000000;
        A[854] = 0.000000000000000;
        A[855] = 0.000000000000000;
        A[856] = 0.000000000000000;
        A[857] = 0.000000000000000;
        A[858] = 0.000000000000000;
        A[859] = 0.000000000000000;
        A[860] = 0.000000000000000;
        A[861] = 0.000000000000000;
        A[862] = 0.000000000000000;
        A[863] = 0.000000000000000;
        A[864] = 0.000000000000000;
        A[865] = 0.000000000000000;
        A[866] = 0.000000000000000;
        A[867] = 0.016666666666667*G0_6 + 0.016666666666667*G0_7 + 0.133333333333333*G0_11;
        A[868] = -0.016666666666667*G0_6 + 0.150000000000000*G0_7 + 0.200000000000000*G0_11;
        A[869] = 0.000000000000000;
        A[870] = 0.000000000000000;
        A[871] = 0.000000000000000;
        A[872] = 0.000000000000000;
        A[873] = 0.000000000000000;
        A[874] = 0.000000000000000;
        A[875] = 0.000000000000000;
        A[876] = 0.000000000000000;
        A[877] = 0.000000000000000;
        A[878] = 0.000000000000000;
        A[879] = 0.000000000000000;
        A[880] = 0.000000000000000;
        A[881] = 0.000000000000000;
        A[882] = 0.000000000000000;
        A[883] = 0.000000000000000;
        A[884] = 0.000000000000000;
        A[885] = 0.000000000000000;
        A[886] = 0.000000000000000;
        A[887] = 0.000000000000000;
        A[888] = 0.000000000000000;
        A[889] = 0.000000000000000;
        A[890] = 0.000000000000000;
        A[891] = 0.000000000000000;
        A[892] = 0.000000000000000;
        A[893] = 0.000000000000000;
        A[894] = 0.000000000000000;
        A[895] = 0.000000000000000;
        A[896] = 0.000000000000000;
        A[897] = 0.000000000000000;
        A[898] = 0.000000000000000;
        A[899] = 0.000000000000000;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        switch (facet1)
      {
      case 0:
        {
          A[0] = 0.092857142857143*G1_0 - 0.007142857142857*G1_1 + 0.047619047619048*G1_5;
        A[1] = -0.007142857142857*G1_0 - 0.007142857142857*G1_1 - 0.019047619047619*G1_5;
        A[2] = 0.000000000000000;
        A[3] = 0.000000000000000;
        A[4] = 0.000000000000000;
        A[5] = 0.047619047619048*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[6] = 0.000000000000000;
        A[7] = 0.000000000000000;
        A[8] = 0.000000000000000;
        A[9] = 0.000000000000000;
        A[10] = 0.000000000000000;
        A[11] = 0.000000000000000;
        A[12] = 0.000000000000000;
        A[13] = 0.000000000000000;
        A[14] = 0.000000000000000;
        A[15] = 0.000000000000000;
        A[16] = 0.000000000000000;
        A[17] = 0.000000000000000;
        A[18] = 0.000000000000000;
        A[19] = 0.000000000000000;
        A[20] = 0.000000000000000;
        A[21] = 0.000000000000000;
        A[22] = 0.000000000000000;
        A[23] = 0.000000000000000;
        A[24] = 0.000000000000000;
        A[25] = 0.000000000000000;
        A[26] = 0.000000000000000;
        A[27] = 0.000000000000000;
        A[28] = 0.000000000000000;
        A[29] = 0.000000000000000;
        A[30] = -0.007142857142857*G1_0 - 0.007142857142857*G1_1 - 0.019047619047619*G1_5;
        A[31] = -0.007142857142857*G1_0 + 0.092857142857143*G1_1 + 0.047619047619048*G1_5;
        A[32] = 0.000000000000000;
        A[33] = 0.000000000000000;
        A[34] = 0.000000000000000;
        A[35] = -0.019047619047619*G1_0 + 0.047619047619048*G1_1 + 0.038095238095238*G1_5;
        A[36] = 0.000000000000000;
        A[37] = 0.000000000000000;
        A[38] = 0.000000000000000;
        A[39] = 0.000000000000000;
        A[40] = 0.000000000000000;
        A[41] = 0.000000000000000;
        A[42] = 0.000000000000000;
        A[43] = 0.000000000000000;
        A[44] = 0.000000000000000;
        A[45] = 0.000000000000000;
        A[46] = 0.000000000000000;
        A[47] = 0.000000000000000;
        A[48] = 0.000000000000000;
        A[49] = 0.000000000000000;
        A[50] = 0.000000000000000;
        A[51] = 0.000000000000000;
        A[52] = 0.000000000000000;
        A[53] = 0.000000000000000;
        A[54] = 0.000000000000000;
        A[55] = 0.000000000000000;
        A[56] = 0.000000000000000;
        A[57] = 0.000000000000000;
        A[58] = 0.000000000000000;
        A[59] = 0.000000000000000;
        A[60] = 0.000000000000000;
        A[61] = 0.000000000000000;
        A[62] = 0.000000000000000;
        A[63] = 0.000000000000000;
        A[64] = 0.000000000000000;
        A[65] = 0.000000000000000;
        A[66] = 0.000000000000000;
        A[67] = 0.000000000000000;
        A[68] = 0.000000000000000;
        A[69] = 0.000000000000000;
        A[70] = 0.000000000000000;
        A[71] = 0.000000000000000;
        A[72] = 0.000000000000000;
        A[73] = 0.000000000000000;
        A[74] = 0.000000000000000;
        A[75] = 0.000000000000000;
        A[76] = 0.000000000000000;
        A[77] = 0.000000000000000;
        A[78] = 0.000000000000000;
        A[79] = 0.000000000000000;
        A[80] = 0.000000000000000;
        A[81] = 0.000000000000000;
        A[82] = 0.000000000000000;
        A[83] = 0.000000000000000;
        A[84] = 0.000000000000000;
        A[85] = 0.000000000000000;
        A[86] = 0.000000000000000;
        A[87] = 0.000000000000000;
        A[88] = 0.000000000000000;
        A[89] = 0.000000000000000;
        A[90] = 0.000000000000000;
        A[91] = 0.000000000000000;
        A[92] = 0.000000000000000;
        A[93] = 0.000000000000000;
        A[94] = 0.000000000000000;
        A[95] = 0.000000000000000;
        A[96] = 0.000000000000000;
        A[97] = 0.000000000000000;
        A[98] = 0.000000000000000;
        A[99] = 0.000000000000000;
        A[100] = 0.000000000000000;
        A[101] = 0.000000000000000;
        A[102] = 0.000000000000000;
        A[103] = 0.000000000000000;
        A[104] = 0.000000000000000;
        A[105] = 0.000000000000000;
        A[106] = 0.000000000000000;
        A[107] = 0.000000000000000;
        A[108] = 0.000000000000000;
        A[109] = 0.000000000000000;
        A[110] = 0.000000000000000;
        A[111] = 0.000000000000000;
        A[112] = 0.000000000000000;
        A[113] = 0.000000000000000;
        A[114] = 0.000000000000000;
        A[115] = 0.000000000000000;
        A[116] = 0.000000000000000;
        A[117] = 0.000000000000000;
        A[118] = 0.000000000000000;
        A[119] = 0.000000000000000;
        A[120] = 0.000000000000000;
        A[121] = 0.000000000000000;
        A[122] = 0.000000000000000;
        A[123] = 0.000000000000000;
        A[124] = 0.000000000000000;
        A[125] = 0.000000000000000;
        A[126] = 0.000000000000000;
        A[127] = 0.000000000000000;
        A[128] = 0.000000000000000;
        A[129] = 0.000000000000000;
        A[130] = 0.000000000000000;
        A[131] = 0.000000000000000;
        A[132] = 0.000000000000000;
        A[133] = 0.000000000000000;
        A[134] = 0.000000000000000;
        A[135] = 0.000000000000000;
        A[136] = 0.000000000000000;
        A[137] = 0.000000000000000;
        A[138] = 0.000000000000000;
        A[139] = 0.000000000000000;
        A[140] = 0.000000000000000;
        A[141] = 0.000000000000000;
        A[142] = 0.000000000000000;
        A[143] = 0.000000000000000;
        A[144] = 0.000000000000000;
        A[145] = 0.000000000000000;
        A[146] = 0.000000000000000;
        A[147] = 0.000000000000000;
        A[148] = 0.000000000000000;
        A[149] = 0.000000000000000;
        A[150] = 0.047619047619048*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[151] = -0.019047619047619*G1_0 + 0.047619047619048*G1_1 + 0.038095238095238*G1_5;
        A[152] = 0.000000000000000;
        A[153] = 0.000000000000000;
        A[154] = 0.000000000000000;
        A[155] = 0.038095238095238*G1_0 + 0.038095238095238*G1_1 + 0.457142857142857*G1_5;
        A[156] = 0.000000000000000;
        A[157] = 0.000000000000000;
        A[158] = 0.000000000000000;
        A[159] = 0.000000000000000;
        A[160] = 0.000000000000000;
        A[161] = 0.000000000000000;
        A[162] = 0.000000000000000;
        A[163] = 0.000000000000000;
        A[164] = 0.000000000000000;
        A[165] = 0.000000000000000;
        A[166] = 0.000000000000000;
        A[167] = 0.000000000000000;
        A[168] = 0.000000000000000;
        A[169] = 0.000000000000000;
        A[170] = 0.000000000000000;
        A[171] = 0.000000000000000;
        A[172] = 0.000000000000000;
        A[173] = 0.000000000000000;
        A[174] = 0.000000000000000;
        A[175] = 0.000000000000000;
        A[176] = 0.000000000000000;
        A[177] = 0.000000000000000;
        A[178] = 0.000000000000000;
        A[179] = 0.000000000000000;
        A[180] = 0.000000000000000;
        A[181] = 0.000000000000000;
        A[182] = 0.000000000000000;
        A[183] = 0.000000000000000;
        A[184] = 0.000000000000000;
        A[185] = 0.000000000000000;
        A[186] = 0.092857142857143*G1_0 - 0.007142857142857*G1_1 + 0.047619047619048*G1_5;
        A[187] = -0.007142857142857*G1_0 - 0.007142857142857*G1_1 - 0.019047619047619*G1_5;
        A[188] = 0.000000000000000;
        A[189] = 0.000000000000000;
        A[190] = 0.000000000000000;
        A[191] = 0.047619047619048*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[192] = 0.000000000000000;
        A[193] = 0.000000000000000;
        A[194] = 0.000000000000000;
        A[195] = 0.000000000000000;
        A[196] = 0.000000000000000;
        A[197] = 0.000000000000000;
        A[198] = 0.000000000000000;
        A[199] = 0.000000000000000;
        A[200] = 0.000000000000000;
        A[201] = 0.000000000000000;
        A[202] = 0.000000000000000;
        A[203] = 0.000000000000000;
        A[204] = 0.000000000000000;
        A[205] = 0.000000000000000;
        A[206] = 0.000000000000000;
        A[207] = 0.000000000000000;
        A[208] = 0.000000000000000;
        A[209] = 0.000000000000000;
        A[210] = 0.000000000000000;
        A[211] = 0.000000000000000;
        A[212] = 0.000000000000000;
        A[213] = 0.000000000000000;
        A[214] = 0.000000000000000;
        A[215] = 0.000000000000000;
        A[216] = -0.007142857142857*G1_0 - 0.007142857142857*G1_1 - 0.019047619047619*G1_5;
        A[217] = -0.007142857142857*G1_0 + 0.092857142857143*G1_1 + 0.047619047619048*G1_5;
        A[218] = 0.000000000000000;
        A[219] = 0.000000000000000;
        A[220] = 0.000000000000000;
        A[221] = -0.019047619047619*G1_0 + 0.047619047619048*G1_1 + 0.038095238095238*G1_5;
        A[222] = 0.000000000000000;
        A[223] = 0.000000000000000;
        A[224] = 0.000000000000000;
        A[225] = 0.000000000000000;
        A[226] = 0.000000000000000;
        A[227] = 0.000000000000000;
        A[228] = 0.000000000000000;
        A[229] = 0.000000000000000;
        A[230] = 0.000000000000000;
        A[231] = 0.000000000000000;
        A[232] = 0.000000000000000;
        A[233] = 0.000000000000000;
        A[234] = 0.000000000000000;
        A[235] = 0.000000000000000;
        A[236] = 0.000000000000000;
        A[237] = 0.000000000000000;
        A[238] = 0.000000000000000;
        A[239] = 0.000000000000000;
        A[240] = 0.000000000000000;
        A[241] = 0.000000000000000;
        A[242] = 0.000000000000000;
        A[243] = 0.000000000000000;
        A[244] = 0.000000000000000;
        A[245] = 0.000000000000000;
        A[246] = 0.000000000000000;
        A[247] = 0.000000000000000;
        A[248] = 0.000000000000000;
        A[249] = 0.000000000000000;
        A[250] = 0.000000000000000;
        A[251] = 0.000000000000000;
        A[252] = 0.000000000000000;
        A[253] = 0.000000000000000;
        A[254] = 0.000000000000000;
        A[255] = 0.000000000000000;
        A[256] = 0.000000000000000;
        A[257] = 0.000000000000000;
        A[258] = 0.000000000000000;
        A[259] = 0.000000000000000;
        A[260] = 0.000000000000000;
        A[261] = 0.000000000000000;
        A[262] = 0.000000000000000;
        A[263] = 0.000000000000000;
        A[264] = 0.000000000000000;
        A[265] = 0.000000000000000;
        A[266] = 0.000000000000000;
        A[267] = 0.000000000000000;
        A[268] = 0.000000000000000;
        A[269] = 0.000000000000000;
        A[270] = 0.000000000000000;
        A[271] = 0.000000000000000;
        A[272] = 0.000000000000000;
        A[273] = 0.000000000000000;
        A[274] = 0.000000000000000;
        A[275] = 0.000000000000000;
        A[276] = 0.000000000000000;
        A[277] = 0.000000000000000;
        A[278] = 0.000000000000000;
        A[279] = 0.000000000000000;
        A[280] = 0.000000000000000;
        A[281] = 0.000000000000000;
        A[282] = 0.000000000000000;
        A[283] = 0.000000000000000;
        A[284] = 0.000000000000000;
        A[285] = 0.000000000000000;
        A[286] = 0.000000000000000;
        A[287] = 0.000000000000000;
        A[288] = 0.000000000000000;
        A[289] = 0.000000000000000;
        A[290] = 0.000000000000000;
        A[291] = 0.000000000000000;
        A[292] = 0.000000000000000;
        A[293] = 0.000000000000000;
        A[294] = 0.000000000000000;
        A[295] = 0.000000000000000;
        A[296] = 0.000000000000000;
        A[297] = 0.000000000000000;
        A[298] = 0.000000000000000;
        A[299] = 0.000000000000000;
        A[300] = 0.000000000000000;
        A[301] = 0.000000000000000;
        A[302] = 0.000000000000000;
        A[303] = 0.000000000000000;
        A[304] = 0.000000000000000;
        A[305] = 0.000000000000000;
        A[306] = 0.000000000000000;
        A[307] = 0.000000000000000;
        A[308] = 0.000000000000000;
        A[309] = 0.000000000000000;
        A[310] = 0.000000000000000;
        A[311] = 0.000000000000000;
        A[312] = 0.000000000000000;
        A[313] = 0.000000000000000;
        A[314] = 0.000000000000000;
        A[315] = 0.000000000000000;
        A[316] = 0.000000000000000;
        A[317] = 0.000000000000000;
        A[318] = 0.000000000000000;
        A[319] = 0.000000000000000;
        A[320] = 0.000000000000000;
        A[321] = 0.000000000000000;
        A[322] = 0.000000000000000;
        A[323] = 0.000000000000000;
        A[324] = 0.000000000000000;
        A[325] = 0.000000000000000;
        A[326] = 0.000000000000000;
        A[327] = 0.000000000000000;
        A[328] = 0.000000000000000;
        A[329] = 0.000000000000000;
        A[330] = 0.000000000000000;
        A[331] = 0.000000000000000;
        A[332] = 0.000000000000000;
        A[333] = 0.000000000000000;
        A[334] = 0.000000000000000;
        A[335] = 0.000000000000000;
        A[336] = 0.047619047619048*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[337] = -0.019047619047619*G1_0 + 0.047619047619048*G1_1 + 0.038095238095238*G1_5;
        A[338] = 0.000000000000000;
        A[339] = 0.000000000000000;
        A[340] = 0.000000000000000;
        A[341] = 0.038095238095238*G1_0 + 0.038095238095238*G1_1 + 0.457142857142857*G1_5;
        A[342] = 0.000000000000000;
        A[343] = 0.000000000000000;
        A[344] = 0.000000000000000;
        A[345] = 0.000000000000000;
        A[346] = 0.000000000000000;
        A[347] = 0.000000000000000;
        A[348] = 0.000000000000000;
        A[349] = 0.000000000000000;
        A[350] = 0.000000000000000;
        A[351] = 0.000000000000000;
        A[352] = 0.000000000000000;
        A[353] = 0.000000000000000;
        A[354] = 0.000000000000000;
        A[355] = 0.000000000000000;
        A[356] = 0.000000000000000;
        A[357] = 0.000000000000000;
        A[358] = 0.000000000000000;
        A[359] = 0.000000000000000;
        A[360] = 0.000000000000000;
        A[361] = 0.000000000000000;
        A[362] = 0.000000000000000;
        A[363] = 0.000000000000000;
        A[364] = 0.000000000000000;
        A[365] = 0.000000000000000;
        A[366] = 0.000000000000000;
        A[367] = 0.000000000000000;
        A[368] = 0.000000000000000;
        A[369] = 0.000000000000000;
        A[370] = 0.000000000000000;
        A[371] = 0.000000000000000;
        A[372] = 0.150000000000000*G1_0 - 0.016666666666667*G1_1 + 0.200000000000000*G1_5;
        A[373] = 0.016666666666667*G1_0 + 0.016666666666667*G1_1 + 0.133333333333333*G1_5;
        A[374] = 0.000000000000000;
        A[375] = 0.000000000000000;
        A[376] = 0.000000000000000;
        A[377] = 0.000000000000000;
        A[378] = 0.000000000000000;
        A[379] = 0.000000000000000;
        A[380] = 0.000000000000000;
        A[381] = 0.000000000000000;
        A[382] = 0.000000000000000;
        A[383] = 0.000000000000000;
        A[384] = 0.000000000000000;
        A[385] = 0.000000000000000;
        A[386] = 0.000000000000000;
        A[387] = 0.000000000000000;
        A[388] = 0.000000000000000;
        A[389] = 0.000000000000000;
        A[390] = 0.000000000000000;
        A[391] = 0.000000000000000;
        A[392] = 0.000000000000000;
        A[393] = 0.000000000000000;
        A[394] = 0.000000000000000;
        A[395] = 0.000000000000000;
        A[396] = 0.000000000000000;
        A[397] = 0.000000000000000;
        A[398] = 0.000000000000000;
        A[399] = 0.000000000000000;
        A[400] = 0.000000000000000;
        A[401] = 0.000000000000000;
        A[402] = 0.016666666666667*G1_0 + 0.016666666666667*G1_1 + 0.133333333333333*G1_5;
        A[403] = -0.016666666666667*G1_0 + 0.150000000000000*G1_1 + 0.200000000000000*G1_5;
        A[404] = 0.000000000000000;
        A[405] = 0.000000000000000;
        A[406] = 0.000000000000000;
        A[407] = 0.000000000000000;
        A[408] = 0.000000000000000;
        A[409] = 0.000000000000000;
        A[410] = 0.000000000000000;
        A[411] = 0.000000000000000;
        A[412] = 0.000000000000000;
        A[413] = 0.000000000000000;
        A[414] = 0.000000000000000;
        A[415] = 0.000000000000000;
        A[416] = 0.000000000000000;
        A[417] = 0.000000000000000;
        A[418] = 0.000000000000000;
        A[419] = 0.000000000000000;
        A[420] = 0.000000000000000;
        A[421] = 0.000000000000000;
        A[422] = 0.000000000000000;
        A[423] = 0.000000000000000;
        A[424] = 0.000000000000000;
        A[425] = 0.000000000000000;
        A[426] = 0.000000000000000;
        A[427] = 0.000000000000000;
        A[428] = 0.000000000000000;
        A[429] = 0.000000000000000;
        A[430] = 0.000000000000000;
        A[431] = 0.000000000000000;
        A[432] = 0.000000000000000;
        A[433] = 0.000000000000000;
        A[434] = 0.000000000000000;
        A[435] = 0.000000000000000;
        A[436] = 0.000000000000000;
        A[437] = 0.000000000000000;
        A[438] = 0.000000000000000;
        A[439] = 0.000000000000000;
        A[440] = 0.000000000000000;
        A[441] = 0.000000000000000;
        A[442] = 0.000000000000000;
        A[443] = 0.000000000000000;
        A[444] = 0.000000000000000;
        A[445] = 0.000000000000000;
        A[446] = 0.000000000000000;
        A[447] = 0.000000000000000;
        A[448] = 0.000000000000000;
        A[449] = 0.000000000000000;
        A[450] = 0.000000000000000;
        A[451] = 0.000000000000000;
        A[452] = 0.000000000000000;
        A[453] = 0.000000000000000;
        A[454] = 0.000000000000000;
        A[455] = 0.000000000000000;
        A[456] = 0.000000000000000;
        A[457] = 0.000000000000000;
        A[458] = 0.000000000000000;
        A[459] = 0.000000000000000;
        A[460] = 0.000000000000000;
        A[461] = 0.000000000000000;
        A[462] = 0.000000000000000;
        A[463] = 0.000000000000000;
        A[464] = 0.000000000000000;
        A[465] = 0.000000000000000;
        A[466] = 0.000000000000000;
        A[467] = 0.000000000000000;
        A[468] = 0.000000000000000;
        A[469] = 0.000000000000000;
        A[470] = 0.000000000000000;
        A[471] = 0.000000000000000;
        A[472] = 0.000000000000000;
        A[473] = 0.000000000000000;
        A[474] = 0.000000000000000;
        A[475] = 0.000000000000000;
        A[476] = 0.000000000000000;
        A[477] = 0.000000000000000;
        A[478] = 0.000000000000000;
        A[479] = 0.000000000000000;
        A[480] = 0.000000000000000;
        A[481] = 0.000000000000000;
        A[482] = 0.000000000000000;
        A[483] = 0.000000000000000;
        A[484] = 0.000000000000000;
        A[485] = 0.000000000000000;
        A[486] = 0.000000000000000;
        A[487] = 0.000000000000000;
        A[488] = 0.000000000000000;
        A[489] = 0.000000000000000;
        A[490] = 0.000000000000000;
        A[491] = 0.000000000000000;
        A[492] = 0.000000000000000;
        A[493] = 0.000000000000000;
        A[494] = 0.000000000000000;
        A[495] = 0.000000000000000;
        A[496] = 0.092857142857143*G0_7 - 0.007142857142857*G0_8 + 0.047619047619048*G0_9;
        A[497] = -0.007142857142857*G0_7 - 0.007142857142857*G0_8 - 0.019047619047619*G0_9;
        A[498] = 0.047619047619048*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[499] = 0.000000000000000;
        A[500] = 0.000000000000000;
        A[501] = 0.000000000000000;
        A[502] = 0.000000000000000;
        A[503] = 0.000000000000000;
        A[504] = 0.000000000000000;
        A[505] = 0.000000000000000;
        A[506] = 0.000000000000000;
        A[507] = 0.000000000000000;
        A[508] = 0.000000000000000;
        A[509] = 0.000000000000000;
        A[510] = 0.000000000000000;
        A[511] = 0.000000000000000;
        A[512] = 0.000000000000000;
        A[513] = 0.000000000000000;
        A[514] = 0.000000000000000;
        A[515] = 0.000000000000000;
        A[516] = 0.000000000000000;
        A[517] = 0.000000000000000;
        A[518] = 0.000000000000000;
        A[519] = 0.000000000000000;
        A[520] = 0.000000000000000;
        A[521] = 0.000000000000000;
        A[522] = 0.000000000000000;
        A[523] = 0.000000000000000;
        A[524] = 0.000000000000000;
        A[525] = 0.000000000000000;
        A[526] = -0.007142857142857*G0_7 - 0.007142857142857*G0_8 - 0.019047619047619*G0_9;
        A[527] = -0.007142857142857*G0_7 + 0.092857142857143*G0_8 + 0.047619047619048*G0_9;
        A[528] = -0.019047619047619*G0_7 + 0.047619047619048*G0_8 + 0.038095238095238*G0_9;
        A[529] = 0.000000000000000;
        A[530] = 0.000000000000000;
        A[531] = 0.000000000000000;
        A[532] = 0.000000000000000;
        A[533] = 0.000000000000000;
        A[534] = 0.000000000000000;
        A[535] = 0.000000000000000;
        A[536] = 0.000000000000000;
        A[537] = 0.000000000000000;
        A[538] = 0.000000000000000;
        A[539] = 0.000000000000000;
        A[540] = 0.000000000000000;
        A[541] = 0.000000000000000;
        A[542] = 0.000000000000000;
        A[543] = 0.000000000000000;
        A[544] = 0.000000000000000;
        A[545] = 0.000000000000000;
        A[546] = 0.000000000000000;
        A[547] = 0.000000000000000;
        A[548] = 0.000000000000000;
        A[549] = 0.000000000000000;
        A[550] = 0.000000000000000;
        A[551] = 0.000000000000000;
        A[552] = 0.000000000000000;
        A[553] = 0.000000000000000;
        A[554] = 0.000000000000000;
        A[555] = 0.000000000000000;
        A[556] = 0.047619047619048*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[557] = -0.019047619047619*G0_7 + 0.047619047619048*G0_8 + 0.038095238095238*G0_9;
        A[558] = 0.038095238095238*G0_7 + 0.038095238095238*G0_8 + 0.457142857142857*G0_9;
        A[559] = 0.000000000000000;
        A[560] = 0.000000000000000;
        A[561] = 0.000000000000000;
        A[562] = 0.000000000000000;
        A[563] = 0.000000000000000;
        A[564] = 0.000000000000000;
        A[565] = 0.000000000000000;
        A[566] = 0.000000000000000;
        A[567] = 0.000000000000000;
        A[568] = 0.000000000000000;
        A[569] = 0.000000000000000;
        A[570] = 0.000000000000000;
        A[571] = 0.000000000000000;
        A[572] = 0.000000000000000;
        A[573] = 0.000000000000000;
        A[574] = 0.000000000000000;
        A[575] = 0.000000000000000;
        A[576] = 0.000000000000000;
        A[577] = 0.000000000000000;
        A[578] = 0.000000000000000;
        A[579] = 0.000000000000000;
        A[580] = 0.000000000000000;
        A[581] = 0.000000000000000;
        A[582] = 0.000000000000000;
        A[583] = 0.000000000000000;
        A[584] = 0.000000000000000;
        A[585] = 0.000000000000000;
        A[586] = 0.000000000000000;
        A[587] = 0.000000000000000;
        A[588] = 0.000000000000000;
        A[589] = 0.000000000000000;
        A[590] = 0.000000000000000;
        A[591] = 0.000000000000000;
        A[592] = 0.000000000000000;
        A[593] = 0.000000000000000;
        A[594] = 0.000000000000000;
        A[595] = 0.000000000000000;
        A[596] = 0.000000000000000;
        A[597] = 0.000000000000000;
        A[598] = 0.000000000000000;
        A[599] = 0.000000000000000;
        A[600] = 0.000000000000000;
        A[601] = 0.000000000000000;
        A[602] = 0.000000000000000;
        A[603] = 0.000000000000000;
        A[604] = 0.000000000000000;
        A[605] = 0.000000000000000;
        A[606] = 0.000000000000000;
        A[607] = 0.000000000000000;
        A[608] = 0.000000000000000;
        A[609] = 0.000000000000000;
        A[610] = 0.000000000000000;
        A[611] = 0.000000000000000;
        A[612] = 0.000000000000000;
        A[613] = 0.000000000000000;
        A[614] = 0.000000000000000;
        A[615] = 0.000000000000000;
        A[616] = 0.000000000000000;
        A[617] = 0.000000000000000;
        A[618] = 0.000000000000000;
        A[619] = 0.000000000000000;
        A[620] = 0.000000000000000;
        A[621] = 0.000000000000000;
        A[622] = 0.000000000000000;
        A[623] = 0.000000000000000;
        A[624] = 0.000000000000000;
        A[625] = 0.000000000000000;
        A[626] = 0.000000000000000;
        A[627] = 0.000000000000000;
        A[628] = 0.000000000000000;
        A[629] = 0.000000000000000;
        A[630] = 0.000000000000000;
        A[631] = 0.000000000000000;
        A[632] = 0.000000000000000;
        A[633] = 0.000000000000000;
        A[634] = 0.000000000000000;
        A[635] = 0.000000000000000;
        A[636] = 0.000000000000000;
        A[637] = 0.000000000000000;
        A[638] = 0.000000000000000;
        A[639] = 0.000000000000000;
        A[640] = 0.000000000000000;
        A[641] = 0.000000000000000;
        A[642] = 0.000000000000000;
        A[643] = 0.000000000000000;
        A[644] = 0.000000000000000;
        A[645] = 0.000000000000000;
        A[646] = 0.000000000000000;
        A[647] = 0.000000000000000;
        A[648] = 0.000000000000000;
        A[649] = 0.000000000000000;
        A[650] = 0.000000000000000;
        A[651] = 0.000000000000000;
        A[652] = 0.000000000000000;
        A[653] = 0.000000000000000;
        A[654] = 0.000000000000000;
        A[655] = 0.000000000000000;
        A[656] = 0.000000000000000;
        A[657] = 0.000000000000000;
        A[658] = 0.000000000000000;
        A[659] = 0.000000000000000;
        A[660] = 0.000000000000000;
        A[661] = 0.000000000000000;
        A[662] = 0.000000000000000;
        A[663] = 0.000000000000000;
        A[664] = 0.000000000000000;
        A[665] = 0.000000000000000;
        A[666] = 0.000000000000000;
        A[667] = 0.000000000000000;
        A[668] = 0.000000000000000;
        A[669] = 0.000000000000000;
        A[670] = 0.000000000000000;
        A[671] = 0.000000000000000;
        A[672] = 0.000000000000000;
        A[673] = 0.000000000000000;
        A[674] = 0.000000000000000;
        A[675] = 0.000000000000000;
        A[676] = 0.000000000000000;
        A[677] = 0.000000000000000;
        A[678] = 0.000000000000000;
        A[679] = 0.000000000000000;
        A[680] = 0.000000000000000;
        A[681] = 0.000000000000000;
        A[682] = 0.092857142857143*G0_7 - 0.007142857142857*G0_8 + 0.047619047619048*G0_9;
        A[683] = -0.007142857142857*G0_7 - 0.007142857142857*G0_8 - 0.019047619047619*G0_9;
        A[684] = 0.047619047619048*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[685] = 0.000000000000000;
        A[686] = 0.000000000000000;
        A[687] = 0.000000000000000;
        A[688] = 0.000000000000000;
        A[689] = 0.000000000000000;
        A[690] = 0.000000000000000;
        A[691] = 0.000000000000000;
        A[692] = 0.000000000000000;
        A[693] = 0.000000000000000;
        A[694] = 0.000000000000000;
        A[695] = 0.000000000000000;
        A[696] = 0.000000000000000;
        A[697] = 0.000000000000000;
        A[698] = 0.000000000000000;
        A[699] = 0.000000000000000;
        A[700] = 0.000000000000000;
        A[701] = 0.000000000000000;
        A[702] = 0.000000000000000;
        A[703] = 0.000000000000000;
        A[704] = 0.000000000000000;
        A[705] = 0.000000000000000;
        A[706] = 0.000000000000000;
        A[707] = 0.000000000000000;
        A[708] = 0.000000000000000;
        A[709] = 0.000000000000000;
        A[710] = 0.000000000000000;
        A[711] = 0.000000000000000;
        A[712] = -0.007142857142857*G0_7 - 0.007142857142857*G0_8 - 0.019047619047619*G0_9;
        A[713] = -0.007142857142857*G0_7 + 0.092857142857143*G0_8 + 0.047619047619048*G0_9;
        A[714] = -0.019047619047619*G0_7 + 0.047619047619048*G0_8 + 0.038095238095238*G0_9;
        A[715] = 0.000000000000000;
        A[716] = 0.000000000000000;
        A[717] = 0.000000000000000;
        A[718] = 0.000000000000000;
        A[719] = 0.000000000000000;
        A[720] = 0.000000000000000;
        A[721] = 0.000000000000000;
        A[722] = 0.000000000000000;
        A[723] = 0.000000000000000;
        A[724] = 0.000000000000000;
        A[725] = 0.000000000000000;
        A[726] = 0.000000000000000;
        A[727] = 0.000000000000000;
        A[728] = 0.000000000000000;
        A[729] = 0.000000000000000;
        A[730] = 0.000000000000000;
        A[731] = 0.000000000000000;
        A[732] = 0.000000000000000;
        A[733] = 0.000000000000000;
        A[734] = 0.000000000000000;
        A[735] = 0.000000000000000;
        A[736] = 0.000000000000000;
        A[737] = 0.000000000000000;
        A[738] = 0.000000000000000;
        A[739] = 0.000000000000000;
        A[740] = 0.000000000000000;
        A[741] = 0.000000000000000;
        A[742] = 0.047619047619048*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[743] = -0.019047619047619*G0_7 + 0.047619047619048*G0_8 + 0.038095238095238*G0_9;
        A[744] = 0.038095238095238*G0_7 + 0.038095238095238*G0_8 + 0.457142857142857*G0_9;
        A[745] = 0.000000000000000;
        A[746] = 0.000000000000000;
        A[747] = 0.000000000000000;
        A[748] = 0.000000000000000;
        A[749] = 0.000000000000000;
        A[750] = 0.000000000000000;
        A[751] = 0.000000000000000;
        A[752] = 0.000000000000000;
        A[753] = 0.000000000000000;
        A[754] = 0.000000000000000;
        A[755] = 0.000000000000000;
        A[756] = 0.000000000000000;
        A[757] = 0.000000000000000;
        A[758] = 0.000000000000000;
        A[759] = 0.000000000000000;
        A[760] = 0.000000000000000;
        A[761] = 0.000000000000000;
        A[762] = 0.000000000000000;
        A[763] = 0.000000000000000;
        A[764] = 0.000000000000000;
        A[765] = 0.000000000000000;
        A[766] = 0.000000000000000;
        A[767] = 0.000000000000000;
        A[768] = 0.000000000000000;
        A[769] = 0.000000000000000;
        A[770] = 0.000000000000000;
        A[771] = 0.000000000000000;
        A[772] = 0.000000000000000;
        A[773] = 0.000000000000000;
        A[774] = 0.000000000000000;
        A[775] = 0.000000000000000;
        A[776] = 0.000000000000000;
        A[777] = 0.000000000000000;
        A[778] = 0.000000000000000;
        A[779] = 0.000000000000000;
        A[780] = 0.000000000000000;
        A[781] = 0.000000000000000;
        A[782] = 0.000000000000000;
        A[783] = 0.000000000000000;
        A[784] = 0.000000000000000;
        A[785] = 0.000000000000000;
        A[786] = 0.000000000000000;
        A[787] = 0.000000000000000;
        A[788] = 0.000000000000000;
        A[789] = 0.000000000000000;
        A[790] = 0.000000000000000;
        A[791] = 0.000000000000000;
        A[792] = 0.000000000000000;
        A[793] = 0.000000000000000;
        A[794] = 0.000000000000000;
        A[795] = 0.000000000000000;
        A[796] = 0.000000000000000;
        A[797] = 0.000000000000000;
        A[798] = 0.000000000000000;
        A[799] = 0.000000000000000;
        A[800] = 0.000000000000000;
        A[801] = 0.000000000000000;
        A[802] = 0.000000000000000;
        A[803] = 0.000000000000000;
        A[804] = 0.000000000000000;
        A[805] = 0.000000000000000;
        A[806] = 0.000000000000000;
        A[807] = 0.000000000000000;
        A[808] = 0.000000000000000;
        A[809] = 0.000000000000000;
        A[810] = 0.000000000000000;
        A[811] = 0.000000000000000;
        A[812] = 0.000000000000000;
        A[813] = 0.000000000000000;
        A[814] = 0.000000000000000;
        A[815] = 0.000000000000000;
        A[816] = 0.000000000000000;
        A[817] = 0.000000000000000;
        A[818] = 0.000000000000000;
        A[819] = 0.000000000000000;
        A[820] = 0.000000000000000;
        A[821] = 0.000000000000000;
        A[822] = 0.000000000000000;
        A[823] = 0.000000000000000;
        A[824] = 0.000000000000000;
        A[825] = 0.000000000000000;
        A[826] = 0.000000000000000;
        A[827] = 0.000000000000000;
        A[828] = 0.000000000000000;
        A[829] = 0.000000000000000;
        A[830] = 0.000000000000000;
        A[831] = 0.000000000000000;
        A[832] = 0.000000000000000;
        A[833] = 0.000000000000000;
        A[834] = 0.000000000000000;
        A[835] = 0.000000000000000;
        A[836] = 0.000000000000000;
        A[837] = 0.000000000000000;
        A[838] = 0.000000000000000;
        A[839] = 0.000000000000000;
        A[840] = 0.000000000000000;
        A[841] = 0.000000000000000;
        A[842] = 0.000000000000000;
        A[843] = 0.000000000000000;
        A[844] = 0.000000000000000;
        A[845] = 0.000000000000000;
        A[846] = 0.000000000000000;
        A[847] = 0.000000000000000;
        A[848] = 0.000000000000000;
        A[849] = 0.000000000000000;
        A[850] = 0.000000000000000;
        A[851] = 0.000000000000000;
        A[852] = 0.000000000000000;
        A[853] = 0.000000000000000;
        A[854] = 0.000000000000000;
        A[855] = 0.000000000000000;
        A[856] = 0.000000000000000;
        A[857] = 0.000000000000000;
        A[858] = 0.000000000000000;
        A[859] = 0.000000000000000;
        A[860] = 0.000000000000000;
        A[861] = 0.000000000000000;
        A[862] = 0.000000000000000;
        A[863] = 0.000000000000000;
        A[864] = 0.000000000000000;
        A[865] = 0.000000000000000;
        A[866] = 0.000000000000000;
        A[867] = 0.000000000000000;
        A[868] = 0.150000000000000*G0_7 - 0.016666666666667*G0_8 + 0.200000000000000*G0_9;
        A[869] = 0.016666666666667*G0_7 + 0.016666666666667*G0_8 + 0.133333333333333*G0_9;
        A[870] = 0.000000000000000;
        A[871] = 0.000000000000000;
        A[872] = 0.000000000000000;
        A[873] = 0.000000000000000;
        A[874] = 0.000000000000000;
        A[875] = 0.000000000000000;
        A[876] = 0.000000000000000;
        A[877] = 0.000000000000000;
        A[878] = 0.000000000000000;
        A[879] = 0.000000000000000;
        A[880] = 0.000000000000000;
        A[881] = 0.000000000000000;
        A[882] = 0.000000000000000;
        A[883] = 0.000000000000000;
        A[884] = 0.000000000000000;
        A[885] = 0.000000000000000;
        A[886] = 0.000000000000000;
        A[887] = 0.000000000000000;
        A[888] = 0.000000000000000;
        A[889] = 0.000000000000000;
        A[890] = 0.000000000000000;
        A[891] = 0.000000000000000;
        A[892] = 0.000000000000000;
        A[893] = 0.000000000000000;
        A[894] = 0.000000000000000;
        A[895] = 0.000000000000000;
        A[896] = 0.000000000000000;
        A[897] = 0.000000000000000;
        A[898] = 0.016666666666667*G0_7 + 0.016666666666667*G0_8 + 0.133333333333333*G0_9;
        A[899] = -0.016666666666667*G0_7 + 0.150000000000000*G0_8 + 0.200000000000000*G0_9;
          break;
        }
      case 1:
        {
          A[0] = 0.092857142857143*G1_0 - 0.007142857142857*G1_1 + 0.047619047619048*G1_5;
        A[1] = -0.007142857142857*G1_0 - 0.007142857142857*G1_1 - 0.019047619047619*G1_5;
        A[2] = 0.000000000000000;
        A[3] = 0.000000000000000;
        A[4] = 0.000000000000000;
        A[5] = 0.047619047619048*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[6] = 0.000000000000000;
        A[7] = 0.000000000000000;
        A[8] = 0.000000000000000;
        A[9] = 0.000000000000000;
        A[10] = 0.000000000000000;
        A[11] = 0.000000000000000;
        A[12] = 0.000000000000000;
        A[13] = 0.000000000000000;
        A[14] = 0.000000000000000;
        A[15] = 0.000000000000000;
        A[16] = 0.000000000000000;
        A[17] = 0.000000000000000;
        A[18] = 0.000000000000000;
        A[19] = 0.000000000000000;
        A[20] = 0.000000000000000;
        A[21] = 0.000000000000000;
        A[22] = 0.000000000000000;
        A[23] = 0.000000000000000;
        A[24] = 0.000000000000000;
        A[25] = 0.000000000000000;
        A[26] = 0.000000000000000;
        A[27] = 0.000000000000000;
        A[28] = 0.000000000000000;
        A[29] = 0.000000000000000;
        A[30] = -0.007142857142857*G1_0 - 0.007142857142857*G1_1 - 0.019047619047619*G1_5;
        A[31] = -0.007142857142857*G1_0 + 0.092857142857143*G1_1 + 0.047619047619048*G1_5;
        A[32] = 0.000000000000000;
        A[33] = 0.000000000000000;
        A[34] = 0.000000000000000;
        A[35] = -0.019047619047619*G1_0 + 0.047619047619048*G1_1 + 0.038095238095238*G1_5;
        A[36] = 0.000000000000000;
        A[37] = 0.000000000000000;
        A[38] = 0.000000000000000;
        A[39] = 0.000000000000000;
        A[40] = 0.000000000000000;
        A[41] = 0.000000000000000;
        A[42] = 0.000000000000000;
        A[43] = 0.000000000000000;
        A[44] = 0.000000000000000;
        A[45] = 0.000000000000000;
        A[46] = 0.000000000000000;
        A[47] = 0.000000000000000;
        A[48] = 0.000000000000000;
        A[49] = 0.000000000000000;
        A[50] = 0.000000000000000;
        A[51] = 0.000000000000000;
        A[52] = 0.000000000000000;
        A[53] = 0.000000000000000;
        A[54] = 0.000000000000000;
        A[55] = 0.000000000000000;
        A[56] = 0.000000000000000;
        A[57] = 0.000000000000000;
        A[58] = 0.000000000000000;
        A[59] = 0.000000000000000;
        A[60] = 0.000000000000000;
        A[61] = 0.000000000000000;
        A[62] = 0.000000000000000;
        A[63] = 0.000000000000000;
        A[64] = 0.000000000000000;
        A[65] = 0.000000000000000;
        A[66] = 0.000000000000000;
        A[67] = 0.000000000000000;
        A[68] = 0.000000000000000;
        A[69] = 0.000000000000000;
        A[70] = 0.000000000000000;
        A[71] = 0.000000000000000;
        A[72] = 0.000000000000000;
        A[73] = 0.000000000000000;
        A[74] = 0.000000000000000;
        A[75] = 0.000000000000000;
        A[76] = 0.000000000000000;
        A[77] = 0.000000000000000;
        A[78] = 0.000000000000000;
        A[79] = 0.000000000000000;
        A[80] = 0.000000000000000;
        A[81] = 0.000000000000000;
        A[82] = 0.000000000000000;
        A[83] = 0.000000000000000;
        A[84] = 0.000000000000000;
        A[85] = 0.000000000000000;
        A[86] = 0.000000000000000;
        A[87] = 0.000000000000000;
        A[88] = 0.000000000000000;
        A[89] = 0.000000000000000;
        A[90] = 0.000000000000000;
        A[91] = 0.000000000000000;
        A[92] = 0.000000000000000;
        A[93] = 0.000000000000000;
        A[94] = 0.000000000000000;
        A[95] = 0.000000000000000;
        A[96] = 0.000000000000000;
        A[97] = 0.000000000000000;
        A[98] = 0.000000000000000;
        A[99] = 0.000000000000000;
        A[100] = 0.000000000000000;
        A[101] = 0.000000000000000;
        A[102] = 0.000000000000000;
        A[103] = 0.000000000000000;
        A[104] = 0.000000000000000;
        A[105] = 0.000000000000000;
        A[106] = 0.000000000000000;
        A[107] = 0.000000000000000;
        A[108] = 0.000000000000000;
        A[109] = 0.000000000000000;
        A[110] = 0.000000000000000;
        A[111] = 0.000000000000000;
        A[112] = 0.000000000000000;
        A[113] = 0.000000000000000;
        A[114] = 0.000000000000000;
        A[115] = 0.000000000000000;
        A[116] = 0.000000000000000;
        A[117] = 0.000000000000000;
        A[118] = 0.000000000000000;
        A[119] = 0.000000000000000;
        A[120] = 0.000000000000000;
        A[121] = 0.000000000000000;
        A[122] = 0.000000000000000;
        A[123] = 0.000000000000000;
        A[124] = 0.000000000000000;
        A[125] = 0.000000000000000;
        A[126] = 0.000000000000000;
        A[127] = 0.000000000000000;
        A[128] = 0.000000000000000;
        A[129] = 0.000000000000000;
        A[130] = 0.000000000000000;
        A[131] = 0.000000000000000;
        A[132] = 0.000000000000000;
        A[133] = 0.000000000000000;
        A[134] = 0.000000000000000;
        A[135] = 0.000000000000000;
        A[136] = 0.000000000000000;
        A[137] = 0.000000000000000;
        A[138] = 0.000000000000000;
        A[139] = 0.000000000000000;
        A[140] = 0.000000000000000;
        A[141] = 0.000000000000000;
        A[142] = 0.000000000000000;
        A[143] = 0.000000000000000;
        A[144] = 0.000000000000000;
        A[145] = 0.000000000000000;
        A[146] = 0.000000000000000;
        A[147] = 0.000000000000000;
        A[148] = 0.000000000000000;
        A[149] = 0.000000000000000;
        A[150] = 0.047619047619048*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[151] = -0.019047619047619*G1_0 + 0.047619047619048*G1_1 + 0.038095238095238*G1_5;
        A[152] = 0.000000000000000;
        A[153] = 0.000000000000000;
        A[154] = 0.000000000000000;
        A[155] = 0.038095238095238*G1_0 + 0.038095238095238*G1_1 + 0.457142857142857*G1_5;
        A[156] = 0.000000000000000;
        A[157] = 0.000000000000000;
        A[158] = 0.000000000000000;
        A[159] = 0.000000000000000;
        A[160] = 0.000000000000000;
        A[161] = 0.000000000000000;
        A[162] = 0.000000000000000;
        A[163] = 0.000000000000000;
        A[164] = 0.000000000000000;
        A[165] = 0.000000000000000;
        A[166] = 0.000000000000000;
        A[167] = 0.000000000000000;
        A[168] = 0.000000000000000;
        A[169] = 0.000000000000000;
        A[170] = 0.000000000000000;
        A[171] = 0.000000000000000;
        A[172] = 0.000000000000000;
        A[173] = 0.000000000000000;
        A[174] = 0.000000000000000;
        A[175] = 0.000000000000000;
        A[176] = 0.000000000000000;
        A[177] = 0.000000000000000;
        A[178] = 0.000000000000000;
        A[179] = 0.000000000000000;
        A[180] = 0.000000000000000;
        A[181] = 0.000000000000000;
        A[182] = 0.000000000000000;
        A[183] = 0.000000000000000;
        A[184] = 0.000000000000000;
        A[185] = 0.000000000000000;
        A[186] = 0.092857142857143*G1_0 - 0.007142857142857*G1_1 + 0.047619047619048*G1_5;
        A[187] = -0.007142857142857*G1_0 - 0.007142857142857*G1_1 - 0.019047619047619*G1_5;
        A[188] = 0.000000000000000;
        A[189] = 0.000000000000000;
        A[190] = 0.000000000000000;
        A[191] = 0.047619047619048*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[192] = 0.000000000000000;
        A[193] = 0.000000000000000;
        A[194] = 0.000000000000000;
        A[195] = 0.000000000000000;
        A[196] = 0.000000000000000;
        A[197] = 0.000000000000000;
        A[198] = 0.000000000000000;
        A[199] = 0.000000000000000;
        A[200] = 0.000000000000000;
        A[201] = 0.000000000000000;
        A[202] = 0.000000000000000;
        A[203] = 0.000000000000000;
        A[204] = 0.000000000000000;
        A[205] = 0.000000000000000;
        A[206] = 0.000000000000000;
        A[207] = 0.000000000000000;
        A[208] = 0.000000000000000;
        A[209] = 0.000000000000000;
        A[210] = 0.000000000000000;
        A[211] = 0.000000000000000;
        A[212] = 0.000000000000000;
        A[213] = 0.000000000000000;
        A[214] = 0.000000000000000;
        A[215] = 0.000000000000000;
        A[216] = -0.007142857142857*G1_0 - 0.007142857142857*G1_1 - 0.019047619047619*G1_5;
        A[217] = -0.007142857142857*G1_0 + 0.092857142857143*G1_1 + 0.047619047619048*G1_5;
        A[218] = 0.000000000000000;
        A[219] = 0.000000000000000;
        A[220] = 0.000000000000000;
        A[221] = -0.019047619047619*G1_0 + 0.047619047619048*G1_1 + 0.038095238095238*G1_5;
        A[222] = 0.000000000000000;
        A[223] = 0.000000000000000;
        A[224] = 0.000000000000000;
        A[225] = 0.000000000000000;
        A[226] = 0.000000000000000;
        A[227] = 0.000000000000000;
        A[228] = 0.000000000000000;
        A[229] = 0.000000000000000;
        A[230] = 0.000000000000000;
        A[231] = 0.000000000000000;
        A[232] = 0.000000000000000;
        A[233] = 0.000000000000000;
        A[234] = 0.000000000000000;
        A[235] = 0.000000000000000;
        A[236] = 0.000000000000000;
        A[237] = 0.000000000000000;
        A[238] = 0.000000000000000;
        A[239] = 0.000000000000000;
        A[240] = 0.000000000000000;
        A[241] = 0.000000000000000;
        A[242] = 0.000000000000000;
        A[243] = 0.000000000000000;
        A[244] = 0.000000000000000;
        A[245] = 0.000000000000000;
        A[246] = 0.000000000000000;
        A[247] = 0.000000000000000;
        A[248] = 0.000000000000000;
        A[249] = 0.000000000000000;
        A[250] = 0.000000000000000;
        A[251] = 0.000000000000000;
        A[252] = 0.000000000000000;
        A[253] = 0.000000000000000;
        A[254] = 0.000000000000000;
        A[255] = 0.000000000000000;
        A[256] = 0.000000000000000;
        A[257] = 0.000000000000000;
        A[258] = 0.000000000000000;
        A[259] = 0.000000000000000;
        A[260] = 0.000000000000000;
        A[261] = 0.000000000000000;
        A[262] = 0.000000000000000;
        A[263] = 0.000000000000000;
        A[264] = 0.000000000000000;
        A[265] = 0.000000000000000;
        A[266] = 0.000000000000000;
        A[267] = 0.000000000000000;
        A[268] = 0.000000000000000;
        A[269] = 0.000000000000000;
        A[270] = 0.000000000000000;
        A[271] = 0.000000000000000;
        A[272] = 0.000000000000000;
        A[273] = 0.000000000000000;
        A[274] = 0.000000000000000;
        A[275] = 0.000000000000000;
        A[276] = 0.000000000000000;
        A[277] = 0.000000000000000;
        A[278] = 0.000000000000000;
        A[279] = 0.000000000000000;
        A[280] = 0.000000000000000;
        A[281] = 0.000000000000000;
        A[282] = 0.000000000000000;
        A[283] = 0.000000000000000;
        A[284] = 0.000000000000000;
        A[285] = 0.000000000000000;
        A[286] = 0.000000000000000;
        A[287] = 0.000000000000000;
        A[288] = 0.000000000000000;
        A[289] = 0.000000000000000;
        A[290] = 0.000000000000000;
        A[291] = 0.000000000000000;
        A[292] = 0.000000000000000;
        A[293] = 0.000000000000000;
        A[294] = 0.000000000000000;
        A[295] = 0.000000000000000;
        A[296] = 0.000000000000000;
        A[297] = 0.000000000000000;
        A[298] = 0.000000000000000;
        A[299] = 0.000000000000000;
        A[300] = 0.000000000000000;
        A[301] = 0.000000000000000;
        A[302] = 0.000000000000000;
        A[303] = 0.000000000000000;
        A[304] = 0.000000000000000;
        A[305] = 0.000000000000000;
        A[306] = 0.000000000000000;
        A[307] = 0.000000000000000;
        A[308] = 0.000000000000000;
        A[309] = 0.000000000000000;
        A[310] = 0.000000000000000;
        A[311] = 0.000000000000000;
        A[312] = 0.000000000000000;
        A[313] = 0.000000000000000;
        A[314] = 0.000000000000000;
        A[315] = 0.000000000000000;
        A[316] = 0.000000000000000;
        A[317] = 0.000000000000000;
        A[318] = 0.000000000000000;
        A[319] = 0.000000000000000;
        A[320] = 0.000000000000000;
        A[321] = 0.000000000000000;
        A[322] = 0.000000000000000;
        A[323] = 0.000000000000000;
        A[324] = 0.000000000000000;
        A[325] = 0.000000000000000;
        A[326] = 0.000000000000000;
        A[327] = 0.000000000000000;
        A[328] = 0.000000000000000;
        A[329] = 0.000000000000000;
        A[330] = 0.000000000000000;
        A[331] = 0.000000000000000;
        A[332] = 0.000000000000000;
        A[333] = 0.000000000000000;
        A[334] = 0.000000000000000;
        A[335] = 0.000000000000000;
        A[336] = 0.047619047619048*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[337] = -0.019047619047619*G1_0 + 0.047619047619048*G1_1 + 0.038095238095238*G1_5;
        A[338] = 0.000000000000000;
        A[339] = 0.000000000000000;
        A[340] = 0.000000000000000;
        A[341] = 0.038095238095238*G1_0 + 0.038095238095238*G1_1 + 0.457142857142857*G1_5;
        A[342] = 0.000000000000000;
        A[343] = 0.000000000000000;
        A[344] = 0.000000000000000;
        A[345] = 0.000000000000000;
        A[346] = 0.000000000000000;
        A[347] = 0.000000000000000;
        A[348] = 0.000000000000000;
        A[349] = 0.000000000000000;
        A[350] = 0.000000000000000;
        A[351] = 0.000000000000000;
        A[352] = 0.000000000000000;
        A[353] = 0.000000000000000;
        A[354] = 0.000000000000000;
        A[355] = 0.000000000000000;
        A[356] = 0.000000000000000;
        A[357] = 0.000000000000000;
        A[358] = 0.000000000000000;
        A[359] = 0.000000000000000;
        A[360] = 0.000000000000000;
        A[361] = 0.000000000000000;
        A[362] = 0.000000000000000;
        A[363] = 0.000000000000000;
        A[364] = 0.000000000000000;
        A[365] = 0.000000000000000;
        A[366] = 0.000000000000000;
        A[367] = 0.000000000000000;
        A[368] = 0.000000000000000;
        A[369] = 0.000000000000000;
        A[370] = 0.000000000000000;
        A[371] = 0.000000000000000;
        A[372] = 0.150000000000000*G1_0 - 0.016666666666667*G1_1 + 0.200000000000000*G1_5;
        A[373] = 0.016666666666667*G1_0 + 0.016666666666667*G1_1 + 0.133333333333333*G1_5;
        A[374] = 0.000000000000000;
        A[375] = 0.000000000000000;
        A[376] = 0.000000000000000;
        A[377] = 0.000000000000000;
        A[378] = 0.000000000000000;
        A[379] = 0.000000000000000;
        A[380] = 0.000000000000000;
        A[381] = 0.000000000000000;
        A[382] = 0.000000000000000;
        A[383] = 0.000000000000000;
        A[384] = 0.000000000000000;
        A[385] = 0.000000000000000;
        A[386] = 0.000000000000000;
        A[387] = 0.000000000000000;
        A[388] = 0.000000000000000;
        A[389] = 0.000000000000000;
        A[390] = 0.000000000000000;
        A[391] = 0.000000000000000;
        A[392] = 0.000000000000000;
        A[393] = 0.000000000000000;
        A[394] = 0.000000000000000;
        A[395] = 0.000000000000000;
        A[396] = 0.000000000000000;
        A[397] = 0.000000000000000;
        A[398] = 0.000000000000000;
        A[399] = 0.000000000000000;
        A[400] = 0.000000000000000;
        A[401] = 0.000000000000000;
        A[402] = 0.016666666666667*G1_0 + 0.016666666666667*G1_1 + 0.133333333333333*G1_5;
        A[403] = -0.016666666666667*G1_0 + 0.150000000000000*G1_1 + 0.200000000000000*G1_5;
        A[404] = 0.000000000000000;
        A[405] = 0.000000000000000;
        A[406] = 0.000000000000000;
        A[407] = 0.000000000000000;
        A[408] = 0.000000000000000;
        A[409] = 0.000000000000000;
        A[410] = 0.000000000000000;
        A[411] = 0.000000000000000;
        A[412] = 0.000000000000000;
        A[413] = 0.000000000000000;
        A[414] = 0.000000000000000;
        A[415] = 0.000000000000000;
        A[416] = 0.000000000000000;
        A[417] = 0.000000000000000;
        A[418] = 0.000000000000000;
        A[419] = 0.000000000000000;
        A[420] = 0.000000000000000;
        A[421] = 0.000000000000000;
        A[422] = 0.000000000000000;
        A[423] = 0.000000000000000;
        A[424] = 0.000000000000000;
        A[425] = 0.000000000000000;
        A[426] = 0.000000000000000;
        A[427] = 0.000000000000000;
        A[428] = 0.000000000000000;
        A[429] = 0.000000000000000;
        A[430] = 0.000000000000000;
        A[431] = 0.000000000000000;
        A[432] = 0.000000000000000;
        A[433] = 0.000000000000000;
        A[434] = 0.000000000000000;
        A[435] = 0.000000000000000;
        A[436] = 0.000000000000000;
        A[437] = 0.000000000000000;
        A[438] = 0.000000000000000;
        A[439] = 0.000000000000000;
        A[440] = 0.000000000000000;
        A[441] = 0.000000000000000;
        A[442] = 0.000000000000000;
        A[443] = 0.000000000000000;
        A[444] = 0.000000000000000;
        A[445] = 0.000000000000000;
        A[446] = 0.000000000000000;
        A[447] = 0.000000000000000;
        A[448] = 0.000000000000000;
        A[449] = 0.000000000000000;
        A[450] = 0.000000000000000;
        A[451] = 0.000000000000000;
        A[452] = 0.000000000000000;
        A[453] = 0.000000000000000;
        A[454] = 0.000000000000000;
        A[455] = 0.000000000000000;
        A[456] = 0.000000000000000;
        A[457] = 0.000000000000000;
        A[458] = 0.000000000000000;
        A[459] = 0.000000000000000;
        A[460] = 0.000000000000000;
        A[461] = 0.000000000000000;
        A[462] = 0.000000000000000;
        A[463] = 0.000000000000000;
        A[464] = 0.000000000000000;
        A[465] = 0.092857142857143*G0_6 - 0.007142857142857*G0_8 + 0.047619047619048*G0_10;
        A[466] = 0.000000000000000;
        A[467] = -0.007142857142857*G0_6 - 0.007142857142857*G0_8 - 0.019047619047619*G0_10;
        A[468] = 0.000000000000000;
        A[469] = 0.047619047619048*G0_6 - 0.019047619047619*G0_8 + 0.038095238095238*G0_10;
        A[470] = 0.000000000000000;
        A[471] = 0.000000000000000;
        A[472] = 0.000000000000000;
        A[473] = 0.000000000000000;
        A[474] = 0.000000000000000;
        A[475] = 0.000000000000000;
        A[476] = 0.000000000000000;
        A[477] = 0.000000000000000;
        A[478] = 0.000000000000000;
        A[479] = 0.000000000000000;
        A[480] = 0.000000000000000;
        A[481] = 0.000000000000000;
        A[482] = 0.000000000000000;
        A[483] = 0.000000000000000;
        A[484] = 0.000000000000000;
        A[485] = 0.000000000000000;
        A[486] = 0.000000000000000;
        A[487] = 0.000000000000000;
        A[488] = 0.000000000000000;
        A[489] = 0.000000000000000;
        A[490] = 0.000000000000000;
        A[491] = 0.000000000000000;
        A[492] = 0.000000000000000;
        A[493] = 0.000000000000000;
        A[494] = 0.000000000000000;
        A[495] = 0.000000000000000;
        A[496] = 0.000000000000000;
        A[497] = 0.000000000000000;
        A[498] = 0.000000000000000;
        A[499] = 0.000000000000000;
        A[500] = 0.000000000000000;
        A[501] = 0.000000000000000;
        A[502] = 0.000000000000000;
        A[503] = 0.000000000000000;
        A[504] = 0.000000000000000;
        A[505] = 0.000000000000000;
        A[506] = 0.000000000000000;
        A[507] = 0.000000000000000;
        A[508] = 0.000000000000000;
        A[509] = 0.000000000000000;
        A[510] = 0.000000000000000;
        A[511] = 0.000000000000000;
        A[512] = 0.000000000000000;
        A[513] = 0.000000000000000;
        A[514] = 0.000000000000000;
        A[515] = 0.000000000000000;
        A[516] = 0.000000000000000;
        A[517] = 0.000000000000000;
        A[518] = 0.000000000000000;
        A[519] = 0.000000000000000;
        A[520] = 0.000000000000000;
        A[521] = 0.000000000000000;
        A[522] = 0.000000000000000;
        A[523] = 0.000000000000000;
        A[524] = 0.000000000000000;
        A[525] = -0.007142857142857*G0_6 - 0.007142857142857*G0_8 - 0.019047619047619*G0_10;
        A[526] = 0.000000000000000;
        A[527] = -0.007142857142857*G0_6 + 0.092857142857143*G0_8 + 0.047619047619048*G0_10;
        A[528] = 0.000000000000000;
        A[529] = -0.019047619047619*G0_6 + 0.047619047619048*G0_8 + 0.038095238095238*G0_10;
        A[530] = 0.000000000000000;
        A[531] = 0.000000000000000;
        A[532] = 0.000000000000000;
        A[533] = 0.000000000000000;
        A[534] = 0.000000000000000;
        A[535] = 0.000000000000000;
        A[536] = 0.000000000000000;
        A[537] = 0.000000000000000;
        A[538] = 0.000000000000000;
        A[539] = 0.000000000000000;
        A[540] = 0.000000000000000;
        A[541] = 0.000000000000000;
        A[542] = 0.000000000000000;
        A[543] = 0.000000000000000;
        A[544] = 0.000000000000000;
        A[545] = 0.000000000000000;
        A[546] = 0.000000000000000;
        A[547] = 0.000000000000000;
        A[548] = 0.000000000000000;
        A[549] = 0.000000000000000;
        A[550] = 0.000000000000000;
        A[551] = 0.000000000000000;
        A[552] = 0.000000000000000;
        A[553] = 0.000000000000000;
        A[554] = 0.000000000000000;
        A[555] = 0.000000000000000;
        A[556] = 0.000000000000000;
        A[557] = 0.000000000000000;
        A[558] = 0.000000000000000;
        A[559] = 0.000000000000000;
        A[560] = 0.000000000000000;
        A[561] = 0.000000000000000;
        A[562] = 0.000000000000000;
        A[563] = 0.000000000000000;
        A[564] = 0.000000000000000;
        A[565] = 0.000000000000000;
        A[566] = 0.000000000000000;
        A[567] = 0.000000000000000;
        A[568] = 0.000000000000000;
        A[569] = 0.000000000000000;
        A[570] = 0.000000000000000;
        A[571] = 0.000000000000000;
        A[572] = 0.000000000000000;
        A[573] = 0.000000000000000;
        A[574] = 0.000000000000000;
        A[575] = 0.000000000000000;
        A[576] = 0.000000000000000;
        A[577] = 0.000000000000000;
        A[578] = 0.000000000000000;
        A[579] = 0.000000000000000;
        A[580] = 0.000000000000000;
        A[581] = 0.000000000000000;
        A[582] = 0.000000000000000;
        A[583] = 0.000000000000000;
        A[584] = 0.000000000000000;
        A[585] = 0.047619047619048*G0_6 - 0.019047619047619*G0_8 + 0.038095238095238*G0_10;
        A[586] = 0.000000000000000;
        A[587] = -0.019047619047619*G0_6 + 0.047619047619048*G0_8 + 0.038095238095238*G0_10;
        A[588] = 0.000000000000000;
        A[589] = 0.038095238095238*G0_6 + 0.038095238095238*G0_8 + 0.457142857142857*G0_10;
        A[590] = 0.000000000000000;
        A[591] = 0.000000000000000;
        A[592] = 0.000000000000000;
        A[593] = 0.000000000000000;
        A[594] = 0.000000000000000;
        A[595] = 0.000000000000000;
        A[596] = 0.000000000000000;
        A[597] = 0.000000000000000;
        A[598] = 0.000000000000000;
        A[599] = 0.000000000000000;
        A[600] = 0.000000000000000;
        A[601] = 0.000000000000000;
        A[602] = 0.000000000000000;
        A[603] = 0.000000000000000;
        A[604] = 0.000000000000000;
        A[605] = 0.000000000000000;
        A[606] = 0.000000000000000;
        A[607] = 0.000000000000000;
        A[608] = 0.000000000000000;
        A[609] = 0.000000000000000;
        A[610] = 0.000000000000000;
        A[611] = 0.000000000000000;
        A[612] = 0.000000000000000;
        A[613] = 0.000000000000000;
        A[614] = 0.000000000000000;
        A[615] = 0.000000000000000;
        A[616] = 0.000000000000000;
        A[617] = 0.000000000000000;
        A[618] = 0.000000000000000;
        A[619] = 0.000000000000000;
        A[620] = 0.000000000000000;
        A[621] = 0.000000000000000;
        A[622] = 0.000000000000000;
        A[623] = 0.000000000000000;
        A[624] = 0.000000000000000;
        A[625] = 0.000000000000000;
        A[626] = 0.000000000000000;
        A[627] = 0.000000000000000;
        A[628] = 0.000000000000000;
        A[629] = 0.000000000000000;
        A[630] = 0.000000000000000;
        A[631] = 0.000000000000000;
        A[632] = 0.000000000000000;
        A[633] = 0.000000000000000;
        A[634] = 0.000000000000000;
        A[635] = 0.000000000000000;
        A[636] = 0.000000000000000;
        A[637] = 0.000000000000000;
        A[638] = 0.000000000000000;
        A[639] = 0.000000000000000;
        A[640] = 0.000000000000000;
        A[641] = 0.000000000000000;
        A[642] = 0.000000000000000;
        A[643] = 0.000000000000000;
        A[644] = 0.000000000000000;
        A[645] = 0.000000000000000;
        A[646] = 0.000000000000000;
        A[647] = 0.000000000000000;
        A[648] = 0.000000000000000;
        A[649] = 0.000000000000000;
        A[650] = 0.000000000000000;
        A[651] = 0.092857142857143*G0_6 - 0.007142857142857*G0_8 + 0.047619047619048*G0_10;
        A[652] = 0.000000000000000;
        A[653] = -0.007142857142857*G0_6 - 0.007142857142857*G0_8 - 0.019047619047619*G0_10;
        A[654] = 0.000000000000000;
        A[655] = 0.047619047619048*G0_6 - 0.019047619047619*G0_8 + 0.038095238095238*G0_10;
        A[656] = 0.000000000000000;
        A[657] = 0.000000000000000;
        A[658] = 0.000000000000000;
        A[659] = 0.000000000000000;
        A[660] = 0.000000000000000;
        A[661] = 0.000000000000000;
        A[662] = 0.000000000000000;
        A[663] = 0.000000000000000;
        A[664] = 0.000000000000000;
        A[665] = 0.000000000000000;
        A[666] = 0.000000000000000;
        A[667] = 0.000000000000000;
        A[668] = 0.000000000000000;
        A[669] = 0.000000000000000;
        A[670] = 0.000000000000000;
        A[671] = 0.000000000000000;
        A[672] = 0.000000000000000;
        A[673] = 0.000000000000000;
        A[674] = 0.000000000000000;
        A[675] = 0.000000000000000;
        A[676] = 0.000000000000000;
        A[677] = 0.000000000000000;
        A[678] = 0.000000000000000;
        A[679] = 0.000000000000000;
        A[680] = 0.000000000000000;
        A[681] = 0.000000000000000;
        A[682] = 0.000000000000000;
        A[683] = 0.000000000000000;
        A[684] = 0.000000000000000;
        A[685] = 0.000000000000000;
        A[686] = 0.000000000000000;
        A[687] = 0.000000000000000;
        A[688] = 0.000000000000000;
        A[689] = 0.000000000000000;
        A[690] = 0.000000000000000;
        A[691] = 0.000000000000000;
        A[692] = 0.000000000000000;
        A[693] = 0.000000000000000;
        A[694] = 0.000000000000000;
        A[695] = 0.000000000000000;
        A[696] = 0.000000000000000;
        A[697] = 0.000000000000000;
        A[698] = 0.000000000000000;
        A[699] = 0.000000000000000;
        A[700] = 0.000000000000000;
        A[701] = 0.000000000000000;
        A[702] = 0.000000000000000;
        A[703] = 0.000000000000000;
        A[704] = 0.000000000000000;
        A[705] = 0.000000000000000;
        A[706] = 0.000000000000000;
        A[707] = 0.000000000000000;
        A[708] = 0.000000000000000;
        A[709] = 0.000000000000000;
        A[710] = 0.000000000000000;
        A[711] = -0.007142857142857*G0_6 - 0.007142857142857*G0_8 - 0.019047619047619*G0_10;
        A[712] = 0.000000000000000;
        A[713] = -0.007142857142857*G0_6 + 0.092857142857143*G0_8 + 0.047619047619048*G0_10;
        A[714] = 0.000000000000000;
        A[715] = -0.019047619047619*G0_6 + 0.047619047619048*G0_8 + 0.038095238095238*G0_10;
        A[716] = 0.000000000000000;
        A[717] = 0.000000000000000;
        A[718] = 0.000000000000000;
        A[719] = 0.000000000000000;
        A[720] = 0.000000000000000;
        A[721] = 0.000000000000000;
        A[722] = 0.000000000000000;
        A[723] = 0.000000000000000;
        A[724] = 0.000000000000000;
        A[725] = 0.000000000000000;
        A[726] = 0.000000000000000;
        A[727] = 0.000000000000000;
        A[728] = 0.000000000000000;
        A[729] = 0.000000000000000;
        A[730] = 0.000000000000000;
        A[731] = 0.000000000000000;
        A[732] = 0.000000000000000;
        A[733] = 0.000000000000000;
        A[734] = 0.000000000000000;
        A[735] = 0.000000000000000;
        A[736] = 0.000000000000000;
        A[737] = 0.000000000000000;
        A[738] = 0.000000000000000;
        A[739] = 0.000000000000000;
        A[740] = 0.000000000000000;
        A[741] = 0.000000000000000;
        A[742] = 0.000000000000000;
        A[743] = 0.000000000000000;
        A[744] = 0.000000000000000;
        A[745] = 0.000000000000000;
        A[746] = 0.000000000000000;
        A[747] = 0.000000000000000;
        A[748] = 0.000000000000000;
        A[749] = 0.000000000000000;
        A[750] = 0.000000000000000;
        A[751] = 0.000000000000000;
        A[752] = 0.000000000000000;
        A[753] = 0.000000000000000;
        A[754] = 0.000000000000000;
        A[755] = 0.000000000000000;
        A[756] = 0.000000000000000;
        A[757] = 0.000000000000000;
        A[758] = 0.000000000000000;
        A[759] = 0.000000000000000;
        A[760] = 0.000000000000000;
        A[761] = 0.000000000000000;
        A[762] = 0.000000000000000;
        A[763] = 0.000000000000000;
        A[764] = 0.000000000000000;
        A[765] = 0.000000000000000;
        A[766] = 0.000000000000000;
        A[767] = 0.000000000000000;
        A[768] = 0.000000000000000;
        A[769] = 0.000000000000000;
        A[770] = 0.000000000000000;
        A[771] = 0.047619047619048*G0_6 - 0.019047619047619*G0_8 + 0.038095238095238*G0_10;
        A[772] = 0.000000000000000;
        A[773] = -0.019047619047619*G0_6 + 0.047619047619048*G0_8 + 0.038095238095238*G0_10;
        A[774] = 0.000000000000000;
        A[775] = 0.038095238095238*G0_6 + 0.038095238095238*G0_8 + 0.457142857142857*G0_10;
        A[776] = 0.000000000000000;
        A[777] = 0.000000000000000;
        A[778] = 0.000000000000000;
        A[779] = 0.000000000000000;
        A[780] = 0.000000000000000;
        A[781] = 0.000000000000000;
        A[782] = 0.000000000000000;
        A[783] = 0.000000000000000;
        A[784] = 0.000000000000000;
        A[785] = 0.000000000000000;
        A[786] = 0.000000000000000;
        A[787] = 0.000000000000000;
        A[788] = 0.000000000000000;
        A[789] = 0.000000000000000;
        A[790] = 0.000000000000000;
        A[791] = 0.000000000000000;
        A[792] = 0.000000000000000;
        A[793] = 0.000000000000000;
        A[794] = 0.000000000000000;
        A[795] = 0.000000000000000;
        A[796] = 0.000000000000000;
        A[797] = 0.000000000000000;
        A[798] = 0.000000000000000;
        A[799] = 0.000000000000000;
        A[800] = 0.000000000000000;
        A[801] = 0.000000000000000;
        A[802] = 0.000000000000000;
        A[803] = 0.000000000000000;
        A[804] = 0.000000000000000;
        A[805] = 0.000000000000000;
        A[806] = 0.000000000000000;
        A[807] = 0.000000000000000;
        A[808] = 0.000000000000000;
        A[809] = 0.000000000000000;
        A[810] = 0.000000000000000;
        A[811] = 0.000000000000000;
        A[812] = 0.000000000000000;
        A[813] = 0.000000000000000;
        A[814] = 0.000000000000000;
        A[815] = 0.000000000000000;
        A[816] = 0.000000000000000;
        A[817] = 0.000000000000000;
        A[818] = 0.000000000000000;
        A[819] = 0.000000000000000;
        A[820] = 0.000000000000000;
        A[821] = 0.000000000000000;
        A[822] = 0.000000000000000;
        A[823] = 0.000000000000000;
        A[824] = 0.000000000000000;
        A[825] = 0.000000000000000;
        A[826] = 0.000000000000000;
        A[827] = 0.000000000000000;
        A[828] = 0.000000000000000;
        A[829] = 0.000000000000000;
        A[830] = 0.000000000000000;
        A[831] = 0.000000000000000;
        A[832] = 0.000000000000000;
        A[833] = 0.000000000000000;
        A[834] = 0.000000000000000;
        A[835] = 0.000000000000000;
        A[836] = 0.000000000000000;
        A[837] = 0.150000000000000*G0_6 - 0.016666666666667*G0_8 + 0.200000000000000*G0_10;
        A[838] = 0.000000000000000;
        A[839] = 0.016666666666667*G0_6 + 0.016666666666667*G0_8 + 0.133333333333333*G0_10;
        A[840] = 0.000000000000000;
        A[841] = 0.000000000000000;
        A[842] = 0.000000000000000;
        A[843] = 0.000000000000000;
        A[844] = 0.000000000000000;
        A[845] = 0.000000000000000;
        A[846] = 0.000000000000000;
        A[847] = 0.000000000000000;
        A[848] = 0.000000000000000;
        A[849] = 0.000000000000000;
        A[850] = 0.000000000000000;
        A[851] = 0.000000000000000;
        A[852] = 0.000000000000000;
        A[853] = 0.000000000000000;
        A[854] = 0.000000000000000;
        A[855] = 0.000000000000000;
        A[856] = 0.000000000000000;
        A[857] = 0.000000000000000;
        A[858] = 0.000000000000000;
        A[859] = 0.000000000000000;
        A[860] = 0.000000000000000;
        A[861] = 0.000000000000000;
        A[862] = 0.000000000000000;
        A[863] = 0.000000000000000;
        A[864] = 0.000000000000000;
        A[865] = 0.000000000000000;
        A[866] = 0.000000000000000;
        A[867] = 0.000000000000000;
        A[868] = 0.000000000000000;
        A[869] = 0.000000000000000;
        A[870] = 0.000000000000000;
        A[871] = 0.000000000000000;
        A[872] = 0.000000000000000;
        A[873] = 0.000000000000000;
        A[874] = 0.000000000000000;
        A[875] = 0.000000000000000;
        A[876] = 0.000000000000000;
        A[877] = 0.000000000000000;
        A[878] = 0.000000000000000;
        A[879] = 0.000000000000000;
        A[880] = 0.000000000000000;
        A[881] = 0.000000000000000;
        A[882] = 0.000000000000000;
        A[883] = 0.000000000000000;
        A[884] = 0.000000000000000;
        A[885] = 0.000000000000000;
        A[886] = 0.000000000000000;
        A[887] = 0.000000000000000;
        A[888] = 0.000000000000000;
        A[889] = 0.000000000000000;
        A[890] = 0.000000000000000;
        A[891] = 0.000000000000000;
        A[892] = 0.000000000000000;
        A[893] = 0.000000000000000;
        A[894] = 0.000000000000000;
        A[895] = 0.000000000000000;
        A[896] = 0.000000000000000;
        A[897] = 0.016666666666667*G0_6 + 0.016666666666667*G0_8 + 0.133333333333333*G0_10;
        A[898] = 0.000000000000000;
        A[899] = -0.016666666666667*G0_6 + 0.150000000000000*G0_8 + 0.200000000000000*G0_10;
          break;
        }
      case 2:
        {
          A[0] = 0.092857142857143*G1_0 - 0.007142857142857*G1_1 + 0.047619047619048*G1_5;
        A[1] = -0.007142857142857*G1_0 - 0.007142857142857*G1_1 - 0.019047619047619*G1_5;
        A[2] = 0.000000000000000;
        A[3] = 0.000000000000000;
        A[4] = 0.000000000000000;
        A[5] = 0.047619047619048*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[6] = 0.000000000000000;
        A[7] = 0.000000000000000;
        A[8] = 0.000000000000000;
        A[9] = 0.000000000000000;
        A[10] = 0.000000000000000;
        A[11] = 0.000000000000000;
        A[12] = 0.000000000000000;
        A[13] = 0.000000000000000;
        A[14] = 0.000000000000000;
        A[15] = 0.000000000000000;
        A[16] = 0.000000000000000;
        A[17] = 0.000000000000000;
        A[18] = 0.000000000000000;
        A[19] = 0.000000000000000;
        A[20] = 0.000000000000000;
        A[21] = 0.000000000000000;
        A[22] = 0.000000000000000;
        A[23] = 0.000000000000000;
        A[24] = 0.000000000000000;
        A[25] = 0.000000000000000;
        A[26] = 0.000000000000000;
        A[27] = 0.000000000000000;
        A[28] = 0.000000000000000;
        A[29] = 0.000000000000000;
        A[30] = -0.007142857142857*G1_0 - 0.007142857142857*G1_1 - 0.019047619047619*G1_5;
        A[31] = -0.007142857142857*G1_0 + 0.092857142857143*G1_1 + 0.047619047619048*G1_5;
        A[32] = 0.000000000000000;
        A[33] = 0.000000000000000;
        A[34] = 0.000000000000000;
        A[35] = -0.019047619047619*G1_0 + 0.047619047619048*G1_1 + 0.038095238095238*G1_5;
        A[36] = 0.000000000000000;
        A[37] = 0.000000000000000;
        A[38] = 0.000000000000000;
        A[39] = 0.000000000000000;
        A[40] = 0.000000000000000;
        A[41] = 0.000000000000000;
        A[42] = 0.000000000000000;
        A[43] = 0.000000000000000;
        A[44] = 0.000000000000000;
        A[45] = 0.000000000000000;
        A[46] = 0.000000000000000;
        A[47] = 0.000000000000000;
        A[48] = 0.000000000000000;
        A[49] = 0.000000000000000;
        A[50] = 0.000000000000000;
        A[51] = 0.000000000000000;
        A[52] = 0.000000000000000;
        A[53] = 0.000000000000000;
        A[54] = 0.000000000000000;
        A[55] = 0.000000000000000;
        A[56] = 0.000000000000000;
        A[57] = 0.000000000000000;
        A[58] = 0.000000000000000;
        A[59] = 0.000000000000000;
        A[60] = 0.000000000000000;
        A[61] = 0.000000000000000;
        A[62] = 0.000000000000000;
        A[63] = 0.000000000000000;
        A[64] = 0.000000000000000;
        A[65] = 0.000000000000000;
        A[66] = 0.000000000000000;
        A[67] = 0.000000000000000;
        A[68] = 0.000000000000000;
        A[69] = 0.000000000000000;
        A[70] = 0.000000000000000;
        A[71] = 0.000000000000000;
        A[72] = 0.000000000000000;
        A[73] = 0.000000000000000;
        A[74] = 0.000000000000000;
        A[75] = 0.000000000000000;
        A[76] = 0.000000000000000;
        A[77] = 0.000000000000000;
        A[78] = 0.000000000000000;
        A[79] = 0.000000000000000;
        A[80] = 0.000000000000000;
        A[81] = 0.000000000000000;
        A[82] = 0.000000000000000;
        A[83] = 0.000000000000000;
        A[84] = 0.000000000000000;
        A[85] = 0.000000000000000;
        A[86] = 0.000000000000000;
        A[87] = 0.000000000000000;
        A[88] = 0.000000000000000;
        A[89] = 0.000000000000000;
        A[90] = 0.000000000000000;
        A[91] = 0.000000000000000;
        A[92] = 0.000000000000000;
        A[93] = 0.000000000000000;
        A[94] = 0.000000000000000;
        A[95] = 0.000000000000000;
        A[96] = 0.000000000000000;
        A[97] = 0.000000000000000;
        A[98] = 0.000000000000000;
        A[99] = 0.000000000000000;
        A[100] = 0.000000000000000;
        A[101] = 0.000000000000000;
        A[102] = 0.000000000000000;
        A[103] = 0.000000000000000;
        A[104] = 0.000000000000000;
        A[105] = 0.000000000000000;
        A[106] = 0.000000000000000;
        A[107] = 0.000000000000000;
        A[108] = 0.000000000000000;
        A[109] = 0.000000000000000;
        A[110] = 0.000000000000000;
        A[111] = 0.000000000000000;
        A[112] = 0.000000000000000;
        A[113] = 0.000000000000000;
        A[114] = 0.000000000000000;
        A[115] = 0.000000000000000;
        A[116] = 0.000000000000000;
        A[117] = 0.000000000000000;
        A[118] = 0.000000000000000;
        A[119] = 0.000000000000000;
        A[120] = 0.000000000000000;
        A[121] = 0.000000000000000;
        A[122] = 0.000000000000000;
        A[123] = 0.000000000000000;
        A[124] = 0.000000000000000;
        A[125] = 0.000000000000000;
        A[126] = 0.000000000000000;
        A[127] = 0.000000000000000;
        A[128] = 0.000000000000000;
        A[129] = 0.000000000000000;
        A[130] = 0.000000000000000;
        A[131] = 0.000000000000000;
        A[132] = 0.000000000000000;
        A[133] = 0.000000000000000;
        A[134] = 0.000000000000000;
        A[135] = 0.000000000000000;
        A[136] = 0.000000000000000;
        A[137] = 0.000000000000000;
        A[138] = 0.000000000000000;
        A[139] = 0.000000000000000;
        A[140] = 0.000000000000000;
        A[141] = 0.000000000000000;
        A[142] = 0.000000000000000;
        A[143] = 0.000000000000000;
        A[144] = 0.000000000000000;
        A[145] = 0.000000000000000;
        A[146] = 0.000000000000000;
        A[147] = 0.000000000000000;
        A[148] = 0.000000000000000;
        A[149] = 0.000000000000000;
        A[150] = 0.047619047619048*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[151] = -0.019047619047619*G1_0 + 0.047619047619048*G1_1 + 0.038095238095238*G1_5;
        A[152] = 0.000000000000000;
        A[153] = 0.000000000000000;
        A[154] = 0.000000000000000;
        A[155] = 0.038095238095238*G1_0 + 0.038095238095238*G1_1 + 0.457142857142857*G1_5;
        A[156] = 0.000000000000000;
        A[157] = 0.000000000000000;
        A[158] = 0.000000000000000;
        A[159] = 0.000000000000000;
        A[160] = 0.000000000000000;
        A[161] = 0.000000000000000;
        A[162] = 0.000000000000000;
        A[163] = 0.000000000000000;
        A[164] = 0.000000000000000;
        A[165] = 0.000000000000000;
        A[166] = 0.000000000000000;
        A[167] = 0.000000000000000;
        A[168] = 0.000000000000000;
        A[169] = 0.000000000000000;
        A[170] = 0.000000000000000;
        A[171] = 0.000000000000000;
        A[172] = 0.000000000000000;
        A[173] = 0.000000000000000;
        A[174] = 0.000000000000000;
        A[175] = 0.000000000000000;
        A[176] = 0.000000000000000;
        A[177] = 0.000000000000000;
        A[178] = 0.000000000000000;
        A[179] = 0.000000000000000;
        A[180] = 0.000000000000000;
        A[181] = 0.000000000000000;
        A[182] = 0.000000000000000;
        A[183] = 0.000000000000000;
        A[184] = 0.000000000000000;
        A[185] = 0.000000000000000;
        A[186] = 0.092857142857143*G1_0 - 0.007142857142857*G1_1 + 0.047619047619048*G1_5;
        A[187] = -0.007142857142857*G1_0 - 0.007142857142857*G1_1 - 0.019047619047619*G1_5;
        A[188] = 0.000000000000000;
        A[189] = 0.000000000000000;
        A[190] = 0.000000000000000;
        A[191] = 0.047619047619048*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[192] = 0.000000000000000;
        A[193] = 0.000000000000000;
        A[194] = 0.000000000000000;
        A[195] = 0.000000000000000;
        A[196] = 0.000000000000000;
        A[197] = 0.000000000000000;
        A[198] = 0.000000000000000;
        A[199] = 0.000000000000000;
        A[200] = 0.000000000000000;
        A[201] = 0.000000000000000;
        A[202] = 0.000000000000000;
        A[203] = 0.000000000000000;
        A[204] = 0.000000000000000;
        A[205] = 0.000000000000000;
        A[206] = 0.000000000000000;
        A[207] = 0.000000000000000;
        A[208] = 0.000000000000000;
        A[209] = 0.000000000000000;
        A[210] = 0.000000000000000;
        A[211] = 0.000000000000000;
        A[212] = 0.000000000000000;
        A[213] = 0.000000000000000;
        A[214] = 0.000000000000000;
        A[215] = 0.000000000000000;
        A[216] = -0.007142857142857*G1_0 - 0.007142857142857*G1_1 - 0.019047619047619*G1_5;
        A[217] = -0.007142857142857*G1_0 + 0.092857142857143*G1_1 + 0.047619047619048*G1_5;
        A[218] = 0.000000000000000;
        A[219] = 0.000000000000000;
        A[220] = 0.000000000000000;
        A[221] = -0.019047619047619*G1_0 + 0.047619047619048*G1_1 + 0.038095238095238*G1_5;
        A[222] = 0.000000000000000;
        A[223] = 0.000000000000000;
        A[224] = 0.000000000000000;
        A[225] = 0.000000000000000;
        A[226] = 0.000000000000000;
        A[227] = 0.000000000000000;
        A[228] = 0.000000000000000;
        A[229] = 0.000000000000000;
        A[230] = 0.000000000000000;
        A[231] = 0.000000000000000;
        A[232] = 0.000000000000000;
        A[233] = 0.000000000000000;
        A[234] = 0.000000000000000;
        A[235] = 0.000000000000000;
        A[236] = 0.000000000000000;
        A[237] = 0.000000000000000;
        A[238] = 0.000000000000000;
        A[239] = 0.000000000000000;
        A[240] = 0.000000000000000;
        A[241] = 0.000000000000000;
        A[242] = 0.000000000000000;
        A[243] = 0.000000000000000;
        A[244] = 0.000000000000000;
        A[245] = 0.000000000000000;
        A[246] = 0.000000000000000;
        A[247] = 0.000000000000000;
        A[248] = 0.000000000000000;
        A[249] = 0.000000000000000;
        A[250] = 0.000000000000000;
        A[251] = 0.000000000000000;
        A[252] = 0.000000000000000;
        A[253] = 0.000000000000000;
        A[254] = 0.000000000000000;
        A[255] = 0.000000000000000;
        A[256] = 0.000000000000000;
        A[257] = 0.000000000000000;
        A[258] = 0.000000000000000;
        A[259] = 0.000000000000000;
        A[260] = 0.000000000000000;
        A[261] = 0.000000000000000;
        A[262] = 0.000000000000000;
        A[263] = 0.000000000000000;
        A[264] = 0.000000000000000;
        A[265] = 0.000000000000000;
        A[266] = 0.000000000000000;
        A[267] = 0.000000000000000;
        A[268] = 0.000000000000000;
        A[269] = 0.000000000000000;
        A[270] = 0.000000000000000;
        A[271] = 0.000000000000000;
        A[272] = 0.000000000000000;
        A[273] = 0.000000000000000;
        A[274] = 0.000000000000000;
        A[275] = 0.000000000000000;
        A[276] = 0.000000000000000;
        A[277] = 0.000000000000000;
        A[278] = 0.000000000000000;
        A[279] = 0.000000000000000;
        A[280] = 0.000000000000000;
        A[281] = 0.000000000000000;
        A[282] = 0.000000000000000;
        A[283] = 0.000000000000000;
        A[284] = 0.000000000000000;
        A[285] = 0.000000000000000;
        A[286] = 0.000000000000000;
        A[287] = 0.000000000000000;
        A[288] = 0.000000000000000;
        A[289] = 0.000000000000000;
        A[290] = 0.000000000000000;
        A[291] = 0.000000000000000;
        A[292] = 0.000000000000000;
        A[293] = 0.000000000000000;
        A[294] = 0.000000000000000;
        A[295] = 0.000000000000000;
        A[296] = 0.000000000000000;
        A[297] = 0.000000000000000;
        A[298] = 0.000000000000000;
        A[299] = 0.000000000000000;
        A[300] = 0.000000000000000;
        A[301] = 0.000000000000000;
        A[302] = 0.000000000000000;
        A[303] = 0.000000000000000;
        A[304] = 0.000000000000000;
        A[305] = 0.000000000000000;
        A[306] = 0.000000000000000;
        A[307] = 0.000000000000000;
        A[308] = 0.000000000000000;
        A[309] = 0.000000000000000;
        A[310] = 0.000000000000000;
        A[311] = 0.000000000000000;
        A[312] = 0.000000000000000;
        A[313] = 0.000000000000000;
        A[314] = 0.000000000000000;
        A[315] = 0.000000000000000;
        A[316] = 0.000000000000000;
        A[317] = 0.000000000000000;
        A[318] = 0.000000000000000;
        A[319] = 0.000000000000000;
        A[320] = 0.000000000000000;
        A[321] = 0.000000000000000;
        A[322] = 0.000000000000000;
        A[323] = 0.000000000000000;
        A[324] = 0.000000000000000;
        A[325] = 0.000000000000000;
        A[326] = 0.000000000000000;
        A[327] = 0.000000000000000;
        A[328] = 0.000000000000000;
        A[329] = 0.000000000000000;
        A[330] = 0.000000000000000;
        A[331] = 0.000000000000000;
        A[332] = 0.000000000000000;
        A[333] = 0.000000000000000;
        A[334] = 0.000000000000000;
        A[335] = 0.000000000000000;
        A[336] = 0.047619047619048*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[337] = -0.019047619047619*G1_0 + 0.047619047619048*G1_1 + 0.038095238095238*G1_5;
        A[338] = 0.000000000000000;
        A[339] = 0.000000000000000;
        A[340] = 0.000000000000000;
        A[341] = 0.038095238095238*G1_0 + 0.038095238095238*G1_1 + 0.457142857142857*G1_5;
        A[342] = 0.000000000000000;
        A[343] = 0.000000000000000;
        A[344] = 0.000000000000000;
        A[345] = 0.000000000000000;
        A[346] = 0.000000000000000;
        A[347] = 0.000000000000000;
        A[348] = 0.000000000000000;
        A[349] = 0.000000000000000;
        A[350] = 0.000000000000000;
        A[351] = 0.000000000000000;
        A[352] = 0.000000000000000;
        A[353] = 0.000000000000000;
        A[354] = 0.000000000000000;
        A[355] = 0.000000000000000;
        A[356] = 0.000000000000000;
        A[357] = 0.000000000000000;
        A[358] = 0.000000000000000;
        A[359] = 0.000000000000000;
        A[360] = 0.000000000000000;
        A[361] = 0.000000000000000;
        A[362] = 0.000000000000000;
        A[363] = 0.000000000000000;
        A[364] = 0.000000000000000;
        A[365] = 0.000000000000000;
        A[366] = 0.000000000000000;
        A[367] = 0.000000000000000;
        A[368] = 0.000000000000000;
        A[369] = 0.000000000000000;
        A[370] = 0.000000000000000;
        A[371] = 0.000000000000000;
        A[372] = 0.150000000000000*G1_0 - 0.016666666666667*G1_1 + 0.200000000000000*G1_5;
        A[373] = 0.016666666666667*G1_0 + 0.016666666666667*G1_1 + 0.133333333333333*G1_5;
        A[374] = 0.000000000000000;
        A[375] = 0.000000000000000;
        A[376] = 0.000000000000000;
        A[377] = 0.000000000000000;
        A[378] = 0.000000000000000;
        A[379] = 0.000000000000000;
        A[380] = 0.000000000000000;
        A[381] = 0.000000000000000;
        A[382] = 0.000000000000000;
        A[383] = 0.000000000000000;
        A[384] = 0.000000000000000;
        A[385] = 0.000000000000000;
        A[386] = 0.000000000000000;
        A[387] = 0.000000000000000;
        A[388] = 0.000000000000000;
        A[389] = 0.000000000000000;
        A[390] = 0.000000000000000;
        A[391] = 0.000000000000000;
        A[392] = 0.000000000000000;
        A[393] = 0.000000000000000;
        A[394] = 0.000000000000000;
        A[395] = 0.000000000000000;
        A[396] = 0.000000000000000;
        A[397] = 0.000000000000000;
        A[398] = 0.000000000000000;
        A[399] = 0.000000000000000;
        A[400] = 0.000000000000000;
        A[401] = 0.000000000000000;
        A[402] = 0.016666666666667*G1_0 + 0.016666666666667*G1_1 + 0.133333333333333*G1_5;
        A[403] = -0.016666666666667*G1_0 + 0.150000000000000*G1_1 + 0.200000000000000*G1_5;
        A[404] = 0.000000000000000;
        A[405] = 0.000000000000000;
        A[406] = 0.000000000000000;
        A[407] = 0.000000000000000;
        A[408] = 0.000000000000000;
        A[409] = 0.000000000000000;
        A[410] = 0.000000000000000;
        A[411] = 0.000000000000000;
        A[412] = 0.000000000000000;
        A[413] = 0.000000000000000;
        A[414] = 0.000000000000000;
        A[415] = 0.000000000000000;
        A[416] = 0.000000000000000;
        A[417] = 0.000000000000000;
        A[418] = 0.000000000000000;
        A[419] = 0.000000000000000;
        A[420] = 0.000000000000000;
        A[421] = 0.000000000000000;
        A[422] = 0.000000000000000;
        A[423] = 0.000000000000000;
        A[424] = 0.000000000000000;
        A[425] = 0.000000000000000;
        A[426] = 0.000000000000000;
        A[427] = 0.000000000000000;
        A[428] = 0.000000000000000;
        A[429] = 0.000000000000000;
        A[430] = 0.000000000000000;
        A[431] = 0.000000000000000;
        A[432] = 0.000000000000000;
        A[433] = 0.000000000000000;
        A[434] = 0.000000000000000;
        A[435] = 0.000000000000000;
        A[436] = 0.000000000000000;
        A[437] = 0.000000000000000;
        A[438] = 0.000000000000000;
        A[439] = 0.000000000000000;
        A[440] = 0.000000000000000;
        A[441] = 0.000000000000000;
        A[442] = 0.000000000000000;
        A[443] = 0.000000000000000;
        A[444] = 0.000000000000000;
        A[445] = 0.000000000000000;
        A[446] = 0.000000000000000;
        A[447] = 0.000000000000000;
        A[448] = 0.000000000000000;
        A[449] = 0.000000000000000;
        A[450] = 0.000000000000000;
        A[451] = 0.000000000000000;
        A[452] = 0.000000000000000;
        A[453] = 0.000000000000000;
        A[454] = 0.000000000000000;
        A[455] = 0.000000000000000;
        A[456] = 0.000000000000000;
        A[457] = 0.000000000000000;
        A[458] = 0.000000000000000;
        A[459] = 0.000000000000000;
        A[460] = 0.000000000000000;
        A[461] = 0.000000000000000;
        A[462] = 0.000000000000000;
        A[463] = 0.000000000000000;
        A[464] = 0.000000000000000;
        A[465] = 0.092857142857143*G0_6 - 0.007142857142857*G0_7 + 0.047619047619048*G0_11;
        A[466] = -0.007142857142857*G0_6 - 0.007142857142857*G0_7 - 0.019047619047619*G0_11;
        A[467] = 0.000000000000000;
        A[468] = 0.000000000000000;
        A[469] = 0.000000000000000;
        A[470] = 0.047619047619048*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[471] = 0.000000000000000;
        A[472] = 0.000000000000000;
        A[473] = 0.000000000000000;
        A[474] = 0.000000000000000;
        A[475] = 0.000000000000000;
        A[476] = 0.000000000000000;
        A[477] = 0.000000000000000;
        A[478] = 0.000000000000000;
        A[479] = 0.000000000000000;
        A[480] = 0.000000000000000;
        A[481] = 0.000000000000000;
        A[482] = 0.000000000000000;
        A[483] = 0.000000000000000;
        A[484] = 0.000000000000000;
        A[485] = 0.000000000000000;
        A[486] = 0.000000000000000;
        A[487] = 0.000000000000000;
        A[488] = 0.000000000000000;
        A[489] = 0.000000000000000;
        A[490] = 0.000000000000000;
        A[491] = 0.000000000000000;
        A[492] = 0.000000000000000;
        A[493] = 0.000000000000000;
        A[494] = 0.000000000000000;
        A[495] = -0.007142857142857*G0_6 - 0.007142857142857*G0_7 - 0.019047619047619*G0_11;
        A[496] = -0.007142857142857*G0_6 + 0.092857142857143*G0_7 + 0.047619047619048*G0_11;
        A[497] = 0.000000000000000;
        A[498] = 0.000000000000000;
        A[499] = 0.000000000000000;
        A[500] = -0.019047619047619*G0_6 + 0.047619047619048*G0_7 + 0.038095238095238*G0_11;
        A[501] = 0.000000000000000;
        A[502] = 0.000000000000000;
        A[503] = 0.000000000000000;
        A[504] = 0.000000000000000;
        A[505] = 0.000000000000000;
        A[506] = 0.000000000000000;
        A[507] = 0.000000000000000;
        A[508] = 0.000000000000000;
        A[509] = 0.000000000000000;
        A[510] = 0.000000000000000;
        A[511] = 0.000000000000000;
        A[512] = 0.000000000000000;
        A[513] = 0.000000000000000;
        A[514] = 0.000000000000000;
        A[515] = 0.000000000000000;
        A[516] = 0.000000000000000;
        A[517] = 0.000000000000000;
        A[518] = 0.000000000000000;
        A[519] = 0.000000000000000;
        A[520] = 0.000000000000000;
        A[521] = 0.000000000000000;
        A[522] = 0.000000000000000;
        A[523] = 0.000000000000000;
        A[524] = 0.000000000000000;
        A[525] = 0.000000000000000;
        A[526] = 0.000000000000000;
        A[527] = 0.000000000000000;
        A[528] = 0.000000000000000;
        A[529] = 0.000000000000000;
        A[530] = 0.000000000000000;
        A[531] = 0.000000000000000;
        A[532] = 0.000000000000000;
        A[533] = 0.000000000000000;
        A[534] = 0.000000000000000;
        A[535] = 0.000000000000000;
        A[536] = 0.000000000000000;
        A[537] = 0.000000000000000;
        A[538] = 0.000000000000000;
        A[539] = 0.000000000000000;
        A[540] = 0.000000000000000;
        A[541] = 0.000000000000000;
        A[542] = 0.000000000000000;
        A[543] = 0.000000000000000;
        A[544] = 0.000000000000000;
        A[545] = 0.000000000000000;
        A[546] = 0.000000000000000;
        A[547] = 0.000000000000000;
        A[548] = 0.000000000000000;
        A[549] = 0.000000000000000;
        A[550] = 0.000000000000000;
        A[551] = 0.000000000000000;
        A[552] = 0.000000000000000;
        A[553] = 0.000000000000000;
        A[554] = 0.000000000000000;
        A[555] = 0.000000000000000;
        A[556] = 0.000000000000000;
        A[557] = 0.000000000000000;
        A[558] = 0.000000000000000;
        A[559] = 0.000000000000000;
        A[560] = 0.000000000000000;
        A[561] = 0.000000000000000;
        A[562] = 0.000000000000000;
        A[563] = 0.000000000000000;
        A[564] = 0.000000000000000;
        A[565] = 0.000000000000000;
        A[566] = 0.000000000000000;
        A[567] = 0.000000000000000;
        A[568] = 0.000000000000000;
        A[569] = 0.000000000000000;
        A[570] = 0.000000000000000;
        A[571] = 0.000000000000000;
        A[572] = 0.000000000000000;
        A[573] = 0.000000000000000;
        A[574] = 0.000000000000000;
        A[575] = 0.000000000000000;
        A[576] = 0.000000000000000;
        A[577] = 0.000000000000000;
        A[578] = 0.000000000000000;
        A[579] = 0.000000000000000;
        A[580] = 0.000000000000000;
        A[581] = 0.000000000000000;
        A[582] = 0.000000000000000;
        A[583] = 0.000000000000000;
        A[584] = 0.000000000000000;
        A[585] = 0.000000000000000;
        A[586] = 0.000000000000000;
        A[587] = 0.000000000000000;
        A[588] = 0.000000000000000;
        A[589] = 0.000000000000000;
        A[590] = 0.000000000000000;
        A[591] = 0.000000000000000;
        A[592] = 0.000000000000000;
        A[593] = 0.000000000000000;
        A[594] = 0.000000000000000;
        A[595] = 0.000000000000000;
        A[596] = 0.000000000000000;
        A[597] = 0.000000000000000;
        A[598] = 0.000000000000000;
        A[599] = 0.000000000000000;
        A[600] = 0.000000000000000;
        A[601] = 0.000000000000000;
        A[602] = 0.000000000000000;
        A[603] = 0.000000000000000;
        A[604] = 0.000000000000000;
        A[605] = 0.000000000000000;
        A[606] = 0.000000000000000;
        A[607] = 0.000000000000000;
        A[608] = 0.000000000000000;
        A[609] = 0.000000000000000;
        A[610] = 0.000000000000000;
        A[611] = 0.000000000000000;
        A[612] = 0.000000000000000;
        A[613] = 0.000000000000000;
        A[614] = 0.000000000000000;
        A[615] = 0.047619047619048*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[616] = -0.019047619047619*G0_6 + 0.047619047619048*G0_7 + 0.038095238095238*G0_11;
        A[617] = 0.000000000000000;
        A[618] = 0.000000000000000;
        A[619] = 0.000000000000000;
        A[620] = 0.038095238095238*G0_6 + 0.038095238095238*G0_7 + 0.457142857142857*G0_11;
        A[621] = 0.000000000000000;
        A[622] = 0.000000000000000;
        A[623] = 0.000000000000000;
        A[624] = 0.000000000000000;
        A[625] = 0.000000000000000;
        A[626] = 0.000000000000000;
        A[627] = 0.000000000000000;
        A[628] = 0.000000000000000;
        A[629] = 0.000000000000000;
        A[630] = 0.000000000000000;
        A[631] = 0.000000000000000;
        A[632] = 0.000000000000000;
        A[633] = 0.000000000000000;
        A[634] = 0.000000000000000;
        A[635] = 0.000000000000000;
        A[636] = 0.000000000000000;
        A[637] = 0.000000000000000;
        A[638] = 0.000000000000000;
        A[639] = 0.000000000000000;
        A[640] = 0.000000000000000;
        A[641] = 0.000000000000000;
        A[642] = 0.000000000000000;
        A[643] = 0.000000000000000;
        A[644] = 0.000000000000000;
        A[645] = 0.000000000000000;
        A[646] = 0.000000000000000;
        A[647] = 0.000000000000000;
        A[648] = 0.000000000000000;
        A[649] = 0.000000000000000;
        A[650] = 0.000000000000000;
        A[651] = 0.092857142857143*G0_6 - 0.007142857142857*G0_7 + 0.047619047619048*G0_11;
        A[652] = -0.007142857142857*G0_6 - 0.007142857142857*G0_7 - 0.019047619047619*G0_11;
        A[653] = 0.000000000000000;
        A[654] = 0.000000000000000;
        A[655] = 0.000000000000000;
        A[656] = 0.047619047619048*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[657] = 0.000000000000000;
        A[658] = 0.000000000000000;
        A[659] = 0.000000000000000;
        A[660] = 0.000000000000000;
        A[661] = 0.000000000000000;
        A[662] = 0.000000000000000;
        A[663] = 0.000000000000000;
        A[664] = 0.000000000000000;
        A[665] = 0.000000000000000;
        A[666] = 0.000000000000000;
        A[667] = 0.000000000000000;
        A[668] = 0.000000000000000;
        A[669] = 0.000000000000000;
        A[670] = 0.000000000000000;
        A[671] = 0.000000000000000;
        A[672] = 0.000000000000000;
        A[673] = 0.000000000000000;
        A[674] = 0.000000000000000;
        A[675] = 0.000000000000000;
        A[676] = 0.000000000000000;
        A[677] = 0.000000000000000;
        A[678] = 0.000000000000000;
        A[679] = 0.000000000000000;
        A[680] = 0.000000000000000;
        A[681] = -0.007142857142857*G0_6 - 0.007142857142857*G0_7 - 0.019047619047619*G0_11;
        A[682] = -0.007142857142857*G0_6 + 0.092857142857143*G0_7 + 0.047619047619048*G0_11;
        A[683] = 0.000000000000000;
        A[684] = 0.000000000000000;
        A[685] = 0.000000000000000;
        A[686] = -0.019047619047619*G0_6 + 0.047619047619048*G0_7 + 0.038095238095238*G0_11;
        A[687] = 0.000000000000000;
        A[688] = 0.000000000000000;
        A[689] = 0.000000000000000;
        A[690] = 0.000000000000000;
        A[691] = 0.000000000000000;
        A[692] = 0.000000000000000;
        A[693] = 0.000000000000000;
        A[694] = 0.000000000000000;
        A[695] = 0.000000000000000;
        A[696] = 0.000000000000000;
        A[697] = 0.000000000000000;
        A[698] = 0.000000000000000;
        A[699] = 0.000000000000000;
        A[700] = 0.000000000000000;
        A[701] = 0.000000000000000;
        A[702] = 0.000000000000000;
        A[703] = 0.000000000000000;
        A[704] = 0.000000000000000;
        A[705] = 0.000000000000000;
        A[706] = 0.000000000000000;
        A[707] = 0.000000000000000;
        A[708] = 0.000000000000000;
        A[709] = 0.000000000000000;
        A[710] = 0.000000000000000;
        A[711] = 0.000000000000000;
        A[712] = 0.000000000000000;
        A[713] = 0.000000000000000;
        A[714] = 0.000000000000000;
        A[715] = 0.000000000000000;
        A[716] = 0.000000000000000;
        A[717] = 0.000000000000000;
        A[718] = 0.000000000000000;
        A[719] = 0.000000000000000;
        A[720] = 0.000000000000000;
        A[721] = 0.000000000000000;
        A[722] = 0.000000000000000;
        A[723] = 0.000000000000000;
        A[724] = 0.000000000000000;
        A[725] = 0.000000000000000;
        A[726] = 0.000000000000000;
        A[727] = 0.000000000000000;
        A[728] = 0.000000000000000;
        A[729] = 0.000000000000000;
        A[730] = 0.000000000000000;
        A[731] = 0.000000000000000;
        A[732] = 0.000000000000000;
        A[733] = 0.000000000000000;
        A[734] = 0.000000000000000;
        A[735] = 0.000000000000000;
        A[736] = 0.000000000000000;
        A[737] = 0.000000000000000;
        A[738] = 0.000000000000000;
        A[739] = 0.000000000000000;
        A[740] = 0.000000000000000;
        A[741] = 0.000000000000000;
        A[742] = 0.000000000000000;
        A[743] = 0.000000000000000;
        A[744] = 0.000000000000000;
        A[745] = 0.000000000000000;
        A[746] = 0.000000000000000;
        A[747] = 0.000000000000000;
        A[748] = 0.000000000000000;
        A[749] = 0.000000000000000;
        A[750] = 0.000000000000000;
        A[751] = 0.000000000000000;
        A[752] = 0.000000000000000;
        A[753] = 0.000000000000000;
        A[754] = 0.000000000000000;
        A[755] = 0.000000000000000;
        A[756] = 0.000000000000000;
        A[757] = 0.000000000000000;
        A[758] = 0.000000000000000;
        A[759] = 0.000000000000000;
        A[760] = 0.000000000000000;
        A[761] = 0.000000000000000;
        A[762] = 0.000000000000000;
        A[763] = 0.000000000000000;
        A[764] = 0.000000000000000;
        A[765] = 0.000000000000000;
        A[766] = 0.000000000000000;
        A[767] = 0.000000000000000;
        A[768] = 0.000000000000000;
        A[769] = 0.000000000000000;
        A[770] = 0.000000000000000;
        A[771] = 0.000000000000000;
        A[772] = 0.000000000000000;
        A[773] = 0.000000000000000;
        A[774] = 0.000000000000000;
        A[775] = 0.000000000000000;
        A[776] = 0.000000000000000;
        A[777] = 0.000000000000000;
        A[778] = 0.000000000000000;
        A[779] = 0.000000000000000;
        A[780] = 0.000000000000000;
        A[781] = 0.000000000000000;
        A[782] = 0.000000000000000;
        A[783] = 0.000000000000000;
        A[784] = 0.000000000000000;
        A[785] = 0.000000000000000;
        A[786] = 0.000000000000000;
        A[787] = 0.000000000000000;
        A[788] = 0.000000000000000;
        A[789] = 0.000000000000000;
        A[790] = 0.000000000000000;
        A[791] = 0.000000000000000;
        A[792] = 0.000000000000000;
        A[793] = 0.000000000000000;
        A[794] = 0.000000000000000;
        A[795] = 0.000000000000000;
        A[796] = 0.000000000000000;
        A[797] = 0.000000000000000;
        A[798] = 0.000000000000000;
        A[799] = 0.000000000000000;
        A[800] = 0.000000000000000;
        A[801] = 0.047619047619048*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[802] = -0.019047619047619*G0_6 + 0.047619047619048*G0_7 + 0.038095238095238*G0_11;
        A[803] = 0.000000000000000;
        A[804] = 0.000000000000000;
        A[805] = 0.000000000000000;
        A[806] = 0.038095238095238*G0_6 + 0.038095238095238*G0_7 + 0.457142857142857*G0_11;
        A[807] = 0.000000000000000;
        A[808] = 0.000000000000000;
        A[809] = 0.000000000000000;
        A[810] = 0.000000000000000;
        A[811] = 0.000000000000000;
        A[812] = 0.000000000000000;
        A[813] = 0.000000000000000;
        A[814] = 0.000000000000000;
        A[815] = 0.000000000000000;
        A[816] = 0.000000000000000;
        A[817] = 0.000000000000000;
        A[818] = 0.000000000000000;
        A[819] = 0.000000000000000;
        A[820] = 0.000000000000000;
        A[821] = 0.000000000000000;
        A[822] = 0.000000000000000;
        A[823] = 0.000000000000000;
        A[824] = 0.000000000000000;
        A[825] = 0.000000000000000;
        A[826] = 0.000000000000000;
        A[827] = 0.000000000000000;
        A[828] = 0.000000000000000;
        A[829] = 0.000000000000000;
        A[830] = 0.000000000000000;
        A[831] = 0.000000000000000;
        A[832] = 0.000000000000000;
        A[833] = 0.000000000000000;
        A[834] = 0.000000000000000;
        A[835] = 0.000000000000000;
        A[836] = 0.000000000000000;
        A[837] = 0.150000000000000*G0_6 - 0.016666666666667*G0_7 + 0.200000000000000*G0_11;
        A[838] = 0.016666666666667*G0_6 + 0.016666666666667*G0_7 + 0.133333333333333*G0_11;
        A[839] = 0.000000000000000;
        A[840] = 0.000000000000000;
        A[841] = 0.000000000000000;
        A[842] = 0.000000000000000;
        A[843] = 0.000000000000000;
        A[844] = 0.000000000000000;
        A[845] = 0.000000000000000;
        A[846] = 0.000000000000000;
        A[847] = 0.000000000000000;
        A[848] = 0.000000000000000;
        A[849] = 0.000000000000000;
        A[850] = 0.000000000000000;
        A[851] = 0.000000000000000;
        A[852] = 0.000000000000000;
        A[853] = 0.000000000000000;
        A[854] = 0.000000000000000;
        A[855] = 0.000000000000000;
        A[856] = 0.000000000000000;
        A[857] = 0.000000000000000;
        A[858] = 0.000000000000000;
        A[859] = 0.000000000000000;
        A[860] = 0.000000000000000;
        A[861] = 0.000000000000000;
        A[862] = 0.000000000000000;
        A[863] = 0.000000000000000;
        A[864] = 0.000000000000000;
        A[865] = 0.000000000000000;
        A[866] = 0.000000000000000;
        A[867] = 0.016666666666667*G0_6 + 0.016666666666667*G0_7 + 0.133333333333333*G0_11;
        A[868] = -0.016666666666667*G0_6 + 0.150000000000000*G0_7 + 0.200000000000000*G0_11;
        A[869] = 0.000000000000000;
        A[870] = 0.000000000000000;
        A[871] = 0.000000000000000;
        A[872] = 0.000000000000000;
        A[873] = 0.000000000000000;
        A[874] = 0.000000000000000;
        A[875] = 0.000000000000000;
        A[876] = 0.000000000000000;
        A[877] = 0.000000000000000;
        A[878] = 0.000000000000000;
        A[879] = 0.000000000000000;
        A[880] = 0.000000000000000;
        A[881] = 0.000000000000000;
        A[882] = 0.000000000000000;
        A[883] = 0.000000000000000;
        A[884] = 0.000000000000000;
        A[885] = 0.000000000000000;
        A[886] = 0.000000000000000;
        A[887] = 0.000000000000000;
        A[888] = 0.000000000000000;
        A[889] = 0.000000000000000;
        A[890] = 0.000000000000000;
        A[891] = 0.000000000000000;
        A[892] = 0.000000000000000;
        A[893] = 0.000000000000000;
        A[894] = 0.000000000000000;
        A[895] = 0.000000000000000;
        A[896] = 0.000000000000000;
        A[897] = 0.000000000000000;
        A[898] = 0.000000000000000;
        A[899] = 0.000000000000000;
          break;
        }
      }
      
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local interior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_5_0: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_5_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_5_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Cell Volume.
    
    // Compute circumradius, assuming triangle is embedded in 2D.
    
    
    // Array of quadrature weights.
    static const double W16[16] = {0.023568368193382, 0.035388067898086, 0.022584049282370, 0.005423225910525, 0.044185088522362, 0.066344216107050, 0.042339724521746, 0.010167259564479, 0.044185088522362, 0.066344216107050, 0.042339724521746, 0.010167259564479, 0.023568368193382, 0.035388067898086, 0.022584049282370, 0.005423225910525};
    // Quadrature points on the UFC reference element: (0.065466994555014, 0.057104196114518), (0.050210123211370, 0.276843013638124), (0.028912084224389, 0.583590432368917), (0.009703785126946, 0.860240135656219), (0.311164552244357, 0.057104196114518), (0.238648659731443, 0.276843013638124), (0.137419104134574, 0.583590432368917), (0.046122079906452, 0.860240135656219), (0.631731251641125, 0.057104196114518), (0.484508326630433, 0.276843013638124), (0.278990463496509, 0.583590432368917), (0.093637784437329, 0.860240135656219), (0.877428809330468, 0.057104196114518), (0.672946863150506, 0.276843013638124), (0.387497483406694, 0.583590432368917), (0.130056079216834, 0.860240135656219)
    
    // Value of basis functions at quadrature points.
    static const double FE1[16][6] = \
    {{0.662333821555697, -0.056895139802882, -0.050582417686747, 0.014953760384390, 0.200419467218139, 0.229770508331402},
    {0.232768098097707, -0.045168010265568, -0.123558905237647, 0.055601287299908, 0.745202550451633, 0.135154979653967},
    {-0.087188884113652, -0.027240266995993, 0.097565153136162, 0.067491262932791, 0.904559295532719, 0.044813439507973},
    {-0.096226911734323, -0.009515458235366, 0.619786046331442, 0.033390341735932, 0.447517836913622, 0.005048144988693},
    {0.166437496959000, -0.117517795097495, -0.050582417686747, 0.071075206460991, 0.144298021141538, 0.786289488222712},
    {-0.015011689481988, -0.124742294148215, -0.123558905237647, 0.264272856643007, 0.536530981108534, 0.462509051116308},
    {-0.123319106052515, -0.099651083772276, 0.097565153136162, 0.320785897590582, 0.651264660874928, 0.153354478223120},
    {-0.076101715088665, -0.041867587396658, 0.619786046331442, 0.158704257101893, 0.322203921547661, 0.017275077504327},
    {-0.117517795097495, 0.166437496959000, -0.050582417686747, 0.144298021141538, 0.071075206460991, 0.786289488222712},
    {-0.124742294148215, -0.015011689481988, -0.123558905237647, 0.536530981108534, 0.264272856643007, 0.462509051116308},
    {-0.099651083772276, -0.123319106052515, 0.097565153136162, 0.651264660874928, 0.320785897590582, 0.153354478223120},
    {-0.041867587396658, -0.076101715088665, 0.619786046331442, 0.322203921547661, 0.158704257101893, 0.017275077504327},
    {-0.056895139802882, 0.662333821555697, -0.050582417686747, 0.200419467218139, 0.014953760384390, 0.229770508331402},
    {-0.045168010265568, 0.232768098097706, -0.123558905237647, 0.745202550451633, 0.055601287299908, 0.135154979653967},
    {-0.027240266995993, -0.087188884113652, 0.097565153136162, 0.904559295532719, 0.067491262932791, 0.044813439507973},
    {-0.009515458235366, -0.096226911734323, 0.619786046331442, 0.447517836913623, 0.033390341735931, 0.005048144988693}};
    
    // Array of non-zero columns
    static const unsigned int nzc5[6] = {6, 7, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc2[6] = {0, 1, 2, 3, 4, 5};
    
    static const double FE1_D01[16][5] = \
    {{-2.509715237321871, -0.771583215541929, 0.261867978220057, 3.281298452863801, -0.261867978220058},
    {-1.691787452602026, 0.107372054552495, 0.200840492845479, 1.584415398049531, -0.200840492845479},
    {-0.549989933626777, 1.334361729475667, 0.115648336897555, -0.784371795848890, -0.115648336897555},
    {0.479775683132663, 2.440960542624878, 0.038815140507783, -2.920736225757540, -0.038815140507783},
    {-1.526925006564501, -0.771583215541929, 1.244658208977427, 2.298508222106431, -1.244658208977428},
    {-0.938033306521733, 0.107372054552495, 0.954594638925771, 0.830661251969238, -0.954594638925771},
    {-0.115961853986035, 1.334361729475667, 0.549676416538297, -1.218399875489632, -0.549676416538297},
    {0.625448862250687, 2.440960542624878, 0.184488319625806, -3.066409404875563, -0.184488319625807},
    {-0.244658208977428, -0.771583215541929, 2.526925006564500, 1.016241424519358, -2.526925006564501},
    {0.045405361074228, 0.107372054552495, 1.938033306521732, -0.152777415626723, -1.938033306521733},
    {0.450323583461703, 1.334361729475667, 1.115961853986035, -1.784685312937369, -1.115961853986035},
    {0.815511680374192, 2.440960542624878, 0.374551137749312, -3.256472222999069, -0.374551137749313},
    {0.738132021779942, -0.771583215541929, 3.509715237321869, 0.033451193761989, -3.509715237321871},
    {0.799159507154521, 0.107372054552495, 2.691787452602024, -0.906531561707015, -2.691787452602025},
    {0.884351663102444, 1.334361729475667, 1.549989933626776, -2.218713392578111, -1.549989933626777},
    {0.961184859492216, 2.440960542624878, 0.520224316867337, -3.402145402117093, -0.520224316867337}};
    
    // Array of non-zero columns
    static const unsigned int nzc6[5] = {6, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc3[5] = {0, 2, 3, 4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc0[5] = {0, 2, 3, 4, 5};
    
    static const double FE1_D10[16][5] = \
    {{-2.509715237321872, -0.738132021779942, 0.228416784458069, -0.228416784458069, 3.247847259101814},
    {-1.691787452602026, -0.799159507154521, 1.107372054552495, -1.107372054552495, 2.490946959756548},
    {-0.549989933626776, -0.884351663102445, 2.334361729475666, -2.334361729475666, 1.434341596729221},
    {0.479775683132663, -0.961184859492216, 3.440960542624875, -3.440960542624875, 0.481409176359553},
    {-1.526925006564501, 0.244658208977428, 0.228416784458069, -0.228416784458069, 1.282266797587073},
    {-0.938033306521733, -0.045405361074228, 1.107372054552495, -1.107372054552495, 0.983438667595962},
    {-0.115961853986035, -0.450323583461703, 2.334361729475666, -2.334361729475666, 0.566285437447738},
    {0.625448862250687, -0.815511680374192, 3.440960542624876, -3.440960542624876, 0.190062818123506},
    {-0.244658208977428, 1.526925006564501, 0.228416784458069, -0.228416784458069, -1.282266797587073},
    {0.045405361074228, 0.938033306521733, 1.107372054552495, -1.107372054552495, -0.983438667595961},
    {0.450323583461703, 0.115961853986035, 2.334361729475666, -2.334361729475666, -0.566285437447738},
    {0.815511680374193, -0.625448862250686, 3.440960542624876, -3.440960542624876, -0.190062818123506},
    {0.738132021779942, 2.509715237321871, 0.228416784458069, -0.228416784458069, -3.247847259101812},
    {0.799159507154520, 1.691787452602025, 1.107372054552495, -1.107372054552495, -2.490946959756545},
    {0.884351663102444, 0.549989933626777, 2.334361729475666, -2.334361729475666, -1.434341596729221},
    {0.961184859492217, -0.479775683132662, 3.440960542624876, -3.440960542624876, -0.481409176359554}};
    
    // Array of non-zero columns
    static const unsigned int nzc7[5] = {6, 7, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc4[5] = {0, 1, 3, 4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc1[5] = {0, 1, 3, 4, 5};
    
    static const double FE2_C2[16][3] = \
    {{0.877428809330468, 0.065466994555014, 0.057104196114518},
    {0.672946863150506, 0.050210123211370, 0.276843013638124},
    {0.387497483406694, 0.028912084224389, 0.583590432368917},
    {0.130056079216834, 0.009703785126946, 0.860240135656219},
    {0.631731251641125, 0.311164552244357, 0.057104196114518},
    {0.484508326630433, 0.238648659731443, 0.276843013638124},
    {0.278990463496509, 0.137419104134574, 0.583590432368917},
    {0.093637784437329, 0.046122079906452, 0.860240135656219},
    {0.311164552244357, 0.631731251641125, 0.057104196114518},
    {0.238648659731443, 0.484508326630433, 0.276843013638124},
    {0.137419104134574, 0.278990463496509, 0.583590432368917},
    {0.046122079906452, 0.093637784437329, 0.860240135656219},
    {0.065466994555014, 0.877428809330468, 0.057104196114518},
    {0.050210123211370, 0.672946863150506, 0.276843013638124},
    {0.028912084224389, 0.387497483406694, 0.583590432368917},
    {0.009703785126946, 0.130056079216835, 0.860240135656219}};
    
    // Array of non-zero columns
    static const unsigned int nzc8[3] = {12, 13, 14};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.000000000000000;
    }// end loop over 'r'
    // Number of operations to compute geometry constants: 23.
    double G[11];
    G[0] =  - K_00*det;
    G[1] =  - K_10*det;
    G[2] =  - K_01*det;
    G[3] =  - K_11*det;
    G[4] = K_00*det;
    G[5] =  - det*w[2][0]*(K_00*K_00 + K_01*K_01);
    G[6] =  - det*w[2][0]*(K_00*K_10 + K_01*K_11);
    G[7] = K_01*det;
    G[8] = K_10*det;
    G[9] =  - det*w[2][0]*(K_10*K_10 + K_11*K_11);
    G[10] = K_11*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 4720
    for (unsigned int ip = 0; ip < 16; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.000000000000000;
      double F1 = 0.000000000000000;
      double F2 = 0.000000000000000;
      double F3 = 0.000000000000000;
      double F4 = 0.000000000000000;
      double F5 = 0.000000000000000;
      double F6 = 0.000000000000000;
      double F7 = 0.000000000000000;
      double F8 = 0.000000000000000;
      double F9 = 0.000000000000000;
      double F10 = 0.000000000000000;
      double F11 = 0.000000000000000;
      double F12 = 0.000000000000000;
      
      // Total number of operations to compute function values = 12
      for (unsigned int r = 0; r < 3; r++)
      {
        F3 += FE2_C2[ip][r]*w[3][nzc8[r]];
        F12 += FE2_C2[ip][r]*w[0][nzc8[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 60
      for (unsigned int r = 0; r < 5; r++)
      {
        F4 += FE1_D10[ip][r]*w[0][nzc4[r]];
        F5 += FE1_D01[ip][r]*w[0][nzc3[r]];
        F8 += FE1_D10[ip][r]*w[0][nzc7[r]];
        F9 += FE1_D01[ip][r]*w[0][nzc6[r]];
        F10 += FE1_D10[ip][r]*w[4][nzc1[r]];
        F11 += FE1_D01[ip][r]*w[4][nzc0[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 60
      for (unsigned int r = 0; r < 6; r++)
      {
        F0 += FE1[ip][r]*w[3][nzc2[r]];
        F1 += FE1[ip][r]*w[4][r];
        F2 += FE1[ip][r]*w[3][nzc5[r]];
        F6 += FE1[ip][r]*w[0][nzc2[r]];
        F7 += FE1[ip][r]*w[0][nzc5[r]];
      }// end loop over 'r'
      
      // Number of operations to compute ip constants: 93
      double I[7];
      // Number of operations: 11
      I[0] = F1*W16[ip]*(F4*G[0] + F5*G[1] + F8*G[2] + F9*G[3] - F3*det);
      
      // Number of operations: 7
      I[1] = F1*W16[ip]*(F12*G[4] + F4*G[5] + F5*G[6]);
      
      // Number of operations: 7
      I[2] = F1*W16[ip]*(F12*G[7] + F8*G[5] + F9*G[6]);
      
      // Number of operations: 7
      I[3] = F1*W16[ip]*(F12*G[8] + F4*G[6] + F5*G[9]);
      
      // Number of operations: 7
      I[4] = F1*W16[ip]*(F12*G[10] + F8*G[6] + F9*G[9]);
      
      // Number of operations: 27
      I[5] = W16[ip]*(F1*(F8*(F6*G[0] + F7*G[2]) + F9*(F6*G[1] + F7*G[3]) - F2*det) + F10*(F12*G[7] + F8*G[5] + F9*G[6]) + F11*(F12*G[10] + F8*G[6] + F9*G[9]));
      
      // Number of operations: 27
      I[6] = W16[ip]*(F1*(F4*(F6*G[0] + F7*G[2]) + F5*(F6*G[1] + F7*G[3]) - F0*det) + F10*(F12*G[4] + F4*G[5] + F5*G[6]) + F11*(F12*G[8] + F4*G[6] + F5*G[9]));
      
      
      // Number of operations for primary indices: 6
      for (unsigned int j = 0; j < 3; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc8[j]] += FE2_C2[ip][j]*I[0];
      }// end loop over 'j'
      
      // Number of operations for primary indices: 40
      for (unsigned int j = 0; j < 5; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc4[j]] += FE1_D10[ip][j]*I[1];
        // Number of operations to compute entry: 2
        A[nzc7[j]] += FE1_D10[ip][j]*I[2];
        // Number of operations to compute entry: 2
        A[nzc3[j]] += FE1_D01[ip][j]*I[3];
        // Number of operations to compute entry: 2
        A[nzc6[j]] += FE1_D01[ip][j]*I[4];
      }// end loop over 'j'
      
      // Number of operations for primary indices: 24
      for (unsigned int j = 0; j < 6; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc5[j]] += FE1[ip][j]*I[5];
        // Number of operations to compute entry: 2
        A[nzc2[j]] += FE1[ip][j]*I[6];
      }// end loop over 'j'
    }// end loop over 'ip'
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not yet implemented (introduced in UFC 2.0).");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_5_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_5_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_5_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x[v1][0] - x[v0][0];
    const double dx1 = x[v1][1] - x[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    const bool direction = dx1*(x[facet][0] - x[v0][0]) - dx0*(x[facet][1] - x[v0][1]) < 0;// Compute facet normals from the facet scale factor constants
    const double n0 = direction ? dx1 / det : -dx1 / det;
    const double n1 = direction ? -dx0 / det : dx0 / det;
    
    // Cell Volume.
    
    // Compute circumradius, assuming triangle is embedded in 2D.
    
    
    // Array of quadrature weights.
    static const double W3[3] = {0.277777777777778, 0.444444444444444, 0.277777777777778};
    // Quadrature points on the UFC reference element: (0.112701665379258), (0.500000000000000), (0.887298334620742)
    
    // Value of basis functions at quadrature points.
    static const double FE0_f0[3][2] = \
    {{0.887298334620742, 0.112701665379258},
    {0.500000000000000, 0.500000000000000},
    {0.112701665379258, 0.887298334620742}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[2] = {1, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 1};
    
    static const double FE1_f0[3][3] = \
    {{0.687298334620742, -0.087298334620742, 0.400000000000000},
    {0.000000000000000, 0.000000000000000, 1.000000000000000},
    {-0.087298334620742, 0.687298334620742, 0.400000000000000}};
    
    // Array of non-zero columns
    static const unsigned int nzc5[3] = {0, 1, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc3[3] = {1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc9[3] = {0, 2, 4};
    
    // Array of non-zero columns
    static const unsigned int nzc10[3] = {6, 8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc13[3] = {6, 7, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc12[3] = {0, 1, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc4[3] = {0, 2, 4};
    
    // Array of non-zero columns
    static const unsigned int nzc6[3] = {1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc7[3] = {7, 8, 9};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.000000000000000;
    }// end loop over 'r'
    // Number of operations to compute geometry constants: 2.
    double G[2];
    G[0] =  - det*n1;
    G[1] =  - det*n0;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    switch (facet)
    {
    case 0:
      {
        // Total number of operations to compute element tensor (from this point): 84
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 84
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.000000000000000;
        double F1 = 0.000000000000000;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc0[r]];
        }// end loop over 'r'
        
        // Total number of operations to compute function values = 6
        for (unsigned int r = 0; r < 3; r++)
        {
          F1 += FE1_f0[ip][r]*w[4][nzc3[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 6
        double I[2];
        // Number of operations: 3
        I[0] = F0*F1*G[0]*W3[ip];
        
        // Number of operations: 3
        I[1] = F0*F1*G[1]*W3[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc7[j]] += FE1_f0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc6[j]] += FE1_f0[ip][j]*I[1];
        }// end loop over 'j'
      }// end loop over 'ip'
        break;
      }
    case 1:
      {
        // Total number of operations to compute element tensor (from this point): 84
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 84
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.000000000000000;
        double F1 = 0.000000000000000;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc1[r]];
        }// end loop over 'r'
        
        // Total number of operations to compute function values = 6
        for (unsigned int r = 0; r < 3; r++)
        {
          F1 += FE1_f0[ip][r]*w[4][nzc4[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 6
        double I[2];
        // Number of operations: 3
        I[0] = F0*F1*G[0]*W3[ip];
        
        // Number of operations: 3
        I[1] = F0*F1*G[1]*W3[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc10[j]] += FE1_f0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc9[j]] += FE1_f0[ip][j]*I[1];
        }// end loop over 'j'
      }// end loop over 'ip'
        break;
      }
    case 2:
      {
        // Total number of operations to compute element tensor (from this point): 84
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 84
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.000000000000000;
        double F1 = 0.000000000000000;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc2[r]];
        }// end loop over 'r'
        
        // Total number of operations to compute function values = 6
        for (unsigned int r = 0; r < 3; r++)
        {
          F1 += FE1_f0[ip][r]*w[4][nzc5[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 6
        double I[2];
        // Number of operations: 3
        I[0] = F0*F1*G[0]*W3[ip];
        
        // Number of operations: 3
        I[1] = F0*F1*G[1]*W3[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc13[j]] += FE1_f0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc12[j]] += FE1_f0[ip][j]*I[1];
        }// end loop over 'j'
      }// end loop over 'ip'
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not yet implemented (introduced in UFC 2.0).");
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_6_0: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_6_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_6_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Cell Volume.
    
    // Compute circumradius, assuming triangle is embedded in 2D.
    
    
    // Array of quadrature weights.
    static const double W12[12] = {0.025422453185103, 0.025422453185103, 0.025422453185103, 0.058393137863189, 0.058393137863189, 0.058393137863189, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187};
    // Quadrature points on the UFC reference element: (0.873821971016996, 0.063089014491502), (0.063089014491502, 0.873821971016996), (0.063089014491502, 0.063089014491502), (0.501426509658179, 0.249286745170910), (0.249286745170910, 0.501426509658179), (0.249286745170910, 0.249286745170910), (0.636502499121399, 0.310352451033785), (0.636502499121399, 0.053145049844816), (0.310352451033785, 0.636502499121399), (0.310352451033785, 0.053145049844816), (0.053145049844816, 0.636502499121399), (0.053145049844816, 0.310352451033785)
    
    // Value of basis functions at quadrature points.
    static const double FE1_C0[12][6] = \
    {{-0.055128566992484, 0.653307703047060, -0.055128566992484, 0.220514267969936, 0.015920894998036, 0.220514267969936},
    {-0.055128566992484, -0.055128566992484, 0.653307703047060, 0.220514267969936, 0.220514267969936, 0.015920894998036},
    {0.653307703047060, -0.055128566992484, -0.055128566992484, 0.015920894998036, 0.220514267969936, 0.220514267969936},
    {-0.124998982535097, 0.001430579517789, -0.124998982535098, 0.499995930140389, 0.248575525271626, 0.499995930140391},
    {-0.124998982535097, -0.124998982535098, 0.001430579517789, 0.499995930140389, 0.499995930140391, 0.248575525271626},
    {0.001430579517790, -0.124998982535098, -0.124998982535098, 0.248575525271625, 0.499995930140390, 0.499995930140390},
    {-0.047496257198800, 0.173768363654174, -0.117715163308429, 0.790160442765823, 0.065974785918605, 0.135307828168627},
    {-0.117715163308429, 0.173768363654174, -0.047496257198800, 0.135307828168627, 0.065974785918605, 0.790160442765823},
    {-0.047496257198800, -0.117715163308429, 0.173768363654174, 0.790160442765823, 0.135307828168627, 0.065974785918605},
    {0.173768363654174, -0.117715163308429, -0.047496257198800, 0.065974785918605, 0.135307828168627, 0.790160442765823},
    {-0.117715163308429, -0.047496257198800, 0.173768363654174, 0.135307828168627, 0.790160442765823, 0.065974785918605},
    {0.173768363654174, -0.047496257198800, -0.117715163308429, 0.065974785918605, 0.790160442765823, 0.135307828168627}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[6] = {0, 1, 2, 3, 4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc3[6] = {6, 7, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc15[6] = {20, 21, 22, 23, 24, 25};
    
    static const double FE1_C0_D01[12][5] = \
    {{0.747643942033992, -0.747643942033992, 3.495287884067981, 0.000000000000000, -3.495287884067983},
    {0.747643942033992, 2.495287884067984, 0.252356057966006, -3.242931826101975, -0.252356057966007},
    {-2.495287884067984, -0.747643942033992, 0.252356057966008, 3.242931826101975, -0.252356057966008},
    {0.002853019316356, -0.002853019316360, 2.005706038632715, 0.000000000000000, -2.005706038632716},
    {0.002853019316356, 1.005706038632716, 0.997146980683640, -1.008559057949072, -0.997146980683640},
    {-1.005706038632720, -0.002853019316360, 0.997146980683640, 1.008559057949080, -0.997146980683640},
    {0.787419800620736, 0.241409804135140, 2.546009996485596, -1.028829604755876, -2.546009996485596},
    {-0.241409804135140, -0.787419800620736, 2.546009996485595, 1.028829604755877, -2.546009996485596},
    {0.787419800620736, 1.546009996485596, 1.241409804135140, -2.333429797106332, -1.241409804135140},
    {-1.546009996485596, -0.787419800620736, 1.241409804135139, 2.333429797106332, -1.241409804135140},
    {-0.241409804135140, 1.546009996485596, 0.212580199379263, -1.304600192350456, -0.212580199379263},
    {-1.546009996485596, 0.241409804135140, 0.212580199379264, 1.304600192350456, -0.212580199379264}};
    
    // Array of non-zero columns
    static const unsigned int nzc1[5] = {0, 2, 3, 4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc4[5] = {6, 8, 9, 10, 11};
    
    static const double FE1_C0_D10[12][5] = \
    {{0.747643942033991, 2.495287884067983, 0.252356057966007, -0.252356057966007, -3.242931826101974},
    {0.747643942033993, -0.747643942033993, 3.495287884067982, -3.495287884067982, 0.000000000000000},
    {-2.495287884067984, -0.747643942033992, 0.252356057966007, -0.252356057966007, 3.242931826101976},
    {0.002853019316356, 1.005706038632716, 0.997146980683639, -0.997146980683639, -1.008559057949072},
    {0.002853019316357, -0.002853019316360, 2.005706038632716, -2.005706038632716, 0.000000000000000},
    {-1.005706038632720, -0.002853019316360, 0.997146980683639, -0.997146980683639, 1.008559057949080},
    {0.787419800620736, 1.546009996485596, 1.241409804135140, -1.241409804135140, -2.333429797106332},
    {-0.241409804135140, 1.546009996485596, 0.212580199379262, -0.212580199379262, -1.304600192350456},
    {0.787419800620737, 0.241409804135140, 2.546009996485595, -2.546009996485595, -1.028829604755876},
    {-1.546009996485596, 0.241409804135140, 0.212580199379263, -0.212580199379263, 1.304600192350456},
    {-0.241409804135140, -0.787419800620737, 2.546009996485595, -2.546009996485595, 1.028829604755876},
    {-1.546009996485596, -0.787419800620737, 1.241409804135140, -1.241409804135140, 2.333429797106333}};
    
    // Array of non-zero columns
    static const unsigned int nzc5[5] = {6, 7, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc2[5] = {0, 1, 3, 4, 5};
    
    static const double FE1_C2[12][3] = \
    {{0.063089014491502, 0.873821971016996, 0.063089014491502},
    {0.063089014491502, 0.063089014491502, 0.873821971016996},
    {0.873821971016996, 0.063089014491502, 0.063089014491502},
    {0.249286745170911, 0.501426509658179, 0.249286745170910},
    {0.249286745170911, 0.249286745170910, 0.501426509658179},
    {0.501426509658180, 0.249286745170910, 0.249286745170910},
    {0.053145049844816, 0.636502499121399, 0.310352451033785},
    {0.310352451033785, 0.636502499121399, 0.053145049844816},
    {0.053145049844816, 0.310352451033785, 0.636502499121399},
    {0.636502499121399, 0.310352451033785, 0.053145049844816},
    {0.310352451033785, 0.053145049844816, 0.636502499121399},
    {0.636502499121399, 0.053145049844816, 0.310352451033785}};
    
    // Array of non-zero columns
    static const unsigned int nzc6[3] = {12, 13, 14};
    
    static const double FE2_C0[12][10] = \
    {{0.046307995390867, 0.440268993398561, 0.046307995390867, 0.402250914961474, -0.201125457480737, -0.014521043556326, -0.014521043556326, -0.201125457480737, 0.402250914961474, 0.093906187970884},
    {0.046307995390867, 0.046307995390867, 0.440268993398561, -0.201125457480737, 0.402250914961474, -0.201125457480737, 0.402250914961474, -0.014521043556326, -0.014521043556326, 0.093906187970883},
    {0.440268993398561, 0.046307995390867, 0.046307995390867, -0.014521043556326, -0.014521043556326, 0.402250914961474, -0.201125457480737, 0.402250914961474, -0.201125457480737, 0.093906187970884},
    {0.039351685817458, -0.062673722052400, 0.039351685817459, 0.283654926157929, -0.141827463078965, -0.070510246199197, -0.070510246199198, -0.141827463078964, 0.283654926157930, 0.841335916657949},
    {0.039351685817458, 0.039351685817459, -0.062673722052400, -0.141827463078965, 0.283654926157929, -0.141827463078964, 0.283654926157930, -0.070510246199197, -0.070510246199198, 0.841335916657949},
    {-0.062673722052400, 0.039351685817459, 0.039351685817459, -0.070510246199198, -0.070510246199198, 0.283654926157931, -0.141827463078965, 0.283654926157931, -0.141827463078966, 0.841335916657947},
    {0.041110728466435, -0.026193226599355, 0.011435826065380, 0.808488952668145, -0.061285221448741, -0.062388096817690, -0.005117035916025, -0.127951879895303, 0.138446419692862, 0.283453533784293},
    {0.011435826065380, -0.026193226599355, 0.041110728466435, 0.138446419692861, -0.127951879895303, -0.005117035916025, -0.062388096817690, -0.061285221448741, 0.808488952668146, 0.283453533784293},
    {0.041110728466435, 0.011435826065380, -0.026193226599355, -0.061285221448741, 0.808488952668146, -0.127951879895303, 0.138446419692862, -0.062388096817690, -0.005117035916025, 0.283453533784293},
    {-0.026193226599355, 0.011435826065380, 0.041110728466435, -0.005117035916025, -0.062388096817690, 0.138446419692861, -0.127951879895303, 0.808488952668146, -0.061285221448741, 0.283453533784293},
    {0.011435826065380, 0.041110728466435, -0.026193226599355, -0.127951879895303, 0.138446419692862, -0.061285221448741, 0.808488952668146, -0.005117035916025, -0.062388096817690, 0.283453533784293},
    {-0.026193226599355, 0.041110728466435, 0.011435826065380, -0.062388096817690, -0.005117035916025, 0.808488952668145, -0.061285221448741, 0.138446419692862, -0.127951879895303, 0.283453533784293}};
    
    // Array of non-zero columns
    static const unsigned int nzc9[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc12[10] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
    
    static const double FE2_C0_D01[12][9] = \
    {{-0.485931890194853, 0.485931890194852, 6.375926430355889, -2.443727560779408, -0.053733020618371, 0.053733020618371, 2.443727560779409, -6.375926430355892, 0.000000000000000},
    {-0.485931890194854, 3.443727560779413, -0.230167544593386, 1.204570743585314, 2.213560016186026, -5.171355686770587, 0.176434523975019, 0.230167544593386, -1.381005267560332},
    {-3.443727560779411, 0.485931890194852, -0.230167544593387, -0.176434523975020, 5.171355686770580, -2.213560016186022, -1.204570743585312, 0.230167544593386, 1.381005267560335},
    {0.404638308746458, -0.404638308746456, 1.137866058475978, 1.118553234985822, -0.838942397791738, 0.838942397791737, -1.118553234985834, -1.137866058475979, 0.000000000000012},
    {0.404638308746458, -0.118553234985829, -0.282847955477360, 2.253182175178532, -1.401401190463194, 1.115316116702565, -0.556094442314379, 0.282847955477361, -1.697087732864153},
    {0.118553234985824, -0.404638308746456, -0.282847955477360, 0.556094442314372, -1.115316116702552, 1.401401190463186, -2.253182175178539, 0.282847955477361, 1.697087732864166},
    {-0.559823901757263, -0.492870367157913, 2.605067077688823, 2.469321742623012, 0.750232850760382, 0.302461418154795, 1.950933405908064, -2.605067077688823, -4.420255148531075},
    {0.492870367157913, 0.559823901757263, 2.605067077688823, -1.950933405908065, -0.302461418154795, -0.750232850760382, -2.469321742623011, -2.605067077688823, 4.420255148531077},
    {-0.559823901757264, 0.740805831642528, -0.096284337505882, 3.936996959017275, 1.749910031966999, -1.930891961852263, 0.951256224701445, 0.096284337505882, -4.888253183718719},
    {-0.740805831642527, 0.559823901757263, -0.096284337505879, -0.951256224701449, 1.930891961852264, -1.749910031967000, -3.936996959017275, 0.096284337505880, 4.888253183718724},
    {0.492870367157913, 0.740805831642527, -0.201023373941063, 0.674175115836558, -2.565606080128890, 1.331929881328449, -0.206177080648912, 0.201023373941063, -0.467998035187647},
    {-0.740805831642527, -0.492870367157913, -0.201023373941065, 0.206177080648914, -1.331929881328450, 2.565606080128891, -0.674175115836559, 0.201023373941066, 0.467998035187645}};
    
    // Array of non-zero columns
    static const unsigned int nzc13[9] = {10, 12, 13, 14, 15, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc10[9] = {0, 2, 3, 4, 5, 6, 7, 8, 9};
    
    static const double FE2_C0_D10[12][9] = \
    {{-0.485931890194853, 3.443727560779410, 1.204570743585312, -0.230167544593389, 0.176434523975015, 0.230167544593389, 2.213560016186021, -5.171355686770577, -1.381005267560327},
    {-0.485931890194854, 0.485931890194854, -2.443727560779412, 6.375926430355897, 2.443727560779413, -6.375926430355898, -0.053733020618370, 0.053733020618368, 0.000000000000000},
    {-3.443727560779410, 0.485931890194852, -0.176434523975019, -0.230167544593390, -1.204570743585313, 0.230167544593389, 5.171355686770577, -2.213560016186020, 1.381005267560331},
    {0.404638308746458, -0.118553234985828, 2.253182175178531, -0.282847955477360, -0.556094442314379, 0.282847955477361, -1.401401190463193, 1.115316116702563, -1.697087732864154},
    {0.404638308746458, -0.404638308746456, 1.118553234985820, 1.137866058475978, -1.118553234985836, -1.137866058475977, -0.838942397791738, 0.838942397791735, 0.000000000000015},
    {0.118553234985824, -0.404638308746456, 0.556094442314372, -0.282847955477361, -2.253182175178539, 0.282847955477361, -1.115316116702552, 1.401401190463184, 1.697087732864167},
    {-0.559823901757263, 0.740805831642528, 3.936996959017273, -0.096284337505878, 0.951256224701447, 0.096284337505879, 1.749910031966999, -1.930891961852264, -4.888253183718721},
    {0.492870367157913, 0.740805831642527, 0.674175115836558, -0.201023373941065, -0.206177080648914, 0.201023373941066, -2.565606080128891, 1.331929881328451, -0.467998035187644},
    {-0.559823901757263, -0.492870367157914, 2.469321742623009, 2.605067077688825, 1.950933405908062, -2.605067077688825, 0.750232850760382, 0.302461418154794, -4.420255148531071},
    {-0.740805831642527, -0.492870367157913, 0.206177080648913, -0.201023373941065, -0.674175115836559, 0.201023373941066, -1.331929881328452, 2.565606080128893, 0.467998035187646},
    {0.492870367157913, 0.559823901757263, -1.950933405908064, 2.605067077688822, -2.469321742623009, -2.605067077688823, -0.302461418154794, -0.750232850760383, 4.420255148531072},
    {-0.740805831642527, 0.559823901757263, -0.951256224701447, -0.096284337505880, -3.936996959017274, 0.096284337505880, 1.930891961852263, -1.749910031966999, 4.888253183718721}};
    
    // Array of non-zero columns
    static const unsigned int nzc14[9] = {10, 11, 13, 14, 15, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc11[9] = {0, 1, 3, 4, 5, 6, 7, 8, 9};
    
    // Reset values in the element tensor.
    A[0] = 0.000000000000000;
    // Number of operations to compute geometry constants: 23.
    double G[11];
    G[0] =  - det*w[2][0]*(K_00*K_10 + K_01*K_11);
    G[1] =  - K_00*det;
    G[2] =  - K_01*det;
    G[3] =  - det*w[2][0]*(K_00*K_00 + K_01*K_01);
    G[4] =  - det*w[2][0]*(K_10*K_10 + K_11*K_11);
    G[5] =  - K_10*det;
    G[6] =  - K_11*det;
    G[7] = K_10*det;
    G[8] = K_01*det;
    G[9] = K_11*det;
    G[10] = K_00*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 3024
    for (unsigned int ip = 0; ip < 12; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.000000000000000;
      double F1 = 0.000000000000000;
      double F2 = 0.000000000000000;
      double F3 = 0.000000000000000;
      double F4 = 0.000000000000000;
      double F5 = 0.000000000000000;
      double F6 = 0.000000000000000;
      double F7 = 0.000000000000000;
      double F8 = 0.000000000000000;
      double F9 = 0.000000000000000;
      double F10 = 0.000000000000000;
      double F11 = 0.000000000000000;
      double F12 = 0.000000000000000;
      double F13 = 0.000000000000000;
      
      // Total number of operations to compute function values = 72
      for (unsigned int r = 0; r < 9; r++)
      {
        F9 += FE2_C0_D10[ip][r]*w[3][nzc11[r]];
        F10 += FE2_C0_D01[ip][r]*w[3][nzc10[r]];
        F11 += FE2_C0_D10[ip][r]*w[3][nzc14[r]];
        F12 += FE2_C0_D01[ip][r]*w[3][nzc13[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 40
      for (unsigned int r = 0; r < 10; r++)
      {
        F4 += FE2_C0[ip][r]*w[3][nzc9[r]];
        F7 += FE2_C0[ip][r]*w[3][nzc12[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 6
      for (unsigned int r = 0; r < 3; r++)
      {
        F13 += FE1_C2[ip][r]*w[0][nzc6[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 40
      for (unsigned int r = 0; r < 5; r++)
      {
        F0 += FE1_C0_D10[ip][r]*w[0][nzc2[r]];
        F1 += FE1_C0_D01[ip][r]*w[0][nzc1[r]];
        F5 += FE1_C0_D10[ip][r]*w[0][nzc5[r]];
        F6 += FE1_C0_D01[ip][r]*w[0][nzc4[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 36
      for (unsigned int r = 0; r < 6; r++)
      {
        F2 += FE1_C0[ip][r]*w[0][nzc0[r]];
        F3 += FE1_C0[ip][r]*w[0][nzc3[r]];
        F8 += FE1_C0[ip][r]*w[3][nzc15[r]];
      }// end loop over 'r'
      
      // Number of operations to compute ip constants: 57
      double I[1];
      // Number of operations: 57
      I[0] = W12[ip]*(F0*(F10*G[0] + F4*(F2*G[1] + F3*G[2]) + F8*G[1] + F9*G[3]) + F1*(F10*G[4] + F3*F4*G[6] + F9*G[0] + G[5]*(F8 + F2*F4)) + F13*(F10*G[7] + F11*G[8] + F12*G[9] + F9*G[10]) + F5*(F11*G[3] + F12*G[0] + F7*(F2*G[1] + F3*G[2]) + F8*G[2]) + F6*(F11*G[0] + F12*G[4] + F2*F7*G[5] + G[6]*(F8 + F3*F7)));
      
      
      // Number of operations for primary indices: 1
      // Number of operations to compute entry: 1
      A[0] += I[0];
    }// end loop over 'ip'
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not yet implemented (introduced in UFC 2.0).");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_6_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_6_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_6_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x[v1][0] - x[v0][0];
    const double dx1 = x[v1][1] - x[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    const bool direction = dx1*(x[facet][0] - x[v0][0]) - dx0*(x[facet][1] - x[v0][1]) < 0;// Compute facet normals from the facet scale factor constants
    const double n0 = direction ? dx1 / det : -dx1 / det;
    const double n1 = direction ? -dx0 / det : dx0 / det;
    
    // Cell Volume.
    
    // Compute circumradius, assuming triangle is embedded in 2D.
    
    
    // Array of quadrature weights.
    static const double W3[3] = {0.277777777777778, 0.444444444444444, 0.277777777777778};
    // Quadrature points on the UFC reference element: (0.112701665379258), (0.500000000000000), (0.887298334620742)
    
    // Value of basis functions at quadrature points.
    static const double FE0_f0[3][2] = \
    {{0.887298334620742, 0.112701665379258},
    {0.500000000000000, 0.500000000000000},
    {0.112701665379258, 0.887298334620742}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[2] = {1, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 1};
    
    static const double FE1_f0_C0[3][4] = \
    {{0.488014084041408, 0.061985915958592, 0.747852751738001, -0.297852751738001},
    {-0.062500000000000, -0.062500000000000, 0.562500000000000, 0.562500000000000},
    {0.061985915958592, 0.488014084041408, -0.297852751738001, 0.747852751738001}};
    
    // Array of non-zero columns
    static const unsigned int nzc3[4] = {1, 2, 3, 4};
    
    // Array of non-zero columns
    static const unsigned int nzc4[4] = {11, 12, 13, 14};
    
    // Array of non-zero columns
    static const unsigned int nzc9[4] = {0, 1, 7, 8};
    
    // Array of non-zero columns
    static const unsigned int nzc10[4] = {10, 11, 17, 18};
    
    // Array of non-zero columns
    static const unsigned int nzc7[4] = {10, 12, 15, 16};
    
    // Array of non-zero columns
    static const unsigned int nzc6[4] = {0, 2, 5, 6};
    
    // Reset values in the element tensor.
    A[0] = 0.000000000000000;
    // Number of operations to compute geometry constants: 2.
    double G[2];
    G[0] =  - det*n0;
    G[1] =  - det*n1;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    switch (facet)
    {
    case 0:
      {
        // Total number of operations to compute element tensor (from this point): 78
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 78
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.000000000000000;
        double F1 = 0.000000000000000;
        double F2 = 0.000000000000000;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc0[r]];
        }// end loop over 'r'
        
        // Total number of operations to compute function values = 16
        for (unsigned int r = 0; r < 4; r++)
        {
          F1 += FE1_f0_C0[ip][r]*w[3][nzc3[r]];
          F2 += FE1_f0_C0[ip][r]*w[3][nzc4[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 5
        double I[1];
        // Number of operations: 5
        I[0] = F0*W3[ip]*(F1*G[0] + F2*G[1]);
        
        
        // Number of operations for primary indices: 1
        // Number of operations to compute entry: 1
        A[0] += I[0];
      }// end loop over 'ip'
        break;
      }
    case 1:
      {
        // Total number of operations to compute element tensor (from this point): 78
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 78
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.000000000000000;
        double F1 = 0.000000000000000;
        double F2 = 0.000000000000000;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc1[r]];
        }// end loop over 'r'
        
        // Total number of operations to compute function values = 16
        for (unsigned int r = 0; r < 4; r++)
        {
          F1 += FE1_f0_C0[ip][r]*w[3][nzc6[r]];
          F2 += FE1_f0_C0[ip][r]*w[3][nzc7[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 5
        double I[1];
        // Number of operations: 5
        I[0] = F0*W3[ip]*(F1*G[0] + F2*G[1]);
        
        
        // Number of operations for primary indices: 1
        // Number of operations to compute entry: 1
        A[0] += I[0];
      }// end loop over 'ip'
        break;
      }
    case 2:
      {
        // Total number of operations to compute element tensor (from this point): 78
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 78
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.000000000000000;
        double F1 = 0.000000000000000;
        double F2 = 0.000000000000000;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc2[r]];
        }// end loop over 'r'
        
        // Total number of operations to compute function values = 16
        for (unsigned int r = 0; r < 4; r++)
        {
          F1 += FE1_f0_C0[ip][r]*w[3][nzc9[r]];
          F2 += FE1_f0_C0[ip][r]*w[3][nzc10[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 5
        double I[1];
        // Number of operations: 5
        I[0] = F0*W3[ip]*(F1*G[0] + F2*G[1]);
        
        
        // Number of operations for primary indices: 1
        // Number of operations to compute entry: 1
        A[0] += I[0];
      }// end loop over 'ip'
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not yet implemented (introduced in UFC 2.0).");
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_7_0: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_7_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_7_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      9
    // Number of operations (multiply-add pairs) for geometry tensor:    292
    // Number of operations (multiply-add pairs) for tensor contraction: 194
    // Total number of operations (multiply-add pairs):                  495
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0_0 = det*w[1][0]*w[0][0]*(1.0);
    const double G0_0_1 = det*w[1][0]*w[0][1]*(1.0);
    const double G0_0_2 = det*w[1][0]*w[0][2]*(1.0);
    const double G0_0_3 = det*w[1][0]*w[0][3]*(1.0);
    const double G0_0_4 = det*w[1][0]*w[0][4]*(1.0);
    const double G0_0_5 = det*w[1][0]*w[0][5]*(1.0);
    const double G0_0_6 = det*w[1][0]*w[0][6]*(1.0);
    const double G0_0_7 = det*w[1][0]*w[0][7]*(1.0);
    const double G0_0_8 = det*w[1][0]*w[0][8]*(1.0);
    const double G0_0_9 = det*w[1][0]*w[0][9]*(1.0);
    const double G0_1_0 = det*w[1][1]*w[0][0]*(1.0);
    const double G0_1_1 = det*w[1][1]*w[0][1]*(1.0);
    const double G0_1_2 = det*w[1][1]*w[0][2]*(1.0);
    const double G0_1_3 = det*w[1][1]*w[0][3]*(1.0);
    const double G0_1_4 = det*w[1][1]*w[0][4]*(1.0);
    const double G0_1_5 = det*w[1][1]*w[0][5]*(1.0);
    const double G0_1_6 = det*w[1][1]*w[0][6]*(1.0);
    const double G0_1_7 = det*w[1][1]*w[0][7]*(1.0);
    const double G0_1_8 = det*w[1][1]*w[0][8]*(1.0);
    const double G0_1_9 = det*w[1][1]*w[0][9]*(1.0);
    const double G0_2_0 = det*w[1][2]*w[0][0]*(1.0);
    const double G0_2_1 = det*w[1][2]*w[0][1]*(1.0);
    const double G0_2_2 = det*w[1][2]*w[0][2]*(1.0);
    const double G0_2_3 = det*w[1][2]*w[0][3]*(1.0);
    const double G0_2_4 = det*w[1][2]*w[0][4]*(1.0);
    const double G0_2_5 = det*w[1][2]*w[0][5]*(1.0);
    const double G0_2_6 = det*w[1][2]*w[0][6]*(1.0);
    const double G0_2_7 = det*w[1][2]*w[0][7]*(1.0);
    const double G0_2_8 = det*w[1][2]*w[0][8]*(1.0);
    const double G0_2_9 = det*w[1][2]*w[0][9]*(1.0);
    const double G0_3_0 = det*w[1][3]*w[0][0]*(1.0);
    const double G0_3_1 = det*w[1][3]*w[0][1]*(1.0);
    const double G0_3_2 = det*w[1][3]*w[0][2]*(1.0);
    const double G0_3_3 = det*w[1][3]*w[0][3]*(1.0);
    const double G0_3_4 = det*w[1][3]*w[0][4]*(1.0);
    const double G0_3_5 = det*w[1][3]*w[0][5]*(1.0);
    const double G0_3_6 = det*w[1][3]*w[0][6]*(1.0);
    const double G0_3_7 = det*w[1][3]*w[0][7]*(1.0);
    const double G0_3_8 = det*w[1][3]*w[0][8]*(1.0);
    const double G0_3_9 = det*w[1][3]*w[0][9]*(1.0);
    const double G0_4_0 = det*w[1][4]*w[0][0]*(1.0);
    const double G0_4_1 = det*w[1][4]*w[0][1]*(1.0);
    const double G0_4_2 = det*w[1][4]*w[0][2]*(1.0);
    const double G0_4_3 = det*w[1][4]*w[0][3]*(1.0);
    const double G0_4_4 = det*w[1][4]*w[0][4]*(1.0);
    const double G0_4_5 = det*w[1][4]*w[0][5]*(1.0);
    const double G0_4_6 = det*w[1][4]*w[0][6]*(1.0);
    const double G0_4_7 = det*w[1][4]*w[0][7]*(1.0);
    const double G0_4_8 = det*w[1][4]*w[0][8]*(1.0);
    const double G0_4_9 = det*w[1][4]*w[0][9]*(1.0);
    const double G0_5_0 = det*w[1][5]*w[0][0]*(1.0);
    const double G0_5_1 = det*w[1][5]*w[0][1]*(1.0);
    const double G0_5_2 = det*w[1][5]*w[0][2]*(1.0);
    const double G0_5_3 = det*w[1][5]*w[0][3]*(1.0);
    const double G0_5_4 = det*w[1][5]*w[0][4]*(1.0);
    const double G0_5_5 = det*w[1][5]*w[0][5]*(1.0);
    const double G0_5_6 = det*w[1][5]*w[0][6]*(1.0);
    const double G0_5_7 = det*w[1][5]*w[0][7]*(1.0);
    const double G0_5_8 = det*w[1][5]*w[0][8]*(1.0);
    const double G0_5_9 = det*w[1][5]*w[0][9]*(1.0);
    const double G0_6_10 = det*w[1][6]*w[0][10]*(1.0);
    const double G0_6_11 = det*w[1][6]*w[0][11]*(1.0);
    const double G0_6_12 = det*w[1][6]*w[0][12]*(1.0);
    const double G0_6_13 = det*w[1][6]*w[0][13]*(1.0);
    const double G0_6_14 = det*w[1][6]*w[0][14]*(1.0);
    const double G0_6_15 = det*w[1][6]*w[0][15]*(1.0);
    const double G0_6_16 = det*w[1][6]*w[0][16]*(1.0);
    const double G0_6_17 = det*w[1][6]*w[0][17]*(1.0);
    const double G0_6_18 = det*w[1][6]*w[0][18]*(1.0);
    const double G0_6_19 = det*w[1][6]*w[0][19]*(1.0);
    const double G0_7_10 = det*w[1][7]*w[0][10]*(1.0);
    const double G0_7_11 = det*w[1][7]*w[0][11]*(1.0);
    const double G0_7_12 = det*w[1][7]*w[0][12]*(1.0);
    const double G0_7_13 = det*w[1][7]*w[0][13]*(1.0);
    const double G0_7_14 = det*w[1][7]*w[0][14]*(1.0);
    const double G0_7_15 = det*w[1][7]*w[0][15]*(1.0);
    const double G0_7_16 = det*w[1][7]*w[0][16]*(1.0);
    const double G0_7_17 = det*w[1][7]*w[0][17]*(1.0);
    const double G0_7_18 = det*w[1][7]*w[0][18]*(1.0);
    const double G0_7_19 = det*w[1][7]*w[0][19]*(1.0);
    const double G0_8_10 = det*w[1][8]*w[0][10]*(1.0);
    const double G0_8_11 = det*w[1][8]*w[0][11]*(1.0);
    const double G0_8_12 = det*w[1][8]*w[0][12]*(1.0);
    const double G0_8_13 = det*w[1][8]*w[0][13]*(1.0);
    const double G0_8_14 = det*w[1][8]*w[0][14]*(1.0);
    const double G0_8_15 = det*w[1][8]*w[0][15]*(1.0);
    const double G0_8_16 = det*w[1][8]*w[0][16]*(1.0);
    const double G0_8_17 = det*w[1][8]*w[0][17]*(1.0);
    const double G0_8_18 = det*w[1][8]*w[0][18]*(1.0);
    const double G0_8_19 = det*w[1][8]*w[0][19]*(1.0);
    const double G0_9_10 = det*w[1][9]*w[0][10]*(1.0);
    const double G0_9_11 = det*w[1][9]*w[0][11]*(1.0);
    const double G0_9_12 = det*w[1][9]*w[0][12]*(1.0);
    const double G0_9_13 = det*w[1][9]*w[0][13]*(1.0);
    const double G0_9_14 = det*w[1][9]*w[0][14]*(1.0);
    const double G0_9_15 = det*w[1][9]*w[0][15]*(1.0);
    const double G0_9_16 = det*w[1][9]*w[0][16]*(1.0);
    const double G0_9_17 = det*w[1][9]*w[0][17]*(1.0);
    const double G0_9_18 = det*w[1][9]*w[0][18]*(1.0);
    const double G0_9_19 = det*w[1][9]*w[0][19]*(1.0);
    const double G0_10_10 = det*w[1][10]*w[0][10]*(1.0);
    const double G0_10_11 = det*w[1][10]*w[0][11]*(1.0);
    const double G0_10_12 = det*w[1][10]*w[0][12]*(1.0);
    const double G0_10_13 = det*w[1][10]*w[0][13]*(1.0);
    const double G0_10_14 = det*w[1][10]*w[0][14]*(1.0);
    const double G0_10_15 = det*w[1][10]*w[0][15]*(1.0);
    const double G0_10_16 = det*w[1][10]*w[0][16]*(1.0);
    const double G0_10_17 = det*w[1][10]*w[0][17]*(1.0);
    const double G0_10_18 = det*w[1][10]*w[0][18]*(1.0);
    const double G0_10_19 = det*w[1][10]*w[0][19]*(1.0);
    const double G0_11_10 = det*w[1][11]*w[0][10]*(1.0);
    const double G0_11_11 = det*w[1][11]*w[0][11]*(1.0);
    const double G0_11_12 = det*w[1][11]*w[0][12]*(1.0);
    const double G0_11_13 = det*w[1][11]*w[0][13]*(1.0);
    const double G0_11_14 = det*w[1][11]*w[0][14]*(1.0);
    const double G0_11_15 = det*w[1][11]*w[0][15]*(1.0);
    const double G0_11_16 = det*w[1][11]*w[0][16]*(1.0);
    const double G0_11_17 = det*w[1][11]*w[0][17]*(1.0);
    const double G0_11_18 = det*w[1][11]*w[0][18]*(1.0);
    const double G0_11_19 = det*w[1][11]*w[0][19]*(1.0);
    const double G0_12_20 = det*w[1][12]*w[0][20]*(1.0);
    const double G0_12_21 = det*w[1][12]*w[0][21]*(1.0);
    const double G0_12_22 = det*w[1][12]*w[0][22]*(1.0);
    const double G0_12_23 = det*w[1][12]*w[0][23]*(1.0);
    const double G0_12_24 = det*w[1][12]*w[0][24]*(1.0);
    const double G0_12_25 = det*w[1][12]*w[0][25]*(1.0);
    const double G0_13_20 = det*w[1][13]*w[0][20]*(1.0);
    const double G0_13_21 = det*w[1][13]*w[0][21]*(1.0);
    const double G0_13_22 = det*w[1][13]*w[0][22]*(1.0);
    const double G0_13_23 = det*w[1][13]*w[0][23]*(1.0);
    const double G0_13_24 = det*w[1][13]*w[0][24]*(1.0);
    const double G0_13_25 = det*w[1][13]*w[0][25]*(1.0);
    const double G0_14_20 = det*w[1][14]*w[0][20]*(1.0);
    const double G0_14_21 = det*w[1][14]*w[0][21]*(1.0);
    const double G0_14_22 = det*w[1][14]*w[0][22]*(1.0);
    const double G0_14_23 = det*w[1][14]*w[0][23]*(1.0);
    const double G0_14_24 = det*w[1][14]*w[0][24]*(1.0);
    const double G0_14_25 = det*w[1][14]*w[0][25]*(1.0);
    const double G1_0_0 = det*w[1][0]*w[3][0]*(1.0);
    const double G1_0_1 = det*w[1][0]*w[3][1]*(1.0);
    const double G1_0_2 = det*w[1][0]*w[3][2]*(1.0);
    const double G1_0_3 = det*w[1][0]*w[3][3]*(1.0);
    const double G1_1_0 = det*w[1][1]*w[3][0]*(1.0);
    const double G1_1_1 = det*w[1][1]*w[3][1]*(1.0);
    const double G1_1_2 = det*w[1][1]*w[3][2]*(1.0);
    const double G1_1_4 = det*w[1][1]*w[3][4]*(1.0);
    const double G1_2_0 = det*w[1][2]*w[3][0]*(1.0);
    const double G1_2_1 = det*w[1][2]*w[3][1]*(1.0);
    const double G1_2_2 = det*w[1][2]*w[3][2]*(1.0);
    const double G1_2_5 = det*w[1][2]*w[3][5]*(1.0);
    const double G1_3_0 = det*w[1][3]*w[3][0]*(1.0);
    const double G1_3_3 = det*w[1][3]*w[3][3]*(1.0);
    const double G1_3_4 = det*w[1][3]*w[3][4]*(1.0);
    const double G1_3_5 = det*w[1][3]*w[3][5]*(1.0);
    const double G1_4_1 = det*w[1][4]*w[3][1]*(1.0);
    const double G1_4_3 = det*w[1][4]*w[3][3]*(1.0);
    const double G1_4_4 = det*w[1][4]*w[3][4]*(1.0);
    const double G1_4_5 = det*w[1][4]*w[3][5]*(1.0);
    const double G1_5_2 = det*w[1][5]*w[3][2]*(1.0);
    const double G1_5_3 = det*w[1][5]*w[3][3]*(1.0);
    const double G1_5_4 = det*w[1][5]*w[3][4]*(1.0);
    const double G1_5_5 = det*w[1][5]*w[3][5]*(1.0);
    const double G1_6_6 = det*w[1][6]*w[3][6]*(1.0);
    const double G1_6_7 = det*w[1][6]*w[3][7]*(1.0);
    const double G1_6_8 = det*w[1][6]*w[3][8]*(1.0);
    const double G1_6_9 = det*w[1][6]*w[3][9]*(1.0);
    const double G1_7_6 = det*w[1][7]*w[3][6]*(1.0);
    const double G1_7_7 = det*w[1][7]*w[3][7]*(1.0);
    const double G1_7_8 = det*w[1][7]*w[3][8]*(1.0);
    const double G1_7_10 = det*w[1][7]*w[3][10]*(1.0);
    const double G1_8_6 = det*w[1][8]*w[3][6]*(1.0);
    const double G1_8_7 = det*w[1][8]*w[3][7]*(1.0);
    const double G1_8_8 = det*w[1][8]*w[3][8]*(1.0);
    const double G1_8_11 = det*w[1][8]*w[3][11]*(1.0);
    const double G1_9_6 = det*w[1][9]*w[3][6]*(1.0);
    const double G1_9_9 = det*w[1][9]*w[3][9]*(1.0);
    const double G1_9_10 = det*w[1][9]*w[3][10]*(1.0);
    const double G1_9_11 = det*w[1][9]*w[3][11]*(1.0);
    const double G1_10_7 = det*w[1][10]*w[3][7]*(1.0);
    const double G1_10_9 = det*w[1][10]*w[3][9]*(1.0);
    const double G1_10_10 = det*w[1][10]*w[3][10]*(1.0);
    const double G1_10_11 = det*w[1][10]*w[3][11]*(1.0);
    const double G1_11_8 = det*w[1][11]*w[3][8]*(1.0);
    const double G1_11_9 = det*w[1][11]*w[3][9]*(1.0);
    const double G1_11_10 = det*w[1][11]*w[3][10]*(1.0);
    const double G1_11_11 = det*w[1][11]*w[3][11]*(1.0);
    const double G1_12_12 = det*w[1][12]*w[3][12]*(1.0);
    const double G1_12_13 = det*w[1][12]*w[3][13]*(1.0);
    const double G1_12_14 = det*w[1][12]*w[3][14]*(1.0);
    const double G1_13_12 = det*w[1][13]*w[3][12]*(1.0);
    const double G1_13_13 = det*w[1][13]*w[3][13]*(1.0);
    const double G1_13_14 = det*w[1][13]*w[3][14]*(1.0);
    const double G1_14_12 = det*w[1][14]*w[3][12]*(1.0);
    const double G1_14_13 = det*w[1][14]*w[3][13]*(1.0);
    const double G1_14_14 = det*w[1][14]*w[3][14]*(1.0);
    
    // Compute element tensor
    A[0] = 0.005952380952381*G0_0_0 + 0.000595238095238*G0_0_1 + 0.000595238095238*G0_0_2 - 0.003571428571429*G0_0_3 - 0.003571428571429*G0_0_4 + 0.016071428571429*G0_0_5 - 0.010714285714286*G0_0_6 + 0.016071428571429*G0_0_7 - 0.010714285714286*G0_0_8 - 0.010714285714286*G0_0_9 + 0.000595238095238*G0_1_0 + 0.005952380952381*G0_1_1 + 0.000595238095238*G0_1_2 + 0.016071428571429*G0_1_3 - 0.010714285714286*G0_1_4 - 0.003571428571429*G0_1_5 - 0.003571428571429*G0_1_6 - 0.010714285714286*G0_1_7 + 0.016071428571429*G0_1_8 - 0.010714285714286*G0_1_9 + 0.000595238095238*G0_2_0 + 0.000595238095238*G0_2_1 + 0.005952380952381*G0_2_2 - 0.010714285714286*G0_2_3 + 0.016071428571429*G0_2_4 - 0.010714285714286*G0_2_5 + 0.016071428571429*G0_2_6 - 0.003571428571429*G0_2_7 - 0.003571428571429*G0_2_8 - 0.010714285714286*G0_2_9 + 0.004761904761905*G0_3_0 + 0.002380952380952*G0_3_1 + 0.002380952380952*G0_3_2 + 0.028571428571429*G0_3_3 + 0.028571428571429*G0_3_4 - 0.007142857142857*G0_3_5 + 0.014285714285714*G0_3_6 - 0.007142857142857*G0_3_7 + 0.014285714285714*G0_3_8 + 0.085714285714286*G0_3_9 + 0.002380952380952*G0_4_0 + 0.004761904761905*G0_4_1 + 0.002380952380952*G0_4_2 - 0.007142857142857*G0_4_3 + 0.014285714285714*G0_4_4 + 0.028571428571429*G0_4_5 + 0.028571428571429*G0_4_6 + 0.014285714285714*G0_4_7 - 0.007142857142857*G0_4_8 + 0.085714285714286*G0_4_9 + 0.002380952380952*G0_5_0 + 0.002380952380952*G0_5_1 + 0.004761904761905*G0_5_2 + 0.014285714285714*G0_5_3 - 0.007142857142857*G0_5_4 + 0.014285714285714*G0_5_5 - 0.007142857142857*G0_5_6 + 0.028571428571429*G0_5_7 + 0.028571428571429*G0_5_8 + 0.085714285714286*G0_5_9 + 0.005952380952381*G0_6_10 + 0.000595238095238*G0_6_11 + 0.000595238095238*G0_6_12 - 0.003571428571429*G0_6_13 - 0.003571428571429*G0_6_14 + 0.016071428571429*G0_6_15 - 0.010714285714286*G0_6_16 + 0.016071428571429*G0_6_17 - 0.010714285714286*G0_6_18 - 0.010714285714286*G0_6_19 + 0.000595238095238*G0_7_10 + 0.005952380952381*G0_7_11 + 0.000595238095238*G0_7_12 + 0.016071428571429*G0_7_13 - 0.010714285714286*G0_7_14 - 0.003571428571429*G0_7_15 - 0.003571428571429*G0_7_16 - 0.010714285714286*G0_7_17 + 0.016071428571429*G0_7_18 - 0.010714285714286*G0_7_19 + 0.000595238095238*G0_8_10 + 0.000595238095238*G0_8_11 + 0.005952380952381*G0_8_12 - 0.010714285714286*G0_8_13 + 0.016071428571429*G0_8_14 - 0.010714285714286*G0_8_15 + 0.016071428571429*G0_8_16 - 0.003571428571429*G0_8_17 - 0.003571428571429*G0_8_18 - 0.010714285714286*G0_8_19 + 0.004761904761905*G0_9_10 + 0.002380952380952*G0_9_11 + 0.002380952380952*G0_9_12 + 0.028571428571429*G0_9_13 + 0.028571428571429*G0_9_14 - 0.007142857142857*G0_9_15 + 0.014285714285714*G0_9_16 - 0.007142857142857*G0_9_17 + 0.014285714285714*G0_9_18 + 0.085714285714286*G0_9_19 + 0.002380952380952*G0_10_10 + 0.004761904761905*G0_10_11 + 0.002380952380952*G0_10_12 - 0.007142857142857*G0_10_13 + 0.014285714285714*G0_10_14 + 0.028571428571429*G0_10_15 + 0.028571428571429*G0_10_16 + 0.014285714285714*G0_10_17 - 0.007142857142857*G0_10_18 + 0.085714285714286*G0_10_19 + 0.002380952380952*G0_11_10 + 0.002380952380952*G0_11_11 + 0.004761904761905*G0_11_12 + 0.014285714285714*G0_11_13 - 0.007142857142857*G0_11_14 + 0.014285714285714*G0_11_15 - 0.007142857142857*G0_11_16 + 0.028571428571429*G0_11_17 + 0.028571428571429*G0_11_18 + 0.085714285714286*G0_11_19 + 0.016666666666667*G0_12_20 - 0.008333333333333*G0_12_21 - 0.008333333333333*G0_12_22 + 0.033333333333333*G0_12_23 + 0.066666666666667*G0_12_24 + 0.066666666666667*G0_12_25 - 0.008333333333333*G0_13_20 + 0.016666666666667*G0_13_21 - 0.008333333333333*G0_13_22 + 0.066666666666667*G0_13_23 + 0.033333333333333*G0_13_24 + 0.066666666666667*G0_13_25 - 0.008333333333333*G0_14_20 - 0.008333333333333*G0_14_21 + 0.016666666666667*G0_14_22 + 0.066666666666667*G0_14_23 + 0.066666666666667*G0_14_24 + 0.033333333333333*G0_14_25 - 0.016666666666667*G1_0_0 + 0.002777777777778*G1_0_1 + 0.002777777777778*G1_0_2 + 0.011111111111111*G1_0_3 + 0.002777777777778*G1_1_0 - 0.016666666666667*G1_1_1 + 0.002777777777778*G1_1_2 + 0.011111111111111*G1_1_4 + 0.002777777777778*G1_2_0 + 0.002777777777778*G1_2_1 - 0.016666666666667*G1_2_2 + 0.011111111111111*G1_2_5 + 0.011111111111111*G1_3_0 - 0.088888888888889*G1_3_3 - 0.044444444444444*G1_3_4 - 0.044444444444444*G1_3_5 + 0.011111111111111*G1_4_1 - 0.044444444444444*G1_4_3 - 0.088888888888889*G1_4_4 - 0.044444444444444*G1_4_5 + 0.011111111111111*G1_5_2 - 0.044444444444444*G1_5_3 - 0.044444444444444*G1_5_4 - 0.088888888888889*G1_5_5 - 0.016666666666667*G1_6_6 + 0.002777777777778*G1_6_7 + 0.002777777777778*G1_6_8 + 0.011111111111111*G1_6_9 + 0.002777777777778*G1_7_6 - 0.016666666666667*G1_7_7 + 0.002777777777778*G1_7_8 + 0.011111111111111*G1_7_10 + 0.002777777777778*G1_8_6 + 0.002777777777778*G1_8_7 - 0.016666666666667*G1_8_8 + 0.011111111111111*G1_8_11 + 0.011111111111111*G1_9_6 - 0.088888888888889*G1_9_9 - 0.044444444444444*G1_9_10 - 0.044444444444444*G1_9_11 + 0.011111111111111*G1_10_7 - 0.044444444444444*G1_10_9 - 0.088888888888889*G1_10_10 - 0.044444444444444*G1_10_11 + 0.011111111111111*G1_11_8 - 0.044444444444444*G1_11_9 - 0.044444444444444*G1_11_10 - 0.088888888888889*G1_11_11 - 0.083333333333333*G1_12_12 - 0.041666666666667*G1_12_13 - 0.041666666666667*G1_12_14 - 0.041666666666667*G1_13_12 - 0.083333333333333*G1_13_13 - 0.041666666666667*G1_13_14 - 0.041666666666667*G1_14_12 - 0.041666666666667*G1_14_13 - 0.083333333333333*G1_14_14;
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_7_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_7_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_7_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      9
    // Number of operations (multiply-add pairs) for geometry tensor:    180
    // Number of operations (multiply-add pairs) for tensor contraction: 136
    // Total number of operations (multiply-add pairs):                  325
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x[v1][0] - x[v0][0];
    const double dx1 = x[v1][1] - x[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    // Compute geometry tensor
    const double G0_0_0 = det*w[2][0]*w[0][0]*(1.0);
    const double G0_0_5 = det*w[2][0]*w[0][5]*(1.0);
    const double G0_0_6 = det*w[2][0]*w[0][6]*(1.0);
    const double G0_0_7 = det*w[2][0]*w[0][7]*(1.0);
    const double G0_0_8 = det*w[2][0]*w[0][8]*(1.0);
    const double G0_1_1 = det*w[2][1]*w[0][1]*(1.0);
    const double G0_1_3 = det*w[2][1]*w[0][3]*(1.0);
    const double G0_1_4 = det*w[2][1]*w[0][4]*(1.0);
    const double G0_1_7 = det*w[2][1]*w[0][7]*(1.0);
    const double G0_1_8 = det*w[2][1]*w[0][8]*(1.0);
    const double G0_2_2 = det*w[2][2]*w[0][2]*(1.0);
    const double G0_2_3 = det*w[2][2]*w[0][3]*(1.0);
    const double G0_2_4 = det*w[2][2]*w[0][4]*(1.0);
    const double G0_2_5 = det*w[2][2]*w[0][5]*(1.0);
    const double G0_2_6 = det*w[2][2]*w[0][6]*(1.0);
    const double G0_3_1 = det*w[2][3]*w[0][1]*(1.0);
    const double G0_3_2 = det*w[2][3]*w[0][2]*(1.0);
    const double G0_3_3 = det*w[2][3]*w[0][3]*(1.0);
    const double G0_3_4 = det*w[2][3]*w[0][4]*(1.0);
    const double G0_4_0 = det*w[2][4]*w[0][0]*(1.0);
    const double G0_4_2 = det*w[2][4]*w[0][2]*(1.0);
    const double G0_4_5 = det*w[2][4]*w[0][5]*(1.0);
    const double G0_4_6 = det*w[2][4]*w[0][6]*(1.0);
    const double G0_5_0 = det*w[2][5]*w[0][0]*(1.0);
    const double G0_5_1 = det*w[2][5]*w[0][1]*(1.0);
    const double G0_5_7 = det*w[2][5]*w[0][7]*(1.0);
    const double G0_5_8 = det*w[2][5]*w[0][8]*(1.0);
    const double G0_6_10 = det*w[2][6]*w[0][10]*(1.0);
    const double G0_6_15 = det*w[2][6]*w[0][15]*(1.0);
    const double G0_6_16 = det*w[2][6]*w[0][16]*(1.0);
    const double G0_6_17 = det*w[2][6]*w[0][17]*(1.0);
    const double G0_6_18 = det*w[2][6]*w[0][18]*(1.0);
    const double G0_7_11 = det*w[2][7]*w[0][11]*(1.0);
    const double G0_7_13 = det*w[2][7]*w[0][13]*(1.0);
    const double G0_7_14 = det*w[2][7]*w[0][14]*(1.0);
    const double G0_7_17 = det*w[2][7]*w[0][17]*(1.0);
    const double G0_7_18 = det*w[2][7]*w[0][18]*(1.0);
    const double G0_8_12 = det*w[2][8]*w[0][12]*(1.0);
    const double G0_8_13 = det*w[2][8]*w[0][13]*(1.0);
    const double G0_8_14 = det*w[2][8]*w[0][14]*(1.0);
    const double G0_8_15 = det*w[2][8]*w[0][15]*(1.0);
    const double G0_8_16 = det*w[2][8]*w[0][16]*(1.0);
    const double G0_9_11 = det*w[2][9]*w[0][11]*(1.0);
    const double G0_9_12 = det*w[2][9]*w[0][12]*(1.0);
    const double G0_9_13 = det*w[2][9]*w[0][13]*(1.0);
    const double G0_9_14 = det*w[2][9]*w[0][14]*(1.0);
    const double G0_10_10 = det*w[2][10]*w[0][10]*(1.0);
    const double G0_10_12 = det*w[2][10]*w[0][12]*(1.0);
    const double G0_10_15 = det*w[2][10]*w[0][15]*(1.0);
    const double G0_10_16 = det*w[2][10]*w[0][16]*(1.0);
    const double G0_11_10 = det*w[2][11]*w[0][10]*(1.0);
    const double G0_11_11 = det*w[2][11]*w[0][11]*(1.0);
    const double G0_11_17 = det*w[2][11]*w[0][17]*(1.0);
    const double G0_11_18 = det*w[2][11]*w[0][18]*(1.0);
    const double G0_12_20 = det*w[2][12]*w[0][20]*(1.0);
    const double G0_12_24 = det*w[2][12]*w[0][24]*(1.0);
    const double G0_12_25 = det*w[2][12]*w[0][25]*(1.0);
    const double G0_13_21 = det*w[2][13]*w[0][21]*(1.0);
    const double G0_13_23 = det*w[2][13]*w[0][23]*(1.0);
    const double G0_13_25 = det*w[2][13]*w[0][25]*(1.0);
    const double G0_14_22 = det*w[2][14]*w[0][22]*(1.0);
    const double G0_14_23 = det*w[2][14]*w[0][23]*(1.0);
    const double G0_14_24 = det*w[2][14]*w[0][24]*(1.0);
    const double G1_0_0 = det*w[2][0]*w[3][0]*(1.0);
    const double G1_0_1 = det*w[2][0]*w[3][1]*(1.0);
    const double G1_0_2 = det*w[2][0]*w[3][2]*(1.0);
    const double G1_0_4 = det*w[2][0]*w[3][4]*(1.0);
    const double G1_0_5 = det*w[2][0]*w[3][5]*(1.0);
    const double G1_1_0 = det*w[2][1]*w[3][0]*(1.0);
    const double G1_1_1 = det*w[2][1]*w[3][1]*(1.0);
    const double G1_1_2 = det*w[2][1]*w[3][2]*(1.0);
    const double G1_1_3 = det*w[2][1]*w[3][3]*(1.0);
    const double G1_1_5 = det*w[2][1]*w[3][5]*(1.0);
    const double G1_2_0 = det*w[2][2]*w[3][0]*(1.0);
    const double G1_2_1 = det*w[2][2]*w[3][1]*(1.0);
    const double G1_2_2 = det*w[2][2]*w[3][2]*(1.0);
    const double G1_2_3 = det*w[2][2]*w[3][3]*(1.0);
    const double G1_2_4 = det*w[2][2]*w[3][4]*(1.0);
    const double G1_3_1 = det*w[2][3]*w[3][1]*(1.0);
    const double G1_3_2 = det*w[2][3]*w[3][2]*(1.0);
    const double G1_3_3 = det*w[2][3]*w[3][3]*(1.0);
    const double G1_4_0 = det*w[2][4]*w[3][0]*(1.0);
    const double G1_4_2 = det*w[2][4]*w[3][2]*(1.0);
    const double G1_4_4 = det*w[2][4]*w[3][4]*(1.0);
    const double G1_5_0 = det*w[2][5]*w[3][0]*(1.0);
    const double G1_5_1 = det*w[2][5]*w[3][1]*(1.0);
    const double G1_5_5 = det*w[2][5]*w[3][5]*(1.0);
    const double G1_6_6 = det*w[2][6]*w[3][6]*(1.0);
    const double G1_6_7 = det*w[2][6]*w[3][7]*(1.0);
    const double G1_6_8 = det*w[2][6]*w[3][8]*(1.0);
    const double G1_6_10 = det*w[2][6]*w[3][10]*(1.0);
    const double G1_6_11 = det*w[2][6]*w[3][11]*(1.0);
    const double G1_7_6 = det*w[2][7]*w[3][6]*(1.0);
    const double G1_7_7 = det*w[2][7]*w[3][7]*(1.0);
    const double G1_7_8 = det*w[2][7]*w[3][8]*(1.0);
    const double G1_7_9 = det*w[2][7]*w[3][9]*(1.0);
    const double G1_7_11 = det*w[2][7]*w[3][11]*(1.0);
    const double G1_8_6 = det*w[2][8]*w[3][6]*(1.0);
    const double G1_8_7 = det*w[2][8]*w[3][7]*(1.0);
    const double G1_8_8 = det*w[2][8]*w[3][8]*(1.0);
    const double G1_8_9 = det*w[2][8]*w[3][9]*(1.0);
    const double G1_8_10 = det*w[2][8]*w[3][10]*(1.0);
    const double G1_9_7 = det*w[2][9]*w[3][7]*(1.0);
    const double G1_9_8 = det*w[2][9]*w[3][8]*(1.0);
    const double G1_9_9 = det*w[2][9]*w[3][9]*(1.0);
    const double G1_10_6 = det*w[2][10]*w[3][6]*(1.0);
    const double G1_10_8 = det*w[2][10]*w[3][8]*(1.0);
    const double G1_10_10 = det*w[2][10]*w[3][10]*(1.0);
    const double G1_11_6 = det*w[2][11]*w[3][6]*(1.0);
    const double G1_11_7 = det*w[2][11]*w[3][7]*(1.0);
    const double G1_11_11 = det*w[2][11]*w[3][11]*(1.0);
    const double G1_12_12 = det*w[2][12]*w[3][12]*(1.0);
    const double G1_12_13 = det*w[2][12]*w[3][13]*(1.0);
    const double G1_12_14 = det*w[2][12]*w[3][14]*(1.0);
    const double G1_13_12 = det*w[2][13]*w[3][12]*(1.0);
    const double G1_13_13 = det*w[2][13]*w[3][13]*(1.0);
    const double G1_13_14 = det*w[2][13]*w[3][14]*(1.0);
    const double G1_14_12 = det*w[2][14]*w[3][12]*(1.0);
    const double G1_14_13 = det*w[2][14]*w[3][13]*(1.0);
    const double G1_14_14 = det*w[2][14]*w[3][14]*(1.0);
    
    // Compute element tensor
    switch (facet)
    {
    case 0:
      {
        A[0] = 0.091666666666667*G0_1_1 + 0.150000000000000*G0_1_3 - 0.075000000000000*G0_1_4 + 0.091666666666667*G0_2_2 - 0.075000000000000*G0_2_3 + 0.150000000000000*G0_2_4 + 0.033333333333333*G0_3_1 + 0.033333333333333*G0_3_2 + 0.300000000000000*G0_3_3 + 0.300000000000000*G0_3_4 + 0.091666666666667*G0_7_11 + 0.150000000000000*G0_7_13 - 0.075000000000000*G0_7_14 + 0.091666666666667*G0_8_12 - 0.075000000000000*G0_8_13 + 0.150000000000000*G0_8_14 + 0.033333333333333*G0_9_11 + 0.033333333333333*G0_9_12 + 0.300000000000000*G0_9_13 + 0.300000000000000*G0_9_14 + 0.166666666666667*G0_13_21 + 0.333333333333333*G0_13_23 + 0.166666666666667*G0_14_22 + 0.333333333333333*G0_14_23 - 0.133333333333333*G1_1_1 + 0.033333333333333*G1_1_2 - 0.066666666666667*G1_1_3 + 0.033333333333333*G1_2_1 - 0.133333333333333*G1_2_2 - 0.066666666666667*G1_2_3 - 0.066666666666667*G1_3_1 - 0.066666666666667*G1_3_2 - 0.533333333333333*G1_3_3 - 0.133333333333333*G1_7_7 + 0.033333333333333*G1_7_8 - 0.066666666666667*G1_7_9 + 0.033333333333333*G1_8_7 - 0.133333333333333*G1_8_8 - 0.066666666666667*G1_8_9 - 0.066666666666667*G1_9_7 - 0.066666666666667*G1_9_8 - 0.533333333333333*G1_9_9 - 0.333333333333333*G1_13_13 - 0.166666666666667*G1_13_14 - 0.166666666666667*G1_14_13 - 0.333333333333333*G1_14_14;
        break;
      }
    case 1:
      {
        A[0] = 0.091666666666667*G0_0_0 + 0.150000000000000*G0_0_5 - 0.075000000000000*G0_0_6 + 0.091666666666667*G0_2_2 - 0.075000000000000*G0_2_5 + 0.150000000000000*G0_2_6 + 0.033333333333333*G0_4_0 + 0.033333333333333*G0_4_2 + 0.300000000000000*G0_4_5 + 0.300000000000000*G0_4_6 + 0.091666666666667*G0_6_10 + 0.150000000000000*G0_6_15 - 0.075000000000000*G0_6_16 + 0.091666666666667*G0_8_12 - 0.075000000000000*G0_8_15 + 0.150000000000000*G0_8_16 + 0.033333333333333*G0_10_10 + 0.033333333333333*G0_10_12 + 0.300000000000000*G0_10_15 + 0.300000000000000*G0_10_16 + 0.166666666666667*G0_12_20 + 0.333333333333333*G0_12_24 + 0.166666666666667*G0_14_22 + 0.333333333333333*G0_14_24 - 0.133333333333333*G1_0_0 + 0.033333333333333*G1_0_2 - 0.066666666666667*G1_0_4 + 0.033333333333333*G1_2_0 - 0.133333333333333*G1_2_2 - 0.066666666666667*G1_2_4 - 0.066666666666667*G1_4_0 - 0.066666666666667*G1_4_2 - 0.533333333333333*G1_4_4 - 0.133333333333333*G1_6_6 + 0.033333333333333*G1_6_8 - 0.066666666666667*G1_6_10 + 0.033333333333333*G1_8_6 - 0.133333333333333*G1_8_8 - 0.066666666666667*G1_8_10 - 0.066666666666667*G1_10_6 - 0.066666666666667*G1_10_8 - 0.533333333333333*G1_10_10 - 0.333333333333333*G1_12_12 - 0.166666666666667*G1_12_14 - 0.166666666666667*G1_14_12 - 0.333333333333333*G1_14_14;
        break;
      }
    case 2:
      {
        A[0] = 0.091666666666667*G0_0_0 + 0.150000000000000*G0_0_7 - 0.075000000000000*G0_0_8 + 0.091666666666667*G0_1_1 - 0.075000000000000*G0_1_7 + 0.150000000000000*G0_1_8 + 0.033333333333333*G0_5_0 + 0.033333333333333*G0_5_1 + 0.300000000000000*G0_5_7 + 0.300000000000000*G0_5_8 + 0.091666666666667*G0_6_10 + 0.150000000000000*G0_6_17 - 0.075000000000000*G0_6_18 + 0.091666666666667*G0_7_11 - 0.075000000000000*G0_7_17 + 0.150000000000000*G0_7_18 + 0.033333333333333*G0_11_10 + 0.033333333333333*G0_11_11 + 0.300000000000000*G0_11_17 + 0.300000000000000*G0_11_18 + 0.166666666666667*G0_12_20 + 0.333333333333333*G0_12_25 + 0.166666666666667*G0_13_21 + 0.333333333333333*G0_13_25 - 0.133333333333333*G1_0_0 + 0.033333333333333*G1_0_1 - 0.066666666666667*G1_0_5 + 0.033333333333333*G1_1_0 - 0.133333333333333*G1_1_1 - 0.066666666666667*G1_1_5 - 0.066666666666667*G1_5_0 - 0.066666666666667*G1_5_1 - 0.533333333333333*G1_5_5 - 0.133333333333333*G1_6_6 + 0.033333333333333*G1_6_7 - 0.066666666666667*G1_6_11 + 0.033333333333333*G1_7_6 - 0.133333333333333*G1_7_7 - 0.066666666666667*G1_7_11 - 0.066666666666667*G1_11_6 - 0.066666666666667*G1_11_7 - 0.533333333333333*G1_11_11 - 0.333333333333333*G1_12_12 - 0.166666666666667*G1_12_13 - 0.166666666666667*G1_13_12 - 0.333333333333333*G1_13_13;
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the
/// interior facet tensor corresponding to the local contribution to
/// a form from the integral over an interior facet.

class adaptivenavierstokes_interior_facet_integral_7_0: public ufc::interior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_interior_facet_integral_7_0() : ufc::interior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_interior_facet_integral_7_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local interior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c0,
                               const ufc::cell& c1,
                               unsigned int facet0,
                               unsigned int facet1) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      12
    // Number of operations (multiply-add pairs) for geometry tensor:    720
    // Number of operations (multiply-add pairs) for tensor contraction: 1647
    // Total number of operations (multiply-add pairs):                  2379
    
    // Extract vertex coordinates
    const double * const * x0 = c0.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet0][0];
    const unsigned int v1 = edge_vertices[facet0][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x0[v1][0] - x0[v0][0];
    const double dx1 = x0[v1][1] - x0[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    // Compute geometry tensor
    const double G0_15_26 = det*w[2][15]*w[0][26]*(1.0);
    const double G0_15_31 = det*w[2][15]*w[0][31]*(1.0);
    const double G0_15_32 = det*w[2][15]*w[0][32]*(1.0);
    const double G0_15_33 = det*w[2][15]*w[0][33]*(1.0);
    const double G0_15_34 = det*w[2][15]*w[0][34]*(1.0);
    const double G0_16_27 = det*w[2][16]*w[0][27]*(1.0);
    const double G0_16_29 = det*w[2][16]*w[0][29]*(1.0);
    const double G0_16_30 = det*w[2][16]*w[0][30]*(1.0);
    const double G0_16_33 = det*w[2][16]*w[0][33]*(1.0);
    const double G0_16_34 = det*w[2][16]*w[0][34]*(1.0);
    const double G0_17_28 = det*w[2][17]*w[0][28]*(1.0);
    const double G0_17_29 = det*w[2][17]*w[0][29]*(1.0);
    const double G0_17_30 = det*w[2][17]*w[0][30]*(1.0);
    const double G0_17_31 = det*w[2][17]*w[0][31]*(1.0);
    const double G0_17_32 = det*w[2][17]*w[0][32]*(1.0);
    const double G0_18_27 = det*w[2][18]*w[0][27]*(1.0);
    const double G0_18_28 = det*w[2][18]*w[0][28]*(1.0);
    const double G0_18_29 = det*w[2][18]*w[0][29]*(1.0);
    const double G0_18_30 = det*w[2][18]*w[0][30]*(1.0);
    const double G0_19_26 = det*w[2][19]*w[0][26]*(1.0);
    const double G0_19_28 = det*w[2][19]*w[0][28]*(1.0);
    const double G0_19_31 = det*w[2][19]*w[0][31]*(1.0);
    const double G0_19_32 = det*w[2][19]*w[0][32]*(1.0);
    const double G0_20_26 = det*w[2][20]*w[0][26]*(1.0);
    const double G0_20_27 = det*w[2][20]*w[0][27]*(1.0);
    const double G0_20_33 = det*w[2][20]*w[0][33]*(1.0);
    const double G0_20_34 = det*w[2][20]*w[0][34]*(1.0);
    const double G0_21_36 = det*w[2][21]*w[0][36]*(1.0);
    const double G0_21_41 = det*w[2][21]*w[0][41]*(1.0);
    const double G0_21_42 = det*w[2][21]*w[0][42]*(1.0);
    const double G0_21_43 = det*w[2][21]*w[0][43]*(1.0);
    const double G0_21_44 = det*w[2][21]*w[0][44]*(1.0);
    const double G0_22_37 = det*w[2][22]*w[0][37]*(1.0);
    const double G0_22_39 = det*w[2][22]*w[0][39]*(1.0);
    const double G0_22_40 = det*w[2][22]*w[0][40]*(1.0);
    const double G0_22_43 = det*w[2][22]*w[0][43]*(1.0);
    const double G0_22_44 = det*w[2][22]*w[0][44]*(1.0);
    const double G0_23_38 = det*w[2][23]*w[0][38]*(1.0);
    const double G0_23_39 = det*w[2][23]*w[0][39]*(1.0);
    const double G0_23_40 = det*w[2][23]*w[0][40]*(1.0);
    const double G0_23_41 = det*w[2][23]*w[0][41]*(1.0);
    const double G0_23_42 = det*w[2][23]*w[0][42]*(1.0);
    const double G0_24_37 = det*w[2][24]*w[0][37]*(1.0);
    const double G0_24_38 = det*w[2][24]*w[0][38]*(1.0);
    const double G0_24_39 = det*w[2][24]*w[0][39]*(1.0);
    const double G0_24_40 = det*w[2][24]*w[0][40]*(1.0);
    const double G0_25_36 = det*w[2][25]*w[0][36]*(1.0);
    const double G0_25_38 = det*w[2][25]*w[0][38]*(1.0);
    const double G0_25_41 = det*w[2][25]*w[0][41]*(1.0);
    const double G0_25_42 = det*w[2][25]*w[0][42]*(1.0);
    const double G0_26_36 = det*w[2][26]*w[0][36]*(1.0);
    const double G0_26_37 = det*w[2][26]*w[0][37]*(1.0);
    const double G0_26_43 = det*w[2][26]*w[0][43]*(1.0);
    const double G0_26_44 = det*w[2][26]*w[0][44]*(1.0);
    const double G0_27_46 = det*w[2][27]*w[0][46]*(1.0);
    const double G0_27_50 = det*w[2][27]*w[0][50]*(1.0);
    const double G0_27_51 = det*w[2][27]*w[0][51]*(1.0);
    const double G0_28_47 = det*w[2][28]*w[0][47]*(1.0);
    const double G0_28_49 = det*w[2][28]*w[0][49]*(1.0);
    const double G0_28_51 = det*w[2][28]*w[0][51]*(1.0);
    const double G0_29_48 = det*w[2][29]*w[0][48]*(1.0);
    const double G0_29_49 = det*w[2][29]*w[0][49]*(1.0);
    const double G0_29_50 = det*w[2][29]*w[0][50]*(1.0);
    const double G1_15_15 = det*w[2][15]*w[3][15]*(1.0);
    const double G1_15_16 = det*w[2][15]*w[3][16]*(1.0);
    const double G1_15_17 = det*w[2][15]*w[3][17]*(1.0);
    const double G1_15_19 = det*w[2][15]*w[3][19]*(1.0);
    const double G1_15_20 = det*w[2][15]*w[3][20]*(1.0);
    const double G1_16_15 = det*w[2][16]*w[3][15]*(1.0);
    const double G1_16_16 = det*w[2][16]*w[3][16]*(1.0);
    const double G1_16_17 = det*w[2][16]*w[3][17]*(1.0);
    const double G1_16_18 = det*w[2][16]*w[3][18]*(1.0);
    const double G1_16_20 = det*w[2][16]*w[3][20]*(1.0);
    const double G1_17_15 = det*w[2][17]*w[3][15]*(1.0);
    const double G1_17_16 = det*w[2][17]*w[3][16]*(1.0);
    const double G1_17_17 = det*w[2][17]*w[3][17]*(1.0);
    const double G1_17_18 = det*w[2][17]*w[3][18]*(1.0);
    const double G1_17_19 = det*w[2][17]*w[3][19]*(1.0);
    const double G1_18_16 = det*w[2][18]*w[3][16]*(1.0);
    const double G1_18_17 = det*w[2][18]*w[3][17]*(1.0);
    const double G1_18_18 = det*w[2][18]*w[3][18]*(1.0);
    const double G1_19_15 = det*w[2][19]*w[3][15]*(1.0);
    const double G1_19_17 = det*w[2][19]*w[3][17]*(1.0);
    const double G1_19_19 = det*w[2][19]*w[3][19]*(1.0);
    const double G1_20_15 = det*w[2][20]*w[3][15]*(1.0);
    const double G1_20_16 = det*w[2][20]*w[3][16]*(1.0);
    const double G1_20_20 = det*w[2][20]*w[3][20]*(1.0);
    const double G1_21_21 = det*w[2][21]*w[3][21]*(1.0);
    const double G1_21_22 = det*w[2][21]*w[3][22]*(1.0);
    const double G1_21_23 = det*w[2][21]*w[3][23]*(1.0);
    const double G1_21_25 = det*w[2][21]*w[3][25]*(1.0);
    const double G1_21_26 = det*w[2][21]*w[3][26]*(1.0);
    const double G1_22_21 = det*w[2][22]*w[3][21]*(1.0);
    const double G1_22_22 = det*w[2][22]*w[3][22]*(1.0);
    const double G1_22_23 = det*w[2][22]*w[3][23]*(1.0);
    const double G1_22_24 = det*w[2][22]*w[3][24]*(1.0);
    const double G1_22_26 = det*w[2][22]*w[3][26]*(1.0);
    const double G1_23_21 = det*w[2][23]*w[3][21]*(1.0);
    const double G1_23_22 = det*w[2][23]*w[3][22]*(1.0);
    const double G1_23_23 = det*w[2][23]*w[3][23]*(1.0);
    const double G1_23_24 = det*w[2][23]*w[3][24]*(1.0);
    const double G1_23_25 = det*w[2][23]*w[3][25]*(1.0);
    const double G1_24_22 = det*w[2][24]*w[3][22]*(1.0);
    const double G1_24_23 = det*w[2][24]*w[3][23]*(1.0);
    const double G1_24_24 = det*w[2][24]*w[3][24]*(1.0);
    const double G1_25_21 = det*w[2][25]*w[3][21]*(1.0);
    const double G1_25_23 = det*w[2][25]*w[3][23]*(1.0);
    const double G1_25_25 = det*w[2][25]*w[3][25]*(1.0);
    const double G1_26_21 = det*w[2][26]*w[3][21]*(1.0);
    const double G1_26_22 = det*w[2][26]*w[3][22]*(1.0);
    const double G1_26_26 = det*w[2][26]*w[3][26]*(1.0);
    const double G1_27_27 = det*w[2][27]*w[3][27]*(1.0);
    const double G1_27_28 = det*w[2][27]*w[3][28]*(1.0);
    const double G1_27_29 = det*w[2][27]*w[3][29]*(1.0);
    const double G1_28_27 = det*w[2][28]*w[3][27]*(1.0);
    const double G1_28_28 = det*w[2][28]*w[3][28]*(1.0);
    const double G1_28_29 = det*w[2][28]*w[3][29]*(1.0);
    const double G1_29_27 = det*w[2][29]*w[3][27]*(1.0);
    const double G1_29_28 = det*w[2][29]*w[3][28]*(1.0);
    const double G1_29_29 = det*w[2][29]*w[3][29]*(1.0);
    const double G2_0_0 = det*w[2][0]*w[0][0]*(1.0);
    const double G2_0_5 = det*w[2][0]*w[0][5]*(1.0);
    const double G2_0_6 = det*w[2][0]*w[0][6]*(1.0);
    const double G2_0_7 = det*w[2][0]*w[0][7]*(1.0);
    const double G2_0_8 = det*w[2][0]*w[0][8]*(1.0);
    const double G2_1_1 = det*w[2][1]*w[0][1]*(1.0);
    const double G2_1_3 = det*w[2][1]*w[0][3]*(1.0);
    const double G2_1_4 = det*w[2][1]*w[0][4]*(1.0);
    const double G2_1_7 = det*w[2][1]*w[0][7]*(1.0);
    const double G2_1_8 = det*w[2][1]*w[0][8]*(1.0);
    const double G2_2_2 = det*w[2][2]*w[0][2]*(1.0);
    const double G2_2_3 = det*w[2][2]*w[0][3]*(1.0);
    const double G2_2_4 = det*w[2][2]*w[0][4]*(1.0);
    const double G2_2_5 = det*w[2][2]*w[0][5]*(1.0);
    const double G2_2_6 = det*w[2][2]*w[0][6]*(1.0);
    const double G2_3_1 = det*w[2][3]*w[0][1]*(1.0);
    const double G2_3_2 = det*w[2][3]*w[0][2]*(1.0);
    const double G2_3_3 = det*w[2][3]*w[0][3]*(1.0);
    const double G2_3_4 = det*w[2][3]*w[0][4]*(1.0);
    const double G2_4_0 = det*w[2][4]*w[0][0]*(1.0);
    const double G2_4_2 = det*w[2][4]*w[0][2]*(1.0);
    const double G2_4_5 = det*w[2][4]*w[0][5]*(1.0);
    const double G2_4_6 = det*w[2][4]*w[0][6]*(1.0);
    const double G2_5_0 = det*w[2][5]*w[0][0]*(1.0);
    const double G2_5_1 = det*w[2][5]*w[0][1]*(1.0);
    const double G2_5_7 = det*w[2][5]*w[0][7]*(1.0);
    const double G2_5_8 = det*w[2][5]*w[0][8]*(1.0);
    const double G2_6_10 = det*w[2][6]*w[0][10]*(1.0);
    const double G2_6_15 = det*w[2][6]*w[0][15]*(1.0);
    const double G2_6_16 = det*w[2][6]*w[0][16]*(1.0);
    const double G2_6_17 = det*w[2][6]*w[0][17]*(1.0);
    const double G2_6_18 = det*w[2][6]*w[0][18]*(1.0);
    const double G2_7_11 = det*w[2][7]*w[0][11]*(1.0);
    const double G2_7_13 = det*w[2][7]*w[0][13]*(1.0);
    const double G2_7_14 = det*w[2][7]*w[0][14]*(1.0);
    const double G2_7_17 = det*w[2][7]*w[0][17]*(1.0);
    const double G2_7_18 = det*w[2][7]*w[0][18]*(1.0);
    const double G2_8_12 = det*w[2][8]*w[0][12]*(1.0);
    const double G2_8_13 = det*w[2][8]*w[0][13]*(1.0);
    const double G2_8_14 = det*w[2][8]*w[0][14]*(1.0);
    const double G2_8_15 = det*w[2][8]*w[0][15]*(1.0);
    const double G2_8_16 = det*w[2][8]*w[0][16]*(1.0);
    const double G2_9_11 = det*w[2][9]*w[0][11]*(1.0);
    const double G2_9_12 = det*w[2][9]*w[0][12]*(1.0);
    const double G2_9_13 = det*w[2][9]*w[0][13]*(1.0);
    const double G2_9_14 = det*w[2][9]*w[0][14]*(1.0);
    const double G2_10_10 = det*w[2][10]*w[0][10]*(1.0);
    const double G2_10_12 = det*w[2][10]*w[0][12]*(1.0);
    const double G2_10_15 = det*w[2][10]*w[0][15]*(1.0);
    const double G2_10_16 = det*w[2][10]*w[0][16]*(1.0);
    const double G2_11_10 = det*w[2][11]*w[0][10]*(1.0);
    const double G2_11_11 = det*w[2][11]*w[0][11]*(1.0);
    const double G2_11_17 = det*w[2][11]*w[0][17]*(1.0);
    const double G2_11_18 = det*w[2][11]*w[0][18]*(1.0);
    const double G2_12_20 = det*w[2][12]*w[0][20]*(1.0);
    const double G2_12_24 = det*w[2][12]*w[0][24]*(1.0);
    const double G2_12_25 = det*w[2][12]*w[0][25]*(1.0);
    const double G2_13_21 = det*w[2][13]*w[0][21]*(1.0);
    const double G2_13_23 = det*w[2][13]*w[0][23]*(1.0);
    const double G2_13_25 = det*w[2][13]*w[0][25]*(1.0);
    const double G2_14_22 = det*w[2][14]*w[0][22]*(1.0);
    const double G2_14_23 = det*w[2][14]*w[0][23]*(1.0);
    const double G2_14_24 = det*w[2][14]*w[0][24]*(1.0);
    const double G3_0_0 = det*w[2][0]*w[3][0]*(1.0);
    const double G3_0_1 = det*w[2][0]*w[3][1]*(1.0);
    const double G3_0_2 = det*w[2][0]*w[3][2]*(1.0);
    const double G3_0_4 = det*w[2][0]*w[3][4]*(1.0);
    const double G3_0_5 = det*w[2][0]*w[3][5]*(1.0);
    const double G3_1_0 = det*w[2][1]*w[3][0]*(1.0);
    const double G3_1_1 = det*w[2][1]*w[3][1]*(1.0);
    const double G3_1_2 = det*w[2][1]*w[3][2]*(1.0);
    const double G3_1_3 = det*w[2][1]*w[3][3]*(1.0);
    const double G3_1_5 = det*w[2][1]*w[3][5]*(1.0);
    const double G3_2_0 = det*w[2][2]*w[3][0]*(1.0);
    const double G3_2_1 = det*w[2][2]*w[3][1]*(1.0);
    const double G3_2_2 = det*w[2][2]*w[3][2]*(1.0);
    const double G3_2_3 = det*w[2][2]*w[3][3]*(1.0);
    const double G3_2_4 = det*w[2][2]*w[3][4]*(1.0);
    const double G3_3_1 = det*w[2][3]*w[3][1]*(1.0);
    const double G3_3_2 = det*w[2][3]*w[3][2]*(1.0);
    const double G3_3_3 = det*w[2][3]*w[3][3]*(1.0);
    const double G3_4_0 = det*w[2][4]*w[3][0]*(1.0);
    const double G3_4_2 = det*w[2][4]*w[3][2]*(1.0);
    const double G3_4_4 = det*w[2][4]*w[3][4]*(1.0);
    const double G3_5_0 = det*w[2][5]*w[3][0]*(1.0);
    const double G3_5_1 = det*w[2][5]*w[3][1]*(1.0);
    const double G3_5_5 = det*w[2][5]*w[3][5]*(1.0);
    const double G3_6_6 = det*w[2][6]*w[3][6]*(1.0);
    const double G3_6_7 = det*w[2][6]*w[3][7]*(1.0);
    const double G3_6_8 = det*w[2][6]*w[3][8]*(1.0);
    const double G3_6_10 = det*w[2][6]*w[3][10]*(1.0);
    const double G3_6_11 = det*w[2][6]*w[3][11]*(1.0);
    const double G3_7_6 = det*w[2][7]*w[3][6]*(1.0);
    const double G3_7_7 = det*w[2][7]*w[3][7]*(1.0);
    const double G3_7_8 = det*w[2][7]*w[3][8]*(1.0);
    const double G3_7_9 = det*w[2][7]*w[3][9]*(1.0);
    const double G3_7_11 = det*w[2][7]*w[3][11]*(1.0);
    const double G3_8_6 = det*w[2][8]*w[3][6]*(1.0);
    const double G3_8_7 = det*w[2][8]*w[3][7]*(1.0);
    const double G3_8_8 = det*w[2][8]*w[3][8]*(1.0);
    const double G3_8_9 = det*w[2][8]*w[3][9]*(1.0);
    const double G3_8_10 = det*w[2][8]*w[3][10]*(1.0);
    const double G3_9_7 = det*w[2][9]*w[3][7]*(1.0);
    const double G3_9_8 = det*w[2][9]*w[3][8]*(1.0);
    const double G3_9_9 = det*w[2][9]*w[3][9]*(1.0);
    const double G3_10_6 = det*w[2][10]*w[3][6]*(1.0);
    const double G3_10_8 = det*w[2][10]*w[3][8]*(1.0);
    const double G3_10_10 = det*w[2][10]*w[3][10]*(1.0);
    const double G3_11_6 = det*w[2][11]*w[3][6]*(1.0);
    const double G3_11_7 = det*w[2][11]*w[3][7]*(1.0);
    const double G3_11_11 = det*w[2][11]*w[3][11]*(1.0);
    const double G3_12_12 = det*w[2][12]*w[3][12]*(1.0);
    const double G3_12_13 = det*w[2][12]*w[3][13]*(1.0);
    const double G3_12_14 = det*w[2][12]*w[3][14]*(1.0);
    const double G3_13_12 = det*w[2][13]*w[3][12]*(1.0);
    const double G3_13_13 = det*w[2][13]*w[3][13]*(1.0);
    const double G3_13_14 = det*w[2][13]*w[3][14]*(1.0);
    const double G3_14_12 = det*w[2][14]*w[3][12]*(1.0);
    const double G3_14_13 = det*w[2][14]*w[3][13]*(1.0);
    const double G3_14_14 = det*w[2][14]*w[3][14]*(1.0);
    const double G4_15_26 = det*w[2][15]*w[0][26]*(1.0);
    const double G4_15_31 = det*w[2][15]*w[0][31]*(1.0);
    const double G4_15_32 = det*w[2][15]*w[0][32]*(1.0);
    const double G4_15_33 = det*w[2][15]*w[0][33]*(1.0);
    const double G4_15_34 = det*w[2][15]*w[0][34]*(1.0);
    const double G4_16_27 = det*w[2][16]*w[0][27]*(1.0);
    const double G4_16_29 = det*w[2][16]*w[0][29]*(1.0);
    const double G4_16_30 = det*w[2][16]*w[0][30]*(1.0);
    const double G4_16_33 = det*w[2][16]*w[0][33]*(1.0);
    const double G4_16_34 = det*w[2][16]*w[0][34]*(1.0);
    const double G4_17_28 = det*w[2][17]*w[0][28]*(1.0);
    const double G4_17_29 = det*w[2][17]*w[0][29]*(1.0);
    const double G4_17_30 = det*w[2][17]*w[0][30]*(1.0);
    const double G4_17_31 = det*w[2][17]*w[0][31]*(1.0);
    const double G4_17_32 = det*w[2][17]*w[0][32]*(1.0);
    const double G4_18_27 = det*w[2][18]*w[0][27]*(1.0);
    const double G4_18_28 = det*w[2][18]*w[0][28]*(1.0);
    const double G4_18_29 = det*w[2][18]*w[0][29]*(1.0);
    const double G4_18_30 = det*w[2][18]*w[0][30]*(1.0);
    const double G4_19_26 = det*w[2][19]*w[0][26]*(1.0);
    const double G4_19_28 = det*w[2][19]*w[0][28]*(1.0);
    const double G4_19_31 = det*w[2][19]*w[0][31]*(1.0);
    const double G4_19_32 = det*w[2][19]*w[0][32]*(1.0);
    const double G4_20_26 = det*w[2][20]*w[0][26]*(1.0);
    const double G4_20_27 = det*w[2][20]*w[0][27]*(1.0);
    const double G4_20_33 = det*w[2][20]*w[0][33]*(1.0);
    const double G4_20_34 = det*w[2][20]*w[0][34]*(1.0);
    const double G4_21_36 = det*w[2][21]*w[0][36]*(1.0);
    const double G4_21_41 = det*w[2][21]*w[0][41]*(1.0);
    const double G4_21_42 = det*w[2][21]*w[0][42]*(1.0);
    const double G4_21_43 = det*w[2][21]*w[0][43]*(1.0);
    const double G4_21_44 = det*w[2][21]*w[0][44]*(1.0);
    const double G4_22_37 = det*w[2][22]*w[0][37]*(1.0);
    const double G4_22_39 = det*w[2][22]*w[0][39]*(1.0);
    const double G4_22_40 = det*w[2][22]*w[0][40]*(1.0);
    const double G4_22_43 = det*w[2][22]*w[0][43]*(1.0);
    const double G4_22_44 = det*w[2][22]*w[0][44]*(1.0);
    const double G4_23_38 = det*w[2][23]*w[0][38]*(1.0);
    const double G4_23_39 = det*w[2][23]*w[0][39]*(1.0);
    const double G4_23_40 = det*w[2][23]*w[0][40]*(1.0);
    const double G4_23_41 = det*w[2][23]*w[0][41]*(1.0);
    const double G4_23_42 = det*w[2][23]*w[0][42]*(1.0);
    const double G4_24_37 = det*w[2][24]*w[0][37]*(1.0);
    const double G4_24_38 = det*w[2][24]*w[0][38]*(1.0);
    const double G4_24_39 = det*w[2][24]*w[0][39]*(1.0);
    const double G4_24_40 = det*w[2][24]*w[0][40]*(1.0);
    const double G4_25_36 = det*w[2][25]*w[0][36]*(1.0);
    const double G4_25_38 = det*w[2][25]*w[0][38]*(1.0);
    const double G4_25_41 = det*w[2][25]*w[0][41]*(1.0);
    const double G4_25_42 = det*w[2][25]*w[0][42]*(1.0);
    const double G4_26_36 = det*w[2][26]*w[0][36]*(1.0);
    const double G4_26_37 = det*w[2][26]*w[0][37]*(1.0);
    const double G4_26_43 = det*w[2][26]*w[0][43]*(1.0);
    const double G4_26_44 = det*w[2][26]*w[0][44]*(1.0);
    const double G4_27_46 = det*w[2][27]*w[0][46]*(1.0);
    const double G4_27_50 = det*w[2][27]*w[0][50]*(1.0);
    const double G4_27_51 = det*w[2][27]*w[0][51]*(1.0);
    const double G4_28_47 = det*w[2][28]*w[0][47]*(1.0);
    const double G4_28_49 = det*w[2][28]*w[0][49]*(1.0);
    const double G4_28_51 = det*w[2][28]*w[0][51]*(1.0);
    const double G4_29_48 = det*w[2][29]*w[0][48]*(1.0);
    const double G4_29_49 = det*w[2][29]*w[0][49]*(1.0);
    const double G4_29_50 = det*w[2][29]*w[0][50]*(1.0);
    const double G5_15_15 = det*w[2][15]*w[3][15]*(1.0);
    const double G5_15_16 = det*w[2][15]*w[3][16]*(1.0);
    const double G5_15_17 = det*w[2][15]*w[3][17]*(1.0);
    const double G5_15_19 = det*w[2][15]*w[3][19]*(1.0);
    const double G5_15_20 = det*w[2][15]*w[3][20]*(1.0);
    const double G5_16_15 = det*w[2][16]*w[3][15]*(1.0);
    const double G5_16_16 = det*w[2][16]*w[3][16]*(1.0);
    const double G5_16_17 = det*w[2][16]*w[3][17]*(1.0);
    const double G5_16_18 = det*w[2][16]*w[3][18]*(1.0);
    const double G5_16_20 = det*w[2][16]*w[3][20]*(1.0);
    const double G5_17_15 = det*w[2][17]*w[3][15]*(1.0);
    const double G5_17_16 = det*w[2][17]*w[3][16]*(1.0);
    const double G5_17_17 = det*w[2][17]*w[3][17]*(1.0);
    const double G5_17_18 = det*w[2][17]*w[3][18]*(1.0);
    const double G5_17_19 = det*w[2][17]*w[3][19]*(1.0);
    const double G5_18_16 = det*w[2][18]*w[3][16]*(1.0);
    const double G5_18_17 = det*w[2][18]*w[3][17]*(1.0);
    const double G5_18_18 = det*w[2][18]*w[3][18]*(1.0);
    const double G5_19_15 = det*w[2][19]*w[3][15]*(1.0);
    const double G5_19_17 = det*w[2][19]*w[3][17]*(1.0);
    const double G5_19_19 = det*w[2][19]*w[3][19]*(1.0);
    const double G5_20_15 = det*w[2][20]*w[3][15]*(1.0);
    const double G5_20_16 = det*w[2][20]*w[3][16]*(1.0);
    const double G5_20_20 = det*w[2][20]*w[3][20]*(1.0);
    const double G5_21_21 = det*w[2][21]*w[3][21]*(1.0);
    const double G5_21_22 = det*w[2][21]*w[3][22]*(1.0);
    const double G5_21_23 = det*w[2][21]*w[3][23]*(1.0);
    const double G5_21_25 = det*w[2][21]*w[3][25]*(1.0);
    const double G5_21_26 = det*w[2][21]*w[3][26]*(1.0);
    const double G5_22_21 = det*w[2][22]*w[3][21]*(1.0);
    const double G5_22_22 = det*w[2][22]*w[3][22]*(1.0);
    const double G5_22_23 = det*w[2][22]*w[3][23]*(1.0);
    const double G5_22_24 = det*w[2][22]*w[3][24]*(1.0);
    const double G5_22_26 = det*w[2][22]*w[3][26]*(1.0);
    const double G5_23_21 = det*w[2][23]*w[3][21]*(1.0);
    const double G5_23_22 = det*w[2][23]*w[3][22]*(1.0);
    const double G5_23_23 = det*w[2][23]*w[3][23]*(1.0);
    const double G5_23_24 = det*w[2][23]*w[3][24]*(1.0);
    const double G5_23_25 = det*w[2][23]*w[3][25]*(1.0);
    const double G5_24_22 = det*w[2][24]*w[3][22]*(1.0);
    const double G5_24_23 = det*w[2][24]*w[3][23]*(1.0);
    const double G5_24_24 = det*w[2][24]*w[3][24]*(1.0);
    const double G5_25_21 = det*w[2][25]*w[3][21]*(1.0);
    const double G5_25_23 = det*w[2][25]*w[3][23]*(1.0);
    const double G5_25_25 = det*w[2][25]*w[3][25]*(1.0);
    const double G5_26_21 = det*w[2][26]*w[3][21]*(1.0);
    const double G5_26_22 = det*w[2][26]*w[3][22]*(1.0);
    const double G5_26_26 = det*w[2][26]*w[3][26]*(1.0);
    const double G5_27_27 = det*w[2][27]*w[3][27]*(1.0);
    const double G5_27_28 = det*w[2][27]*w[3][28]*(1.0);
    const double G5_27_29 = det*w[2][27]*w[3][29]*(1.0);
    const double G5_28_27 = det*w[2][28]*w[3][27]*(1.0);
    const double G5_28_28 = det*w[2][28]*w[3][28]*(1.0);
    const double G5_28_29 = det*w[2][28]*w[3][29]*(1.0);
    const double G5_29_27 = det*w[2][29]*w[3][27]*(1.0);
    const double G5_29_28 = det*w[2][29]*w[3][28]*(1.0);
    const double G5_29_29 = det*w[2][29]*w[3][29]*(1.0);
    const double G6_0_0 = det*w[2][0]*w[0][0]*(1.0);
    const double G6_0_5 = det*w[2][0]*w[0][5]*(1.0);
    const double G6_0_6 = det*w[2][0]*w[0][6]*(1.0);
    const double G6_0_7 = det*w[2][0]*w[0][7]*(1.0);
    const double G6_0_8 = det*w[2][0]*w[0][8]*(1.0);
    const double G6_1_1 = det*w[2][1]*w[0][1]*(1.0);
    const double G6_1_3 = det*w[2][1]*w[0][3]*(1.0);
    const double G6_1_4 = det*w[2][1]*w[0][4]*(1.0);
    const double G6_1_7 = det*w[2][1]*w[0][7]*(1.0);
    const double G6_1_8 = det*w[2][1]*w[0][8]*(1.0);
    const double G6_2_2 = det*w[2][2]*w[0][2]*(1.0);
    const double G6_2_3 = det*w[2][2]*w[0][3]*(1.0);
    const double G6_2_4 = det*w[2][2]*w[0][4]*(1.0);
    const double G6_2_5 = det*w[2][2]*w[0][5]*(1.0);
    const double G6_2_6 = det*w[2][2]*w[0][6]*(1.0);
    const double G6_3_1 = det*w[2][3]*w[0][1]*(1.0);
    const double G6_3_2 = det*w[2][3]*w[0][2]*(1.0);
    const double G6_3_3 = det*w[2][3]*w[0][3]*(1.0);
    const double G6_3_4 = det*w[2][3]*w[0][4]*(1.0);
    const double G6_4_0 = det*w[2][4]*w[0][0]*(1.0);
    const double G6_4_2 = det*w[2][4]*w[0][2]*(1.0);
    const double G6_4_5 = det*w[2][4]*w[0][5]*(1.0);
    const double G6_4_6 = det*w[2][4]*w[0][6]*(1.0);
    const double G6_5_0 = det*w[2][5]*w[0][0]*(1.0);
    const double G6_5_1 = det*w[2][5]*w[0][1]*(1.0);
    const double G6_5_7 = det*w[2][5]*w[0][7]*(1.0);
    const double G6_5_8 = det*w[2][5]*w[0][8]*(1.0);
    const double G6_6_10 = det*w[2][6]*w[0][10]*(1.0);
    const double G6_6_15 = det*w[2][6]*w[0][15]*(1.0);
    const double G6_6_16 = det*w[2][6]*w[0][16]*(1.0);
    const double G6_6_17 = det*w[2][6]*w[0][17]*(1.0);
    const double G6_6_18 = det*w[2][6]*w[0][18]*(1.0);
    const double G6_7_11 = det*w[2][7]*w[0][11]*(1.0);
    const double G6_7_13 = det*w[2][7]*w[0][13]*(1.0);
    const double G6_7_14 = det*w[2][7]*w[0][14]*(1.0);
    const double G6_7_17 = det*w[2][7]*w[0][17]*(1.0);
    const double G6_7_18 = det*w[2][7]*w[0][18]*(1.0);
    const double G6_8_12 = det*w[2][8]*w[0][12]*(1.0);
    const double G6_8_13 = det*w[2][8]*w[0][13]*(1.0);
    const double G6_8_14 = det*w[2][8]*w[0][14]*(1.0);
    const double G6_8_15 = det*w[2][8]*w[0][15]*(1.0);
    const double G6_8_16 = det*w[2][8]*w[0][16]*(1.0);
    const double G6_9_11 = det*w[2][9]*w[0][11]*(1.0);
    const double G6_9_12 = det*w[2][9]*w[0][12]*(1.0);
    const double G6_9_13 = det*w[2][9]*w[0][13]*(1.0);
    const double G6_9_14 = det*w[2][9]*w[0][14]*(1.0);
    const double G6_10_10 = det*w[2][10]*w[0][10]*(1.0);
    const double G6_10_12 = det*w[2][10]*w[0][12]*(1.0);
    const double G6_10_15 = det*w[2][10]*w[0][15]*(1.0);
    const double G6_10_16 = det*w[2][10]*w[0][16]*(1.0);
    const double G6_11_10 = det*w[2][11]*w[0][10]*(1.0);
    const double G6_11_11 = det*w[2][11]*w[0][11]*(1.0);
    const double G6_11_17 = det*w[2][11]*w[0][17]*(1.0);
    const double G6_11_18 = det*w[2][11]*w[0][18]*(1.0);
    const double G6_12_20 = det*w[2][12]*w[0][20]*(1.0);
    const double G6_12_24 = det*w[2][12]*w[0][24]*(1.0);
    const double G6_12_25 = det*w[2][12]*w[0][25]*(1.0);
    const double G6_13_21 = det*w[2][13]*w[0][21]*(1.0);
    const double G6_13_23 = det*w[2][13]*w[0][23]*(1.0);
    const double G6_13_25 = det*w[2][13]*w[0][25]*(1.0);
    const double G6_14_22 = det*w[2][14]*w[0][22]*(1.0);
    const double G6_14_23 = det*w[2][14]*w[0][23]*(1.0);
    const double G6_14_24 = det*w[2][14]*w[0][24]*(1.0);
    const double G7_0_0 = det*w[2][0]*w[3][0]*(1.0);
    const double G7_0_1 = det*w[2][0]*w[3][1]*(1.0);
    const double G7_0_2 = det*w[2][0]*w[3][2]*(1.0);
    const double G7_0_4 = det*w[2][0]*w[3][4]*(1.0);
    const double G7_0_5 = det*w[2][0]*w[3][5]*(1.0);
    const double G7_1_0 = det*w[2][1]*w[3][0]*(1.0);
    const double G7_1_1 = det*w[2][1]*w[3][1]*(1.0);
    const double G7_1_2 = det*w[2][1]*w[3][2]*(1.0);
    const double G7_1_3 = det*w[2][1]*w[3][3]*(1.0);
    const double G7_1_5 = det*w[2][1]*w[3][5]*(1.0);
    const double G7_2_0 = det*w[2][2]*w[3][0]*(1.0);
    const double G7_2_1 = det*w[2][2]*w[3][1]*(1.0);
    const double G7_2_2 = det*w[2][2]*w[3][2]*(1.0);
    const double G7_2_3 = det*w[2][2]*w[3][3]*(1.0);
    const double G7_2_4 = det*w[2][2]*w[3][4]*(1.0);
    const double G7_3_1 = det*w[2][3]*w[3][1]*(1.0);
    const double G7_3_2 = det*w[2][3]*w[3][2]*(1.0);
    const double G7_3_3 = det*w[2][3]*w[3][3]*(1.0);
    const double G7_4_0 = det*w[2][4]*w[3][0]*(1.0);
    const double G7_4_2 = det*w[2][4]*w[3][2]*(1.0);
    const double G7_4_4 = det*w[2][4]*w[3][4]*(1.0);
    const double G7_5_0 = det*w[2][5]*w[3][0]*(1.0);
    const double G7_5_1 = det*w[2][5]*w[3][1]*(1.0);
    const double G7_5_5 = det*w[2][5]*w[3][5]*(1.0);
    const double G7_6_6 = det*w[2][6]*w[3][6]*(1.0);
    const double G7_6_7 = det*w[2][6]*w[3][7]*(1.0);
    const double G7_6_8 = det*w[2][6]*w[3][8]*(1.0);
    const double G7_6_10 = det*w[2][6]*w[3][10]*(1.0);
    const double G7_6_11 = det*w[2][6]*w[3][11]*(1.0);
    const double G7_7_6 = det*w[2][7]*w[3][6]*(1.0);
    const double G7_7_7 = det*w[2][7]*w[3][7]*(1.0);
    const double G7_7_8 = det*w[2][7]*w[3][8]*(1.0);
    const double G7_7_9 = det*w[2][7]*w[3][9]*(1.0);
    const double G7_7_11 = det*w[2][7]*w[3][11]*(1.0);
    const double G7_8_6 = det*w[2][8]*w[3][6]*(1.0);
    const double G7_8_7 = det*w[2][8]*w[3][7]*(1.0);
    const double G7_8_8 = det*w[2][8]*w[3][8]*(1.0);
    const double G7_8_9 = det*w[2][8]*w[3][9]*(1.0);
    const double G7_8_10 = det*w[2][8]*w[3][10]*(1.0);
    const double G7_9_7 = det*w[2][9]*w[3][7]*(1.0);
    const double G7_9_8 = det*w[2][9]*w[3][8]*(1.0);
    const double G7_9_9 = det*w[2][9]*w[3][9]*(1.0);
    const double G7_10_6 = det*w[2][10]*w[3][6]*(1.0);
    const double G7_10_8 = det*w[2][10]*w[3][8]*(1.0);
    const double G7_10_10 = det*w[2][10]*w[3][10]*(1.0);
    const double G7_11_6 = det*w[2][11]*w[3][6]*(1.0);
    const double G7_11_7 = det*w[2][11]*w[3][7]*(1.0);
    const double G7_11_11 = det*w[2][11]*w[3][11]*(1.0);
    const double G7_12_12 = det*w[2][12]*w[3][12]*(1.0);
    const double G7_12_13 = det*w[2][12]*w[3][13]*(1.0);
    const double G7_12_14 = det*w[2][12]*w[3][14]*(1.0);
    const double G7_13_12 = det*w[2][13]*w[3][12]*(1.0);
    const double G7_13_13 = det*w[2][13]*w[3][13]*(1.0);
    const double G7_13_14 = det*w[2][13]*w[3][14]*(1.0);
    const double G7_14_12 = det*w[2][14]*w[3][12]*(1.0);
    const double G7_14_13 = det*w[2][14]*w[3][13]*(1.0);
    const double G7_14_14 = det*w[2][14]*w[3][14]*(1.0);
    
    // Compute element tensor
    switch (facet0)
    {
    case 0:
      {
        switch (facet1)
      {
      case 0:
        {
          A[0] = 0.045833333333333*G4_16_27 + 0.075000000000000*G4_16_29 - 0.037500000000000*G4_16_30 + 0.045833333333333*G4_17_28 - 0.037500000000000*G4_17_29 + 0.075000000000000*G4_17_30 + 0.016666666666667*G4_18_27 + 0.016666666666667*G4_18_28 + 0.150000000000000*G4_18_29 + 0.150000000000000*G4_18_30 + 0.045833333333333*G4_22_37 + 0.075000000000000*G4_22_39 - 0.037500000000000*G4_22_40 + 0.045833333333333*G4_23_38 - 0.037500000000000*G4_23_39 + 0.075000000000000*G4_23_40 + 0.016666666666667*G4_24_37 + 0.016666666666667*G4_24_38 + 0.150000000000000*G4_24_39 + 0.150000000000000*G4_24_40 + 0.083333333333333*G4_28_47 + 0.166666666666667*G4_28_49 + 0.083333333333333*G4_29_48 + 0.166666666666667*G4_29_49 - 0.066666666666667*G5_16_16 + 0.016666666666667*G5_16_17 - 0.033333333333333*G5_16_18 + 0.016666666666667*G5_17_16 - 0.066666666666667*G5_17_17 - 0.033333333333333*G5_17_18 - 0.033333333333333*G5_18_16 - 0.033333333333333*G5_18_17 - 0.266666666666666*G5_18_18 - 0.066666666666667*G5_22_22 + 0.016666666666667*G5_22_23 - 0.033333333333333*G5_22_24 + 0.016666666666667*G5_23_22 - 0.066666666666667*G5_23_23 - 0.033333333333333*G5_23_24 - 0.033333333333333*G5_24_22 - 0.033333333333333*G5_24_23 - 0.266666666666666*G5_24_24 - 0.166666666666667*G5_28_28 - 0.083333333333333*G5_28_29 - 0.083333333333333*G5_29_28 - 0.166666666666667*G5_29_29 + 0.045833333333333*G6_1_1 + 0.075000000000000*G6_1_3 - 0.037500000000000*G6_1_4 + 0.045833333333333*G6_2_2 - 0.037500000000000*G6_2_3 + 0.075000000000000*G6_2_4 + 0.016666666666667*G6_3_1 + 0.016666666666667*G6_3_2 + 0.150000000000000*G6_3_3 + 0.150000000000000*G6_3_4 + 0.045833333333333*G6_7_11 + 0.075000000000000*G6_7_13 - 0.037500000000000*G6_7_14 + 0.045833333333333*G6_8_12 - 0.037500000000000*G6_8_13 + 0.075000000000000*G6_8_14 + 0.016666666666667*G6_9_11 + 0.016666666666667*G6_9_12 + 0.150000000000000*G6_9_13 + 0.150000000000000*G6_9_14 + 0.083333333333333*G6_13_21 + 0.166666666666667*G6_13_23 + 0.083333333333333*G6_14_22 + 0.166666666666667*G6_14_23 - 0.066666666666667*G7_1_1 + 0.016666666666667*G7_1_2 - 0.033333333333333*G7_1_3 + 0.016666666666667*G7_2_1 - 0.066666666666667*G7_2_2 - 0.033333333333333*G7_2_3 - 0.033333333333333*G7_3_1 - 0.033333333333333*G7_3_2 - 0.266666666666666*G7_3_3 - 0.066666666666667*G7_7_7 + 0.016666666666667*G7_7_8 - 0.033333333333333*G7_7_9 + 0.016666666666667*G7_8_7 - 0.066666666666667*G7_8_8 - 0.033333333333333*G7_8_9 - 0.033333333333333*G7_9_7 - 0.033333333333333*G7_9_8 - 0.266666666666666*G7_9_9 - 0.166666666666667*G7_13_13 - 0.083333333333333*G7_13_14 - 0.083333333333333*G7_14_13 - 0.166666666666667*G7_14_14;
        A[1] = 0.045833333333333*G0_16_27 + 0.075000000000000*G0_16_29 - 0.037500000000000*G0_16_30 + 0.045833333333333*G0_17_28 - 0.037500000000000*G0_17_29 + 0.075000000000000*G0_17_30 + 0.016666666666667*G0_18_27 + 0.016666666666667*G0_18_28 + 0.150000000000000*G0_18_29 + 0.150000000000000*G0_18_30 + 0.045833333333333*G0_22_37 + 0.075000000000000*G0_22_39 - 0.037500000000000*G0_22_40 + 0.045833333333333*G0_23_38 - 0.037500000000000*G0_23_39 + 0.075000000000000*G0_23_40 + 0.016666666666667*G0_24_37 + 0.016666666666667*G0_24_38 + 0.150000000000000*G0_24_39 + 0.150000000000000*G0_24_40 + 0.083333333333333*G0_28_47 + 0.166666666666667*G0_28_49 + 0.083333333333333*G0_29_48 + 0.166666666666667*G0_29_49 - 0.066666666666667*G1_16_16 + 0.016666666666667*G1_16_17 - 0.033333333333333*G1_16_18 + 0.016666666666667*G1_17_16 - 0.066666666666667*G1_17_17 - 0.033333333333333*G1_17_18 - 0.033333333333333*G1_18_16 - 0.033333333333333*G1_18_17 - 0.266666666666666*G1_18_18 - 0.066666666666667*G1_22_22 + 0.016666666666667*G1_22_23 - 0.033333333333333*G1_22_24 + 0.016666666666667*G1_23_22 - 0.066666666666667*G1_23_23 - 0.033333333333333*G1_23_24 - 0.033333333333333*G1_24_22 - 0.033333333333333*G1_24_23 - 0.266666666666666*G1_24_24 - 0.166666666666667*G1_28_28 - 0.083333333333333*G1_28_29 - 0.083333333333333*G1_29_28 - 0.166666666666667*G1_29_29 + 0.045833333333333*G2_1_1 + 0.075000000000000*G2_1_3 - 0.037500000000000*G2_1_4 + 0.045833333333333*G2_2_2 - 0.037500000000000*G2_2_3 + 0.075000000000000*G2_2_4 + 0.016666666666667*G2_3_1 + 0.016666666666667*G2_3_2 + 0.150000000000000*G2_3_3 + 0.150000000000000*G2_3_4 + 0.045833333333333*G2_7_11 + 0.075000000000000*G2_7_13 - 0.037500000000000*G2_7_14 + 0.045833333333333*G2_8_12 - 0.037500000000000*G2_8_13 + 0.075000000000000*G2_8_14 + 0.016666666666667*G2_9_11 + 0.016666666666667*G2_9_12 + 0.150000000000000*G2_9_13 + 0.150000000000000*G2_9_14 + 0.083333333333333*G2_13_21 + 0.166666666666667*G2_13_23 + 0.083333333333333*G2_14_22 + 0.166666666666667*G2_14_23 - 0.066666666666667*G3_1_1 + 0.016666666666667*G3_1_2 - 0.033333333333333*G3_1_3 + 0.016666666666667*G3_2_1 - 0.066666666666667*G3_2_2 - 0.033333333333333*G3_2_3 - 0.033333333333333*G3_3_1 - 0.033333333333333*G3_3_2 - 0.266666666666666*G3_3_3 - 0.066666666666667*G3_7_7 + 0.016666666666667*G3_7_8 - 0.033333333333333*G3_7_9 + 0.016666666666667*G3_8_7 - 0.066666666666667*G3_8_8 - 0.033333333333333*G3_8_9 - 0.033333333333333*G3_9_7 - 0.033333333333333*G3_9_8 - 0.266666666666666*G3_9_9 - 0.166666666666667*G3_13_13 - 0.083333333333333*G3_13_14 - 0.083333333333333*G3_14_13 - 0.166666666666667*G3_14_14;
          break;
        }
      case 1:
        {
          A[0] = 0.045833333333333*G4_15_26 + 0.075000000000000*G4_15_31 - 0.037500000000000*G4_15_32 + 0.045833333333333*G4_17_28 - 0.037500000000000*G4_17_31 + 0.075000000000000*G4_17_32 + 0.016666666666667*G4_19_26 + 0.016666666666667*G4_19_28 + 0.150000000000000*G4_19_31 + 0.150000000000000*G4_19_32 + 0.045833333333333*G4_21_36 + 0.075000000000000*G4_21_41 - 0.037500000000000*G4_21_42 + 0.045833333333333*G4_23_38 - 0.037500000000000*G4_23_41 + 0.075000000000000*G4_23_42 + 0.016666666666667*G4_25_36 + 0.016666666666667*G4_25_38 + 0.150000000000000*G4_25_41 + 0.150000000000000*G4_25_42 + 0.083333333333333*G4_27_46 + 0.166666666666667*G4_27_50 + 0.083333333333333*G4_29_48 + 0.166666666666667*G4_29_50 - 0.066666666666667*G5_15_15 + 0.016666666666667*G5_15_17 - 0.033333333333333*G5_15_19 + 0.016666666666667*G5_17_15 - 0.066666666666667*G5_17_17 - 0.033333333333333*G5_17_19 - 0.033333333333333*G5_19_15 - 0.033333333333333*G5_19_17 - 0.266666666666666*G5_19_19 - 0.066666666666667*G5_21_21 + 0.016666666666667*G5_21_23 - 0.033333333333333*G5_21_25 + 0.016666666666667*G5_23_21 - 0.066666666666667*G5_23_23 - 0.033333333333333*G5_23_25 - 0.033333333333333*G5_25_21 - 0.033333333333333*G5_25_23 - 0.266666666666666*G5_25_25 - 0.166666666666667*G5_27_27 - 0.083333333333333*G5_27_29 - 0.083333333333333*G5_29_27 - 0.166666666666667*G5_29_29 + 0.045833333333333*G6_1_1 + 0.075000000000000*G6_1_3 - 0.037500000000000*G6_1_4 + 0.045833333333333*G6_2_2 - 0.037500000000000*G6_2_3 + 0.075000000000000*G6_2_4 + 0.016666666666667*G6_3_1 + 0.016666666666667*G6_3_2 + 0.150000000000000*G6_3_3 + 0.150000000000000*G6_3_4 + 0.045833333333333*G6_7_11 + 0.075000000000000*G6_7_13 - 0.037500000000000*G6_7_14 + 0.045833333333333*G6_8_12 - 0.037500000000000*G6_8_13 + 0.075000000000000*G6_8_14 + 0.016666666666667*G6_9_11 + 0.016666666666667*G6_9_12 + 0.150000000000000*G6_9_13 + 0.150000000000000*G6_9_14 + 0.083333333333333*G6_13_21 + 0.166666666666667*G6_13_23 + 0.083333333333333*G6_14_22 + 0.166666666666667*G6_14_23 - 0.066666666666667*G7_1_1 + 0.016666666666667*G7_1_2 - 0.033333333333333*G7_1_3 + 0.016666666666667*G7_2_1 - 0.066666666666667*G7_2_2 - 0.033333333333333*G7_2_3 - 0.033333333333333*G7_3_1 - 0.033333333333333*G7_3_2 - 0.266666666666666*G7_3_3 - 0.066666666666667*G7_7_7 + 0.016666666666667*G7_7_8 - 0.033333333333333*G7_7_9 + 0.016666666666667*G7_8_7 - 0.066666666666667*G7_8_8 - 0.033333333333333*G7_8_9 - 0.033333333333333*G7_9_7 - 0.033333333333333*G7_9_8 - 0.266666666666666*G7_9_9 - 0.166666666666667*G7_13_13 - 0.083333333333333*G7_13_14 - 0.083333333333333*G7_14_13 - 0.166666666666667*G7_14_14;
        A[1] = 0.045833333333333*G0_15_26 + 0.075000000000000*G0_15_31 - 0.037500000000000*G0_15_32 + 0.045833333333333*G0_17_28 - 0.037500000000000*G0_17_31 + 0.075000000000000*G0_17_32 + 0.016666666666667*G0_19_26 + 0.016666666666667*G0_19_28 + 0.150000000000000*G0_19_31 + 0.150000000000000*G0_19_32 + 0.045833333333333*G0_21_36 + 0.075000000000000*G0_21_41 - 0.037500000000000*G0_21_42 + 0.045833333333333*G0_23_38 - 0.037500000000000*G0_23_41 + 0.075000000000000*G0_23_42 + 0.016666666666667*G0_25_36 + 0.016666666666667*G0_25_38 + 0.150000000000000*G0_25_41 + 0.150000000000000*G0_25_42 + 0.083333333333333*G0_27_46 + 0.166666666666667*G0_27_50 + 0.083333333333333*G0_29_48 + 0.166666666666667*G0_29_50 - 0.066666666666667*G1_15_15 + 0.016666666666667*G1_15_17 - 0.033333333333333*G1_15_19 + 0.016666666666667*G1_17_15 - 0.066666666666667*G1_17_17 - 0.033333333333333*G1_17_19 - 0.033333333333333*G1_19_15 - 0.033333333333333*G1_19_17 - 0.266666666666666*G1_19_19 - 0.066666666666667*G1_21_21 + 0.016666666666667*G1_21_23 - 0.033333333333333*G1_21_25 + 0.016666666666667*G1_23_21 - 0.066666666666667*G1_23_23 - 0.033333333333333*G1_23_25 - 0.033333333333333*G1_25_21 - 0.033333333333333*G1_25_23 - 0.266666666666666*G1_25_25 - 0.166666666666667*G1_27_27 - 0.083333333333333*G1_27_29 - 0.083333333333333*G1_29_27 - 0.166666666666667*G1_29_29 + 0.045833333333333*G2_1_1 + 0.075000000000000*G2_1_3 - 0.037500000000000*G2_1_4 + 0.045833333333333*G2_2_2 - 0.037500000000000*G2_2_3 + 0.075000000000000*G2_2_4 + 0.016666666666667*G2_3_1 + 0.016666666666667*G2_3_2 + 0.150000000000000*G2_3_3 + 0.150000000000000*G2_3_4 + 0.045833333333333*G2_7_11 + 0.075000000000000*G2_7_13 - 0.037500000000000*G2_7_14 + 0.045833333333333*G2_8_12 - 0.037500000000000*G2_8_13 + 0.075000000000000*G2_8_14 + 0.016666666666667*G2_9_11 + 0.016666666666667*G2_9_12 + 0.150000000000000*G2_9_13 + 0.150000000000000*G2_9_14 + 0.083333333333333*G2_13_21 + 0.166666666666667*G2_13_23 + 0.083333333333333*G2_14_22 + 0.166666666666667*G2_14_23 - 0.066666666666667*G3_1_1 + 0.016666666666667*G3_1_2 - 0.033333333333333*G3_1_3 + 0.016666666666667*G3_2_1 - 0.066666666666667*G3_2_2 - 0.033333333333333*G3_2_3 - 0.033333333333333*G3_3_1 - 0.033333333333333*G3_3_2 - 0.266666666666666*G3_3_3 - 0.066666666666667*G3_7_7 + 0.016666666666667*G3_7_8 - 0.033333333333333*G3_7_9 + 0.016666666666667*G3_8_7 - 0.066666666666667*G3_8_8 - 0.033333333333333*G3_8_9 - 0.033333333333333*G3_9_7 - 0.033333333333333*G3_9_8 - 0.266666666666666*G3_9_9 - 0.166666666666667*G3_13_13 - 0.083333333333333*G3_13_14 - 0.083333333333333*G3_14_13 - 0.166666666666667*G3_14_14;
          break;
        }
      case 2:
        {
          A[0] = 0.045833333333333*G4_15_26 + 0.075000000000000*G4_15_33 - 0.037500000000000*G4_15_34 + 0.045833333333333*G4_16_27 - 0.037500000000000*G4_16_33 + 0.075000000000000*G4_16_34 + 0.016666666666667*G4_20_26 + 0.016666666666667*G4_20_27 + 0.150000000000000*G4_20_33 + 0.150000000000000*G4_20_34 + 0.045833333333333*G4_21_36 + 0.075000000000000*G4_21_43 - 0.037500000000000*G4_21_44 + 0.045833333333333*G4_22_37 - 0.037500000000000*G4_22_43 + 0.075000000000000*G4_22_44 + 0.016666666666667*G4_26_36 + 0.016666666666667*G4_26_37 + 0.150000000000000*G4_26_43 + 0.150000000000000*G4_26_44 + 0.083333333333333*G4_27_46 + 0.166666666666667*G4_27_51 + 0.083333333333333*G4_28_47 + 0.166666666666667*G4_28_51 - 0.066666666666667*G5_15_15 + 0.016666666666667*G5_15_16 - 0.033333333333333*G5_15_20 + 0.016666666666667*G5_16_15 - 0.066666666666667*G5_16_16 - 0.033333333333333*G5_16_20 - 0.033333333333333*G5_20_15 - 0.033333333333333*G5_20_16 - 0.266666666666667*G5_20_20 - 0.066666666666667*G5_21_21 + 0.016666666666667*G5_21_22 - 0.033333333333333*G5_21_26 + 0.016666666666667*G5_22_21 - 0.066666666666667*G5_22_22 - 0.033333333333333*G5_22_26 - 0.033333333333333*G5_26_21 - 0.033333333333333*G5_26_22 - 0.266666666666667*G5_26_26 - 0.166666666666667*G5_27_27 - 0.083333333333333*G5_27_28 - 0.083333333333333*G5_28_27 - 0.166666666666667*G5_28_28 + 0.045833333333333*G6_1_1 + 0.075000000000000*G6_1_3 - 0.037500000000000*G6_1_4 + 0.045833333333333*G6_2_2 - 0.037500000000000*G6_2_3 + 0.075000000000000*G6_2_4 + 0.016666666666667*G6_3_1 + 0.016666666666667*G6_3_2 + 0.150000000000000*G6_3_3 + 0.150000000000000*G6_3_4 + 0.045833333333333*G6_7_11 + 0.075000000000000*G6_7_13 - 0.037500000000000*G6_7_14 + 0.045833333333333*G6_8_12 - 0.037500000000000*G6_8_13 + 0.075000000000000*G6_8_14 + 0.016666666666667*G6_9_11 + 0.016666666666667*G6_9_12 + 0.150000000000000*G6_9_13 + 0.150000000000000*G6_9_14 + 0.083333333333333*G6_13_21 + 0.166666666666667*G6_13_23 + 0.083333333333333*G6_14_22 + 0.166666666666667*G6_14_23 - 0.066666666666667*G7_1_1 + 0.016666666666667*G7_1_2 - 0.033333333333333*G7_1_3 + 0.016666666666667*G7_2_1 - 0.066666666666667*G7_2_2 - 0.033333333333333*G7_2_3 - 0.033333333333333*G7_3_1 - 0.033333333333333*G7_3_2 - 0.266666666666666*G7_3_3 - 0.066666666666667*G7_7_7 + 0.016666666666667*G7_7_8 - 0.033333333333333*G7_7_9 + 0.016666666666667*G7_8_7 - 0.066666666666667*G7_8_8 - 0.033333333333333*G7_8_9 - 0.033333333333333*G7_9_7 - 0.033333333333333*G7_9_8 - 0.266666666666666*G7_9_9 - 0.166666666666667*G7_13_13 - 0.083333333333333*G7_13_14 - 0.083333333333333*G7_14_13 - 0.166666666666667*G7_14_14;
        A[1] = 0.045833333333333*G0_15_26 + 0.075000000000000*G0_15_33 - 0.037500000000000*G0_15_34 + 0.045833333333333*G0_16_27 - 0.037500000000000*G0_16_33 + 0.075000000000000*G0_16_34 + 0.016666666666667*G0_20_26 + 0.016666666666667*G0_20_27 + 0.150000000000000*G0_20_33 + 0.150000000000000*G0_20_34 + 0.045833333333333*G0_21_36 + 0.075000000000000*G0_21_43 - 0.037500000000000*G0_21_44 + 0.045833333333333*G0_22_37 - 0.037500000000000*G0_22_43 + 0.075000000000000*G0_22_44 + 0.016666666666667*G0_26_36 + 0.016666666666667*G0_26_37 + 0.150000000000000*G0_26_43 + 0.150000000000000*G0_26_44 + 0.083333333333333*G0_27_46 + 0.166666666666667*G0_27_51 + 0.083333333333333*G0_28_47 + 0.166666666666667*G0_28_51 - 0.066666666666667*G1_15_15 + 0.016666666666667*G1_15_16 - 0.033333333333333*G1_15_20 + 0.016666666666667*G1_16_15 - 0.066666666666667*G1_16_16 - 0.033333333333333*G1_16_20 - 0.033333333333333*G1_20_15 - 0.033333333333333*G1_20_16 - 0.266666666666667*G1_20_20 - 0.066666666666667*G1_21_21 + 0.016666666666667*G1_21_22 - 0.033333333333333*G1_21_26 + 0.016666666666667*G1_22_21 - 0.066666666666667*G1_22_22 - 0.033333333333333*G1_22_26 - 0.033333333333333*G1_26_21 - 0.033333333333333*G1_26_22 - 0.266666666666667*G1_26_26 - 0.166666666666667*G1_27_27 - 0.083333333333333*G1_27_28 - 0.083333333333333*G1_28_27 - 0.166666666666667*G1_28_28 + 0.045833333333333*G2_1_1 + 0.075000000000000*G2_1_3 - 0.037500000000000*G2_1_4 + 0.045833333333333*G2_2_2 - 0.037500000000000*G2_2_3 + 0.075000000000000*G2_2_4 + 0.016666666666667*G2_3_1 + 0.016666666666667*G2_3_2 + 0.150000000000000*G2_3_3 + 0.150000000000000*G2_3_4 + 0.045833333333333*G2_7_11 + 0.075000000000000*G2_7_13 - 0.037500000000000*G2_7_14 + 0.045833333333333*G2_8_12 - 0.037500000000000*G2_8_13 + 0.075000000000000*G2_8_14 + 0.016666666666667*G2_9_11 + 0.016666666666667*G2_9_12 + 0.150000000000000*G2_9_13 + 0.150000000000000*G2_9_14 + 0.083333333333333*G2_13_21 + 0.166666666666667*G2_13_23 + 0.083333333333333*G2_14_22 + 0.166666666666667*G2_14_23 - 0.066666666666667*G3_1_1 + 0.016666666666667*G3_1_2 - 0.033333333333333*G3_1_3 + 0.016666666666667*G3_2_1 - 0.066666666666667*G3_2_2 - 0.033333333333333*G3_2_3 - 0.033333333333333*G3_3_1 - 0.033333333333333*G3_3_2 - 0.266666666666666*G3_3_3 - 0.066666666666667*G3_7_7 + 0.016666666666667*G3_7_8 - 0.033333333333333*G3_7_9 + 0.016666666666667*G3_8_7 - 0.066666666666667*G3_8_8 - 0.033333333333333*G3_8_9 - 0.033333333333333*G3_9_7 - 0.033333333333333*G3_9_8 - 0.266666666666666*G3_9_9 - 0.166666666666667*G3_13_13 - 0.083333333333333*G3_13_14 - 0.083333333333333*G3_14_13 - 0.166666666666667*G3_14_14;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        switch (facet1)
      {
      case 0:
        {
          A[0] = 0.045833333333333*G4_16_27 + 0.075000000000000*G4_16_29 - 0.037500000000000*G4_16_30 + 0.045833333333333*G4_17_28 - 0.037500000000000*G4_17_29 + 0.075000000000000*G4_17_30 + 0.016666666666667*G4_18_27 + 0.016666666666667*G4_18_28 + 0.150000000000000*G4_18_29 + 0.150000000000000*G4_18_30 + 0.045833333333333*G4_22_37 + 0.075000000000000*G4_22_39 - 0.037500000000000*G4_22_40 + 0.045833333333333*G4_23_38 - 0.037500000000000*G4_23_39 + 0.075000000000000*G4_23_40 + 0.016666666666667*G4_24_37 + 0.016666666666667*G4_24_38 + 0.150000000000000*G4_24_39 + 0.150000000000000*G4_24_40 + 0.083333333333333*G4_28_47 + 0.166666666666667*G4_28_49 + 0.083333333333333*G4_29_48 + 0.166666666666667*G4_29_49 - 0.066666666666667*G5_16_16 + 0.016666666666667*G5_16_17 - 0.033333333333333*G5_16_18 + 0.016666666666667*G5_17_16 - 0.066666666666667*G5_17_17 - 0.033333333333333*G5_17_18 - 0.033333333333333*G5_18_16 - 0.033333333333333*G5_18_17 - 0.266666666666666*G5_18_18 - 0.066666666666667*G5_22_22 + 0.016666666666667*G5_22_23 - 0.033333333333333*G5_22_24 + 0.016666666666667*G5_23_22 - 0.066666666666667*G5_23_23 - 0.033333333333333*G5_23_24 - 0.033333333333333*G5_24_22 - 0.033333333333333*G5_24_23 - 0.266666666666666*G5_24_24 - 0.166666666666667*G5_28_28 - 0.083333333333333*G5_28_29 - 0.083333333333333*G5_29_28 - 0.166666666666667*G5_29_29 + 0.045833333333333*G6_0_0 + 0.075000000000000*G6_0_5 - 0.037500000000000*G6_0_6 + 0.045833333333333*G6_2_2 - 0.037500000000000*G6_2_5 + 0.075000000000000*G6_2_6 + 0.016666666666667*G6_4_0 + 0.016666666666667*G6_4_2 + 0.150000000000000*G6_4_5 + 0.150000000000000*G6_4_6 + 0.045833333333333*G6_6_10 + 0.075000000000000*G6_6_15 - 0.037500000000000*G6_6_16 + 0.045833333333333*G6_8_12 - 0.037500000000000*G6_8_15 + 0.075000000000000*G6_8_16 + 0.016666666666667*G6_10_10 + 0.016666666666667*G6_10_12 + 0.150000000000000*G6_10_15 + 0.150000000000000*G6_10_16 + 0.083333333333333*G6_12_20 + 0.166666666666667*G6_12_24 + 0.083333333333333*G6_14_22 + 0.166666666666667*G6_14_24 - 0.066666666666667*G7_0_0 + 0.016666666666667*G7_0_2 - 0.033333333333333*G7_0_4 + 0.016666666666667*G7_2_0 - 0.066666666666667*G7_2_2 - 0.033333333333333*G7_2_4 - 0.033333333333333*G7_4_0 - 0.033333333333333*G7_4_2 - 0.266666666666666*G7_4_4 - 0.066666666666667*G7_6_6 + 0.016666666666667*G7_6_8 - 0.033333333333333*G7_6_10 + 0.016666666666667*G7_8_6 - 0.066666666666667*G7_8_8 - 0.033333333333333*G7_8_10 - 0.033333333333333*G7_10_6 - 0.033333333333333*G7_10_8 - 0.266666666666666*G7_10_10 - 0.166666666666667*G7_12_12 - 0.083333333333333*G7_12_14 - 0.083333333333333*G7_14_12 - 0.166666666666667*G7_14_14;
        A[1] = 0.045833333333333*G0_16_27 + 0.075000000000000*G0_16_29 - 0.037500000000000*G0_16_30 + 0.045833333333333*G0_17_28 - 0.037500000000000*G0_17_29 + 0.075000000000000*G0_17_30 + 0.016666666666667*G0_18_27 + 0.016666666666667*G0_18_28 + 0.150000000000000*G0_18_29 + 0.150000000000000*G0_18_30 + 0.045833333333333*G0_22_37 + 0.075000000000000*G0_22_39 - 0.037500000000000*G0_22_40 + 0.045833333333333*G0_23_38 - 0.037500000000000*G0_23_39 + 0.075000000000000*G0_23_40 + 0.016666666666667*G0_24_37 + 0.016666666666667*G0_24_38 + 0.150000000000000*G0_24_39 + 0.150000000000000*G0_24_40 + 0.083333333333333*G0_28_47 + 0.166666666666667*G0_28_49 + 0.083333333333333*G0_29_48 + 0.166666666666667*G0_29_49 - 0.066666666666667*G1_16_16 + 0.016666666666667*G1_16_17 - 0.033333333333333*G1_16_18 + 0.016666666666667*G1_17_16 - 0.066666666666667*G1_17_17 - 0.033333333333333*G1_17_18 - 0.033333333333333*G1_18_16 - 0.033333333333333*G1_18_17 - 0.266666666666666*G1_18_18 - 0.066666666666667*G1_22_22 + 0.016666666666667*G1_22_23 - 0.033333333333333*G1_22_24 + 0.016666666666667*G1_23_22 - 0.066666666666667*G1_23_23 - 0.033333333333333*G1_23_24 - 0.033333333333333*G1_24_22 - 0.033333333333333*G1_24_23 - 0.266666666666666*G1_24_24 - 0.166666666666667*G1_28_28 - 0.083333333333333*G1_28_29 - 0.083333333333333*G1_29_28 - 0.166666666666667*G1_29_29 + 0.045833333333333*G2_0_0 + 0.075000000000000*G2_0_5 - 0.037500000000000*G2_0_6 + 0.045833333333333*G2_2_2 - 0.037500000000000*G2_2_5 + 0.075000000000000*G2_2_6 + 0.016666666666667*G2_4_0 + 0.016666666666667*G2_4_2 + 0.150000000000000*G2_4_5 + 0.150000000000000*G2_4_6 + 0.045833333333333*G2_6_10 + 0.075000000000000*G2_6_15 - 0.037500000000000*G2_6_16 + 0.045833333333333*G2_8_12 - 0.037500000000000*G2_8_15 + 0.075000000000000*G2_8_16 + 0.016666666666667*G2_10_10 + 0.016666666666667*G2_10_12 + 0.150000000000000*G2_10_15 + 0.150000000000000*G2_10_16 + 0.083333333333333*G2_12_20 + 0.166666666666667*G2_12_24 + 0.083333333333333*G2_14_22 + 0.166666666666667*G2_14_24 - 0.066666666666667*G3_0_0 + 0.016666666666667*G3_0_2 - 0.033333333333333*G3_0_4 + 0.016666666666667*G3_2_0 - 0.066666666666667*G3_2_2 - 0.033333333333333*G3_2_4 - 0.033333333333333*G3_4_0 - 0.033333333333333*G3_4_2 - 0.266666666666666*G3_4_4 - 0.066666666666667*G3_6_6 + 0.016666666666667*G3_6_8 - 0.033333333333333*G3_6_10 + 0.016666666666667*G3_8_6 - 0.066666666666667*G3_8_8 - 0.033333333333333*G3_8_10 - 0.033333333333333*G3_10_6 - 0.033333333333333*G3_10_8 - 0.266666666666666*G3_10_10 - 0.166666666666667*G3_12_12 - 0.083333333333333*G3_12_14 - 0.083333333333333*G3_14_12 - 0.166666666666667*G3_14_14;
          break;
        }
      case 1:
        {
          A[0] = 0.045833333333333*G4_15_26 + 0.075000000000000*G4_15_31 - 0.037500000000000*G4_15_32 + 0.045833333333333*G4_17_28 - 0.037500000000000*G4_17_31 + 0.075000000000000*G4_17_32 + 0.016666666666667*G4_19_26 + 0.016666666666667*G4_19_28 + 0.150000000000000*G4_19_31 + 0.150000000000000*G4_19_32 + 0.045833333333333*G4_21_36 + 0.075000000000000*G4_21_41 - 0.037500000000000*G4_21_42 + 0.045833333333333*G4_23_38 - 0.037500000000000*G4_23_41 + 0.075000000000000*G4_23_42 + 0.016666666666667*G4_25_36 + 0.016666666666667*G4_25_38 + 0.150000000000000*G4_25_41 + 0.150000000000000*G4_25_42 + 0.083333333333333*G4_27_46 + 0.166666666666667*G4_27_50 + 0.083333333333333*G4_29_48 + 0.166666666666667*G4_29_50 - 0.066666666666667*G5_15_15 + 0.016666666666667*G5_15_17 - 0.033333333333333*G5_15_19 + 0.016666666666667*G5_17_15 - 0.066666666666667*G5_17_17 - 0.033333333333333*G5_17_19 - 0.033333333333333*G5_19_15 - 0.033333333333333*G5_19_17 - 0.266666666666666*G5_19_19 - 0.066666666666667*G5_21_21 + 0.016666666666667*G5_21_23 - 0.033333333333333*G5_21_25 + 0.016666666666667*G5_23_21 - 0.066666666666667*G5_23_23 - 0.033333333333333*G5_23_25 - 0.033333333333333*G5_25_21 - 0.033333333333333*G5_25_23 - 0.266666666666666*G5_25_25 - 0.166666666666667*G5_27_27 - 0.083333333333333*G5_27_29 - 0.083333333333333*G5_29_27 - 0.166666666666667*G5_29_29 + 0.045833333333333*G6_0_0 + 0.075000000000000*G6_0_5 - 0.037500000000000*G6_0_6 + 0.045833333333333*G6_2_2 - 0.037500000000000*G6_2_5 + 0.075000000000000*G6_2_6 + 0.016666666666667*G6_4_0 + 0.016666666666667*G6_4_2 + 0.150000000000000*G6_4_5 + 0.150000000000000*G6_4_6 + 0.045833333333333*G6_6_10 + 0.075000000000000*G6_6_15 - 0.037500000000000*G6_6_16 + 0.045833333333333*G6_8_12 - 0.037500000000000*G6_8_15 + 0.075000000000000*G6_8_16 + 0.016666666666667*G6_10_10 + 0.016666666666667*G6_10_12 + 0.150000000000000*G6_10_15 + 0.150000000000000*G6_10_16 + 0.083333333333333*G6_12_20 + 0.166666666666667*G6_12_24 + 0.083333333333333*G6_14_22 + 0.166666666666667*G6_14_24 - 0.066666666666667*G7_0_0 + 0.016666666666667*G7_0_2 - 0.033333333333333*G7_0_4 + 0.016666666666667*G7_2_0 - 0.066666666666667*G7_2_2 - 0.033333333333333*G7_2_4 - 0.033333333333333*G7_4_0 - 0.033333333333333*G7_4_2 - 0.266666666666666*G7_4_4 - 0.066666666666667*G7_6_6 + 0.016666666666667*G7_6_8 - 0.033333333333333*G7_6_10 + 0.016666666666667*G7_8_6 - 0.066666666666667*G7_8_8 - 0.033333333333333*G7_8_10 - 0.033333333333333*G7_10_6 - 0.033333333333333*G7_10_8 - 0.266666666666666*G7_10_10 - 0.166666666666667*G7_12_12 - 0.083333333333333*G7_12_14 - 0.083333333333333*G7_14_12 - 0.166666666666667*G7_14_14;
        A[1] = 0.045833333333333*G0_15_26 + 0.075000000000000*G0_15_31 - 0.037500000000000*G0_15_32 + 0.045833333333333*G0_17_28 - 0.037500000000000*G0_17_31 + 0.075000000000000*G0_17_32 + 0.016666666666667*G0_19_26 + 0.016666666666667*G0_19_28 + 0.150000000000000*G0_19_31 + 0.150000000000000*G0_19_32 + 0.045833333333333*G0_21_36 + 0.075000000000000*G0_21_41 - 0.037500000000000*G0_21_42 + 0.045833333333333*G0_23_38 - 0.037500000000000*G0_23_41 + 0.075000000000000*G0_23_42 + 0.016666666666667*G0_25_36 + 0.016666666666667*G0_25_38 + 0.150000000000000*G0_25_41 + 0.150000000000000*G0_25_42 + 0.083333333333333*G0_27_46 + 0.166666666666667*G0_27_50 + 0.083333333333333*G0_29_48 + 0.166666666666667*G0_29_50 - 0.066666666666667*G1_15_15 + 0.016666666666667*G1_15_17 - 0.033333333333333*G1_15_19 + 0.016666666666667*G1_17_15 - 0.066666666666667*G1_17_17 - 0.033333333333333*G1_17_19 - 0.033333333333333*G1_19_15 - 0.033333333333333*G1_19_17 - 0.266666666666666*G1_19_19 - 0.066666666666667*G1_21_21 + 0.016666666666667*G1_21_23 - 0.033333333333333*G1_21_25 + 0.016666666666667*G1_23_21 - 0.066666666666667*G1_23_23 - 0.033333333333333*G1_23_25 - 0.033333333333333*G1_25_21 - 0.033333333333333*G1_25_23 - 0.266666666666666*G1_25_25 - 0.166666666666667*G1_27_27 - 0.083333333333333*G1_27_29 - 0.083333333333333*G1_29_27 - 0.166666666666667*G1_29_29 + 0.045833333333333*G2_0_0 + 0.075000000000000*G2_0_5 - 0.037500000000000*G2_0_6 + 0.045833333333333*G2_2_2 - 0.037500000000000*G2_2_5 + 0.075000000000000*G2_2_6 + 0.016666666666667*G2_4_0 + 0.016666666666667*G2_4_2 + 0.150000000000000*G2_4_5 + 0.150000000000000*G2_4_6 + 0.045833333333333*G2_6_10 + 0.075000000000000*G2_6_15 - 0.037500000000000*G2_6_16 + 0.045833333333333*G2_8_12 - 0.037500000000000*G2_8_15 + 0.075000000000000*G2_8_16 + 0.016666666666667*G2_10_10 + 0.016666666666667*G2_10_12 + 0.150000000000000*G2_10_15 + 0.150000000000000*G2_10_16 + 0.083333333333333*G2_12_20 + 0.166666666666667*G2_12_24 + 0.083333333333333*G2_14_22 + 0.166666666666667*G2_14_24 - 0.066666666666667*G3_0_0 + 0.016666666666667*G3_0_2 - 0.033333333333333*G3_0_4 + 0.016666666666667*G3_2_0 - 0.066666666666667*G3_2_2 - 0.033333333333333*G3_2_4 - 0.033333333333333*G3_4_0 - 0.033333333333333*G3_4_2 - 0.266666666666666*G3_4_4 - 0.066666666666667*G3_6_6 + 0.016666666666667*G3_6_8 - 0.033333333333333*G3_6_10 + 0.016666666666667*G3_8_6 - 0.066666666666667*G3_8_8 - 0.033333333333333*G3_8_10 - 0.033333333333333*G3_10_6 - 0.033333333333333*G3_10_8 - 0.266666666666666*G3_10_10 - 0.166666666666667*G3_12_12 - 0.083333333333333*G3_12_14 - 0.083333333333333*G3_14_12 - 0.166666666666667*G3_14_14;
          break;
        }
      case 2:
        {
          A[0] = 0.045833333333333*G4_15_26 + 0.075000000000000*G4_15_33 - 0.037500000000000*G4_15_34 + 0.045833333333333*G4_16_27 - 0.037500000000000*G4_16_33 + 0.075000000000000*G4_16_34 + 0.016666666666667*G4_20_26 + 0.016666666666667*G4_20_27 + 0.150000000000000*G4_20_33 + 0.150000000000000*G4_20_34 + 0.045833333333333*G4_21_36 + 0.075000000000000*G4_21_43 - 0.037500000000000*G4_21_44 + 0.045833333333333*G4_22_37 - 0.037500000000000*G4_22_43 + 0.075000000000000*G4_22_44 + 0.016666666666667*G4_26_36 + 0.016666666666667*G4_26_37 + 0.150000000000000*G4_26_43 + 0.150000000000000*G4_26_44 + 0.083333333333333*G4_27_46 + 0.166666666666667*G4_27_51 + 0.083333333333333*G4_28_47 + 0.166666666666667*G4_28_51 - 0.066666666666667*G5_15_15 + 0.016666666666667*G5_15_16 - 0.033333333333333*G5_15_20 + 0.016666666666667*G5_16_15 - 0.066666666666667*G5_16_16 - 0.033333333333333*G5_16_20 - 0.033333333333333*G5_20_15 - 0.033333333333333*G5_20_16 - 0.266666666666667*G5_20_20 - 0.066666666666667*G5_21_21 + 0.016666666666667*G5_21_22 - 0.033333333333333*G5_21_26 + 0.016666666666667*G5_22_21 - 0.066666666666667*G5_22_22 - 0.033333333333333*G5_22_26 - 0.033333333333333*G5_26_21 - 0.033333333333333*G5_26_22 - 0.266666666666667*G5_26_26 - 0.166666666666667*G5_27_27 - 0.083333333333333*G5_27_28 - 0.083333333333333*G5_28_27 - 0.166666666666667*G5_28_28 + 0.045833333333333*G6_0_0 + 0.075000000000000*G6_0_5 - 0.037500000000000*G6_0_6 + 0.045833333333333*G6_2_2 - 0.037500000000000*G6_2_5 + 0.075000000000000*G6_2_6 + 0.016666666666667*G6_4_0 + 0.016666666666667*G6_4_2 + 0.150000000000000*G6_4_5 + 0.150000000000000*G6_4_6 + 0.045833333333333*G6_6_10 + 0.075000000000000*G6_6_15 - 0.037500000000000*G6_6_16 + 0.045833333333333*G6_8_12 - 0.037500000000000*G6_8_15 + 0.075000000000000*G6_8_16 + 0.016666666666667*G6_10_10 + 0.016666666666667*G6_10_12 + 0.150000000000000*G6_10_15 + 0.150000000000000*G6_10_16 + 0.083333333333333*G6_12_20 + 0.166666666666667*G6_12_24 + 0.083333333333333*G6_14_22 + 0.166666666666667*G6_14_24 - 0.066666666666667*G7_0_0 + 0.016666666666667*G7_0_2 - 0.033333333333333*G7_0_4 + 0.016666666666667*G7_2_0 - 0.066666666666667*G7_2_2 - 0.033333333333333*G7_2_4 - 0.033333333333333*G7_4_0 - 0.033333333333333*G7_4_2 - 0.266666666666666*G7_4_4 - 0.066666666666667*G7_6_6 + 0.016666666666667*G7_6_8 - 0.033333333333333*G7_6_10 + 0.016666666666667*G7_8_6 - 0.066666666666667*G7_8_8 - 0.033333333333333*G7_8_10 - 0.033333333333333*G7_10_6 - 0.033333333333333*G7_10_8 - 0.266666666666666*G7_10_10 - 0.166666666666667*G7_12_12 - 0.083333333333333*G7_12_14 - 0.083333333333333*G7_14_12 - 0.166666666666667*G7_14_14;
        A[1] = 0.045833333333333*G0_15_26 + 0.075000000000000*G0_15_33 - 0.037500000000000*G0_15_34 + 0.045833333333333*G0_16_27 - 0.037500000000000*G0_16_33 + 0.075000000000000*G0_16_34 + 0.016666666666667*G0_20_26 + 0.016666666666667*G0_20_27 + 0.150000000000000*G0_20_33 + 0.150000000000000*G0_20_34 + 0.045833333333333*G0_21_36 + 0.075000000000000*G0_21_43 - 0.037500000000000*G0_21_44 + 0.045833333333333*G0_22_37 - 0.037500000000000*G0_22_43 + 0.075000000000000*G0_22_44 + 0.016666666666667*G0_26_36 + 0.016666666666667*G0_26_37 + 0.150000000000000*G0_26_43 + 0.150000000000000*G0_26_44 + 0.083333333333333*G0_27_46 + 0.166666666666667*G0_27_51 + 0.083333333333333*G0_28_47 + 0.166666666666667*G0_28_51 - 0.066666666666667*G1_15_15 + 0.016666666666667*G1_15_16 - 0.033333333333333*G1_15_20 + 0.016666666666667*G1_16_15 - 0.066666666666667*G1_16_16 - 0.033333333333333*G1_16_20 - 0.033333333333333*G1_20_15 - 0.033333333333333*G1_20_16 - 0.266666666666667*G1_20_20 - 0.066666666666667*G1_21_21 + 0.016666666666667*G1_21_22 - 0.033333333333333*G1_21_26 + 0.016666666666667*G1_22_21 - 0.066666666666667*G1_22_22 - 0.033333333333333*G1_22_26 - 0.033333333333333*G1_26_21 - 0.033333333333333*G1_26_22 - 0.266666666666667*G1_26_26 - 0.166666666666667*G1_27_27 - 0.083333333333333*G1_27_28 - 0.083333333333333*G1_28_27 - 0.166666666666667*G1_28_28 + 0.045833333333333*G2_0_0 + 0.075000000000000*G2_0_5 - 0.037500000000000*G2_0_6 + 0.045833333333333*G2_2_2 - 0.037500000000000*G2_2_5 + 0.075000000000000*G2_2_6 + 0.016666666666667*G2_4_0 + 0.016666666666667*G2_4_2 + 0.150000000000000*G2_4_5 + 0.150000000000000*G2_4_6 + 0.045833333333333*G2_6_10 + 0.075000000000000*G2_6_15 - 0.037500000000000*G2_6_16 + 0.045833333333333*G2_8_12 - 0.037500000000000*G2_8_15 + 0.075000000000000*G2_8_16 + 0.016666666666667*G2_10_10 + 0.016666666666667*G2_10_12 + 0.150000000000000*G2_10_15 + 0.150000000000000*G2_10_16 + 0.083333333333333*G2_12_20 + 0.166666666666667*G2_12_24 + 0.083333333333333*G2_14_22 + 0.166666666666667*G2_14_24 - 0.066666666666667*G3_0_0 + 0.016666666666667*G3_0_2 - 0.033333333333333*G3_0_4 + 0.016666666666667*G3_2_0 - 0.066666666666667*G3_2_2 - 0.033333333333333*G3_2_4 - 0.033333333333333*G3_4_0 - 0.033333333333333*G3_4_2 - 0.266666666666666*G3_4_4 - 0.066666666666667*G3_6_6 + 0.016666666666667*G3_6_8 - 0.033333333333333*G3_6_10 + 0.016666666666667*G3_8_6 - 0.066666666666667*G3_8_8 - 0.033333333333333*G3_8_10 - 0.033333333333333*G3_10_6 - 0.033333333333333*G3_10_8 - 0.266666666666666*G3_10_10 - 0.166666666666667*G3_12_12 - 0.083333333333333*G3_12_14 - 0.083333333333333*G3_14_12 - 0.166666666666667*G3_14_14;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        switch (facet1)
      {
      case 0:
        {
          A[0] = 0.045833333333333*G4_16_27 + 0.075000000000000*G4_16_29 - 0.037500000000000*G4_16_30 + 0.045833333333333*G4_17_28 - 0.037500000000000*G4_17_29 + 0.075000000000000*G4_17_30 + 0.016666666666667*G4_18_27 + 0.016666666666667*G4_18_28 + 0.150000000000000*G4_18_29 + 0.150000000000000*G4_18_30 + 0.045833333333333*G4_22_37 + 0.075000000000000*G4_22_39 - 0.037500000000000*G4_22_40 + 0.045833333333333*G4_23_38 - 0.037500000000000*G4_23_39 + 0.075000000000000*G4_23_40 + 0.016666666666667*G4_24_37 + 0.016666666666667*G4_24_38 + 0.150000000000000*G4_24_39 + 0.150000000000000*G4_24_40 + 0.083333333333333*G4_28_47 + 0.166666666666667*G4_28_49 + 0.083333333333333*G4_29_48 + 0.166666666666667*G4_29_49 - 0.066666666666667*G5_16_16 + 0.016666666666667*G5_16_17 - 0.033333333333333*G5_16_18 + 0.016666666666667*G5_17_16 - 0.066666666666667*G5_17_17 - 0.033333333333333*G5_17_18 - 0.033333333333333*G5_18_16 - 0.033333333333333*G5_18_17 - 0.266666666666666*G5_18_18 - 0.066666666666667*G5_22_22 + 0.016666666666667*G5_22_23 - 0.033333333333333*G5_22_24 + 0.016666666666667*G5_23_22 - 0.066666666666667*G5_23_23 - 0.033333333333333*G5_23_24 - 0.033333333333333*G5_24_22 - 0.033333333333333*G5_24_23 - 0.266666666666666*G5_24_24 - 0.166666666666667*G5_28_28 - 0.083333333333333*G5_28_29 - 0.083333333333333*G5_29_28 - 0.166666666666667*G5_29_29 + 0.045833333333333*G6_0_0 + 0.075000000000000*G6_0_7 - 0.037500000000000*G6_0_8 + 0.045833333333333*G6_1_1 - 0.037500000000000*G6_1_7 + 0.075000000000000*G6_1_8 + 0.016666666666667*G6_5_0 + 0.016666666666667*G6_5_1 + 0.150000000000000*G6_5_7 + 0.150000000000000*G6_5_8 + 0.045833333333333*G6_6_10 + 0.075000000000000*G6_6_17 - 0.037500000000000*G6_6_18 + 0.045833333333333*G6_7_11 - 0.037500000000000*G6_7_17 + 0.075000000000000*G6_7_18 + 0.016666666666667*G6_11_10 + 0.016666666666667*G6_11_11 + 0.150000000000000*G6_11_17 + 0.150000000000000*G6_11_18 + 0.083333333333333*G6_12_20 + 0.166666666666667*G6_12_25 + 0.083333333333333*G6_13_21 + 0.166666666666667*G6_13_25 - 0.066666666666667*G7_0_0 + 0.016666666666667*G7_0_1 - 0.033333333333333*G7_0_5 + 0.016666666666667*G7_1_0 - 0.066666666666667*G7_1_1 - 0.033333333333333*G7_1_5 - 0.033333333333333*G7_5_0 - 0.033333333333333*G7_5_1 - 0.266666666666667*G7_5_5 - 0.066666666666667*G7_6_6 + 0.016666666666667*G7_6_7 - 0.033333333333333*G7_6_11 + 0.016666666666667*G7_7_6 - 0.066666666666667*G7_7_7 - 0.033333333333333*G7_7_11 - 0.033333333333333*G7_11_6 - 0.033333333333333*G7_11_7 - 0.266666666666667*G7_11_11 - 0.166666666666667*G7_12_12 - 0.083333333333333*G7_12_13 - 0.083333333333333*G7_13_12 - 0.166666666666667*G7_13_13;
        A[1] = 0.045833333333333*G0_16_27 + 0.075000000000000*G0_16_29 - 0.037500000000000*G0_16_30 + 0.045833333333333*G0_17_28 - 0.037500000000000*G0_17_29 + 0.075000000000000*G0_17_30 + 0.016666666666667*G0_18_27 + 0.016666666666667*G0_18_28 + 0.150000000000000*G0_18_29 + 0.150000000000000*G0_18_30 + 0.045833333333333*G0_22_37 + 0.075000000000000*G0_22_39 - 0.037500000000000*G0_22_40 + 0.045833333333333*G0_23_38 - 0.037500000000000*G0_23_39 + 0.075000000000000*G0_23_40 + 0.016666666666667*G0_24_37 + 0.016666666666667*G0_24_38 + 0.150000000000000*G0_24_39 + 0.150000000000000*G0_24_40 + 0.083333333333333*G0_28_47 + 0.166666666666667*G0_28_49 + 0.083333333333333*G0_29_48 + 0.166666666666667*G0_29_49 - 0.066666666666667*G1_16_16 + 0.016666666666667*G1_16_17 - 0.033333333333333*G1_16_18 + 0.016666666666667*G1_17_16 - 0.066666666666667*G1_17_17 - 0.033333333333333*G1_17_18 - 0.033333333333333*G1_18_16 - 0.033333333333333*G1_18_17 - 0.266666666666666*G1_18_18 - 0.066666666666667*G1_22_22 + 0.016666666666667*G1_22_23 - 0.033333333333333*G1_22_24 + 0.016666666666667*G1_23_22 - 0.066666666666667*G1_23_23 - 0.033333333333333*G1_23_24 - 0.033333333333333*G1_24_22 - 0.033333333333333*G1_24_23 - 0.266666666666666*G1_24_24 - 0.166666666666667*G1_28_28 - 0.083333333333333*G1_28_29 - 0.083333333333333*G1_29_28 - 0.166666666666667*G1_29_29 + 0.045833333333333*G2_0_0 + 0.075000000000000*G2_0_7 - 0.037500000000000*G2_0_8 + 0.045833333333333*G2_1_1 - 0.037500000000000*G2_1_7 + 0.075000000000000*G2_1_8 + 0.016666666666667*G2_5_0 + 0.016666666666667*G2_5_1 + 0.150000000000000*G2_5_7 + 0.150000000000000*G2_5_8 + 0.045833333333333*G2_6_10 + 0.075000000000000*G2_6_17 - 0.037500000000000*G2_6_18 + 0.045833333333333*G2_7_11 - 0.037500000000000*G2_7_17 + 0.075000000000000*G2_7_18 + 0.016666666666667*G2_11_10 + 0.016666666666667*G2_11_11 + 0.150000000000000*G2_11_17 + 0.150000000000000*G2_11_18 + 0.083333333333333*G2_12_20 + 0.166666666666667*G2_12_25 + 0.083333333333333*G2_13_21 + 0.166666666666667*G2_13_25 - 0.066666666666667*G3_0_0 + 0.016666666666667*G3_0_1 - 0.033333333333333*G3_0_5 + 0.016666666666667*G3_1_0 - 0.066666666666667*G3_1_1 - 0.033333333333333*G3_1_5 - 0.033333333333333*G3_5_0 - 0.033333333333333*G3_5_1 - 0.266666666666667*G3_5_5 - 0.066666666666667*G3_6_6 + 0.016666666666667*G3_6_7 - 0.033333333333333*G3_6_11 + 0.016666666666667*G3_7_6 - 0.066666666666667*G3_7_7 - 0.033333333333333*G3_7_11 - 0.033333333333333*G3_11_6 - 0.033333333333333*G3_11_7 - 0.266666666666667*G3_11_11 - 0.166666666666667*G3_12_12 - 0.083333333333333*G3_12_13 - 0.083333333333333*G3_13_12 - 0.166666666666667*G3_13_13;
          break;
        }
      case 1:
        {
          A[0] = 0.045833333333333*G4_15_26 + 0.075000000000000*G4_15_31 - 0.037500000000000*G4_15_32 + 0.045833333333333*G4_17_28 - 0.037500000000000*G4_17_31 + 0.075000000000000*G4_17_32 + 0.016666666666667*G4_19_26 + 0.016666666666667*G4_19_28 + 0.150000000000000*G4_19_31 + 0.150000000000000*G4_19_32 + 0.045833333333333*G4_21_36 + 0.075000000000000*G4_21_41 - 0.037500000000000*G4_21_42 + 0.045833333333333*G4_23_38 - 0.037500000000000*G4_23_41 + 0.075000000000000*G4_23_42 + 0.016666666666667*G4_25_36 + 0.016666666666667*G4_25_38 + 0.150000000000000*G4_25_41 + 0.150000000000000*G4_25_42 + 0.083333333333333*G4_27_46 + 0.166666666666667*G4_27_50 + 0.083333333333333*G4_29_48 + 0.166666666666667*G4_29_50 - 0.066666666666667*G5_15_15 + 0.016666666666667*G5_15_17 - 0.033333333333333*G5_15_19 + 0.016666666666667*G5_17_15 - 0.066666666666667*G5_17_17 - 0.033333333333333*G5_17_19 - 0.033333333333333*G5_19_15 - 0.033333333333333*G5_19_17 - 0.266666666666666*G5_19_19 - 0.066666666666667*G5_21_21 + 0.016666666666667*G5_21_23 - 0.033333333333333*G5_21_25 + 0.016666666666667*G5_23_21 - 0.066666666666667*G5_23_23 - 0.033333333333333*G5_23_25 - 0.033333333333333*G5_25_21 - 0.033333333333333*G5_25_23 - 0.266666666666666*G5_25_25 - 0.166666666666667*G5_27_27 - 0.083333333333333*G5_27_29 - 0.083333333333333*G5_29_27 - 0.166666666666667*G5_29_29 + 0.045833333333333*G6_0_0 + 0.075000000000000*G6_0_7 - 0.037500000000000*G6_0_8 + 0.045833333333333*G6_1_1 - 0.037500000000000*G6_1_7 + 0.075000000000000*G6_1_8 + 0.016666666666667*G6_5_0 + 0.016666666666667*G6_5_1 + 0.150000000000000*G6_5_7 + 0.150000000000000*G6_5_8 + 0.045833333333333*G6_6_10 + 0.075000000000000*G6_6_17 - 0.037500000000000*G6_6_18 + 0.045833333333333*G6_7_11 - 0.037500000000000*G6_7_17 + 0.075000000000000*G6_7_18 + 0.016666666666667*G6_11_10 + 0.016666666666667*G6_11_11 + 0.150000000000000*G6_11_17 + 0.150000000000000*G6_11_18 + 0.083333333333333*G6_12_20 + 0.166666666666667*G6_12_25 + 0.083333333333333*G6_13_21 + 0.166666666666667*G6_13_25 - 0.066666666666667*G7_0_0 + 0.016666666666667*G7_0_1 - 0.033333333333333*G7_0_5 + 0.016666666666667*G7_1_0 - 0.066666666666667*G7_1_1 - 0.033333333333333*G7_1_5 - 0.033333333333333*G7_5_0 - 0.033333333333333*G7_5_1 - 0.266666666666667*G7_5_5 - 0.066666666666667*G7_6_6 + 0.016666666666667*G7_6_7 - 0.033333333333333*G7_6_11 + 0.016666666666667*G7_7_6 - 0.066666666666667*G7_7_7 - 0.033333333333333*G7_7_11 - 0.033333333333333*G7_11_6 - 0.033333333333333*G7_11_7 - 0.266666666666667*G7_11_11 - 0.166666666666667*G7_12_12 - 0.083333333333333*G7_12_13 - 0.083333333333333*G7_13_12 - 0.166666666666667*G7_13_13;
        A[1] = 0.045833333333333*G0_15_26 + 0.075000000000000*G0_15_31 - 0.037500000000000*G0_15_32 + 0.045833333333333*G0_17_28 - 0.037500000000000*G0_17_31 + 0.075000000000000*G0_17_32 + 0.016666666666667*G0_19_26 + 0.016666666666667*G0_19_28 + 0.150000000000000*G0_19_31 + 0.150000000000000*G0_19_32 + 0.045833333333333*G0_21_36 + 0.075000000000000*G0_21_41 - 0.037500000000000*G0_21_42 + 0.045833333333333*G0_23_38 - 0.037500000000000*G0_23_41 + 0.075000000000000*G0_23_42 + 0.016666666666667*G0_25_36 + 0.016666666666667*G0_25_38 + 0.150000000000000*G0_25_41 + 0.150000000000000*G0_25_42 + 0.083333333333333*G0_27_46 + 0.166666666666667*G0_27_50 + 0.083333333333333*G0_29_48 + 0.166666666666667*G0_29_50 - 0.066666666666667*G1_15_15 + 0.016666666666667*G1_15_17 - 0.033333333333333*G1_15_19 + 0.016666666666667*G1_17_15 - 0.066666666666667*G1_17_17 - 0.033333333333333*G1_17_19 - 0.033333333333333*G1_19_15 - 0.033333333333333*G1_19_17 - 0.266666666666666*G1_19_19 - 0.066666666666667*G1_21_21 + 0.016666666666667*G1_21_23 - 0.033333333333333*G1_21_25 + 0.016666666666667*G1_23_21 - 0.066666666666667*G1_23_23 - 0.033333333333333*G1_23_25 - 0.033333333333333*G1_25_21 - 0.033333333333333*G1_25_23 - 0.266666666666666*G1_25_25 - 0.166666666666667*G1_27_27 - 0.083333333333333*G1_27_29 - 0.083333333333333*G1_29_27 - 0.166666666666667*G1_29_29 + 0.045833333333333*G2_0_0 + 0.075000000000000*G2_0_7 - 0.037500000000000*G2_0_8 + 0.045833333333333*G2_1_1 - 0.037500000000000*G2_1_7 + 0.075000000000000*G2_1_8 + 0.016666666666667*G2_5_0 + 0.016666666666667*G2_5_1 + 0.150000000000000*G2_5_7 + 0.150000000000000*G2_5_8 + 0.045833333333333*G2_6_10 + 0.075000000000000*G2_6_17 - 0.037500000000000*G2_6_18 + 0.045833333333333*G2_7_11 - 0.037500000000000*G2_7_17 + 0.075000000000000*G2_7_18 + 0.016666666666667*G2_11_10 + 0.016666666666667*G2_11_11 + 0.150000000000000*G2_11_17 + 0.150000000000000*G2_11_18 + 0.083333333333333*G2_12_20 + 0.166666666666667*G2_12_25 + 0.083333333333333*G2_13_21 + 0.166666666666667*G2_13_25 - 0.066666666666667*G3_0_0 + 0.016666666666667*G3_0_1 - 0.033333333333333*G3_0_5 + 0.016666666666667*G3_1_0 - 0.066666666666667*G3_1_1 - 0.033333333333333*G3_1_5 - 0.033333333333333*G3_5_0 - 0.033333333333333*G3_5_1 - 0.266666666666667*G3_5_5 - 0.066666666666667*G3_6_6 + 0.016666666666667*G3_6_7 - 0.033333333333333*G3_6_11 + 0.016666666666667*G3_7_6 - 0.066666666666667*G3_7_7 - 0.033333333333333*G3_7_11 - 0.033333333333333*G3_11_6 - 0.033333333333333*G3_11_7 - 0.266666666666667*G3_11_11 - 0.166666666666667*G3_12_12 - 0.083333333333333*G3_12_13 - 0.083333333333333*G3_13_12 - 0.166666666666667*G3_13_13;
          break;
        }
      case 2:
        {
          A[0] = 0.045833333333333*G4_15_26 + 0.075000000000000*G4_15_33 - 0.037500000000000*G4_15_34 + 0.045833333333333*G4_16_27 - 0.037500000000000*G4_16_33 + 0.075000000000000*G4_16_34 + 0.016666666666667*G4_20_26 + 0.016666666666667*G4_20_27 + 0.150000000000000*G4_20_33 + 0.150000000000000*G4_20_34 + 0.045833333333333*G4_21_36 + 0.075000000000000*G4_21_43 - 0.037500000000000*G4_21_44 + 0.045833333333333*G4_22_37 - 0.037500000000000*G4_22_43 + 0.075000000000000*G4_22_44 + 0.016666666666667*G4_26_36 + 0.016666666666667*G4_26_37 + 0.150000000000000*G4_26_43 + 0.150000000000000*G4_26_44 + 0.083333333333333*G4_27_46 + 0.166666666666667*G4_27_51 + 0.083333333333333*G4_28_47 + 0.166666666666667*G4_28_51 - 0.066666666666667*G5_15_15 + 0.016666666666667*G5_15_16 - 0.033333333333333*G5_15_20 + 0.016666666666667*G5_16_15 - 0.066666666666667*G5_16_16 - 0.033333333333333*G5_16_20 - 0.033333333333333*G5_20_15 - 0.033333333333333*G5_20_16 - 0.266666666666667*G5_20_20 - 0.066666666666667*G5_21_21 + 0.016666666666667*G5_21_22 - 0.033333333333333*G5_21_26 + 0.016666666666667*G5_22_21 - 0.066666666666667*G5_22_22 - 0.033333333333333*G5_22_26 - 0.033333333333333*G5_26_21 - 0.033333333333333*G5_26_22 - 0.266666666666667*G5_26_26 - 0.166666666666667*G5_27_27 - 0.083333333333333*G5_27_28 - 0.083333333333333*G5_28_27 - 0.166666666666667*G5_28_28 + 0.045833333333333*G6_0_0 + 0.075000000000000*G6_0_7 - 0.037500000000000*G6_0_8 + 0.045833333333333*G6_1_1 - 0.037500000000000*G6_1_7 + 0.075000000000000*G6_1_8 + 0.016666666666667*G6_5_0 + 0.016666666666667*G6_5_1 + 0.150000000000000*G6_5_7 + 0.150000000000000*G6_5_8 + 0.045833333333333*G6_6_10 + 0.075000000000000*G6_6_17 - 0.037500000000000*G6_6_18 + 0.045833333333333*G6_7_11 - 0.037500000000000*G6_7_17 + 0.075000000000000*G6_7_18 + 0.016666666666667*G6_11_10 + 0.016666666666667*G6_11_11 + 0.150000000000000*G6_11_17 + 0.150000000000000*G6_11_18 + 0.083333333333333*G6_12_20 + 0.166666666666667*G6_12_25 + 0.083333333333333*G6_13_21 + 0.166666666666667*G6_13_25 - 0.066666666666667*G7_0_0 + 0.016666666666667*G7_0_1 - 0.033333333333333*G7_0_5 + 0.016666666666667*G7_1_0 - 0.066666666666667*G7_1_1 - 0.033333333333333*G7_1_5 - 0.033333333333333*G7_5_0 - 0.033333333333333*G7_5_1 - 0.266666666666667*G7_5_5 - 0.066666666666667*G7_6_6 + 0.016666666666667*G7_6_7 - 0.033333333333333*G7_6_11 + 0.016666666666667*G7_7_6 - 0.066666666666667*G7_7_7 - 0.033333333333333*G7_7_11 - 0.033333333333333*G7_11_6 - 0.033333333333333*G7_11_7 - 0.266666666666667*G7_11_11 - 0.166666666666667*G7_12_12 - 0.083333333333333*G7_12_13 - 0.083333333333333*G7_13_12 - 0.166666666666667*G7_13_13;
        A[1] = 0.045833333333333*G0_15_26 + 0.075000000000000*G0_15_33 - 0.037500000000000*G0_15_34 + 0.045833333333333*G0_16_27 - 0.037500000000000*G0_16_33 + 0.075000000000000*G0_16_34 + 0.016666666666667*G0_20_26 + 0.016666666666667*G0_20_27 + 0.150000000000000*G0_20_33 + 0.150000000000000*G0_20_34 + 0.045833333333333*G0_21_36 + 0.075000000000000*G0_21_43 - 0.037500000000000*G0_21_44 + 0.045833333333333*G0_22_37 - 0.037500000000000*G0_22_43 + 0.075000000000000*G0_22_44 + 0.016666666666667*G0_26_36 + 0.016666666666667*G0_26_37 + 0.150000000000000*G0_26_43 + 0.150000000000000*G0_26_44 + 0.083333333333333*G0_27_46 + 0.166666666666667*G0_27_51 + 0.083333333333333*G0_28_47 + 0.166666666666667*G0_28_51 - 0.066666666666667*G1_15_15 + 0.016666666666667*G1_15_16 - 0.033333333333333*G1_15_20 + 0.016666666666667*G1_16_15 - 0.066666666666667*G1_16_16 - 0.033333333333333*G1_16_20 - 0.033333333333333*G1_20_15 - 0.033333333333333*G1_20_16 - 0.266666666666667*G1_20_20 - 0.066666666666667*G1_21_21 + 0.016666666666667*G1_21_22 - 0.033333333333333*G1_21_26 + 0.016666666666667*G1_22_21 - 0.066666666666667*G1_22_22 - 0.033333333333333*G1_22_26 - 0.033333333333333*G1_26_21 - 0.033333333333333*G1_26_22 - 0.266666666666667*G1_26_26 - 0.166666666666667*G1_27_27 - 0.083333333333333*G1_27_28 - 0.083333333333333*G1_28_27 - 0.166666666666667*G1_28_28 + 0.045833333333333*G2_0_0 + 0.075000000000000*G2_0_7 - 0.037500000000000*G2_0_8 + 0.045833333333333*G2_1_1 - 0.037500000000000*G2_1_7 + 0.075000000000000*G2_1_8 + 0.016666666666667*G2_5_0 + 0.016666666666667*G2_5_1 + 0.150000000000000*G2_5_7 + 0.150000000000000*G2_5_8 + 0.045833333333333*G2_6_10 + 0.075000000000000*G2_6_17 - 0.037500000000000*G2_6_18 + 0.045833333333333*G2_7_11 - 0.037500000000000*G2_7_17 + 0.075000000000000*G2_7_18 + 0.016666666666667*G2_11_10 + 0.016666666666667*G2_11_11 + 0.150000000000000*G2_11_17 + 0.150000000000000*G2_11_18 + 0.083333333333333*G2_12_20 + 0.166666666666667*G2_12_25 + 0.083333333333333*G2_13_21 + 0.166666666666667*G2_13_25 - 0.066666666666667*G3_0_0 + 0.016666666666667*G3_0_1 - 0.033333333333333*G3_0_5 + 0.016666666666667*G3_1_0 - 0.066666666666667*G3_1_1 - 0.033333333333333*G3_1_5 - 0.033333333333333*G3_5_0 - 0.033333333333333*G3_5_1 - 0.266666666666667*G3_5_5 - 0.066666666666667*G3_6_6 + 0.016666666666667*G3_6_7 - 0.033333333333333*G3_6_11 + 0.016666666666667*G3_7_6 - 0.066666666666667*G3_7_7 - 0.033333333333333*G3_7_11 - 0.033333333333333*G3_11_6 - 0.033333333333333*G3_11_7 - 0.266666666666667*G3_11_11 - 0.166666666666667*G3_12_12 - 0.083333333333333*G3_12_13 - 0.083333333333333*G3_13_12 - 0.166666666666667*G3_13_13;
          break;
        }
      }
      
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local interior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_8_0: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_8_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_8_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      11
    // Number of operations (multiply-add pairs) for geometry tensor:    172
    // Number of operations (multiply-add pairs) for tensor contraction: 2992
    // Total number of operations (multiply-add pairs):                  3175
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0 = det*K_00*(1.0);
    const double G0_1 = det*K_10*(1.0);
    const double G1_0 = det*K_01*(1.0);
    const double G1_1 = det*K_11*(1.0);
    const double G2_0_0_0 = det*w[1][0]*K_00*K_00*(1.0);
    const double G2_0_0_1 = det*w[1][0]*K_00*K_10*(1.0);
    const double G2_0_1_0 = det*w[1][0]*K_10*K_00*(1.0);
    const double G2_0_1_1 = det*w[1][0]*K_10*K_10*(1.0);
    const double G3_0_0_0 = det*w[1][0]*K_00*K_00*(1.0);
    const double G3_0_0_1 = det*w[1][0]*K_00*K_10*(1.0);
    const double G3_0_1_0 = det*w[1][0]*K_10*K_00*(1.0);
    const double G3_0_1_1 = det*w[1][0]*K_10*K_10*(1.0);
    const double G4_0_0_0 = det*w[1][0]*K_01*K_01*(1.0);
    const double G4_0_0_1 = det*w[1][0]*K_01*K_11*(1.0);
    const double G4_0_1_0 = det*w[1][0]*K_11*K_01*(1.0);
    const double G4_0_1_1 = det*w[1][0]*K_11*K_11*(1.0);
    const double G5_0_0_0 = det*w[1][0]*K_01*K_01*(1.0);
    const double G5_0_0_1 = det*w[1][0]*K_01*K_11*(1.0);
    const double G5_0_1_0 = det*w[1][0]*K_11*K_01*(1.0);
    const double G5_0_1_1 = det*w[1][0]*K_11*K_11*(1.0);
    const double G6_0 = det*K_00*(1.0);
    const double G6_1 = det*K_10*(1.0);
    const double G7_0 = det*K_01*(1.0);
    const double G7_1 = det*K_11*(1.0);
    const double G8_0_0 = det*w[0][0]*K_00*(1.0);
    const double G8_0_1 = det*w[0][0]*K_10*(1.0);
    const double G8_1_0 = det*w[0][1]*K_00*(1.0);
    const double G8_2_1 = det*w[0][2]*K_10*(1.0);
    const double G8_3_0 = det*w[0][3]*K_00*(1.0);
    const double G8_3_1 = det*w[0][3]*K_10*(1.0);
    const double G8_4_0 = det*w[0][4]*K_00*(1.0);
    const double G8_4_1 = det*w[0][4]*K_10*(1.0);
    const double G8_5_0 = det*w[0][5]*K_00*(1.0);
    const double G8_5_1 = det*w[0][5]*K_10*(1.0);
    const double G9_0_0 = det*w[0][0]*K_00*(1.0);
    const double G9_0_1 = det*w[0][0]*K_10*(1.0);
    const double G9_1_0 = det*w[0][1]*K_00*(1.0);
    const double G9_1_1 = det*w[0][1]*K_10*(1.0);
    const double G9_2_0 = det*w[0][2]*K_00*(1.0);
    const double G9_2_1 = det*w[0][2]*K_10*(1.0);
    const double G9_3_0 = det*w[0][3]*K_00*(1.0);
    const double G9_3_1 = det*w[0][3]*K_10*(1.0);
    const double G9_4_0 = det*w[0][4]*K_00*(1.0);
    const double G9_4_1 = det*w[0][4]*K_10*(1.0);
    const double G9_5_0 = det*w[0][5]*K_00*(1.0);
    const double G9_5_1 = det*w[0][5]*K_10*(1.0);
    const double G10_0_0 = det*w[0][0]*K_01*(1.0);
    const double G10_0_1 = det*w[0][0]*K_11*(1.0);
    const double G10_1_0 = det*w[0][1]*K_01*(1.0);
    const double G10_2_1 = det*w[0][2]*K_11*(1.0);
    const double G10_3_0 = det*w[0][3]*K_01*(1.0);
    const double G10_3_1 = det*w[0][3]*K_11*(1.0);
    const double G10_4_0 = det*w[0][4]*K_01*(1.0);
    const double G10_4_1 = det*w[0][4]*K_11*(1.0);
    const double G10_5_0 = det*w[0][5]*K_01*(1.0);
    const double G10_5_1 = det*w[0][5]*K_11*(1.0);
    const double G11_6_0 = det*w[0][6]*K_01*(1.0);
    const double G11_6_1 = det*w[0][6]*K_11*(1.0);
    const double G11_7_0 = det*w[0][7]*K_01*(1.0);
    const double G11_7_1 = det*w[0][7]*K_11*(1.0);
    const double G11_8_0 = det*w[0][8]*K_01*(1.0);
    const double G11_8_1 = det*w[0][8]*K_11*(1.0);
    const double G11_9_0 = det*w[0][9]*K_01*(1.0);
    const double G11_9_1 = det*w[0][9]*K_11*(1.0);
    const double G11_10_0 = det*w[0][10]*K_01*(1.0);
    const double G11_10_1 = det*w[0][10]*K_11*(1.0);
    const double G11_11_0 = det*w[0][11]*K_01*(1.0);
    const double G11_11_1 = det*w[0][11]*K_11*(1.0);
    const double G12_6_0 = det*w[0][6]*K_00*(1.0);
    const double G12_6_1 = det*w[0][6]*K_10*(1.0);
    const double G12_7_0 = det*w[0][7]*K_00*(1.0);
    const double G12_8_1 = det*w[0][8]*K_10*(1.0);
    const double G12_9_0 = det*w[0][9]*K_00*(1.0);
    const double G12_9_1 = det*w[0][9]*K_10*(1.0);
    const double G12_10_0 = det*w[0][10]*K_00*(1.0);
    const double G12_10_1 = det*w[0][10]*K_10*(1.0);
    const double G12_11_0 = det*w[0][11]*K_00*(1.0);
    const double G12_11_1 = det*w[0][11]*K_10*(1.0);
    const double G13_0_0 = det*w[0][0]*K_00*(1.0);
    const double G13_0_1 = det*w[0][0]*K_10*(1.0);
    const double G13_1_0 = det*w[0][1]*K_00*(1.0);
    const double G13_1_1 = det*w[0][1]*K_10*(1.0);
    const double G13_2_0 = det*w[0][2]*K_00*(1.0);
    const double G13_2_1 = det*w[0][2]*K_10*(1.0);
    const double G13_3_0 = det*w[0][3]*K_00*(1.0);
    const double G13_3_1 = det*w[0][3]*K_10*(1.0);
    const double G13_4_0 = det*w[0][4]*K_00*(1.0);
    const double G13_4_1 = det*w[0][4]*K_10*(1.0);
    const double G13_5_0 = det*w[0][5]*K_00*(1.0);
    const double G13_5_1 = det*w[0][5]*K_10*(1.0);
    const double G14_6_0 = det*w[0][6]*K_01*(1.0);
    const double G14_6_1 = det*w[0][6]*K_11*(1.0);
    const double G14_7_0 = det*w[0][7]*K_01*(1.0);
    const double G14_8_1 = det*w[0][8]*K_11*(1.0);
    const double G14_9_0 = det*w[0][9]*K_01*(1.0);
    const double G14_9_1 = det*w[0][9]*K_11*(1.0);
    const double G14_10_0 = det*w[0][10]*K_01*(1.0);
    const double G14_10_1 = det*w[0][10]*K_11*(1.0);
    const double G14_11_0 = det*w[0][11]*K_01*(1.0);
    const double G14_11_1 = det*w[0][11]*K_11*(1.0);
    const double G15_6_0 = det*w[0][6]*K_01*(1.0);
    const double G15_6_1 = det*w[0][6]*K_11*(1.0);
    const double G15_7_0 = det*w[0][7]*K_01*(1.0);
    const double G15_7_1 = det*w[0][7]*K_11*(1.0);
    const double G15_8_0 = det*w[0][8]*K_01*(1.0);
    const double G15_8_1 = det*w[0][8]*K_11*(1.0);
    const double G15_9_0 = det*w[0][9]*K_01*(1.0);
    const double G15_9_1 = det*w[0][9]*K_11*(1.0);
    const double G15_10_0 = det*w[0][10]*K_01*(1.0);
    const double G15_10_1 = det*w[0][10]*K_11*(1.0);
    const double G15_11_0 = det*w[0][11]*K_01*(1.0);
    const double G15_11_1 = det*w[0][11]*K_11*(1.0);
    
    // Compute element tensor
    A[0] = 0.500000000000000*G2_0_0_0 + 0.500000000000000*G2_0_0_1 + 0.500000000000000*G2_0_1_0 + 0.500000000000000*G2_0_1_1 + 0.500000000000000*G4_0_0_0 + 0.500000000000000*G4_0_0_1 + 0.500000000000000*G4_0_1_0 + 0.500000000000000*G4_0_1_1 - 0.030952380952381*G8_0_0 - 0.030952380952381*G8_0_1 - 0.007142857142857*G8_1_0 - 0.007142857142857*G8_2_1 + 0.009523809523810*G8_3_0 + 0.009523809523810*G8_3_1 - 0.009523809523810*G8_4_0 + 0.038095238095238*G8_4_1 + 0.038095238095238*G8_5_0 - 0.009523809523810*G8_5_1 - 0.030952380952381*G9_0_0 - 0.030952380952381*G9_0_1 + 0.003571428571429*G9_1_0 + 0.003571428571429*G9_1_1 + 0.003571428571429*G9_2_0 + 0.003571428571429*G9_2_1 - 0.004761904761905*G9_3_0 - 0.004761904761905*G9_3_1 - 0.019047619047619*G9_4_0 - 0.019047619047619*G9_4_1 - 0.019047619047619*G9_5_0 - 0.019047619047619*G9_5_1 - 0.030952380952381*G11_6_0 - 0.030952380952381*G11_6_1 + 0.003571428571429*G11_7_0 + 0.003571428571429*G11_7_1 + 0.003571428571429*G11_8_0 + 0.003571428571429*G11_8_1 - 0.004761904761905*G11_9_0 - 0.004761904761905*G11_9_1 - 0.019047619047619*G11_10_0 - 0.019047619047619*G11_10_1 - 0.019047619047619*G11_11_0 - 0.019047619047619*G11_11_1;
    A[1] = 0.166666666666667*G2_0_0_0 + 0.166666666666667*G2_0_1_0 + 0.166666666666667*G4_0_0_0 + 0.166666666666667*G4_0_1_0 + 0.003571428571429*G8_0_0 + 0.003571428571429*G8_0_1 - 0.003571428571429*G8_1_0 + 0.004365079365079*G8_2_1 + 0.001587301587302*G8_3_0 - 0.006349206349206*G8_3_1 - 0.001587301587302*G8_4_0 - 0.007936507936508*G8_4_1 + 0.006349206349206*G8_5_1 - 0.007142857142857*G9_0_0 - 0.003571428571429*G9_1_0 + 0.004365079365079*G9_2_0 - 0.007936507936508*G9_3_0 - 0.006349206349206*G9_4_0 - 0.012698412698413*G9_5_0 - 0.007142857142857*G11_6_0 - 0.003571428571429*G11_7_0 + 0.004365079365079*G11_8_0 - 0.007936507936508*G11_9_0 - 0.006349206349206*G11_10_0 - 0.012698412698413*G11_11_0;
    A[2] = 0.166666666666667*G2_0_0_1 + 0.166666666666667*G2_0_1_1 + 0.166666666666667*G4_0_0_1 + 0.166666666666667*G4_0_1_1 + 0.003571428571429*G8_0_0 + 0.003571428571429*G8_0_1 + 0.004365079365079*G8_1_0 - 0.003571428571429*G8_2_1 - 0.006349206349206*G8_3_0 + 0.001587301587302*G8_3_1 + 0.006349206349206*G8_4_0 - 0.007936507936508*G8_5_0 - 0.001587301587302*G8_5_1 - 0.007142857142857*G9_0_1 + 0.004365079365079*G9_1_1 - 0.003571428571429*G9_2_1 - 0.007936507936508*G9_3_1 - 0.012698412698413*G9_4_1 - 0.006349206349206*G9_5_1 - 0.007142857142857*G11_6_1 + 0.004365079365079*G11_7_1 - 0.003571428571429*G11_8_1 - 0.007936507936508*G11_9_1 - 0.012698412698413*G11_10_1 - 0.006349206349206*G11_11_1;
    A[3] = -0.004761904761905*G8_0_0 - 0.004761904761905*G8_0_1 - 0.007936507936508*G8_1_0 - 0.007936507936508*G8_2_1 - 0.019047619047619*G8_3_0 - 0.019047619047619*G8_3_1 + 0.019047619047619*G8_4_0 + 0.012698412698413*G8_4_1 + 0.012698412698413*G8_5_0 + 0.019047619047619*G8_5_1 + 0.009523809523810*G9_0_0 + 0.009523809523810*G9_0_1 + 0.001587301587302*G9_1_0 - 0.006349206349206*G9_1_1 - 0.006349206349206*G9_2_0 + 0.001587301587302*G9_2_1 - 0.019047619047619*G9_3_0 - 0.019047619047619*G9_3_1 - 0.012698412698413*G9_4_0 - 0.006349206349206*G9_4_1 - 0.006349206349206*G9_5_0 - 0.012698412698413*G9_5_1 + 0.009523809523810*G11_6_0 + 0.009523809523810*G11_6_1 + 0.001587301587302*G11_7_0 - 0.006349206349206*G11_7_1 - 0.006349206349206*G11_8_0 + 0.001587301587302*G11_8_1 - 0.019047619047619*G11_9_0 - 0.019047619047619*G11_9_1 - 0.012698412698413*G11_10_0 - 0.006349206349206*G11_10_1 - 0.006349206349206*G11_11_0 - 0.012698412698413*G11_11_1;
    A[4] = -0.666666666666667*G2_0_0_1 - 0.666666666666667*G2_0_1_1 - 0.666666666666667*G4_0_0_1 - 0.666666666666667*G4_0_1_1 - 0.019047619047619*G8_0_0 - 0.019047619047619*G8_0_1 - 0.006349206349206*G8_1_0 - 0.012698412698413*G8_2_1 - 0.012698412698413*G8_3_0 - 0.006349206349206*G8_3_1 + 0.012698412698413*G8_4_0 + 0.031746031746032*G8_4_1 + 0.025396825396825*G8_5_0 + 0.006349206349206*G8_5_1 - 0.009523809523810*G9_0_0 + 0.038095238095238*G9_0_1 - 0.001587301587302*G9_1_0 - 0.007936507936508*G9_1_1 + 0.006349206349206*G9_2_0 + 0.019047619047619*G9_3_0 + 0.012698412698413*G9_3_1 + 0.012698412698413*G9_4_0 + 0.031746031746032*G9_4_1 + 0.006349206349206*G9_5_0 + 0.025396825396825*G9_5_1 - 0.009523809523810*G11_6_0 + 0.038095238095238*G11_6_1 - 0.001587301587302*G11_7_0 - 0.007936507936508*G11_7_1 + 0.006349206349206*G11_8_0 + 0.019047619047619*G11_9_0 + 0.012698412698413*G11_9_1 + 0.012698412698413*G11_10_0 + 0.031746031746032*G11_10_1 + 0.006349206349206*G11_11_0 + 0.025396825396825*G11_11_1;
    A[5] = -0.666666666666667*G2_0_0_0 - 0.666666666666667*G2_0_1_0 - 0.666666666666667*G4_0_0_0 - 0.666666666666667*G4_0_1_0 - 0.019047619047619*G8_0_0 - 0.019047619047619*G8_0_1 - 0.012698412698413*G8_1_0 - 0.006349206349206*G8_2_1 - 0.006349206349206*G8_3_0 - 0.012698412698413*G8_3_1 + 0.006349206349206*G8_4_0 + 0.025396825396825*G8_4_1 + 0.031746031746032*G8_5_0 + 0.012698412698413*G8_5_1 + 0.038095238095238*G9_0_0 - 0.009523809523810*G9_0_1 + 0.006349206349206*G9_1_1 - 0.007936507936508*G9_2_0 - 0.001587301587302*G9_2_1 + 0.012698412698413*G9_3_0 + 0.019047619047619*G9_3_1 + 0.025396825396825*G9_4_0 + 0.006349206349206*G9_4_1 + 0.031746031746032*G9_5_0 + 0.012698412698413*G9_5_1 + 0.038095238095238*G11_6_0 - 0.009523809523810*G11_6_1 + 0.006349206349206*G11_7_1 - 0.007936507936508*G11_8_0 - 0.001587301587302*G11_8_1 + 0.012698412698413*G11_9_0 + 0.019047619047619*G11_9_1 + 0.025396825396825*G11_10_0 + 0.006349206349206*G11_10_1 + 0.031746031746032*G11_11_0 + 0.012698412698413*G11_11_1;
    A[6] = -0.030952380952381*G10_0_0 - 0.030952380952381*G10_0_1 - 0.007142857142857*G10_1_0 - 0.007142857142857*G10_2_1 + 0.009523809523810*G10_3_0 + 0.009523809523810*G10_3_1 - 0.009523809523810*G10_4_0 + 0.038095238095238*G10_4_1 + 0.038095238095238*G10_5_0 - 0.009523809523810*G10_5_1;
    A[7] = 0.003571428571429*G10_0_0 + 0.003571428571429*G10_0_1 - 0.003571428571429*G10_1_0 + 0.004365079365079*G10_2_1 + 0.001587301587302*G10_3_0 - 0.006349206349206*G10_3_1 - 0.001587301587302*G10_4_0 - 0.007936507936508*G10_4_1 + 0.006349206349206*G10_5_1;
    A[8] = 0.003571428571429*G10_0_0 + 0.003571428571429*G10_0_1 + 0.004365079365079*G10_1_0 - 0.003571428571429*G10_2_1 - 0.006349206349206*G10_3_0 + 0.001587301587302*G10_3_1 + 0.006349206349206*G10_4_0 - 0.007936507936508*G10_5_0 - 0.001587301587302*G10_5_1;
    A[9] = -0.004761904761905*G10_0_0 - 0.004761904761905*G10_0_1 - 0.007936507936508*G10_1_0 - 0.007936507936508*G10_2_1 - 0.019047619047619*G10_3_0 - 0.019047619047619*G10_3_1 + 0.019047619047619*G10_4_0 + 0.012698412698413*G10_4_1 + 0.012698412698413*G10_5_0 + 0.019047619047619*G10_5_1;
    A[10] = -0.019047619047619*G10_0_0 - 0.019047619047619*G10_0_1 - 0.006349206349206*G10_1_0 - 0.012698412698413*G10_2_1 - 0.012698412698413*G10_3_0 - 0.006349206349206*G10_3_1 + 0.012698412698413*G10_4_0 + 0.031746031746032*G10_4_1 + 0.025396825396825*G10_5_0 + 0.006349206349206*G10_5_1;
    A[11] = -0.019047619047619*G10_0_0 - 0.019047619047619*G10_0_1 - 0.012698412698413*G10_1_0 - 0.006349206349206*G10_2_1 - 0.006349206349206*G10_3_0 - 0.012698412698413*G10_3_1 + 0.006349206349206*G10_4_0 + 0.025396825396825*G10_4_1 + 0.031746031746032*G10_5_0 + 0.012698412698413*G10_5_1;
    A[12] = 0.166666666666667*G6_0 + 0.166666666666667*G6_1;
    A[13] = 0.000000000000000;
    A[14] = 0.000000000000000;
    A[15] = 0.166666666666667*G2_0_0_0 + 0.166666666666667*G2_0_0_1 + 0.166666666666667*G4_0_0_0 + 0.166666666666667*G4_0_0_1 + 0.003571428571429*G8_0_0 + 0.003571428571429*G8_0_1 - 0.003571428571429*G8_1_0 + 0.004365079365079*G8_2_1 + 0.001587301587302*G8_3_0 - 0.006349206349206*G8_3_1 - 0.001587301587302*G8_4_0 - 0.007936507936508*G8_4_1 + 0.006349206349206*G8_5_1 + 0.003571428571429*G9_0_0 + 0.003571428571429*G9_0_1 + 0.007142857142857*G9_1_0 + 0.007142857142857*G9_1_1 - 0.004365079365079*G9_2_0 - 0.004365079365079*G9_2_1 + 0.006349206349206*G9_3_0 + 0.006349206349206*G9_3_1 + 0.007936507936508*G9_4_0 + 0.007936507936508*G9_4_1 + 0.012698412698413*G9_5_0 + 0.012698412698413*G9_5_1 + 0.003571428571429*G11_6_0 + 0.003571428571429*G11_6_1 + 0.007142857142857*G11_7_0 + 0.007142857142857*G11_7_1 - 0.004365079365079*G11_8_0 - 0.004365079365079*G11_8_1 + 0.006349206349206*G11_9_0 + 0.006349206349206*G11_9_1 + 0.007936507936508*G11_10_0 + 0.007936507936508*G11_10_1 + 0.012698412698413*G11_11_0 + 0.012698412698413*G11_11_1;
    A[16] = 0.500000000000000*G2_0_0_0 + 0.500000000000000*G4_0_0_0 + 0.007142857142857*G8_0_0 + 0.007142857142857*G8_0_1 + 0.030952380952381*G8_1_0 - 0.007142857142857*G8_2_1 + 0.009523809523810*G8_3_0 + 0.047619047619048*G8_3_1 - 0.009523809523810*G8_4_0 - 0.038095238095238*G8_5_0 - 0.047619047619048*G8_5_1 - 0.003571428571429*G9_0_0 + 0.030952380952381*G9_1_0 - 0.003571428571429*G9_2_0 + 0.019047619047619*G9_3_0 + 0.004761904761905*G9_4_0 + 0.019047619047619*G9_5_0 - 0.003571428571429*G11_6_0 + 0.030952380952381*G11_7_0 - 0.003571428571429*G11_8_0 + 0.019047619047619*G11_9_0 + 0.004761904761905*G11_10_0 + 0.019047619047619*G11_11_0;
    A[17] = -0.166666666666667*G2_0_0_1 - 0.166666666666667*G4_0_0_1 - 0.004365079365079*G8_0_0 - 0.004365079365079*G8_0_1 - 0.003571428571429*G8_1_0 - 0.003571428571429*G8_2_1 - 0.006349206349206*G8_3_0 - 0.006349206349206*G8_3_1 + 0.006349206349206*G8_4_0 + 0.007936507936508*G8_4_1 + 0.007936507936508*G8_5_0 + 0.006349206349206*G8_5_1 + 0.004365079365079*G9_0_1 - 0.007142857142857*G9_1_1 - 0.003571428571429*G9_2_1 - 0.012698412698413*G9_3_1 - 0.007936507936508*G9_4_1 - 0.006349206349206*G9_5_1 + 0.004365079365079*G11_6_1 - 0.007142857142857*G11_7_1 - 0.003571428571429*G11_8_1 - 0.012698412698413*G11_9_1 - 0.007936507936508*G11_10_1 - 0.006349206349206*G11_11_1;
    A[18] = 0.666666666666666*G2_0_0_1 + 0.666666666666666*G4_0_0_1 + 0.006349206349206*G8_0_0 + 0.006349206349206*G8_0_1 + 0.019047619047619*G8_1_0 - 0.012698412698413*G8_2_1 - 0.012698412698413*G8_3_0 + 0.019047619047619*G8_3_1 + 0.012698412698413*G8_4_0 + 0.006349206349206*G8_4_1 - 0.025396825396825*G8_5_0 - 0.019047619047619*G8_5_1 + 0.001587301587302*G9_0_0 - 0.006349206349206*G9_0_1 + 0.009523809523810*G9_1_0 + 0.047619047619048*G9_1_1 - 0.006349206349206*G9_2_0 - 0.006349206349206*G9_2_1 - 0.012698412698413*G9_3_0 + 0.019047619047619*G9_3_1 - 0.019047619047619*G9_4_0 - 0.006349206349206*G9_4_1 - 0.006349206349206*G9_5_0 + 0.019047619047619*G9_5_1 + 0.001587301587302*G11_6_0 - 0.006349206349206*G11_6_1 + 0.009523809523810*G11_7_0 + 0.047619047619048*G11_7_1 - 0.006349206349206*G11_8_0 - 0.006349206349206*G11_8_1 - 0.012698412698413*G11_9_0 + 0.019047619047619*G11_9_1 - 0.019047619047619*G11_10_0 - 0.006349206349206*G11_10_1 - 0.006349206349206*G11_11_0 + 0.019047619047619*G11_11_1;
    A[19] = 0.007936507936508*G8_0_0 + 0.007936507936508*G8_0_1 + 0.004761904761905*G8_1_0 - 0.007936507936508*G8_2_1 - 0.019047619047619*G8_3_0 - 0.006349206349206*G8_3_1 + 0.019047619047619*G8_4_0 - 0.012698412698413*G8_5_0 + 0.006349206349206*G8_5_1 - 0.001587301587302*G9_0_0 - 0.007936507936508*G9_0_1 - 0.009523809523810*G9_1_0 + 0.006349206349206*G9_2_0 + 0.007936507936508*G9_2_1 + 0.012698412698413*G9_3_0 + 0.006349206349206*G9_3_1 + 0.019047619047619*G9_4_0 + 0.006349206349206*G9_5_0 - 0.006349206349206*G9_5_1 - 0.001587301587302*G11_6_0 - 0.007936507936508*G11_6_1 - 0.009523809523810*G11_7_0 + 0.006349206349206*G11_8_0 + 0.007936507936508*G11_8_1 + 0.012698412698413*G11_9_0 + 0.006349206349206*G11_9_1 + 0.019047619047619*G11_10_0 + 0.006349206349206*G11_11_0 - 0.006349206349206*G11_11_1;
    A[20] = -0.666666666666666*G2_0_0_0 - 0.666666666666666*G2_0_0_1 - 0.666666666666666*G4_0_0_0 - 0.666666666666666*G4_0_0_1 + 0.012698412698413*G8_0_0 + 0.012698412698413*G8_0_1 + 0.019047619047619*G8_1_0 - 0.006349206349206*G8_2_1 - 0.006349206349206*G8_3_0 + 0.019047619047619*G8_3_1 + 0.006349206349206*G8_4_0 - 0.006349206349206*G8_4_1 - 0.031746031746032*G8_5_0 - 0.019047619047619*G8_5_1 + 0.006349206349206*G9_0_1 - 0.038095238095238*G9_1_0 - 0.047619047619048*G9_1_1 + 0.007936507936508*G9_2_0 + 0.006349206349206*G9_2_1 - 0.025396825396825*G9_3_0 - 0.019047619047619*G9_3_1 - 0.012698412698413*G9_4_0 + 0.006349206349206*G9_4_1 - 0.031746031746032*G9_5_0 - 0.019047619047619*G9_5_1 + 0.006349206349206*G11_6_1 - 0.038095238095238*G11_7_0 - 0.047619047619048*G11_7_1 + 0.007936507936508*G11_8_0 + 0.006349206349206*G11_8_1 - 0.025396825396825*G11_9_0 - 0.019047619047619*G11_9_1 - 0.012698412698413*G11_10_0 + 0.006349206349206*G11_10_1 - 0.031746031746032*G11_11_0 - 0.019047619047619*G11_11_1;
    A[21] = 0.003571428571429*G10_0_0 + 0.003571428571429*G10_0_1 - 0.003571428571429*G10_1_0 + 0.004365079365079*G10_2_1 + 0.001587301587302*G10_3_0 - 0.006349206349206*G10_3_1 - 0.001587301587302*G10_4_0 - 0.007936507936508*G10_4_1 + 0.006349206349206*G10_5_1;
    A[22] = 0.007142857142857*G10_0_0 + 0.007142857142857*G10_0_1 + 0.030952380952381*G10_1_0 - 0.007142857142857*G10_2_1 + 0.009523809523810*G10_3_0 + 0.047619047619048*G10_3_1 - 0.009523809523810*G10_4_0 - 0.038095238095238*G10_5_0 - 0.047619047619048*G10_5_1;
    A[23] = -0.004365079365079*G10_0_0 - 0.004365079365079*G10_0_1 - 0.003571428571429*G10_1_0 - 0.003571428571429*G10_2_1 - 0.006349206349206*G10_3_0 - 0.006349206349206*G10_3_1 + 0.006349206349206*G10_4_0 + 0.007936507936508*G10_4_1 + 0.007936507936508*G10_5_0 + 0.006349206349206*G10_5_1;
    A[24] = 0.006349206349206*G10_0_0 + 0.006349206349206*G10_0_1 + 0.019047619047619*G10_1_0 - 0.012698412698413*G10_2_1 - 0.012698412698413*G10_3_0 + 0.019047619047619*G10_3_1 + 0.012698412698413*G10_4_0 + 0.006349206349206*G10_4_1 - 0.025396825396825*G10_5_0 - 0.019047619047619*G10_5_1;
    A[25] = 0.007936507936508*G10_0_0 + 0.007936507936508*G10_0_1 + 0.004761904761905*G10_1_0 - 0.007936507936508*G10_2_1 - 0.019047619047619*G10_3_0 - 0.006349206349206*G10_3_1 + 0.019047619047619*G10_4_0 - 0.012698412698413*G10_5_0 + 0.006349206349206*G10_5_1;
    A[26] = 0.012698412698413*G10_0_0 + 0.012698412698413*G10_0_1 + 0.019047619047619*G10_1_0 - 0.006349206349206*G10_2_1 - 0.006349206349206*G10_3_0 + 0.019047619047619*G10_3_1 + 0.006349206349206*G10_4_0 - 0.006349206349206*G10_4_1 - 0.031746031746032*G10_5_0 - 0.019047619047619*G10_5_1;
    A[27] = 0.000000000000000;
    A[28] = -0.166666666666667*G6_0;
    A[29] = 0.000000000000000;
    A[30] = 0.166666666666667*G2_0_1_0 + 0.166666666666667*G2_0_1_1 + 0.166666666666667*G4_0_1_0 + 0.166666666666667*G4_0_1_1 + 0.003571428571429*G8_0_0 + 0.003571428571429*G8_0_1 + 0.004365079365079*G8_1_0 - 0.003571428571429*G8_2_1 - 0.006349206349206*G8_3_0 + 0.001587301587302*G8_3_1 + 0.006349206349206*G8_4_0 - 0.007936507936508*G8_5_0 - 0.001587301587302*G8_5_1 + 0.003571428571429*G9_0_0 + 0.003571428571429*G9_0_1 - 0.004365079365079*G9_1_0 - 0.004365079365079*G9_1_1 + 0.007142857142857*G9_2_0 + 0.007142857142857*G9_2_1 + 0.006349206349206*G9_3_0 + 0.006349206349206*G9_3_1 + 0.012698412698413*G9_4_0 + 0.012698412698413*G9_4_1 + 0.007936507936508*G9_5_0 + 0.007936507936508*G9_5_1 + 0.003571428571429*G11_6_0 + 0.003571428571429*G11_6_1 - 0.004365079365079*G11_7_0 - 0.004365079365079*G11_7_1 + 0.007142857142857*G11_8_0 + 0.007142857142857*G11_8_1 + 0.006349206349206*G11_9_0 + 0.006349206349206*G11_9_1 + 0.012698412698413*G11_10_0 + 0.012698412698413*G11_10_1 + 0.007936507936508*G11_11_0 + 0.007936507936508*G11_11_1;
    A[31] = -0.166666666666667*G2_0_1_0 - 0.166666666666667*G4_0_1_0 - 0.004365079365079*G8_0_0 - 0.004365079365079*G8_0_1 - 0.003571428571429*G8_1_0 - 0.003571428571429*G8_2_1 - 0.006349206349206*G8_3_0 - 0.006349206349206*G8_3_1 + 0.006349206349206*G8_4_0 + 0.007936507936508*G8_4_1 + 0.007936507936508*G8_5_0 + 0.006349206349206*G8_5_1 + 0.004365079365079*G9_0_0 - 0.003571428571429*G9_1_0 - 0.007142857142857*G9_2_0 - 0.012698412698413*G9_3_0 - 0.006349206349206*G9_4_0 - 0.007936507936508*G9_5_0 + 0.004365079365079*G11_6_0 - 0.003571428571429*G11_7_0 - 0.007142857142857*G11_8_0 - 0.012698412698413*G11_9_0 - 0.006349206349206*G11_10_0 - 0.007936507936508*G11_11_0;
    A[32] = 0.500000000000000*G2_0_1_1 + 0.500000000000000*G4_0_1_1 + 0.007142857142857*G8_0_0 + 0.007142857142857*G8_0_1 - 0.007142857142857*G8_1_0 + 0.030952380952381*G8_2_1 + 0.047619047619048*G8_3_0 + 0.009523809523809*G8_3_1 - 0.047619047619048*G8_4_0 - 0.038095238095238*G8_4_1 - 0.009523809523810*G8_5_1 - 0.003571428571429*G9_0_1 - 0.003571428571429*G9_1_1 + 0.030952380952381*G9_2_1 + 0.019047619047619*G9_3_1 + 0.019047619047619*G9_4_1 + 0.004761904761905*G9_5_1 - 0.003571428571429*G11_6_1 - 0.003571428571429*G11_7_1 + 0.030952380952381*G11_8_1 + 0.019047619047619*G11_9_1 + 0.019047619047619*G11_10_1 + 0.004761904761905*G11_11_1;
    A[33] = 0.666666666666666*G2_0_1_0 + 0.666666666666666*G4_0_1_0 + 0.006349206349206*G8_0_0 + 0.006349206349206*G8_0_1 - 0.012698412698413*G8_1_0 + 0.019047619047619*G8_2_1 + 0.019047619047619*G8_3_0 - 0.012698412698413*G8_3_1 - 0.019047619047619*G8_4_0 - 0.025396825396825*G8_4_1 + 0.006349206349206*G8_5_0 + 0.012698412698413*G8_5_1 - 0.006349206349206*G9_0_0 + 0.001587301587302*G9_0_1 - 0.006349206349206*G9_1_0 - 0.006349206349206*G9_1_1 + 0.047619047619048*G9_2_0 + 0.009523809523809*G9_2_1 + 0.019047619047619*G9_3_0 - 0.012698412698413*G9_3_1 + 0.019047619047619*G9_4_0 - 0.006349206349206*G9_4_1 - 0.006349206349206*G9_5_0 - 0.019047619047619*G9_5_1 - 0.006349206349206*G11_6_0 + 0.001587301587302*G11_6_1 - 0.006349206349206*G11_7_0 - 0.006349206349206*G11_7_1 + 0.047619047619048*G11_8_0 + 0.009523809523809*G11_8_1 + 0.019047619047619*G11_9_0 - 0.012698412698413*G11_9_1 + 0.019047619047619*G11_10_0 - 0.006349206349206*G11_10_1 - 0.006349206349206*G11_11_0 - 0.019047619047619*G11_11_1;
    A[34] = -0.666666666666666*G2_0_1_0 - 0.666666666666666*G2_0_1_1 - 0.666666666666666*G4_0_1_0 - 0.666666666666666*G4_0_1_1 + 0.012698412698413*G8_0_0 + 0.012698412698413*G8_0_1 - 0.006349206349206*G8_1_0 + 0.019047619047619*G8_2_1 + 0.019047619047619*G8_3_0 - 0.006349206349206*G8_3_1 - 0.019047619047619*G8_4_0 - 0.031746031746032*G8_4_1 - 0.006349206349206*G8_5_0 + 0.006349206349206*G8_5_1 + 0.006349206349206*G9_0_0 + 0.006349206349206*G9_1_0 + 0.007936507936508*G9_1_1 - 0.047619047619048*G9_2_0 - 0.038095238095238*G9_2_1 - 0.019047619047619*G9_3_0 - 0.025396825396825*G9_3_1 - 0.019047619047619*G9_4_0 - 0.031746031746032*G9_4_1 + 0.006349206349206*G9_5_0 - 0.012698412698413*G9_5_1 + 0.006349206349206*G11_6_0 + 0.006349206349206*G11_7_0 + 0.007936507936508*G11_7_1 - 0.047619047619048*G11_8_0 - 0.038095238095238*G11_8_1 - 0.019047619047619*G11_9_0 - 0.025396825396825*G11_9_1 - 0.019047619047619*G11_10_0 - 0.031746031746032*G11_10_1 + 0.006349206349206*G11_11_0 - 0.012698412698413*G11_11_1;
    A[35] = 0.007936507936508*G8_0_0 + 0.007936507936508*G8_0_1 - 0.007936507936508*G8_1_0 + 0.004761904761905*G8_2_1 - 0.006349206349206*G8_3_0 - 0.019047619047619*G8_3_1 + 0.006349206349206*G8_4_0 - 0.012698412698413*G8_4_1 + 0.019047619047619*G8_5_1 - 0.007936507936508*G9_0_0 - 0.001587301587302*G9_0_1 + 0.007936507936508*G9_1_0 + 0.006349206349206*G9_1_1 - 0.009523809523810*G9_2_1 + 0.006349206349206*G9_3_0 + 0.012698412698413*G9_3_1 - 0.006349206349206*G9_4_0 + 0.006349206349206*G9_4_1 + 0.019047619047619*G9_5_1 - 0.007936507936508*G11_6_0 - 0.001587301587302*G11_6_1 + 0.007936507936508*G11_7_0 + 0.006349206349206*G11_7_1 - 0.009523809523810*G11_8_1 + 0.006349206349206*G11_9_0 + 0.012698412698413*G11_9_1 - 0.006349206349206*G11_10_0 + 0.006349206349206*G11_10_1 + 0.019047619047619*G11_11_1;
    A[36] = 0.003571428571429*G10_0_0 + 0.003571428571429*G10_0_1 + 0.004365079365079*G10_1_0 - 0.003571428571429*G10_2_1 - 0.006349206349206*G10_3_0 + 0.001587301587302*G10_3_1 + 0.006349206349206*G10_4_0 - 0.007936507936508*G10_5_0 - 0.001587301587302*G10_5_1;
    A[37] = -0.004365079365079*G10_0_0 - 0.004365079365079*G10_0_1 - 0.003571428571429*G10_1_0 - 0.003571428571429*G10_2_1 - 0.006349206349206*G10_3_0 - 0.006349206349206*G10_3_1 + 0.006349206349206*G10_4_0 + 0.007936507936508*G10_4_1 + 0.007936507936508*G10_5_0 + 0.006349206349206*G10_5_1;
    A[38] = 0.007142857142857*G10_0_0 + 0.007142857142857*G10_0_1 - 0.007142857142857*G10_1_0 + 0.030952380952381*G10_2_1 + 0.047619047619048*G10_3_0 + 0.009523809523809*G10_3_1 - 0.047619047619048*G10_4_0 - 0.038095238095238*G10_4_1 - 0.009523809523810*G10_5_1;
    A[39] = 0.006349206349206*G10_0_0 + 0.006349206349206*G10_0_1 - 0.012698412698413*G10_1_0 + 0.019047619047619*G10_2_1 + 0.019047619047619*G10_3_0 - 0.012698412698413*G10_3_1 - 0.019047619047619*G10_4_0 - 0.025396825396825*G10_4_1 + 0.006349206349206*G10_5_0 + 0.012698412698413*G10_5_1;
    A[40] = 0.012698412698413*G10_0_0 + 0.012698412698413*G10_0_1 - 0.006349206349206*G10_1_0 + 0.019047619047619*G10_2_1 + 0.019047619047619*G10_3_0 - 0.006349206349206*G10_3_1 - 0.019047619047619*G10_4_0 - 0.031746031746032*G10_4_1 - 0.006349206349206*G10_5_0 + 0.006349206349206*G10_5_1;
    A[41] = 0.007936507936508*G10_0_0 + 0.007936507936508*G10_0_1 - 0.007936507936508*G10_1_0 + 0.004761904761905*G10_2_1 - 0.006349206349206*G10_3_0 - 0.019047619047619*G10_3_1 + 0.006349206349206*G10_4_0 - 0.012698412698413*G10_4_1 + 0.019047619047619*G10_5_1;
    A[42] = 0.000000000000000;
    A[43] = 0.000000000000000;
    A[44] = -0.166666666666667*G6_1;
    A[45] = -0.004761904761905*G8_0_0 - 0.004761904761905*G8_0_1 - 0.007936507936508*G8_1_0 - 0.007936507936508*G8_2_1 - 0.019047619047619*G8_3_0 - 0.019047619047619*G8_3_1 + 0.019047619047619*G8_4_0 + 0.012698412698413*G8_4_1 + 0.012698412698413*G8_5_0 + 0.019047619047619*G8_5_1 - 0.004761904761905*G9_0_0 - 0.004761904761905*G9_0_1 + 0.006349206349206*G9_1_0 + 0.006349206349206*G9_1_1 + 0.006349206349206*G9_2_0 + 0.006349206349206*G9_2_1 + 0.038095238095238*G9_3_0 + 0.038095238095238*G9_3_1 - 0.006349206349206*G9_4_0 - 0.006349206349206*G9_4_1 - 0.006349206349206*G9_5_0 - 0.006349206349206*G9_5_1 - 0.004761904761905*G11_6_0 - 0.004761904761905*G11_6_1 + 0.006349206349206*G11_7_0 + 0.006349206349206*G11_7_1 + 0.006349206349206*G11_8_0 + 0.006349206349206*G11_8_1 + 0.038095238095238*G11_9_0 + 0.038095238095238*G11_9_1 - 0.006349206349206*G11_10_0 - 0.006349206349206*G11_10_1 - 0.006349206349206*G11_11_0 - 0.006349206349206*G11_11_1;
    A[46] = 0.666666666666666*G2_0_1_0 + 0.666666666666666*G4_0_1_0 + 0.006349206349206*G8_0_0 + 0.006349206349206*G8_0_1 + 0.019047619047619*G8_1_0 - 0.012698412698413*G8_2_1 - 0.012698412698413*G8_3_0 + 0.019047619047619*G8_3_1 + 0.012698412698413*G8_4_0 + 0.006349206349206*G8_4_1 - 0.025396825396825*G8_5_0 - 0.019047619047619*G8_5_1 - 0.007936507936508*G9_0_0 + 0.019047619047619*G9_1_0 - 0.012698412698413*G9_2_0 + 0.063492063492063*G9_3_0 + 0.006349206349206*G9_4_0 + 0.031746031746032*G9_5_0 - 0.007936507936508*G11_6_0 + 0.019047619047619*G11_7_0 - 0.012698412698413*G11_8_0 + 0.063492063492063*G11_9_0 + 0.006349206349206*G11_10_0 + 0.031746031746032*G11_11_0;
    A[47] = 0.666666666666666*G2_0_0_1 + 0.666666666666666*G4_0_0_1 + 0.006349206349206*G8_0_0 + 0.006349206349206*G8_0_1 - 0.012698412698413*G8_1_0 + 0.019047619047619*G8_2_1 + 0.019047619047619*G8_3_0 - 0.012698412698413*G8_3_1 - 0.019047619047619*G8_4_0 - 0.025396825396825*G8_4_1 + 0.006349206349206*G8_5_0 + 0.012698412698413*G8_5_1 - 0.007936507936508*G9_0_1 - 0.012698412698413*G9_1_1 + 0.019047619047619*G9_2_1 + 0.063492063492063*G9_3_1 + 0.031746031746032*G9_4_1 + 0.006349206349206*G9_5_1 - 0.007936507936508*G11_6_1 - 0.012698412698413*G11_7_1 + 0.019047619047619*G11_8_1 + 0.063492063492063*G11_9_1 + 0.031746031746032*G11_10_1 + 0.006349206349206*G11_11_1;
    A[48] = 1.333333333333332*G2_0_0_0 + 0.666666666666666*G2_0_0_1 + 0.666666666666666*G2_0_1_0 + 1.333333333333332*G2_0_1_1 + 1.333333333333332*G4_0_0_0 + 0.666666666666666*G4_0_0_1 + 0.666666666666666*G4_0_1_0 + 1.333333333333332*G4_0_1_1 + 0.038095238095238*G8_0_0 + 0.038095238095238*G8_0_1 + 0.063492063492063*G8_1_0 + 0.063492063492063*G8_2_1 + 0.152380952380952*G8_3_0 + 0.152380952380952*G8_3_1 - 0.152380952380952*G8_4_0 - 0.101587301587301*G8_4_1 - 0.101587301587301*G8_5_0 - 0.152380952380952*G8_5_1 - 0.019047619047619*G9_0_0 - 0.019047619047619*G9_0_1 - 0.012698412698413*G9_1_0 + 0.019047619047619*G9_1_1 + 0.019047619047619*G9_2_0 - 0.012698412698413*G9_2_1 + 0.152380952380952*G9_3_0 + 0.152380952380952*G9_3_1 + 0.076190476190476*G9_4_0 + 0.050793650793651*G9_4_1 + 0.050793650793651*G9_5_0 + 0.076190476190476*G9_5_1 - 0.019047619047619*G11_6_0 - 0.019047619047619*G11_6_1 - 0.012698412698413*G11_7_0 + 0.019047619047619*G11_7_1 + 0.019047619047619*G11_8_0 - 0.012698412698413*G11_8_1 + 0.152380952380952*G11_9_0 + 0.152380952380952*G11_9_1 + 0.076190476190476*G11_10_0 + 0.050793650793651*G11_10_1 + 0.050793650793651*G11_11_0 + 0.076190476190476*G11_11_1;
    A[49] = -1.333333333333332*G2_0_0_0 - 0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_0 - 1.333333333333332*G4_0_0_0 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_0 - 0.006349206349206*G8_0_0 - 0.006349206349206*G8_0_1 + 0.006349206349206*G8_1_0 + 0.031746031746032*G8_2_1 + 0.076190476190476*G8_3_0 + 0.050793650793651*G8_3_1 - 0.076190476190476*G8_4_0 - 0.025396825396825*G8_4_1 - 0.050793650793651*G8_5_1 + 0.019047619047619*G9_0_0 + 0.012698412698413*G9_0_1 + 0.012698412698413*G9_1_0 + 0.006349206349206*G9_1_1 - 0.019047619047619*G9_2_0 - 0.025396825396825*G9_2_1 - 0.152380952380952*G9_3_0 - 0.101587301587301*G9_3_1 - 0.076190476190476*G9_4_0 - 0.025396825396825*G9_4_1 - 0.050793650793651*G9_5_0 + 0.019047619047619*G11_6_0 + 0.012698412698413*G11_6_1 + 0.012698412698413*G11_7_0 + 0.006349206349206*G11_7_1 - 0.019047619047619*G11_8_0 - 0.025396825396825*G11_8_1 - 0.152380952380952*G11_9_0 - 0.101587301587301*G11_9_1 - 0.076190476190476*G11_10_0 - 0.025396825396825*G11_10_1 - 0.050793650793651*G11_11_0;
    A[50] = -0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_0 - 1.333333333333332*G2_0_1_1 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_0 - 1.333333333333332*G4_0_1_1 - 0.006349206349206*G8_0_0 - 0.006349206349206*G8_0_1 + 0.031746031746032*G8_1_0 + 0.006349206349206*G8_2_1 + 0.050793650793651*G8_3_0 + 0.076190476190476*G8_3_1 - 0.050793650793651*G8_4_0 - 0.025396825396825*G8_5_0 - 0.076190476190476*G8_5_1 + 0.012698412698413*G9_0_0 + 0.019047619047619*G9_0_1 - 0.025396825396825*G9_1_0 - 0.019047619047619*G9_1_1 + 0.006349206349206*G9_2_0 + 0.012698412698413*G9_2_1 - 0.101587301587301*G9_3_0 - 0.152380952380952*G9_3_1 - 0.050793650793651*G9_4_1 - 0.025396825396825*G9_5_0 - 0.076190476190476*G9_5_1 + 0.012698412698413*G11_6_0 + 0.019047619047619*G11_6_1 - 0.025396825396825*G11_7_0 - 0.019047619047619*G11_7_1 + 0.006349206349206*G11_8_0 + 0.012698412698413*G11_8_1 - 0.101587301587301*G11_9_0 - 0.152380952380952*G11_9_1 - 0.050793650793651*G11_10_1 - 0.025396825396825*G11_11_0 - 0.076190476190476*G11_11_1;
    A[51] = -0.004761904761905*G10_0_0 - 0.004761904761905*G10_0_1 - 0.007936507936508*G10_1_0 - 0.007936507936508*G10_2_1 - 0.019047619047619*G10_3_0 - 0.019047619047619*G10_3_1 + 0.019047619047619*G10_4_0 + 0.012698412698413*G10_4_1 + 0.012698412698413*G10_5_0 + 0.019047619047619*G10_5_1;
    A[52] = 0.006349206349206*G10_0_0 + 0.006349206349206*G10_0_1 + 0.019047619047619*G10_1_0 - 0.012698412698413*G10_2_1 - 0.012698412698413*G10_3_0 + 0.019047619047619*G10_3_1 + 0.012698412698413*G10_4_0 + 0.006349206349206*G10_4_1 - 0.025396825396825*G10_5_0 - 0.019047619047619*G10_5_1;
    A[53] = 0.006349206349206*G10_0_0 + 0.006349206349206*G10_0_1 - 0.012698412698413*G10_1_0 + 0.019047619047619*G10_2_1 + 0.019047619047619*G10_3_0 - 0.012698412698413*G10_3_1 - 0.019047619047619*G10_4_0 - 0.025396825396825*G10_4_1 + 0.006349206349206*G10_5_0 + 0.012698412698413*G10_5_1;
    A[54] = 0.038095238095238*G10_0_0 + 0.038095238095238*G10_0_1 + 0.063492063492063*G10_1_0 + 0.063492063492063*G10_2_1 + 0.152380952380952*G10_3_0 + 0.152380952380952*G10_3_1 - 0.152380952380952*G10_4_0 - 0.101587301587301*G10_4_1 - 0.101587301587301*G10_5_0 - 0.152380952380952*G10_5_1;
    A[55] = -0.006349206349206*G10_0_0 - 0.006349206349206*G10_0_1 + 0.006349206349206*G10_1_0 + 0.031746031746032*G10_2_1 + 0.076190476190476*G10_3_0 + 0.050793650793651*G10_3_1 - 0.076190476190476*G10_4_0 - 0.025396825396825*G10_4_1 - 0.050793650793651*G10_5_1;
    A[56] = -0.006349206349206*G10_0_0 - 0.006349206349206*G10_0_1 + 0.031746031746032*G10_1_0 + 0.006349206349206*G10_2_1 + 0.050793650793651*G10_3_0 + 0.076190476190476*G10_3_1 - 0.050793650793651*G10_4_0 - 0.025396825396825*G10_5_0 - 0.076190476190476*G10_5_1;
    A[57] = -0.166666666666667*G6_0 - 0.166666666666667*G6_1;
    A[58] = -0.166666666666667*G6_0 - 0.333333333333333*G6_1;
    A[59] = -0.333333333333333*G6_0 - 0.166666666666667*G6_1;
    A[60] = -0.666666666666667*G2_0_1_0 - 0.666666666666667*G2_0_1_1 - 0.666666666666667*G4_0_1_0 - 0.666666666666667*G4_0_1_1 - 0.019047619047619*G8_0_0 - 0.019047619047619*G8_0_1 - 0.006349206349206*G8_1_0 - 0.012698412698413*G8_2_1 - 0.012698412698413*G8_3_0 - 0.006349206349206*G8_3_1 + 0.012698412698413*G8_4_0 + 0.031746031746032*G8_4_1 + 0.025396825396825*G8_5_0 + 0.006349206349206*G8_5_1 - 0.019047619047619*G9_0_0 - 0.019047619047619*G9_0_1 + 0.007936507936508*G9_1_0 + 0.007936507936508*G9_1_1 + 0.012698412698413*G9_2_0 + 0.012698412698413*G9_2_1 - 0.006349206349206*G9_3_0 - 0.006349206349206*G9_3_1 - 0.063492063492063*G9_4_0 - 0.063492063492063*G9_4_1 - 0.031746031746032*G9_5_0 - 0.031746031746032*G9_5_1 - 0.019047619047619*G11_6_0 - 0.019047619047619*G11_6_1 + 0.007936507936508*G11_7_0 + 0.007936507936508*G11_7_1 + 0.012698412698413*G11_8_0 + 0.012698412698413*G11_8_1 - 0.006349206349206*G11_9_0 - 0.006349206349206*G11_9_1 - 0.063492063492063*G11_10_0 - 0.063492063492063*G11_10_1 - 0.031746031746032*G11_11_0 - 0.031746031746032*G11_11_1;
    A[61] = 0.007936507936508*G8_0_0 + 0.007936507936508*G8_0_1 + 0.004761904761905*G8_1_0 - 0.007936507936508*G8_2_1 - 0.019047619047619*G8_3_0 - 0.006349206349206*G8_3_1 + 0.019047619047619*G8_4_0 - 0.012698412698413*G8_5_0 + 0.006349206349206*G8_5_1 - 0.006349206349206*G9_0_0 + 0.004761904761905*G9_1_0 - 0.006349206349206*G9_2_0 + 0.006349206349206*G9_3_0 - 0.038095238095238*G9_4_0 + 0.006349206349206*G9_5_0 - 0.006349206349206*G11_6_0 + 0.004761904761905*G11_7_0 - 0.006349206349206*G11_8_0 + 0.006349206349206*G11_9_0 - 0.038095238095238*G11_10_0 + 0.006349206349206*G11_11_0;
    A[62] = -0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_1 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_1 + 0.012698412698413*G8_0_0 + 0.012698412698413*G8_0_1 - 0.006349206349206*G8_1_0 + 0.019047619047619*G8_2_1 + 0.019047619047619*G8_3_0 - 0.006349206349206*G8_3_1 - 0.019047619047619*G8_4_0 - 0.031746031746032*G8_4_1 - 0.006349206349206*G8_5_0 + 0.006349206349206*G8_5_1 - 0.012698412698413*G9_0_1 - 0.007936507936508*G9_1_1 + 0.019047619047619*G9_2_1 + 0.031746031746032*G9_3_1 + 0.063492063492063*G9_4_1 + 0.006349206349206*G9_5_1 - 0.012698412698413*G11_6_1 - 0.007936507936508*G11_7_1 + 0.019047619047619*G11_8_1 + 0.031746031746032*G11_9_1 + 0.063492063492063*G11_10_1 + 0.006349206349206*G11_11_1;
    A[63] = -1.333333333333332*G2_0_0_0 - 0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_0 - 1.333333333333332*G4_0_0_0 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_0 - 0.006349206349206*G8_0_0 - 0.006349206349206*G8_0_1 + 0.006349206349206*G8_1_0 + 0.031746031746032*G8_2_1 + 0.076190476190476*G8_3_0 + 0.050793650793651*G8_3_1 - 0.076190476190476*G8_4_0 - 0.025396825396825*G8_4_1 - 0.050793650793651*G8_5_1 - 0.012698412698413*G9_0_0 - 0.006349206349206*G9_0_1 - 0.019047619047619*G9_1_0 - 0.006349206349206*G9_1_1 + 0.019047619047619*G9_2_0 - 0.006349206349206*G9_2_1 + 0.076190476190476*G9_3_0 + 0.050793650793651*G9_3_1 + 0.152380952380952*G9_4_0 + 0.050793650793651*G9_4_1 + 0.050793650793651*G9_5_0 + 0.050793650793651*G9_5_1 - 0.012698412698413*G11_6_0 - 0.006349206349206*G11_6_1 - 0.019047619047619*G11_7_0 - 0.006349206349206*G11_7_1 + 0.019047619047619*G11_8_0 - 0.006349206349206*G11_8_1 + 0.076190476190476*G11_9_0 + 0.050793650793651*G11_9_1 + 0.152380952380952*G11_10_0 + 0.050793650793651*G11_10_1 + 0.050793650793651*G11_11_0 + 0.050793650793651*G11_11_1;
    A[64] = 1.333333333333332*G2_0_0_0 + 0.666666666666666*G2_0_0_1 + 0.666666666666666*G2_0_1_0 + 1.333333333333333*G2_0_1_1 + 1.333333333333332*G4_0_0_0 + 0.666666666666666*G4_0_0_1 + 0.666666666666666*G4_0_1_0 + 1.333333333333333*G4_0_1_1 - 0.063492063492063*G8_0_0 - 0.063492063492063*G8_0_1 - 0.038095238095238*G8_1_0 + 0.063492063492063*G8_2_1 + 0.152380952380952*G8_3_0 + 0.050793650793651*G8_3_1 - 0.152380952380952*G8_4_0 + 0.101587301587302*G8_5_0 - 0.050793650793651*G8_5_1 + 0.012698412698413*G9_0_0 + 0.031746031746032*G9_0_1 + 0.019047619047619*G9_1_0 - 0.019047619047619*G9_2_0 - 0.031746031746032*G9_2_1 - 0.076190476190476*G9_3_0 - 0.025396825396825*G9_3_1 - 0.152380952380952*G9_4_0 - 0.050793650793651*G9_5_0 + 0.025396825396825*G9_5_1 + 0.012698412698413*G11_6_0 + 0.031746031746032*G11_6_1 + 0.019047619047619*G11_7_0 - 0.019047619047619*G11_8_0 - 0.031746031746032*G11_8_1 - 0.076190476190476*G11_9_0 - 0.025396825396825*G11_9_1 - 0.152380952380952*G11_10_0 - 0.050793650793651*G11_11_0 + 0.025396825396825*G11_11_1;
    A[65] = 0.666666666666666*G2_0_0_1 + 0.666666666666667*G2_0_1_0 + 0.666666666666666*G4_0_0_1 + 0.666666666666667*G4_0_1_0 - 0.031746031746032*G8_0_0 - 0.031746031746032*G8_0_1 + 0.006349206349206*G8_1_0 + 0.006349206349206*G8_2_1 + 0.050793650793651*G8_3_0 + 0.050793650793651*G8_3_1 - 0.050793650793651*G8_4_0 + 0.025396825396825*G8_4_1 + 0.025396825396825*G8_5_0 - 0.050793650793651*G8_5_1 + 0.025396825396825*G9_0_0 + 0.006349206349206*G9_0_1 - 0.012698412698413*G9_1_0 + 0.006349206349206*G9_1_1 - 0.006349206349206*G9_2_0 + 0.006349206349206*G9_2_1 - 0.050793650793651*G9_3_1 + 0.101587301587302*G9_4_0 - 0.050793650793651*G9_4_1 + 0.025396825396825*G9_5_0 - 0.050793650793651*G9_5_1 + 0.025396825396825*G11_6_0 + 0.006349206349206*G11_6_1 - 0.012698412698413*G11_7_0 + 0.006349206349206*G11_7_1 - 0.006349206349206*G11_8_0 + 0.006349206349206*G11_8_1 - 0.050793650793651*G11_9_1 + 0.101587301587302*G11_10_0 - 0.050793650793651*G11_10_1 + 0.025396825396825*G11_11_0 - 0.050793650793651*G11_11_1;
    A[66] = -0.019047619047619*G10_0_0 - 0.019047619047619*G10_0_1 - 0.006349206349206*G10_1_0 - 0.012698412698413*G10_2_1 - 0.012698412698413*G10_3_0 - 0.006349206349206*G10_3_1 + 0.012698412698413*G10_4_0 + 0.031746031746032*G10_4_1 + 0.025396825396825*G10_5_0 + 0.006349206349206*G10_5_1;
    A[67] = 0.007936507936508*G10_0_0 + 0.007936507936508*G10_0_1 + 0.004761904761905*G10_1_0 - 0.007936507936508*G10_2_1 - 0.019047619047619*G10_3_0 - 0.006349206349206*G10_3_1 + 0.019047619047619*G10_4_0 - 0.012698412698413*G10_5_0 + 0.006349206349206*G10_5_1;
    A[68] = 0.012698412698413*G10_0_0 + 0.012698412698413*G10_0_1 - 0.006349206349206*G10_1_0 + 0.019047619047619*G10_2_1 + 0.019047619047619*G10_3_0 - 0.006349206349206*G10_3_1 - 0.019047619047619*G10_4_0 - 0.031746031746032*G10_4_1 - 0.006349206349206*G10_5_0 + 0.006349206349206*G10_5_1;
    A[69] = -0.006349206349206*G10_0_0 - 0.006349206349206*G10_0_1 + 0.006349206349206*G10_1_0 + 0.031746031746032*G10_2_1 + 0.076190476190476*G10_3_0 + 0.050793650793651*G10_3_1 - 0.076190476190476*G10_4_0 - 0.025396825396825*G10_4_1 - 0.050793650793651*G10_5_1;
    A[70] = -0.063492063492063*G10_0_0 - 0.063492063492063*G10_0_1 - 0.038095238095238*G10_1_0 + 0.063492063492063*G10_2_1 + 0.152380952380952*G10_3_0 + 0.050793650793651*G10_3_1 - 0.152380952380952*G10_4_0 + 0.101587301587302*G10_5_0 - 0.050793650793651*G10_5_1;
    A[71] = -0.031746031746032*G10_0_0 - 0.031746031746032*G10_0_1 + 0.006349206349206*G10_1_0 + 0.006349206349206*G10_2_1 + 0.050793650793651*G10_3_0 + 0.050793650793651*G10_3_1 - 0.050793650793651*G10_4_0 + 0.025396825396825*G10_4_1 + 0.025396825396825*G10_5_0 - 0.050793650793651*G10_5_1;
    A[72] = 0.166666666666667*G6_0 - 0.166666666666667*G6_1;
    A[73] = 0.166666666666667*G6_0;
    A[74] = 0.333333333333333*G6_0 + 0.166666666666666*G6_1;
    A[75] = -0.666666666666667*G2_0_0_0 - 0.666666666666667*G2_0_0_1 - 0.666666666666667*G4_0_0_0 - 0.666666666666667*G4_0_0_1 - 0.019047619047619*G8_0_0 - 0.019047619047619*G8_0_1 - 0.012698412698413*G8_1_0 - 0.006349206349206*G8_2_1 - 0.006349206349206*G8_3_0 - 0.012698412698413*G8_3_1 + 0.006349206349206*G8_4_0 + 0.025396825396825*G8_4_1 + 0.031746031746032*G8_5_0 + 0.012698412698413*G8_5_1 - 0.019047619047619*G9_0_0 - 0.019047619047619*G9_0_1 + 0.012698412698413*G9_1_0 + 0.012698412698413*G9_1_1 + 0.007936507936508*G9_2_0 + 0.007936507936508*G9_2_1 - 0.006349206349206*G9_3_0 - 0.006349206349206*G9_3_1 - 0.031746031746032*G9_4_0 - 0.031746031746032*G9_4_1 - 0.063492063492063*G9_5_0 - 0.063492063492063*G9_5_1 - 0.019047619047619*G11_6_0 - 0.019047619047619*G11_6_1 + 0.012698412698413*G11_7_0 + 0.012698412698413*G11_7_1 + 0.007936507936508*G11_8_0 + 0.007936507936508*G11_8_1 - 0.006349206349206*G11_9_0 - 0.006349206349206*G11_9_1 - 0.031746031746032*G11_10_0 - 0.031746031746032*G11_10_1 - 0.063492063492063*G11_11_0 - 0.063492063492063*G11_11_1;
    A[76] = -0.666666666666666*G2_0_0_0 - 0.666666666666666*G2_0_1_0 - 0.666666666666666*G4_0_0_0 - 0.666666666666666*G4_0_1_0 + 0.012698412698413*G8_0_0 + 0.012698412698413*G8_0_1 + 0.019047619047619*G8_1_0 - 0.006349206349206*G8_2_1 - 0.006349206349206*G8_3_0 + 0.019047619047619*G8_3_1 + 0.006349206349206*G8_4_0 - 0.006349206349206*G8_4_1 - 0.031746031746032*G8_5_0 - 0.019047619047619*G8_5_1 - 0.012698412698413*G9_0_0 + 0.019047619047619*G9_1_0 - 0.007936507936508*G9_2_0 + 0.031746031746032*G9_3_0 + 0.006349206349206*G9_4_0 + 0.063492063492064*G9_5_0 - 0.012698412698413*G11_6_0 + 0.019047619047619*G11_7_0 - 0.007936507936508*G11_8_0 + 0.031746031746032*G11_9_0 + 0.006349206349206*G11_10_0 + 0.063492063492064*G11_11_0;
    A[77] = 0.007936507936508*G8_0_0 + 0.007936507936508*G8_0_1 - 0.007936507936508*G8_1_0 + 0.004761904761905*G8_2_1 - 0.006349206349206*G8_3_0 - 0.019047619047619*G8_3_1 + 0.006349206349206*G8_4_0 - 0.012698412698413*G8_4_1 + 0.019047619047619*G8_5_1 - 0.006349206349206*G9_0_1 - 0.006349206349206*G9_1_1 + 0.004761904761905*G9_2_1 + 0.006349206349206*G9_3_1 + 0.006349206349206*G9_4_1 - 0.038095238095238*G9_5_1 - 0.006349206349206*G11_6_1 - 0.006349206349206*G11_7_1 + 0.004761904761905*G11_8_1 + 0.006349206349206*G11_9_1 + 0.006349206349206*G11_10_1 - 0.038095238095238*G11_11_1;
    A[78] = -0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_0 - 1.333333333333333*G2_0_1_1 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_0 - 1.333333333333333*G4_0_1_1 - 0.006349206349206*G8_0_0 - 0.006349206349206*G8_0_1 + 0.031746031746032*G8_1_0 + 0.006349206349206*G8_2_1 + 0.050793650793651*G8_3_0 + 0.076190476190476*G8_3_1 - 0.050793650793651*G8_4_0 - 0.025396825396825*G8_5_0 - 0.076190476190476*G8_5_1 - 0.006349206349206*G9_0_0 - 0.012698412698413*G9_0_1 - 0.006349206349206*G9_1_0 + 0.019047619047619*G9_1_1 - 0.006349206349206*G9_2_0 - 0.019047619047619*G9_2_1 + 0.050793650793651*G9_3_0 + 0.076190476190476*G9_3_1 + 0.050793650793651*G9_4_0 + 0.050793650793651*G9_4_1 + 0.050793650793651*G9_5_0 + 0.152380952380952*G9_5_1 - 0.006349206349206*G11_6_0 - 0.012698412698413*G11_6_1 - 0.006349206349206*G11_7_0 + 0.019047619047619*G11_7_1 - 0.006349206349206*G11_8_0 - 0.019047619047619*G11_8_1 + 0.050793650793651*G11_9_0 + 0.076190476190476*G11_9_1 + 0.050793650793651*G11_10_0 + 0.050793650793651*G11_10_1 + 0.050793650793651*G11_11_0 + 0.152380952380952*G11_11_1;
    A[79] = 0.666666666666667*G2_0_0_1 + 0.666666666666666*G2_0_1_0 + 0.666666666666667*G4_0_0_1 + 0.666666666666666*G4_0_1_0 - 0.031746031746032*G8_0_0 - 0.031746031746032*G8_0_1 + 0.006349206349206*G8_1_0 + 0.006349206349206*G8_2_1 + 0.050793650793651*G8_3_0 + 0.050793650793651*G8_3_1 - 0.050793650793651*G8_4_0 + 0.025396825396825*G8_4_1 + 0.025396825396825*G8_5_0 - 0.050793650793651*G8_5_1 + 0.006349206349206*G9_0_0 + 0.025396825396825*G9_0_1 + 0.006349206349206*G9_1_0 - 0.006349206349206*G9_1_1 + 0.006349206349206*G9_2_0 - 0.012698412698413*G9_2_1 - 0.050793650793651*G9_3_0 - 0.050793650793651*G9_4_0 + 0.025396825396825*G9_4_1 - 0.050793650793651*G9_5_0 + 0.101587301587302*G9_5_1 + 0.006349206349206*G11_6_0 + 0.025396825396825*G11_6_1 + 0.006349206349206*G11_7_0 - 0.006349206349206*G11_7_1 + 0.006349206349206*G11_8_0 - 0.012698412698413*G11_8_1 - 0.050793650793651*G11_9_0 - 0.050793650793651*G11_10_0 + 0.025396825396825*G11_10_1 - 0.050793650793651*G11_11_0 + 0.101587301587302*G11_11_1;
    A[80] = 1.333333333333333*G2_0_0_0 + 0.666666666666666*G2_0_0_1 + 0.666666666666666*G2_0_1_0 + 1.333333333333333*G2_0_1_1 + 1.333333333333333*G4_0_0_0 + 0.666666666666666*G4_0_0_1 + 0.666666666666666*G4_0_1_0 + 1.333333333333333*G4_0_1_1 - 0.063492063492063*G8_0_0 - 0.063492063492063*G8_0_1 + 0.063492063492064*G8_1_0 - 0.038095238095238*G8_2_1 + 0.050793650793651*G8_3_0 + 0.152380952380952*G8_3_1 - 0.050793650793651*G8_4_0 + 0.101587301587302*G8_4_1 - 0.152380952380952*G8_5_1 + 0.031746031746032*G9_0_0 + 0.012698412698413*G9_0_1 - 0.031746031746032*G9_1_0 - 0.019047619047619*G9_1_1 + 0.019047619047619*G9_2_1 - 0.025396825396825*G9_3_0 - 0.076190476190476*G9_3_1 + 0.025396825396825*G9_4_0 - 0.050793650793651*G9_4_1 - 0.152380952380952*G9_5_1 + 0.031746031746032*G11_6_0 + 0.012698412698413*G11_6_1 - 0.031746031746032*G11_7_0 - 0.019047619047619*G11_7_1 + 0.019047619047619*G11_8_1 - 0.025396825396825*G11_9_0 - 0.076190476190476*G11_9_1 + 0.025396825396825*G11_10_0 - 0.050793650793651*G11_10_1 - 0.152380952380952*G11_11_1;
    A[81] = -0.019047619047619*G10_0_0 - 0.019047619047619*G10_0_1 - 0.012698412698413*G10_1_0 - 0.006349206349206*G10_2_1 - 0.006349206349206*G10_3_0 - 0.012698412698413*G10_3_1 + 0.006349206349206*G10_4_0 + 0.025396825396825*G10_4_1 + 0.031746031746032*G10_5_0 + 0.012698412698413*G10_5_1;
    A[82] = 0.012698412698413*G10_0_0 + 0.012698412698413*G10_0_1 + 0.019047619047619*G10_1_0 - 0.006349206349206*G10_2_1 - 0.006349206349206*G10_3_0 + 0.019047619047619*G10_3_1 + 0.006349206349206*G10_4_0 - 0.006349206349206*G10_4_1 - 0.031746031746032*G10_5_0 - 0.019047619047619*G10_5_1;
    A[83] = 0.007936507936508*G10_0_0 + 0.007936507936508*G10_0_1 - 0.007936507936508*G10_1_0 + 0.004761904761905*G10_2_1 - 0.006349206349206*G10_3_0 - 0.019047619047619*G10_3_1 + 0.006349206349206*G10_4_0 - 0.012698412698413*G10_4_1 + 0.019047619047619*G10_5_1;
    A[84] = -0.006349206349206*G10_0_0 - 0.006349206349206*G10_0_1 + 0.031746031746032*G10_1_0 + 0.006349206349206*G10_2_1 + 0.050793650793651*G10_3_0 + 0.076190476190476*G10_3_1 - 0.050793650793651*G10_4_0 - 0.025396825396825*G10_5_0 - 0.076190476190476*G10_5_1;
    A[85] = -0.031746031746032*G10_0_0 - 0.031746031746032*G10_0_1 + 0.006349206349206*G10_1_0 + 0.006349206349206*G10_2_1 + 0.050793650793651*G10_3_0 + 0.050793650793651*G10_3_1 - 0.050793650793651*G10_4_0 + 0.025396825396825*G10_4_1 + 0.025396825396825*G10_5_0 - 0.050793650793651*G10_5_1;
    A[86] = -0.063492063492063*G10_0_0 - 0.063492063492063*G10_0_1 + 0.063492063492064*G10_1_0 - 0.038095238095238*G10_2_1 + 0.050793650793651*G10_3_0 + 0.152380952380952*G10_3_1 - 0.050793650793651*G10_4_0 + 0.101587301587302*G10_4_1 - 0.152380952380952*G10_5_1;
    A[87] = -0.166666666666667*G6_0 + 0.166666666666667*G6_1;
    A[88] = 0.166666666666667*G6_0 + 0.333333333333333*G6_1;
    A[89] = 0.166666666666667*G6_1;
    A[90] = -0.030952380952381*G12_6_0 - 0.030952380952381*G12_6_1 - 0.007142857142857*G12_7_0 - 0.007142857142857*G12_8_1 + 0.009523809523810*G12_9_0 + 0.009523809523810*G12_9_1 - 0.009523809523810*G12_10_0 + 0.038095238095238*G12_10_1 + 0.038095238095238*G12_11_0 - 0.009523809523810*G12_11_1;
    A[91] = 0.003571428571429*G12_6_0 + 0.003571428571429*G12_6_1 - 0.003571428571429*G12_7_0 + 0.004365079365079*G12_8_1 + 0.001587301587302*G12_9_0 - 0.006349206349206*G12_9_1 - 0.001587301587302*G12_10_0 - 0.007936507936508*G12_10_1 + 0.006349206349206*G12_11_1;
    A[92] = 0.003571428571429*G12_6_0 + 0.003571428571429*G12_6_1 + 0.004365079365079*G12_7_0 - 0.003571428571429*G12_8_1 - 0.006349206349206*G12_9_0 + 0.001587301587302*G12_9_1 + 0.006349206349206*G12_10_0 - 0.007936507936508*G12_11_0 - 0.001587301587302*G12_11_1;
    A[93] = -0.004761904761905*G12_6_0 - 0.004761904761905*G12_6_1 - 0.007936507936508*G12_7_0 - 0.007936507936508*G12_8_1 - 0.019047619047619*G12_9_0 - 0.019047619047619*G12_9_1 + 0.019047619047619*G12_10_0 + 0.012698412698413*G12_10_1 + 0.012698412698413*G12_11_0 + 0.019047619047619*G12_11_1;
    A[94] = -0.019047619047619*G12_6_0 - 0.019047619047619*G12_6_1 - 0.006349206349206*G12_7_0 - 0.012698412698413*G12_8_1 - 0.012698412698413*G12_9_0 - 0.006349206349206*G12_9_1 + 0.012698412698413*G12_10_0 + 0.031746031746032*G12_10_1 + 0.025396825396825*G12_11_0 + 0.006349206349206*G12_11_1;
    A[95] = -0.019047619047619*G12_6_0 - 0.019047619047619*G12_6_1 - 0.012698412698413*G12_7_0 - 0.006349206349206*G12_8_1 - 0.006349206349206*G12_9_0 - 0.012698412698413*G12_9_1 + 0.006349206349206*G12_10_0 + 0.025396825396825*G12_10_1 + 0.031746031746032*G12_11_0 + 0.012698412698413*G12_11_1;
    A[96] = 0.500000000000000*G3_0_0_0 + 0.500000000000000*G3_0_0_1 + 0.500000000000000*G3_0_1_0 + 0.500000000000000*G3_0_1_1 + 0.500000000000000*G5_0_0_0 + 0.500000000000000*G5_0_0_1 + 0.500000000000000*G5_0_1_0 + 0.500000000000000*G5_0_1_1 - 0.030952380952381*G13_0_0 - 0.030952380952381*G13_0_1 + 0.003571428571429*G13_1_0 + 0.003571428571429*G13_1_1 + 0.003571428571429*G13_2_0 + 0.003571428571429*G13_2_1 - 0.004761904761905*G13_3_0 - 0.004761904761905*G13_3_1 - 0.019047619047619*G13_4_0 - 0.019047619047619*G13_4_1 - 0.019047619047619*G13_5_0 - 0.019047619047619*G13_5_1 - 0.030952380952381*G14_6_0 - 0.030952380952381*G14_6_1 - 0.007142857142857*G14_7_0 - 0.007142857142857*G14_8_1 + 0.009523809523810*G14_9_0 + 0.009523809523810*G14_9_1 - 0.009523809523810*G14_10_0 + 0.038095238095238*G14_10_1 + 0.038095238095238*G14_11_0 - 0.009523809523810*G14_11_1 - 0.030952380952381*G15_6_0 - 0.030952380952381*G15_6_1 + 0.003571428571429*G15_7_0 + 0.003571428571429*G15_7_1 + 0.003571428571429*G15_8_0 + 0.003571428571429*G15_8_1 - 0.004761904761905*G15_9_0 - 0.004761904761905*G15_9_1 - 0.019047619047619*G15_10_0 - 0.019047619047619*G15_10_1 - 0.019047619047619*G15_11_0 - 0.019047619047619*G15_11_1;
    A[97] = 0.166666666666667*G3_0_0_0 + 0.166666666666667*G3_0_1_0 + 0.166666666666667*G5_0_0_0 + 0.166666666666667*G5_0_1_0 - 0.007142857142857*G13_0_0 - 0.003571428571429*G13_1_0 + 0.004365079365079*G13_2_0 - 0.007936507936508*G13_3_0 - 0.006349206349206*G13_4_0 - 0.012698412698413*G13_5_0 + 0.003571428571429*G14_6_0 + 0.003571428571429*G14_6_1 - 0.003571428571429*G14_7_0 + 0.004365079365079*G14_8_1 + 0.001587301587302*G14_9_0 - 0.006349206349206*G14_9_1 - 0.001587301587302*G14_10_0 - 0.007936507936508*G14_10_1 + 0.006349206349206*G14_11_1 - 0.007142857142857*G15_6_0 - 0.003571428571429*G15_7_0 + 0.004365079365079*G15_8_0 - 0.007936507936508*G15_9_0 - 0.006349206349206*G15_10_0 - 0.012698412698413*G15_11_0;
    A[98] = 0.166666666666667*G3_0_0_1 + 0.166666666666667*G3_0_1_1 + 0.166666666666667*G5_0_0_1 + 0.166666666666667*G5_0_1_1 - 0.007142857142857*G13_0_1 + 0.004365079365079*G13_1_1 - 0.003571428571429*G13_2_1 - 0.007936507936508*G13_3_1 - 0.012698412698413*G13_4_1 - 0.006349206349206*G13_5_1 + 0.003571428571429*G14_6_0 + 0.003571428571429*G14_6_1 + 0.004365079365079*G14_7_0 - 0.003571428571429*G14_8_1 - 0.006349206349206*G14_9_0 + 0.001587301587302*G14_9_1 + 0.006349206349206*G14_10_0 - 0.007936507936508*G14_11_0 - 0.001587301587302*G14_11_1 - 0.007142857142857*G15_6_1 + 0.004365079365079*G15_7_1 - 0.003571428571429*G15_8_1 - 0.007936507936508*G15_9_1 - 0.012698412698413*G15_10_1 - 0.006349206349206*G15_11_1;
    A[99] = 0.009523809523810*G13_0_0 + 0.009523809523810*G13_0_1 + 0.001587301587302*G13_1_0 - 0.006349206349206*G13_1_1 - 0.006349206349206*G13_2_0 + 0.001587301587302*G13_2_1 - 0.019047619047619*G13_3_0 - 0.019047619047619*G13_3_1 - 0.012698412698413*G13_4_0 - 0.006349206349206*G13_4_1 - 0.006349206349206*G13_5_0 - 0.012698412698413*G13_5_1 - 0.004761904761905*G14_6_0 - 0.004761904761905*G14_6_1 - 0.007936507936508*G14_7_0 - 0.007936507936508*G14_8_1 - 0.019047619047619*G14_9_0 - 0.019047619047619*G14_9_1 + 0.019047619047619*G14_10_0 + 0.012698412698413*G14_10_1 + 0.012698412698413*G14_11_0 + 0.019047619047619*G14_11_1 + 0.009523809523810*G15_6_0 + 0.009523809523810*G15_6_1 + 0.001587301587302*G15_7_0 - 0.006349206349206*G15_7_1 - 0.006349206349206*G15_8_0 + 0.001587301587302*G15_8_1 - 0.019047619047619*G15_9_0 - 0.019047619047619*G15_9_1 - 0.012698412698413*G15_10_0 - 0.006349206349206*G15_10_1 - 0.006349206349206*G15_11_0 - 0.012698412698413*G15_11_1;
    A[100] = -0.666666666666667*G3_0_0_1 - 0.666666666666667*G3_0_1_1 - 0.666666666666667*G5_0_0_1 - 0.666666666666667*G5_0_1_1 - 0.009523809523810*G13_0_0 + 0.038095238095238*G13_0_1 - 0.001587301587302*G13_1_0 - 0.007936507936508*G13_1_1 + 0.006349206349206*G13_2_0 + 0.019047619047619*G13_3_0 + 0.012698412698413*G13_3_1 + 0.012698412698413*G13_4_0 + 0.031746031746032*G13_4_1 + 0.006349206349206*G13_5_0 + 0.025396825396825*G13_5_1 - 0.019047619047619*G14_6_0 - 0.019047619047619*G14_6_1 - 0.006349206349206*G14_7_0 - 0.012698412698413*G14_8_1 - 0.012698412698413*G14_9_0 - 0.006349206349206*G14_9_1 + 0.012698412698413*G14_10_0 + 0.031746031746032*G14_10_1 + 0.025396825396825*G14_11_0 + 0.006349206349206*G14_11_1 - 0.009523809523810*G15_6_0 + 0.038095238095238*G15_6_1 - 0.001587301587302*G15_7_0 - 0.007936507936508*G15_7_1 + 0.006349206349206*G15_8_0 + 0.019047619047619*G15_9_0 + 0.012698412698413*G15_9_1 + 0.012698412698413*G15_10_0 + 0.031746031746032*G15_10_1 + 0.006349206349206*G15_11_0 + 0.025396825396825*G15_11_1;
    A[101] = -0.666666666666667*G3_0_0_0 - 0.666666666666667*G3_0_1_0 - 0.666666666666667*G5_0_0_0 - 0.666666666666667*G5_0_1_0 + 0.038095238095238*G13_0_0 - 0.009523809523810*G13_0_1 + 0.006349206349206*G13_1_1 - 0.007936507936508*G13_2_0 - 0.001587301587302*G13_2_1 + 0.012698412698413*G13_3_0 + 0.019047619047619*G13_3_1 + 0.025396825396825*G13_4_0 + 0.006349206349206*G13_4_1 + 0.031746031746032*G13_5_0 + 0.012698412698413*G13_5_1 - 0.019047619047619*G14_6_0 - 0.019047619047619*G14_6_1 - 0.012698412698413*G14_7_0 - 0.006349206349206*G14_8_1 - 0.006349206349206*G14_9_0 - 0.012698412698413*G14_9_1 + 0.006349206349206*G14_10_0 + 0.025396825396825*G14_10_1 + 0.031746031746032*G14_11_0 + 0.012698412698413*G14_11_1 + 0.038095238095238*G15_6_0 - 0.009523809523810*G15_6_1 + 0.006349206349206*G15_7_1 - 0.007936507936508*G15_8_0 - 0.001587301587302*G15_8_1 + 0.012698412698413*G15_9_0 + 0.019047619047619*G15_9_1 + 0.025396825396825*G15_10_0 + 0.006349206349206*G15_10_1 + 0.031746031746032*G15_11_0 + 0.012698412698413*G15_11_1;
    A[102] = 0.166666666666667*G7_0 + 0.166666666666667*G7_1;
    A[103] = 0.000000000000000;
    A[104] = 0.000000000000000;
    A[105] = 0.003571428571429*G12_6_0 + 0.003571428571429*G12_6_1 - 0.003571428571429*G12_7_0 + 0.004365079365079*G12_8_1 + 0.001587301587302*G12_9_0 - 0.006349206349206*G12_9_1 - 0.001587301587302*G12_10_0 - 0.007936507936508*G12_10_1 + 0.006349206349206*G12_11_1;
    A[106] = 0.007142857142857*G12_6_0 + 0.007142857142857*G12_6_1 + 0.030952380952381*G12_7_0 - 0.007142857142857*G12_8_1 + 0.009523809523810*G12_9_0 + 0.047619047619048*G12_9_1 - 0.009523809523810*G12_10_0 - 0.038095238095238*G12_11_0 - 0.047619047619048*G12_11_1;
    A[107] = -0.004365079365079*G12_6_0 - 0.004365079365079*G12_6_1 - 0.003571428571429*G12_7_0 - 0.003571428571429*G12_8_1 - 0.006349206349206*G12_9_0 - 0.006349206349206*G12_9_1 + 0.006349206349206*G12_10_0 + 0.007936507936508*G12_10_1 + 0.007936507936508*G12_11_0 + 0.006349206349206*G12_11_1;
    A[108] = 0.006349206349206*G12_6_0 + 0.006349206349206*G12_6_1 + 0.019047619047619*G12_7_0 - 0.012698412698413*G12_8_1 - 0.012698412698413*G12_9_0 + 0.019047619047619*G12_9_1 + 0.012698412698413*G12_10_0 + 0.006349206349206*G12_10_1 - 0.025396825396825*G12_11_0 - 0.019047619047619*G12_11_1;
    A[109] = 0.007936507936508*G12_6_0 + 0.007936507936508*G12_6_1 + 0.004761904761905*G12_7_0 - 0.007936507936508*G12_8_1 - 0.019047619047619*G12_9_0 - 0.006349206349206*G12_9_1 + 0.019047619047619*G12_10_0 - 0.012698412698413*G12_11_0 + 0.006349206349206*G12_11_1;
    A[110] = 0.012698412698413*G12_6_0 + 0.012698412698413*G12_6_1 + 0.019047619047619*G12_7_0 - 0.006349206349206*G12_8_1 - 0.006349206349206*G12_9_0 + 0.019047619047619*G12_9_1 + 0.006349206349206*G12_10_0 - 0.006349206349206*G12_10_1 - 0.031746031746032*G12_11_0 - 0.019047619047619*G12_11_1;
    A[111] = 0.166666666666667*G3_0_0_0 + 0.166666666666667*G3_0_0_1 + 0.166666666666667*G5_0_0_0 + 0.166666666666667*G5_0_0_1 + 0.003571428571429*G13_0_0 + 0.003571428571429*G13_0_1 + 0.007142857142857*G13_1_0 + 0.007142857142857*G13_1_1 - 0.004365079365079*G13_2_0 - 0.004365079365079*G13_2_1 + 0.006349206349206*G13_3_0 + 0.006349206349206*G13_3_1 + 0.007936507936508*G13_4_0 + 0.007936507936508*G13_4_1 + 0.012698412698413*G13_5_0 + 0.012698412698413*G13_5_1 + 0.003571428571429*G14_6_0 + 0.003571428571429*G14_6_1 - 0.003571428571429*G14_7_0 + 0.004365079365079*G14_8_1 + 0.001587301587302*G14_9_0 - 0.006349206349206*G14_9_1 - 0.001587301587302*G14_10_0 - 0.007936507936508*G14_10_1 + 0.006349206349206*G14_11_1 + 0.003571428571429*G15_6_0 + 0.003571428571429*G15_6_1 + 0.007142857142857*G15_7_0 + 0.007142857142857*G15_7_1 - 0.004365079365079*G15_8_0 - 0.004365079365079*G15_8_1 + 0.006349206349206*G15_9_0 + 0.006349206349206*G15_9_1 + 0.007936507936508*G15_10_0 + 0.007936507936508*G15_10_1 + 0.012698412698413*G15_11_0 + 0.012698412698413*G15_11_1;
    A[112] = 0.500000000000000*G3_0_0_0 + 0.500000000000000*G5_0_0_0 - 0.003571428571429*G13_0_0 + 0.030952380952381*G13_1_0 - 0.003571428571429*G13_2_0 + 0.019047619047619*G13_3_0 + 0.004761904761905*G13_4_0 + 0.019047619047619*G13_5_0 + 0.007142857142857*G14_6_0 + 0.007142857142857*G14_6_1 + 0.030952380952381*G14_7_0 - 0.007142857142857*G14_8_1 + 0.009523809523810*G14_9_0 + 0.047619047619048*G14_9_1 - 0.009523809523810*G14_10_0 - 0.038095238095238*G14_11_0 - 0.047619047619048*G14_11_1 - 0.003571428571429*G15_6_0 + 0.030952380952381*G15_7_0 - 0.003571428571429*G15_8_0 + 0.019047619047619*G15_9_0 + 0.004761904761905*G15_10_0 + 0.019047619047619*G15_11_0;
    A[113] = -0.166666666666667*G3_0_0_1 - 0.166666666666667*G5_0_0_1 + 0.004365079365079*G13_0_1 - 0.007142857142857*G13_1_1 - 0.003571428571429*G13_2_1 - 0.012698412698413*G13_3_1 - 0.007936507936508*G13_4_1 - 0.006349206349206*G13_5_1 - 0.004365079365079*G14_6_0 - 0.004365079365079*G14_6_1 - 0.003571428571429*G14_7_0 - 0.003571428571429*G14_8_1 - 0.006349206349206*G14_9_0 - 0.006349206349206*G14_9_1 + 0.006349206349206*G14_10_0 + 0.007936507936508*G14_10_1 + 0.007936507936508*G14_11_0 + 0.006349206349206*G14_11_1 + 0.004365079365079*G15_6_1 - 0.007142857142857*G15_7_1 - 0.003571428571429*G15_8_1 - 0.012698412698413*G15_9_1 - 0.007936507936508*G15_10_1 - 0.006349206349206*G15_11_1;
    A[114] = 0.666666666666666*G3_0_0_1 + 0.666666666666666*G5_0_0_1 + 0.001587301587302*G13_0_0 - 0.006349206349206*G13_0_1 + 0.009523809523810*G13_1_0 + 0.047619047619048*G13_1_1 - 0.006349206349206*G13_2_0 - 0.006349206349206*G13_2_1 - 0.012698412698413*G13_3_0 + 0.019047619047619*G13_3_1 - 0.019047619047619*G13_4_0 - 0.006349206349206*G13_4_1 - 0.006349206349206*G13_5_0 + 0.019047619047619*G13_5_1 + 0.006349206349206*G14_6_0 + 0.006349206349206*G14_6_1 + 0.019047619047619*G14_7_0 - 0.012698412698413*G14_8_1 - 0.012698412698413*G14_9_0 + 0.019047619047619*G14_9_1 + 0.012698412698413*G14_10_0 + 0.006349206349206*G14_10_1 - 0.025396825396825*G14_11_0 - 0.019047619047619*G14_11_1 + 0.001587301587302*G15_6_0 - 0.006349206349206*G15_6_1 + 0.009523809523810*G15_7_0 + 0.047619047619048*G15_7_1 - 0.006349206349206*G15_8_0 - 0.006349206349206*G15_8_1 - 0.012698412698413*G15_9_0 + 0.019047619047619*G15_9_1 - 0.019047619047619*G15_10_0 - 0.006349206349206*G15_10_1 - 0.006349206349206*G15_11_0 + 0.019047619047619*G15_11_1;
    A[115] = -0.001587301587302*G13_0_0 - 0.007936507936508*G13_0_1 - 0.009523809523810*G13_1_0 + 0.006349206349206*G13_2_0 + 0.007936507936508*G13_2_1 + 0.012698412698413*G13_3_0 + 0.006349206349206*G13_3_1 + 0.019047619047619*G13_4_0 + 0.006349206349206*G13_5_0 - 0.006349206349206*G13_5_1 + 0.007936507936508*G14_6_0 + 0.007936507936508*G14_6_1 + 0.004761904761905*G14_7_0 - 0.007936507936508*G14_8_1 - 0.019047619047619*G14_9_0 - 0.006349206349206*G14_9_1 + 0.019047619047619*G14_10_0 - 0.012698412698413*G14_11_0 + 0.006349206349206*G14_11_1 - 0.001587301587302*G15_6_0 - 0.007936507936508*G15_6_1 - 0.009523809523810*G15_7_0 + 0.006349206349206*G15_8_0 + 0.007936507936508*G15_8_1 + 0.012698412698413*G15_9_0 + 0.006349206349206*G15_9_1 + 0.019047619047619*G15_10_0 + 0.006349206349206*G15_11_0 - 0.006349206349206*G15_11_1;
    A[116] = -0.666666666666666*G3_0_0_0 - 0.666666666666666*G3_0_0_1 - 0.666666666666666*G5_0_0_0 - 0.666666666666666*G5_0_0_1 + 0.006349206349206*G13_0_1 - 0.038095238095238*G13_1_0 - 0.047619047619048*G13_1_1 + 0.007936507936508*G13_2_0 + 0.006349206349206*G13_2_1 - 0.025396825396825*G13_3_0 - 0.019047619047619*G13_3_1 - 0.012698412698413*G13_4_0 + 0.006349206349206*G13_4_1 - 0.031746031746032*G13_5_0 - 0.019047619047619*G13_5_1 + 0.012698412698413*G14_6_0 + 0.012698412698413*G14_6_1 + 0.019047619047619*G14_7_0 - 0.006349206349206*G14_8_1 - 0.006349206349206*G14_9_0 + 0.019047619047619*G14_9_1 + 0.006349206349206*G14_10_0 - 0.006349206349206*G14_10_1 - 0.031746031746032*G14_11_0 - 0.019047619047619*G14_11_1 + 0.006349206349206*G15_6_1 - 0.038095238095238*G15_7_0 - 0.047619047619048*G15_7_1 + 0.007936507936508*G15_8_0 + 0.006349206349206*G15_8_1 - 0.025396825396825*G15_9_0 - 0.019047619047619*G15_9_1 - 0.012698412698413*G15_10_0 + 0.006349206349206*G15_10_1 - 0.031746031746032*G15_11_0 - 0.019047619047619*G15_11_1;
    A[117] = 0.000000000000000;
    A[118] = -0.166666666666667*G7_0;
    A[119] = 0.000000000000000;
    A[120] = 0.003571428571429*G12_6_0 + 0.003571428571429*G12_6_1 + 0.004365079365079*G12_7_0 - 0.003571428571429*G12_8_1 - 0.006349206349206*G12_9_0 + 0.001587301587302*G12_9_1 + 0.006349206349206*G12_10_0 - 0.007936507936508*G12_11_0 - 0.001587301587302*G12_11_1;
    A[121] = -0.004365079365079*G12_6_0 - 0.004365079365079*G12_6_1 - 0.003571428571429*G12_7_0 - 0.003571428571429*G12_8_1 - 0.006349206349206*G12_9_0 - 0.006349206349206*G12_9_1 + 0.006349206349206*G12_10_0 + 0.007936507936508*G12_10_1 + 0.007936507936508*G12_11_0 + 0.006349206349206*G12_11_1;
    A[122] = 0.007142857142857*G12_6_0 + 0.007142857142857*G12_6_1 - 0.007142857142857*G12_7_0 + 0.030952380952381*G12_8_1 + 0.047619047619048*G12_9_0 + 0.009523809523809*G12_9_1 - 0.047619047619048*G12_10_0 - 0.038095238095238*G12_10_1 - 0.009523809523810*G12_11_1;
    A[123] = 0.006349206349206*G12_6_0 + 0.006349206349206*G12_6_1 - 0.012698412698413*G12_7_0 + 0.019047619047619*G12_8_1 + 0.019047619047619*G12_9_0 - 0.012698412698413*G12_9_1 - 0.019047619047619*G12_10_0 - 0.025396825396825*G12_10_1 + 0.006349206349206*G12_11_0 + 0.012698412698413*G12_11_1;
    A[124] = 0.012698412698413*G12_6_0 + 0.012698412698413*G12_6_1 - 0.006349206349206*G12_7_0 + 0.019047619047619*G12_8_1 + 0.019047619047619*G12_9_0 - 0.006349206349206*G12_9_1 - 0.019047619047619*G12_10_0 - 0.031746031746032*G12_10_1 - 0.006349206349206*G12_11_0 + 0.006349206349206*G12_11_1;
    A[125] = 0.007936507936508*G12_6_0 + 0.007936507936508*G12_6_1 - 0.007936507936508*G12_7_0 + 0.004761904761905*G12_8_1 - 0.006349206349206*G12_9_0 - 0.019047619047619*G12_9_1 + 0.006349206349206*G12_10_0 - 0.012698412698413*G12_10_1 + 0.019047619047619*G12_11_1;
    A[126] = 0.166666666666667*G3_0_1_0 + 0.166666666666667*G3_0_1_1 + 0.166666666666667*G5_0_1_0 + 0.166666666666667*G5_0_1_1 + 0.003571428571429*G13_0_0 + 0.003571428571429*G13_0_1 - 0.004365079365079*G13_1_0 - 0.004365079365079*G13_1_1 + 0.007142857142857*G13_2_0 + 0.007142857142857*G13_2_1 + 0.006349206349206*G13_3_0 + 0.006349206349206*G13_3_1 + 0.012698412698413*G13_4_0 + 0.012698412698413*G13_4_1 + 0.007936507936508*G13_5_0 + 0.007936507936508*G13_5_1 + 0.003571428571429*G14_6_0 + 0.003571428571429*G14_6_1 + 0.004365079365079*G14_7_0 - 0.003571428571429*G14_8_1 - 0.006349206349206*G14_9_0 + 0.001587301587302*G14_9_1 + 0.006349206349206*G14_10_0 - 0.007936507936508*G14_11_0 - 0.001587301587302*G14_11_1 + 0.003571428571429*G15_6_0 + 0.003571428571429*G15_6_1 - 0.004365079365079*G15_7_0 - 0.004365079365079*G15_7_1 + 0.007142857142857*G15_8_0 + 0.007142857142857*G15_8_1 + 0.006349206349206*G15_9_0 + 0.006349206349206*G15_9_1 + 0.012698412698413*G15_10_0 + 0.012698412698413*G15_10_1 + 0.007936507936508*G15_11_0 + 0.007936507936508*G15_11_1;
    A[127] = -0.166666666666667*G3_0_1_0 - 0.166666666666667*G5_0_1_0 + 0.004365079365079*G13_0_0 - 0.003571428571429*G13_1_0 - 0.007142857142857*G13_2_0 - 0.012698412698413*G13_3_0 - 0.006349206349206*G13_4_0 - 0.007936507936508*G13_5_0 - 0.004365079365079*G14_6_0 - 0.004365079365079*G14_6_1 - 0.003571428571429*G14_7_0 - 0.003571428571429*G14_8_1 - 0.006349206349206*G14_9_0 - 0.006349206349206*G14_9_1 + 0.006349206349206*G14_10_0 + 0.007936507936508*G14_10_1 + 0.007936507936508*G14_11_0 + 0.006349206349206*G14_11_1 + 0.004365079365079*G15_6_0 - 0.003571428571429*G15_7_0 - 0.007142857142857*G15_8_0 - 0.012698412698413*G15_9_0 - 0.006349206349206*G15_10_0 - 0.007936507936508*G15_11_0;
    A[128] = 0.500000000000000*G3_0_1_1 + 0.500000000000000*G5_0_1_1 - 0.003571428571429*G13_0_1 - 0.003571428571429*G13_1_1 + 0.030952380952381*G13_2_1 + 0.019047619047619*G13_3_1 + 0.019047619047619*G13_4_1 + 0.004761904761905*G13_5_1 + 0.007142857142857*G14_6_0 + 0.007142857142857*G14_6_1 - 0.007142857142857*G14_7_0 + 0.030952380952381*G14_8_1 + 0.047619047619048*G14_9_0 + 0.009523809523809*G14_9_1 - 0.047619047619048*G14_10_0 - 0.038095238095238*G14_10_1 - 0.009523809523810*G14_11_1 - 0.003571428571429*G15_6_1 - 0.003571428571429*G15_7_1 + 0.030952380952381*G15_8_1 + 0.019047619047619*G15_9_1 + 0.019047619047619*G15_10_1 + 0.004761904761905*G15_11_1;
    A[129] = 0.666666666666666*G3_0_1_0 + 0.666666666666666*G5_0_1_0 - 0.006349206349206*G13_0_0 + 0.001587301587302*G13_0_1 - 0.006349206349206*G13_1_0 - 0.006349206349206*G13_1_1 + 0.047619047619048*G13_2_0 + 0.009523809523809*G13_2_1 + 0.019047619047619*G13_3_0 - 0.012698412698413*G13_3_1 + 0.019047619047619*G13_4_0 - 0.006349206349206*G13_4_1 - 0.006349206349206*G13_5_0 - 0.019047619047619*G13_5_1 + 0.006349206349206*G14_6_0 + 0.006349206349206*G14_6_1 - 0.012698412698413*G14_7_0 + 0.019047619047619*G14_8_1 + 0.019047619047619*G14_9_0 - 0.012698412698413*G14_9_1 - 0.019047619047619*G14_10_0 - 0.025396825396825*G14_10_1 + 0.006349206349206*G14_11_0 + 0.012698412698413*G14_11_1 - 0.006349206349206*G15_6_0 + 0.001587301587302*G15_6_1 - 0.006349206349206*G15_7_0 - 0.006349206349206*G15_7_1 + 0.047619047619048*G15_8_0 + 0.009523809523809*G15_8_1 + 0.019047619047619*G15_9_0 - 0.012698412698413*G15_9_1 + 0.019047619047619*G15_10_0 - 0.006349206349206*G15_10_1 - 0.006349206349206*G15_11_0 - 0.019047619047619*G15_11_1;
    A[130] = -0.666666666666666*G3_0_1_0 - 0.666666666666666*G3_0_1_1 - 0.666666666666666*G5_0_1_0 - 0.666666666666666*G5_0_1_1 + 0.006349206349206*G13_0_0 + 0.006349206349206*G13_1_0 + 0.007936507936508*G13_1_1 - 0.047619047619048*G13_2_0 - 0.038095238095238*G13_2_1 - 0.019047619047619*G13_3_0 - 0.025396825396825*G13_3_1 - 0.019047619047619*G13_4_0 - 0.031746031746032*G13_4_1 + 0.006349206349206*G13_5_0 - 0.012698412698413*G13_5_1 + 0.012698412698413*G14_6_0 + 0.012698412698413*G14_6_1 - 0.006349206349206*G14_7_0 + 0.019047619047619*G14_8_1 + 0.019047619047619*G14_9_0 - 0.006349206349206*G14_9_1 - 0.019047619047619*G14_10_0 - 0.031746031746032*G14_10_1 - 0.006349206349206*G14_11_0 + 0.006349206349206*G14_11_1 + 0.006349206349206*G15_6_0 + 0.006349206349206*G15_7_0 + 0.007936507936508*G15_7_1 - 0.047619047619048*G15_8_0 - 0.038095238095238*G15_8_1 - 0.019047619047619*G15_9_0 - 0.025396825396825*G15_9_1 - 0.019047619047619*G15_10_0 - 0.031746031746032*G15_10_1 + 0.006349206349206*G15_11_0 - 0.012698412698413*G15_11_1;
    A[131] = -0.007936507936508*G13_0_0 - 0.001587301587302*G13_0_1 + 0.007936507936508*G13_1_0 + 0.006349206349206*G13_1_1 - 0.009523809523810*G13_2_1 + 0.006349206349206*G13_3_0 + 0.012698412698413*G13_3_1 - 0.006349206349206*G13_4_0 + 0.006349206349206*G13_4_1 + 0.019047619047619*G13_5_1 + 0.007936507936508*G14_6_0 + 0.007936507936508*G14_6_1 - 0.007936507936508*G14_7_0 + 0.004761904761905*G14_8_1 - 0.006349206349206*G14_9_0 - 0.019047619047619*G14_9_1 + 0.006349206349206*G14_10_0 - 0.012698412698413*G14_10_1 + 0.019047619047619*G14_11_1 - 0.007936507936508*G15_6_0 - 0.001587301587302*G15_6_1 + 0.007936507936508*G15_7_0 + 0.006349206349206*G15_7_1 - 0.009523809523810*G15_8_1 + 0.006349206349206*G15_9_0 + 0.012698412698413*G15_9_1 - 0.006349206349206*G15_10_0 + 0.006349206349206*G15_10_1 + 0.019047619047619*G15_11_1;
    A[132] = 0.000000000000000;
    A[133] = 0.000000000000000;
    A[134] = -0.166666666666667*G7_1;
    A[135] = -0.004761904761905*G12_6_0 - 0.004761904761905*G12_6_1 - 0.007936507936508*G12_7_0 - 0.007936507936508*G12_8_1 - 0.019047619047619*G12_9_0 - 0.019047619047619*G12_9_1 + 0.019047619047619*G12_10_0 + 0.012698412698413*G12_10_1 + 0.012698412698413*G12_11_0 + 0.019047619047619*G12_11_1;
    A[136] = 0.006349206349206*G12_6_0 + 0.006349206349206*G12_6_1 + 0.019047619047619*G12_7_0 - 0.012698412698413*G12_8_1 - 0.012698412698413*G12_9_0 + 0.019047619047619*G12_9_1 + 0.012698412698413*G12_10_0 + 0.006349206349206*G12_10_1 - 0.025396825396825*G12_11_0 - 0.019047619047619*G12_11_1;
    A[137] = 0.006349206349206*G12_6_0 + 0.006349206349206*G12_6_1 - 0.012698412698413*G12_7_0 + 0.019047619047619*G12_8_1 + 0.019047619047619*G12_9_0 - 0.012698412698413*G12_9_1 - 0.019047619047619*G12_10_0 - 0.025396825396825*G12_10_1 + 0.006349206349206*G12_11_0 + 0.012698412698413*G12_11_1;
    A[138] = 0.038095238095238*G12_6_0 + 0.038095238095238*G12_6_1 + 0.063492063492063*G12_7_0 + 0.063492063492063*G12_8_1 + 0.152380952380952*G12_9_0 + 0.152380952380952*G12_9_1 - 0.152380952380952*G12_10_0 - 0.101587301587301*G12_10_1 - 0.101587301587301*G12_11_0 - 0.152380952380952*G12_11_1;
    A[139] = -0.006349206349206*G12_6_0 - 0.006349206349206*G12_6_1 + 0.006349206349206*G12_7_0 + 0.031746031746032*G12_8_1 + 0.076190476190476*G12_9_0 + 0.050793650793651*G12_9_1 - 0.076190476190476*G12_10_0 - 0.025396825396825*G12_10_1 - 0.050793650793651*G12_11_1;
    A[140] = -0.006349206349206*G12_6_0 - 0.006349206349206*G12_6_1 + 0.031746031746032*G12_7_0 + 0.006349206349206*G12_8_1 + 0.050793650793651*G12_9_0 + 0.076190476190476*G12_9_1 - 0.050793650793651*G12_10_0 - 0.025396825396825*G12_11_0 - 0.076190476190476*G12_11_1;
    A[141] = -0.004761904761905*G13_0_0 - 0.004761904761905*G13_0_1 + 0.006349206349206*G13_1_0 + 0.006349206349206*G13_1_1 + 0.006349206349206*G13_2_0 + 0.006349206349206*G13_2_1 + 0.038095238095238*G13_3_0 + 0.038095238095238*G13_3_1 - 0.006349206349206*G13_4_0 - 0.006349206349206*G13_4_1 - 0.006349206349206*G13_5_0 - 0.006349206349206*G13_5_1 - 0.004761904761905*G14_6_0 - 0.004761904761905*G14_6_1 - 0.007936507936508*G14_7_0 - 0.007936507936508*G14_8_1 - 0.019047619047619*G14_9_0 - 0.019047619047619*G14_9_1 + 0.019047619047619*G14_10_0 + 0.012698412698413*G14_10_1 + 0.012698412698413*G14_11_0 + 0.019047619047619*G14_11_1 - 0.004761904761905*G15_6_0 - 0.004761904761905*G15_6_1 + 0.006349206349206*G15_7_0 + 0.006349206349206*G15_7_1 + 0.006349206349206*G15_8_0 + 0.006349206349206*G15_8_1 + 0.038095238095238*G15_9_0 + 0.038095238095238*G15_9_1 - 0.006349206349206*G15_10_0 - 0.006349206349206*G15_10_1 - 0.006349206349206*G15_11_0 - 0.006349206349206*G15_11_1;
    A[142] = 0.666666666666666*G3_0_1_0 + 0.666666666666666*G5_0_1_0 - 0.007936507936508*G13_0_0 + 0.019047619047619*G13_1_0 - 0.012698412698413*G13_2_0 + 0.063492063492063*G13_3_0 + 0.006349206349206*G13_4_0 + 0.031746031746032*G13_5_0 + 0.006349206349206*G14_6_0 + 0.006349206349206*G14_6_1 + 0.019047619047619*G14_7_0 - 0.012698412698413*G14_8_1 - 0.012698412698413*G14_9_0 + 0.019047619047619*G14_9_1 + 0.012698412698413*G14_10_0 + 0.006349206349206*G14_10_1 - 0.025396825396825*G14_11_0 - 0.019047619047619*G14_11_1 - 0.007936507936508*G15_6_0 + 0.019047619047619*G15_7_0 - 0.012698412698413*G15_8_0 + 0.063492063492063*G15_9_0 + 0.006349206349206*G15_10_0 + 0.031746031746032*G15_11_0;
    A[143] = 0.666666666666666*G3_0_0_1 + 0.666666666666666*G5_0_0_1 - 0.007936507936508*G13_0_1 - 0.012698412698413*G13_1_1 + 0.019047619047619*G13_2_1 + 0.063492063492063*G13_3_1 + 0.031746031746032*G13_4_1 + 0.006349206349206*G13_5_1 + 0.006349206349206*G14_6_0 + 0.006349206349206*G14_6_1 - 0.012698412698413*G14_7_0 + 0.019047619047619*G14_8_1 + 0.019047619047619*G14_9_0 - 0.012698412698413*G14_9_1 - 0.019047619047619*G14_10_0 - 0.025396825396825*G14_10_1 + 0.006349206349206*G14_11_0 + 0.012698412698413*G14_11_1 - 0.007936507936508*G15_6_1 - 0.012698412698413*G15_7_1 + 0.019047619047619*G15_8_1 + 0.063492063492063*G15_9_1 + 0.031746031746032*G15_10_1 + 0.006349206349206*G15_11_1;
    A[144] = 1.333333333333332*G3_0_0_0 + 0.666666666666666*G3_0_0_1 + 0.666666666666666*G3_0_1_0 + 1.333333333333332*G3_0_1_1 + 1.333333333333332*G5_0_0_0 + 0.666666666666666*G5_0_0_1 + 0.666666666666666*G5_0_1_0 + 1.333333333333332*G5_0_1_1 - 0.019047619047619*G13_0_0 - 0.019047619047619*G13_0_1 - 0.012698412698413*G13_1_0 + 0.019047619047619*G13_1_1 + 0.019047619047619*G13_2_0 - 0.012698412698413*G13_2_1 + 0.152380952380952*G13_3_0 + 0.152380952380952*G13_3_1 + 0.076190476190476*G13_4_0 + 0.050793650793651*G13_4_1 + 0.050793650793651*G13_5_0 + 0.076190476190476*G13_5_1 + 0.038095238095238*G14_6_0 + 0.038095238095238*G14_6_1 + 0.063492063492063*G14_7_0 + 0.063492063492063*G14_8_1 + 0.152380952380952*G14_9_0 + 0.152380952380952*G14_9_1 - 0.152380952380952*G14_10_0 - 0.101587301587301*G14_10_1 - 0.101587301587301*G14_11_0 - 0.152380952380952*G14_11_1 - 0.019047619047619*G15_6_0 - 0.019047619047619*G15_6_1 - 0.012698412698413*G15_7_0 + 0.019047619047619*G15_7_1 + 0.019047619047619*G15_8_0 - 0.012698412698413*G15_8_1 + 0.152380952380952*G15_9_0 + 0.152380952380952*G15_9_1 + 0.076190476190476*G15_10_0 + 0.050793650793651*G15_10_1 + 0.050793650793651*G15_11_0 + 0.076190476190476*G15_11_1;
    A[145] = -1.333333333333332*G3_0_0_0 - 0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_0 - 1.333333333333332*G5_0_0_0 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_0 + 0.019047619047619*G13_0_0 + 0.012698412698413*G13_0_1 + 0.012698412698413*G13_1_0 + 0.006349206349206*G13_1_1 - 0.019047619047619*G13_2_0 - 0.025396825396825*G13_2_1 - 0.152380952380952*G13_3_0 - 0.101587301587301*G13_3_1 - 0.076190476190476*G13_4_0 - 0.025396825396825*G13_4_1 - 0.050793650793651*G13_5_0 - 0.006349206349206*G14_6_0 - 0.006349206349206*G14_6_1 + 0.006349206349206*G14_7_0 + 0.031746031746032*G14_8_1 + 0.076190476190476*G14_9_0 + 0.050793650793651*G14_9_1 - 0.076190476190476*G14_10_0 - 0.025396825396825*G14_10_1 - 0.050793650793651*G14_11_1 + 0.019047619047619*G15_6_0 + 0.012698412698413*G15_6_1 + 0.012698412698413*G15_7_0 + 0.006349206349206*G15_7_1 - 0.019047619047619*G15_8_0 - 0.025396825396825*G15_8_1 - 0.152380952380952*G15_9_0 - 0.101587301587301*G15_9_1 - 0.076190476190476*G15_10_0 - 0.025396825396825*G15_10_1 - 0.050793650793651*G15_11_0;
    A[146] = -0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_0 - 1.333333333333332*G3_0_1_1 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_0 - 1.333333333333332*G5_0_1_1 + 0.012698412698413*G13_0_0 + 0.019047619047619*G13_0_1 - 0.025396825396825*G13_1_0 - 0.019047619047619*G13_1_1 + 0.006349206349206*G13_2_0 + 0.012698412698413*G13_2_1 - 0.101587301587301*G13_3_0 - 0.152380952380952*G13_3_1 - 0.050793650793651*G13_4_1 - 0.025396825396825*G13_5_0 - 0.076190476190476*G13_5_1 - 0.006349206349206*G14_6_0 - 0.006349206349206*G14_6_1 + 0.031746031746032*G14_7_0 + 0.006349206349206*G14_8_1 + 0.050793650793651*G14_9_0 + 0.076190476190476*G14_9_1 - 0.050793650793651*G14_10_0 - 0.025396825396825*G14_11_0 - 0.076190476190476*G14_11_1 + 0.012698412698413*G15_6_0 + 0.019047619047619*G15_6_1 - 0.025396825396825*G15_7_0 - 0.019047619047619*G15_7_1 + 0.006349206349206*G15_8_0 + 0.012698412698413*G15_8_1 - 0.101587301587301*G15_9_0 - 0.152380952380952*G15_9_1 - 0.050793650793651*G15_10_1 - 0.025396825396825*G15_11_0 - 0.076190476190476*G15_11_1;
    A[147] = -0.166666666666667*G7_0 - 0.166666666666667*G7_1;
    A[148] = -0.166666666666667*G7_0 - 0.333333333333333*G7_1;
    A[149] = -0.333333333333333*G7_0 - 0.166666666666667*G7_1;
    A[150] = -0.019047619047619*G12_6_0 - 0.019047619047619*G12_6_1 - 0.006349206349206*G12_7_0 - 0.012698412698413*G12_8_1 - 0.012698412698413*G12_9_0 - 0.006349206349206*G12_9_1 + 0.012698412698413*G12_10_0 + 0.031746031746032*G12_10_1 + 0.025396825396825*G12_11_0 + 0.006349206349206*G12_11_1;
    A[151] = 0.007936507936508*G12_6_0 + 0.007936507936508*G12_6_1 + 0.004761904761905*G12_7_0 - 0.007936507936508*G12_8_1 - 0.019047619047619*G12_9_0 - 0.006349206349206*G12_9_1 + 0.019047619047619*G12_10_0 - 0.012698412698413*G12_11_0 + 0.006349206349206*G12_11_1;
    A[152] = 0.012698412698413*G12_6_0 + 0.012698412698413*G12_6_1 - 0.006349206349206*G12_7_0 + 0.019047619047619*G12_8_1 + 0.019047619047619*G12_9_0 - 0.006349206349206*G12_9_1 - 0.019047619047619*G12_10_0 - 0.031746031746032*G12_10_1 - 0.006349206349206*G12_11_0 + 0.006349206349206*G12_11_1;
    A[153] = -0.006349206349206*G12_6_0 - 0.006349206349206*G12_6_1 + 0.006349206349206*G12_7_0 + 0.031746031746032*G12_8_1 + 0.076190476190476*G12_9_0 + 0.050793650793651*G12_9_1 - 0.076190476190476*G12_10_0 - 0.025396825396825*G12_10_1 - 0.050793650793651*G12_11_1;
    A[154] = -0.063492063492063*G12_6_0 - 0.063492063492063*G12_6_1 - 0.038095238095238*G12_7_0 + 0.063492063492063*G12_8_1 + 0.152380952380952*G12_9_0 + 0.050793650793651*G12_9_1 - 0.152380952380952*G12_10_0 + 0.101587301587302*G12_11_0 - 0.050793650793651*G12_11_1;
    A[155] = -0.031746031746032*G12_6_0 - 0.031746031746032*G12_6_1 + 0.006349206349206*G12_7_0 + 0.006349206349206*G12_8_1 + 0.050793650793651*G12_9_0 + 0.050793650793651*G12_9_1 - 0.050793650793651*G12_10_0 + 0.025396825396825*G12_10_1 + 0.025396825396825*G12_11_0 - 0.050793650793651*G12_11_1;
    A[156] = -0.666666666666667*G3_0_1_0 - 0.666666666666667*G3_0_1_1 - 0.666666666666667*G5_0_1_0 - 0.666666666666667*G5_0_1_1 - 0.019047619047619*G13_0_0 - 0.019047619047619*G13_0_1 + 0.007936507936508*G13_1_0 + 0.007936507936508*G13_1_1 + 0.012698412698413*G13_2_0 + 0.012698412698413*G13_2_1 - 0.006349206349206*G13_3_0 - 0.006349206349206*G13_3_1 - 0.063492063492063*G13_4_0 - 0.063492063492063*G13_4_1 - 0.031746031746032*G13_5_0 - 0.031746031746032*G13_5_1 - 0.019047619047619*G14_6_0 - 0.019047619047619*G14_6_1 - 0.006349206349206*G14_7_0 - 0.012698412698413*G14_8_1 - 0.012698412698413*G14_9_0 - 0.006349206349206*G14_9_1 + 0.012698412698413*G14_10_0 + 0.031746031746032*G14_10_1 + 0.025396825396825*G14_11_0 + 0.006349206349206*G14_11_1 - 0.019047619047619*G15_6_0 - 0.019047619047619*G15_6_1 + 0.007936507936508*G15_7_0 + 0.007936507936508*G15_7_1 + 0.012698412698413*G15_8_0 + 0.012698412698413*G15_8_1 - 0.006349206349206*G15_9_0 - 0.006349206349206*G15_9_1 - 0.063492063492063*G15_10_0 - 0.063492063492063*G15_10_1 - 0.031746031746032*G15_11_0 - 0.031746031746032*G15_11_1;
    A[157] = -0.006349206349206*G13_0_0 + 0.004761904761905*G13_1_0 - 0.006349206349206*G13_2_0 + 0.006349206349206*G13_3_0 - 0.038095238095238*G13_4_0 + 0.006349206349206*G13_5_0 + 0.007936507936508*G14_6_0 + 0.007936507936508*G14_6_1 + 0.004761904761905*G14_7_0 - 0.007936507936508*G14_8_1 - 0.019047619047619*G14_9_0 - 0.006349206349206*G14_9_1 + 0.019047619047619*G14_10_0 - 0.012698412698413*G14_11_0 + 0.006349206349206*G14_11_1 - 0.006349206349206*G15_6_0 + 0.004761904761905*G15_7_0 - 0.006349206349206*G15_8_0 + 0.006349206349206*G15_9_0 - 0.038095238095238*G15_10_0 + 0.006349206349206*G15_11_0;
    A[158] = -0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_1 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_1 - 0.012698412698413*G13_0_1 - 0.007936507936508*G13_1_1 + 0.019047619047619*G13_2_1 + 0.031746031746032*G13_3_1 + 0.063492063492063*G13_4_1 + 0.006349206349206*G13_5_1 + 0.012698412698413*G14_6_0 + 0.012698412698413*G14_6_1 - 0.006349206349206*G14_7_0 + 0.019047619047619*G14_8_1 + 0.019047619047619*G14_9_0 - 0.006349206349206*G14_9_1 - 0.019047619047619*G14_10_0 - 0.031746031746032*G14_10_1 - 0.006349206349206*G14_11_0 + 0.006349206349206*G14_11_1 - 0.012698412698413*G15_6_1 - 0.007936507936508*G15_7_1 + 0.019047619047619*G15_8_1 + 0.031746031746032*G15_9_1 + 0.063492063492063*G15_10_1 + 0.006349206349206*G15_11_1;
    A[159] = -1.333333333333332*G3_0_0_0 - 0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_0 - 1.333333333333332*G5_0_0_0 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_0 - 0.012698412698413*G13_0_0 - 0.006349206349206*G13_0_1 - 0.019047619047619*G13_1_0 - 0.006349206349206*G13_1_1 + 0.019047619047619*G13_2_0 - 0.006349206349206*G13_2_1 + 0.076190476190476*G13_3_0 + 0.050793650793651*G13_3_1 + 0.152380952380952*G13_4_0 + 0.050793650793651*G13_4_1 + 0.050793650793651*G13_5_0 + 0.050793650793651*G13_5_1 - 0.006349206349206*G14_6_0 - 0.006349206349206*G14_6_1 + 0.006349206349206*G14_7_0 + 0.031746031746032*G14_8_1 + 0.076190476190476*G14_9_0 + 0.050793650793651*G14_9_1 - 0.076190476190476*G14_10_0 - 0.025396825396825*G14_10_1 - 0.050793650793651*G14_11_1 - 0.012698412698413*G15_6_0 - 0.006349206349206*G15_6_1 - 0.019047619047619*G15_7_0 - 0.006349206349206*G15_7_1 + 0.019047619047619*G15_8_0 - 0.006349206349206*G15_8_1 + 0.076190476190476*G15_9_0 + 0.050793650793651*G15_9_1 + 0.152380952380952*G15_10_0 + 0.050793650793651*G15_10_1 + 0.050793650793651*G15_11_0 + 0.050793650793651*G15_11_1;
    A[160] = 1.333333333333332*G3_0_0_0 + 0.666666666666666*G3_0_0_1 + 0.666666666666666*G3_0_1_0 + 1.333333333333333*G3_0_1_1 + 1.333333333333332*G5_0_0_0 + 0.666666666666666*G5_0_0_1 + 0.666666666666666*G5_0_1_0 + 1.333333333333333*G5_0_1_1 + 0.012698412698413*G13_0_0 + 0.031746031746032*G13_0_1 + 0.019047619047619*G13_1_0 - 0.019047619047619*G13_2_0 - 0.031746031746032*G13_2_1 - 0.076190476190476*G13_3_0 - 0.025396825396825*G13_3_1 - 0.152380952380952*G13_4_0 - 0.050793650793651*G13_5_0 + 0.025396825396825*G13_5_1 - 0.063492063492063*G14_6_0 - 0.063492063492063*G14_6_1 - 0.038095238095238*G14_7_0 + 0.063492063492063*G14_8_1 + 0.152380952380952*G14_9_0 + 0.050793650793651*G14_9_1 - 0.152380952380952*G14_10_0 + 0.101587301587302*G14_11_0 - 0.050793650793651*G14_11_1 + 0.012698412698413*G15_6_0 + 0.031746031746032*G15_6_1 + 0.019047619047619*G15_7_0 - 0.019047619047619*G15_8_0 - 0.031746031746032*G15_8_1 - 0.076190476190476*G15_9_0 - 0.025396825396825*G15_9_1 - 0.152380952380952*G15_10_0 - 0.050793650793651*G15_11_0 + 0.025396825396825*G15_11_1;
    A[161] = 0.666666666666666*G3_0_0_1 + 0.666666666666667*G3_0_1_0 + 0.666666666666666*G5_0_0_1 + 0.666666666666667*G5_0_1_0 + 0.025396825396825*G13_0_0 + 0.006349206349206*G13_0_1 - 0.012698412698413*G13_1_0 + 0.006349206349206*G13_1_1 - 0.006349206349206*G13_2_0 + 0.006349206349206*G13_2_1 - 0.050793650793651*G13_3_1 + 0.101587301587302*G13_4_0 - 0.050793650793651*G13_4_1 + 0.025396825396825*G13_5_0 - 0.050793650793651*G13_5_1 - 0.031746031746032*G14_6_0 - 0.031746031746032*G14_6_1 + 0.006349206349206*G14_7_0 + 0.006349206349206*G14_8_1 + 0.050793650793651*G14_9_0 + 0.050793650793651*G14_9_1 - 0.050793650793651*G14_10_0 + 0.025396825396825*G14_10_1 + 0.025396825396825*G14_11_0 - 0.050793650793651*G14_11_1 + 0.025396825396825*G15_6_0 + 0.006349206349206*G15_6_1 - 0.012698412698413*G15_7_0 + 0.006349206349206*G15_7_1 - 0.006349206349206*G15_8_0 + 0.006349206349206*G15_8_1 - 0.050793650793651*G15_9_1 + 0.101587301587302*G15_10_0 - 0.050793650793651*G15_10_1 + 0.025396825396825*G15_11_0 - 0.050793650793651*G15_11_1;
    A[162] = 0.166666666666667*G7_0 - 0.166666666666667*G7_1;
    A[163] = 0.166666666666667*G7_0;
    A[164] = 0.333333333333333*G7_0 + 0.166666666666666*G7_1;
    A[165] = -0.019047619047619*G12_6_0 - 0.019047619047619*G12_6_1 - 0.012698412698413*G12_7_0 - 0.006349206349206*G12_8_1 - 0.006349206349206*G12_9_0 - 0.012698412698413*G12_9_1 + 0.006349206349206*G12_10_0 + 0.025396825396825*G12_10_1 + 0.031746031746032*G12_11_0 + 0.012698412698413*G12_11_1;
    A[166] = 0.012698412698413*G12_6_0 + 0.012698412698413*G12_6_1 + 0.019047619047619*G12_7_0 - 0.006349206349206*G12_8_1 - 0.006349206349206*G12_9_0 + 0.019047619047619*G12_9_1 + 0.006349206349206*G12_10_0 - 0.006349206349206*G12_10_1 - 0.031746031746032*G12_11_0 - 0.019047619047619*G12_11_1;
    A[167] = 0.007936507936508*G12_6_0 + 0.007936507936508*G12_6_1 - 0.007936507936508*G12_7_0 + 0.004761904761905*G12_8_1 - 0.006349206349206*G12_9_0 - 0.019047619047619*G12_9_1 + 0.006349206349206*G12_10_0 - 0.012698412698413*G12_10_1 + 0.019047619047619*G12_11_1;
    A[168] = -0.006349206349206*G12_6_0 - 0.006349206349206*G12_6_1 + 0.031746031746032*G12_7_0 + 0.006349206349206*G12_8_1 + 0.050793650793651*G12_9_0 + 0.076190476190476*G12_9_1 - 0.050793650793651*G12_10_0 - 0.025396825396825*G12_11_0 - 0.076190476190476*G12_11_1;
    A[169] = -0.031746031746032*G12_6_0 - 0.031746031746032*G12_6_1 + 0.006349206349206*G12_7_0 + 0.006349206349206*G12_8_1 + 0.050793650793651*G12_9_0 + 0.050793650793651*G12_9_1 - 0.050793650793651*G12_10_0 + 0.025396825396825*G12_10_1 + 0.025396825396825*G12_11_0 - 0.050793650793651*G12_11_1;
    A[170] = -0.063492063492063*G12_6_0 - 0.063492063492063*G12_6_1 + 0.063492063492064*G12_7_0 - 0.038095238095238*G12_8_1 + 0.050793650793651*G12_9_0 + 0.152380952380952*G12_9_1 - 0.050793650793651*G12_10_0 + 0.101587301587302*G12_10_1 - 0.152380952380952*G12_11_1;
    A[171] = -0.666666666666667*G3_0_0_0 - 0.666666666666667*G3_0_0_1 - 0.666666666666667*G5_0_0_0 - 0.666666666666667*G5_0_0_1 - 0.019047619047619*G13_0_0 - 0.019047619047619*G13_0_1 + 0.012698412698413*G13_1_0 + 0.012698412698413*G13_1_1 + 0.007936507936508*G13_2_0 + 0.007936507936508*G13_2_1 - 0.006349206349206*G13_3_0 - 0.006349206349206*G13_3_1 - 0.031746031746032*G13_4_0 - 0.031746031746032*G13_4_1 - 0.063492063492063*G13_5_0 - 0.063492063492063*G13_5_1 - 0.019047619047619*G14_6_0 - 0.019047619047619*G14_6_1 - 0.012698412698413*G14_7_0 - 0.006349206349206*G14_8_1 - 0.006349206349206*G14_9_0 - 0.012698412698413*G14_9_1 + 0.006349206349206*G14_10_0 + 0.025396825396825*G14_10_1 + 0.031746031746032*G14_11_0 + 0.012698412698413*G14_11_1 - 0.019047619047619*G15_6_0 - 0.019047619047619*G15_6_1 + 0.012698412698413*G15_7_0 + 0.012698412698413*G15_7_1 + 0.007936507936508*G15_8_0 + 0.007936507936508*G15_8_1 - 0.006349206349206*G15_9_0 - 0.006349206349206*G15_9_1 - 0.031746031746032*G15_10_0 - 0.031746031746032*G15_10_1 - 0.063492063492063*G15_11_0 - 0.063492063492063*G15_11_1;
    A[172] = -0.666666666666666*G3_0_0_0 - 0.666666666666666*G3_0_1_0 - 0.666666666666666*G5_0_0_0 - 0.666666666666666*G5_0_1_0 - 0.012698412698413*G13_0_0 + 0.019047619047619*G13_1_0 - 0.007936507936508*G13_2_0 + 0.031746031746032*G13_3_0 + 0.006349206349206*G13_4_0 + 0.063492063492064*G13_5_0 + 0.012698412698413*G14_6_0 + 0.012698412698413*G14_6_1 + 0.019047619047619*G14_7_0 - 0.006349206349206*G14_8_1 - 0.006349206349206*G14_9_0 + 0.019047619047619*G14_9_1 + 0.006349206349206*G14_10_0 - 0.006349206349206*G14_10_1 - 0.031746031746032*G14_11_0 - 0.019047619047619*G14_11_1 - 0.012698412698413*G15_6_0 + 0.019047619047619*G15_7_0 - 0.007936507936508*G15_8_0 + 0.031746031746032*G15_9_0 + 0.006349206349206*G15_10_0 + 0.063492063492064*G15_11_0;
    A[173] = -0.006349206349206*G13_0_1 - 0.006349206349206*G13_1_1 + 0.004761904761905*G13_2_1 + 0.006349206349206*G13_3_1 + 0.006349206349206*G13_4_1 - 0.038095238095238*G13_5_1 + 0.007936507936508*G14_6_0 + 0.007936507936508*G14_6_1 - 0.007936507936508*G14_7_0 + 0.004761904761905*G14_8_1 - 0.006349206349206*G14_9_0 - 0.019047619047619*G14_9_1 + 0.006349206349206*G14_10_0 - 0.012698412698413*G14_10_1 + 0.019047619047619*G14_11_1 - 0.006349206349206*G15_6_1 - 0.006349206349206*G15_7_1 + 0.004761904761905*G15_8_1 + 0.006349206349206*G15_9_1 + 0.006349206349206*G15_10_1 - 0.038095238095238*G15_11_1;
    A[174] = -0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_0 - 1.333333333333333*G3_0_1_1 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_0 - 1.333333333333333*G5_0_1_1 - 0.006349206349206*G13_0_0 - 0.012698412698413*G13_0_1 - 0.006349206349206*G13_1_0 + 0.019047619047619*G13_1_1 - 0.006349206349206*G13_2_0 - 0.019047619047619*G13_2_1 + 0.050793650793651*G13_3_0 + 0.076190476190476*G13_3_1 + 0.050793650793651*G13_4_0 + 0.050793650793651*G13_4_1 + 0.050793650793651*G13_5_0 + 0.152380952380952*G13_5_1 - 0.006349206349206*G14_6_0 - 0.006349206349206*G14_6_1 + 0.031746031746032*G14_7_0 + 0.006349206349206*G14_8_1 + 0.050793650793651*G14_9_0 + 0.076190476190476*G14_9_1 - 0.050793650793651*G14_10_0 - 0.025396825396825*G14_11_0 - 0.076190476190476*G14_11_1 - 0.006349206349206*G15_6_0 - 0.012698412698413*G15_6_1 - 0.006349206349206*G15_7_0 + 0.019047619047619*G15_7_1 - 0.006349206349206*G15_8_0 - 0.019047619047619*G15_8_1 + 0.050793650793651*G15_9_0 + 0.076190476190476*G15_9_1 + 0.050793650793651*G15_10_0 + 0.050793650793651*G15_10_1 + 0.050793650793651*G15_11_0 + 0.152380952380952*G15_11_1;
    A[175] = 0.666666666666667*G3_0_0_1 + 0.666666666666666*G3_0_1_0 + 0.666666666666667*G5_0_0_1 + 0.666666666666666*G5_0_1_0 + 0.006349206349206*G13_0_0 + 0.025396825396825*G13_0_1 + 0.006349206349206*G13_1_0 - 0.006349206349206*G13_1_1 + 0.006349206349206*G13_2_0 - 0.012698412698413*G13_2_1 - 0.050793650793651*G13_3_0 - 0.050793650793651*G13_4_0 + 0.025396825396825*G13_4_1 - 0.050793650793651*G13_5_0 + 0.101587301587302*G13_5_1 - 0.031746031746032*G14_6_0 - 0.031746031746032*G14_6_1 + 0.006349206349206*G14_7_0 + 0.006349206349206*G14_8_1 + 0.050793650793651*G14_9_0 + 0.050793650793651*G14_9_1 - 0.050793650793651*G14_10_0 + 0.025396825396825*G14_10_1 + 0.025396825396825*G14_11_0 - 0.050793650793651*G14_11_1 + 0.006349206349206*G15_6_0 + 0.025396825396825*G15_6_1 + 0.006349206349206*G15_7_0 - 0.006349206349206*G15_7_1 + 0.006349206349206*G15_8_0 - 0.012698412698413*G15_8_1 - 0.050793650793651*G15_9_0 - 0.050793650793651*G15_10_0 + 0.025396825396825*G15_10_1 - 0.050793650793651*G15_11_0 + 0.101587301587302*G15_11_1;
    A[176] = 1.333333333333333*G3_0_0_0 + 0.666666666666666*G3_0_0_1 + 0.666666666666666*G3_0_1_0 + 1.333333333333333*G3_0_1_1 + 1.333333333333333*G5_0_0_0 + 0.666666666666666*G5_0_0_1 + 0.666666666666666*G5_0_1_0 + 1.333333333333333*G5_0_1_1 + 0.031746031746032*G13_0_0 + 0.012698412698413*G13_0_1 - 0.031746031746032*G13_1_0 - 0.019047619047619*G13_1_1 + 0.019047619047619*G13_2_1 - 0.025396825396825*G13_3_0 - 0.076190476190476*G13_3_1 + 0.025396825396825*G13_4_0 - 0.050793650793651*G13_4_1 - 0.152380952380952*G13_5_1 - 0.063492063492063*G14_6_0 - 0.063492063492063*G14_6_1 + 0.063492063492064*G14_7_0 - 0.038095238095238*G14_8_1 + 0.050793650793651*G14_9_0 + 0.152380952380952*G14_9_1 - 0.050793650793651*G14_10_0 + 0.101587301587302*G14_10_1 - 0.152380952380952*G14_11_1 + 0.031746031746032*G15_6_0 + 0.012698412698413*G15_6_1 - 0.031746031746032*G15_7_0 - 0.019047619047619*G15_7_1 + 0.019047619047619*G15_8_1 - 0.025396825396825*G15_9_0 - 0.076190476190476*G15_9_1 + 0.025396825396825*G15_10_0 - 0.050793650793651*G15_10_1 - 0.152380952380952*G15_11_1;
    A[177] = -0.166666666666667*G7_0 + 0.166666666666667*G7_1;
    A[178] = 0.166666666666667*G7_0 + 0.333333333333333*G7_1;
    A[179] = 0.166666666666667*G7_1;
    A[180] = -0.166666666666667*G0_0 - 0.166666666666667*G0_1;
    A[181] = 0.000000000000000;
    A[182] = 0.000000000000000;
    A[183] = 0.166666666666667*G0_0 + 0.166666666666667*G0_1;
    A[184] = -0.166666666666667*G0_0 + 0.166666666666667*G0_1;
    A[185] = 0.166666666666667*G0_0 - 0.166666666666667*G0_1;
    A[186] = -0.166666666666667*G1_0 - 0.166666666666667*G1_1;
    A[187] = 0.000000000000000;
    A[188] = 0.000000000000000;
    A[189] = 0.166666666666667*G1_0 + 0.166666666666667*G1_1;
    A[190] = -0.166666666666667*G1_0 + 0.166666666666667*G1_1;
    A[191] = 0.166666666666667*G1_0 - 0.166666666666667*G1_1;
    A[192] = 0.000000000000000;
    A[193] = 0.000000000000000;
    A[194] = 0.000000000000000;
    A[195] = 0.000000000000000;
    A[196] = 0.166666666666667*G0_0;
    A[197] = 0.000000000000000;
    A[198] = 0.166666666666667*G0_0 + 0.333333333333333*G0_1;
    A[199] = -0.166666666666667*G0_0;
    A[200] = -0.166666666666667*G0_0 - 0.333333333333333*G0_1;
    A[201] = 0.000000000000000;
    A[202] = 0.166666666666667*G1_0;
    A[203] = 0.000000000000000;
    A[204] = 0.166666666666667*G1_0 + 0.333333333333333*G1_1;
    A[205] = -0.166666666666667*G1_0;
    A[206] = -0.166666666666667*G1_0 - 0.333333333333333*G1_1;
    A[207] = 0.000000000000000;
    A[208] = 0.000000000000000;
    A[209] = 0.000000000000000;
    A[210] = 0.000000000000000;
    A[211] = 0.000000000000000;
    A[212] = 0.166666666666667*G0_1;
    A[213] = 0.333333333333333*G0_0 + 0.166666666666667*G0_1;
    A[214] = -0.333333333333333*G0_0 - 0.166666666666666*G0_1;
    A[215] = -0.166666666666667*G0_1;
    A[216] = 0.000000000000000;
    A[217] = 0.000000000000000;
    A[218] = 0.166666666666667*G1_1;
    A[219] = 0.333333333333333*G1_0 + 0.166666666666667*G1_1;
    A[220] = -0.333333333333333*G1_0 - 0.166666666666666*G1_1;
    A[221] = -0.166666666666667*G1_1;
    A[222] = 0.000000000000000;
    A[223] = 0.000000000000000;
    A[224] = 0.000000000000000;
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_9_0: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_9_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_9_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Cell Volume.
    
    // Compute circumradius, assuming triangle is embedded in 2D.
    
    
    // Array of quadrature weights.
    static const double W7[7] = {0.112500000000000, 0.062969590272414, 0.062969590272414, 0.062969590272414, 0.066197076394253, 0.066197076394253, 0.066197076394253};
    // Quadrature points on the UFC reference element: (0.333333333333333, 0.333333333333333), (0.797426985353087, 0.101286507323456), (0.101286507323456, 0.797426985353087), (0.101286507323456, 0.101286507323456), (0.059715871789770, 0.470142064105115), (0.470142064105115, 0.059715871789770), (0.470142064105115, 0.470142064105115)
    
    // Value of basis functions at quadrature points.
    static const double FE1_C0[7][6] = \
    {{-0.111111111111111, -0.111111111111111, -0.111111111111111, 0.444444444444444, 0.444444444444444, 0.444444444444445},
    {-0.080768594191887, 0.474352608585538, -0.080768594191887, 0.323074376767549, 0.041035826263138, 0.323074376767549},
    {-0.080768594191887, -0.080768594191887, 0.474352608585538, 0.323074376767549, 0.323074376767549, 0.041035826263138},
    {0.474352608585539, -0.080768594191887, -0.080768594191887, 0.041035826263138, 0.323074376767549, 0.323074376767549},
    {-0.028074943223079, -0.052583901102545, -0.028074943223079, 0.112299772892315, 0.884134241764073, 0.112299772892315},
    {-0.028074943223079, -0.028074943223079, -0.052583901102545, 0.112299772892315, 0.112299772892315, 0.884134241764073},
    {-0.052583901102545, -0.028074943223079, -0.028074943223079, 0.884134241764072, 0.112299772892315, 0.112299772892315}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[6] = {0, 1, 2, 3, 4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc3[6] = {6, 7, 8, 9, 10, 11};
    
    static const double FE1_C0_D01[7][5] = \
    {{-0.333333333333333, 0.333333333333334, 1.333333333333333, 0.000000000000000, -1.333333333333333},
    {0.594853970706174, -0.594853970706174, 3.189707941412347, 0.000000000000000, -3.189707941412349},
    {0.594853970706175, 2.189707941412349, 0.405146029293824, -2.784561912118522, -0.405146029293825},
    {-2.189707941412349, -0.594853970706174, 0.405146029293825, 2.784561912118524, -0.405146029293825},
    {-0.880568256420461, 0.880568256420460, 0.238863487159079, 0.000000000000000, -0.238863487159079},
    {-0.880568256420460, -0.761136512840921, 1.880568256420459, 1.641704769261382, -1.880568256420460},
    {0.761136512840921, 0.880568256420460, 1.880568256420460, -1.641704769261381, -1.880568256420460}};
    
    // Array of non-zero columns
    static const unsigned int nzc4[5] = {6, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc1[5] = {0, 2, 3, 4, 5};
    
    static const double FE1_C0_D10[7][5] = \
    {{-0.333333333333333, 0.333333333333333, 1.333333333333333, -1.333333333333333, 0.000000000000000},
    {0.594853970706174, 2.189707941412348, 0.405146029293824, -0.405146029293824, -2.784561912118522},
    {0.594853970706175, -0.594853970706175, 3.189707941412347, -3.189707941412347, 0.000000000000000},
    {-2.189707941412349, -0.594853970706175, 0.405146029293824, -0.405146029293824, 2.784561912118524},
    {-0.880568256420461, -0.761136512840922, 1.880568256420460, -1.880568256420460, 1.641704769261382},
    {-0.880568256420460, 0.880568256420460, 0.238863487159078, -0.238863487159078, 0.000000000000000},
    {0.761136512840921, 0.880568256420460, 1.880568256420460, -1.880568256420460, -1.641704769261381}};
    
    // Array of non-zero columns
    static const unsigned int nzc5[5] = {6, 7, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc2[5] = {0, 1, 3, 4, 5};
    
    static const double FE1_C2[7][3] = \
    {{0.333333333333333, 0.333333333333333, 0.333333333333333},
    {0.101286507323456, 0.797426985353087, 0.101286507323456},
    {0.101286507323457, 0.101286507323456, 0.797426985353087},
    {0.797426985353087, 0.101286507323456, 0.101286507323456},
    {0.470142064105115, 0.059715871789770, 0.470142064105115},
    {0.470142064105115, 0.470142064105115, 0.059715871789770},
    {0.059715871789770, 0.470142064105115, 0.470142064105115}};
    
    // Array of non-zero columns
    static const unsigned int nzc6[3] = {12, 13, 14};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.000000000000000;
    }// end loop over 'r'
    // Number of operations to compute geometry constants: 23.
    double G[11];
    G[0] = K_00*det;
    G[1] = K_10*det;
    G[2] = K_01*det;
    G[3] = K_11*det;
    G[4] = det*w[2][0]*(K_00*K_10 + K_01*K_11);
    G[5] = det*w[2][0]*(K_10*K_10 + K_11*K_11);
    G[6] =  - K_11*det;
    G[7] = det*w[2][0]*(K_00*K_00 + K_01*K_01);
    G[8] =  - K_00*det;
    G[9] =  - K_10*det;
    G[10] =  - K_01*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 1344
    for (unsigned int ip = 0; ip < 7; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.000000000000000;
      double F1 = 0.000000000000000;
      double F2 = 0.000000000000000;
      double F3 = 0.000000000000000;
      double F4 = 0.000000000000000;
      double F5 = 0.000000000000000;
      double F6 = 0.000000000000000;
      
      // Total number of operations to compute function values = 6
      for (unsigned int r = 0; r < 3; r++)
      {
        F6 += FE1_C2[ip][r]*w[0][nzc6[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 40
      for (unsigned int r = 0; r < 5; r++)
      {
        F0 += FE1_C0_D10[ip][r]*w[0][nzc2[r]];
        F1 += FE1_C0_D01[ip][r]*w[0][nzc1[r]];
        F4 += FE1_C0_D10[ip][r]*w[0][nzc5[r]];
        F5 += FE1_C0_D01[ip][r]*w[0][nzc4[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 24
      for (unsigned int r = 0; r < 6; r++)
      {
        F2 += FE1_C0[ip][r]*w[0][nzc0[r]];
        F3 += FE1_C0[ip][r]*w[0][nzc3[r]];
      }// end loop over 'r'
      
      // Number of operations to compute ip constants: 52
      double I[7];
      // Number of operations: 8
      I[0] = W7[ip]*(F0*G[0] + F1*G[1] + F4*G[2] + F5*G[3]);
      
      // Number of operations: 6
      I[1] = W7[ip]*(F4*G[4] + F5*G[5] + F6*G[6]);
      
      // Number of operations: 6
      I[2] = W7[ip]*(F0*G[7] + F1*G[4] + F6*G[8]);
      
      // Number of operations: 6
      I[3] = W7[ip]*(F0*G[4] + F1*G[5] + F6*G[9]);
      
      // Number of operations: 6
      I[4] = W7[ip]*(F4*G[7] + F5*G[4] + F6*G[10]);
      
      // Number of operations: 10
      I[5] = W7[ip]*(F0*(F2*G[0] + F3*G[2]) + F1*(F2*G[1] + F3*G[3]));
      
      // Number of operations: 10
      I[6] = W7[ip]*(F2*(F4*G[0] + F5*G[1]) + F3*(F4*G[2] + F5*G[3]));
      
      
      // Number of operations for primary indices: 6
      for (unsigned int j = 0; j < 3; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc6[j]] += FE1_C2[ip][j]*I[0];
      }// end loop over 'j'
      
      // Number of operations for primary indices: 40
      for (unsigned int j = 0; j < 5; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc4[j]] += FE1_C0_D01[ip][j]*I[1];
        // Number of operations to compute entry: 2
        A[nzc2[j]] += FE1_C0_D10[ip][j]*I[2];
        // Number of operations to compute entry: 2
        A[nzc1[j]] += FE1_C0_D01[ip][j]*I[3];
        // Number of operations to compute entry: 2
        A[nzc5[j]] += FE1_C0_D10[ip][j]*I[4];
      }// end loop over 'j'
      
      // Number of operations for primary indices: 24
      for (unsigned int j = 0; j < 6; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc0[j]] += FE1_C0[ip][j]*I[5];
        // Number of operations to compute entry: 2
        A[nzc3[j]] += FE1_C0[ip][j]*I[6];
      }// end loop over 'j'
    }// end loop over 'ip'
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not yet implemented (introduced in UFC 2.0).");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_9_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_9_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_9_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x[v1][0] - x[v0][0];
    const double dx1 = x[v1][1] - x[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    const bool direction = dx1*(x[facet][0] - x[v0][0]) - dx0*(x[facet][1] - x[v0][1]) < 0;// Compute facet normals from the facet scale factor constants
    const double n0 = direction ? dx1 / det : -dx1 / det;
    const double n1 = direction ? -dx0 / det : dx0 / det;
    
    // Cell Volume.
    
    // Compute circumradius, assuming triangle is embedded in 2D.
    
    
    // Array of quadrature weights.
    static const double W2[2] = {0.500000000000000, 0.500000000000000};
    // Quadrature points on the UFC reference element: (0.211324865405187), (0.788675134594813)
    
    // Value of basis functions at quadrature points.
    static const double FE0_f0[2][2] = \
    {{0.788675134594813, 0.211324865405187},
    {0.211324865405187, 0.788675134594813}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[2] = {1, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 1};
    
    static const double FE1_f0_C0[2][3] = \
    {{0.455341801261479, -0.122008467928146, 0.666666666666667},
    {-0.122008467928146, 0.455341801261480, 0.666666666666667}};
    
    // Array of non-zero columns
    static const unsigned int nzc3[3] = {1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc4[3] = {7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc9[3] = {0, 1, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc10[3] = {6, 7, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc7[3] = {6, 8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc6[3] = {0, 2, 4};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.000000000000000;
    }// end loop over 'r'
    // Number of operations to compute geometry constants: 2.
    double G[2];
    G[0] = det*n0;
    G[1] = det*n1;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    switch (facet)
    {
    case 0:
      {
        // Total number of operations to compute element tensor (from this point): 40
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 40
      for (unsigned int ip = 0; ip < 2; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.000000000000000;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc0[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 4
        double I[2];
        // Number of operations: 2
        I[0] = F0*G[0]*W2[ip];
        
        // Number of operations: 2
        I[1] = F0*G[1]*W2[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc3[j]] += FE1_f0_C0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc4[j]] += FE1_f0_C0[ip][j]*I[1];
        }// end loop over 'j'
      }// end loop over 'ip'
        break;
      }
    case 1:
      {
        // Total number of operations to compute element tensor (from this point): 40
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 40
      for (unsigned int ip = 0; ip < 2; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.000000000000000;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc1[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 4
        double I[2];
        // Number of operations: 2
        I[0] = F0*G[1]*W2[ip];
        
        // Number of operations: 2
        I[1] = F0*G[0]*W2[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc7[j]] += FE1_f0_C0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc6[j]] += FE1_f0_C0[ip][j]*I[1];
        }// end loop over 'j'
      }// end loop over 'ip'
        break;
      }
    case 2:
      {
        // Total number of operations to compute element tensor (from this point): 40
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 40
      for (unsigned int ip = 0; ip < 2; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.000000000000000;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc2[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 4
        double I[2];
        // Number of operations: 2
        I[0] = F0*G[1]*W2[ip];
        
        // Number of operations: 2
        I[1] = F0*G[0]*W2[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc10[j]] += FE1_f0_C0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc9[j]] += FE1_f0_C0[ip][j]*I[1];
        }// end loop over 'j'
      }// end loop over 'ip'
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not yet implemented (introduced in UFC 2.0).");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_10_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_10_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_10_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      9
    // Number of operations (multiply-add pairs) for geometry tensor:    6
    // Number of operations (multiply-add pairs) for tensor contraction: 7
    // Total number of operations (multiply-add pairs):                  22
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x[v1][0] - x[v0][0];
    const double dx1 = x[v1][1] - x[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    // Compute geometry tensor
    const double G0_0 = det*w[0][0]*(1.0);
    const double G0_1 = det*w[0][1]*(1.0);
    const double G0_2 = det*w[0][2]*(1.0);
    const double G0_3 = det*w[0][3]*(1.0);
    const double G0_4 = det*w[0][4]*(1.0);
    const double G0_5 = det*w[0][5]*(1.0);
    
    // Compute element tensor
    switch (facet)
    {
    case 0:
      {
        A[0] = 0.166666666666667*G0_1 + 0.166666666666667*G0_2 + 0.666666666666666*G0_3;
        break;
      }
    case 1:
      {
        A[0] = 0.166666666666667*G0_0 + 0.166666666666667*G0_2 + 0.666666666666666*G0_4;
        break;
      }
    case 2:
      {
        A[0] = 0.166666666666667*G0_0 + 0.166666666666667*G0_1 + 0.666666666666666*G0_5;
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_0: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_0() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_0()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Sum(IndexSum(Product(Indexed(ComponentTensor(IndexSum(Sum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((Index(1), Index(0)), {Index(0): 2, Index(1): 2})), MultiIndex((Index(2), Index(3)), {Index(2): 2, Index(3): 2})), Indexed(ListTensor(Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {FixedIndex(0): 3})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {FixedIndex(1): 3}))), MultiIndex((Index(3),), {Index(3): 2}))), Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((Index(1), Index(0)), {Index(0): 2, Index(1): 2})), MultiIndex((Index(2), Index(3)), {Index(2): 2, Index(3): 2})), Indexed(ListTensor(Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {FixedIndex(0): 3})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {FixedIndex(1): 3}))), MultiIndex((Index(3),), {Index(3): 2})))), MultiIndex((Index(3),), {Index(3): 2})), MultiIndex((Index(2),), {Index(2): 2})), MultiIndex((Index(4),), {Index(4): 2})), Indexed(ListTensor(Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((FixedIndex(0),), {FixedIndex(0): 3})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((FixedIndex(1),), {FixedIndex(1): 3}))), MultiIndex((Index(4),), {Index(4): 2}))), MultiIndex((Index(4),), {Index(4): 2})), Sum(Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((Index(5),), {Index(5): 2})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((FixedIndex(2),), {FixedIndex(2): 3}))), Sum(Product(Constant(Cell('triangle', Space(2)), 1), IndexSum(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((Index(7), Index(6)), {Index(7): 2, Index(6): 2})), MultiIndex((Index(8), Index(9)), {Index(8): 2, Index(9): 2})), Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(11),), {Index(11): 2})), MultiIndex((Index(11), Index(10)), {Index(11): 2, Index(10): 2})), MultiIndex((Index(8), Index(9)), {Index(8): 2, Index(9): 2}))), MultiIndex((Index(8),), {Index(8): 2})), MultiIndex((Index(9),), {Index(9): 2}))), Product(IntValue(-1, (), (), {}), Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((Index(12),), {Index(12): 2})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(2),), {FixedIndex(2): 3}))))))), Measure('cell', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 2;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_9();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_9();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_cell_integral_0_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_1: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_1() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_1()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {FixedIndex(0): 3})), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 0;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_1_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_2: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_2() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_2()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(IndexSum(Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(0),), {Index(0): 3})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 0), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((Index(0),), {Index(0): 3}))), MultiIndex((Index(0),), {Index(0): 3})), Measure('cell', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 1;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_8();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_8();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_4();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_8();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_8();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_4();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_cell_integral_2_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_3: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_3() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_3()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Product(IntValue(-1, (), (), {}), Sum(IndexSum(Product(Indexed(ComponentTensor(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((Index(1), Index(0)), {Index(0): 2, Index(1): 2})), MultiIndex((Index(2), Index(3)), {Index(2): 2, Index(3): 2})), Indexed(ListTensor(Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {FixedIndex(0): 3})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {FixedIndex(1): 3}))), MultiIndex((Index(3),), {Index(3): 2}))), MultiIndex((Index(3),), {Index(3): 2})), MultiIndex((Index(2),), {Index(2): 2})), MultiIndex((Index(4),), {Index(4): 2})), Indexed(ListTensor(Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3}))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(0),), {})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3}))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(4),), {Index(4): 2}))), MultiIndex((Index(4),), {Index(4): 2})), Sum(Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((Index(6),), {Index(6): 2})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3}))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(2),), {}))), Sum(Product(Constant(Cell('triangle', Space(2)), 2), IndexSum(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(ComponentTensor(Sum(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(SpatialDerivative(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((Index(5),), {Index(5): 3}))), Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3})), SpatialDerivative(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), MultiIndex((Index(7),), {Index(7): 2})))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(0),), {})), Indexed(ComponentTensor(Sum(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(SpatialDerivative(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((Index(5),), {Index(5): 3}))), Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3})), SpatialDerivative(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), MultiIndex((Index(7),), {Index(7): 2})))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(8),), {Index(8): 2})), MultiIndex((Index(8), Index(7)), {Index(7): 2, Index(8): 2})), MultiIndex((Index(9), Index(10)), {Index(10): 2, Index(9): 2})), Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(11),), {Index(11): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(11),), {Index(11): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((Index(12), Index(11)), {Index(11): 2, Index(12): 2})), MultiIndex((Index(9), Index(10)), {Index(10): 2, Index(9): 2}))), MultiIndex((Index(9),), {Index(9): 2})), MultiIndex((Index(10),), {Index(10): 2}))), Product(IntValue(-1, (), (), {}), Product(IndexSum(Indexed(ListTensor(Indexed(ComponentTensor(Sum(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(SpatialDerivative(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(13),), {Index(13): 2})), MultiIndex((Index(5),), {Index(5): 3}))), Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3})), SpatialDerivative(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), MultiIndex((Index(13),), {Index(13): 2})))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(0),), {})), Indexed(ComponentTensor(Sum(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(SpatialDerivative(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(13),), {Index(13): 2})), MultiIndex((Index(5),), {Index(5): 3}))), Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3})), SpatialDerivative(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), MultiIndex((Index(13),), {Index(13): 2})))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(13),), {Index(13): 2})), MultiIndex((Index(13),), {Index(13): 2})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(2),), {FixedIndex(2): 3})))))))), Measure('cell', 0, None)), Integral(Product(IntValue(-1, (), (), {}), Product(Coefficient(FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), 1), IndexSum(Product(Indexed(FacetNormal(Cell('triangle', Space(2))), MultiIndex((Index(14),), {Index(14): 2})), Indexed(ListTensor(Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3}))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(0),), {})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3}))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(14),), {Index(14): 2}))), MultiIndex((Index(14),), {Index(14): 2})))), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 4;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_8();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_11();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_9();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_finite_element_4();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_8();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_11();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_9();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_dofmap_4();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_cell_integral_3_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_3_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_4: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_4() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_4()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Sum(IndexSum(Product(Indexed(NegativeRestricted(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1)), MultiIndex((Index(0),), {Index(0): 3})), Indexed(NegativeRestricted(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 0), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(0),), {Index(0): 3}))), MultiIndex((Index(0),), {Index(0): 3})), IndexSum(Product(Indexed(PositiveRestricted(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1)), MultiIndex((Index(2),), {Index(2): 3})), Indexed(PositiveRestricted(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 0), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(2),), {Index(2): 3}))), MultiIndex((Index(2),), {Index(2): 3}))), Measure('interior_facet', 0, None)), Integral(IndexSum(Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(3),), {Index(3): 3})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 0), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((Index(3),), {Index(3): 3}))), MultiIndex((Index(3),), {Index(3): 3})), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 1;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 1;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_8();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_8();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_8();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_8();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_4_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_interior_facet_integral_4_0();
        break;
      }
    }
    
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_5: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_5() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_5()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Sum(Product(IntValue(-1, (), (), {}), IndexSum(Product(Indexed(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(0),), {Index(0): 3})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((Index(0),), {Index(0): 3}))), MultiIndex((Index(0),), {Index(0): 3}))), Product(IntValue(-1, (), (), {}), Sum(IndexSum(Product(Indexed(ComponentTensor(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(2),), {Index(2): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(2),), {Index(2): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(3),), {Index(3): 2})), MultiIndex((Index(3), Index(2)), {Index(2): 2, Index(3): 2})), MultiIndex((Index(4), Index(5)), {Index(4): 2, Index(5): 2})), Indexed(ListTensor(Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {FixedIndex(0): 3})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {FixedIndex(1): 3}))), MultiIndex((Index(5),), {Index(5): 2}))), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((Index(4),), {Index(4): 2})), MultiIndex((Index(6),), {Index(6): 2})), Indexed(ListTensor(Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(0),), {})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(6),), {Index(6): 2}))), MultiIndex((Index(6),), {Index(6): 2})), Sum(Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((Index(7),), {Index(7): 2})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(2),), {}))), Sum(Product(Constant(Cell('triangle', Space(2)), 2), IndexSum(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(ComponentTensor(Sum(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(SpatialDerivative(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(8),), {Index(8): 2})), MultiIndex((Index(1),), {Index(1): 3}))), Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3})), SpatialDerivative(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), MultiIndex((Index(8),), {Index(8): 2})))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(0),), {})), Indexed(ComponentTensor(Sum(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(SpatialDerivative(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(8),), {Index(8): 2})), MultiIndex((Index(1),), {Index(1): 3}))), Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3})), SpatialDerivative(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), MultiIndex((Index(8),), {Index(8): 2})))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(9),), {Index(9): 2})), MultiIndex((Index(9), Index(8)), {Index(8): 2, Index(9): 2})), MultiIndex((Index(10), Index(11)), {Index(11): 2, Index(10): 2})), Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(13),), {Index(13): 2})), MultiIndex((Index(13), Index(12)), {Index(13): 2, Index(12): 2})), MultiIndex((Index(10), Index(11)), {Index(11): 2, Index(10): 2}))), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((Index(11),), {Index(11): 2}))), Product(IntValue(-1, (), (), {}), Product(IndexSum(Indexed(ListTensor(Indexed(ComponentTensor(Sum(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(SpatialDerivative(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(14),), {Index(14): 2})), MultiIndex((Index(1),), {Index(1): 3}))), Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3})), SpatialDerivative(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), MultiIndex((Index(14),), {Index(14): 2})))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(0),), {})), Indexed(ComponentTensor(Sum(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(SpatialDerivative(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(14),), {Index(14): 2})), MultiIndex((Index(1),), {Index(1): 3}))), Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3})), SpatialDerivative(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), MultiIndex((Index(14),), {Index(14): 2})))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(14),), {Index(14): 2})), MultiIndex((Index(14),), {Index(14): 2})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(2),), {FixedIndex(2): 3}))))))))), Measure('cell', 0, None)), Integral(Product(IntValue(-1, (), (), {}), Product(Coefficient(FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), 1), IndexSum(Product(Indexed(FacetNormal(Cell('triangle', Space(2))), MultiIndex((Index(15),), {Index(15): 2})), Indexed(ListTensor(Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(0),), {})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(15),), {Index(15): 2}))), MultiIndex((Index(15),), {Index(15): 2})))), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 5;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_8();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_11();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_9();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_finite_element_8();
        break;
      }
    case 5:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_8();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_11();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_9();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_dofmap_8();
        break;
      }
    case 5:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_cell_integral_5_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_5_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_6: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_6() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_6()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Product(IntValue(-1, (), (), {}), Sum(IndexSum(Product(Indexed(ComponentTensor(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((Index(1), Index(0)), {Index(0): 2, Index(1): 2})), MultiIndex((Index(2), Index(3)), {Index(2): 2, Index(3): 2})), Indexed(ListTensor(Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {FixedIndex(0): 3})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {FixedIndex(1): 3}))), MultiIndex((Index(3),), {Index(3): 2}))), MultiIndex((Index(3),), {Index(3): 2})), MultiIndex((Index(2),), {Index(2): 2})), MultiIndex((Index(4),), {Index(4): 2})), Indexed(ListTensor(Indexed(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((FixedIndex(0),), {FixedIndex(0): 3})), Indexed(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((FixedIndex(1),), {FixedIndex(1): 3}))), MultiIndex((Index(4),), {Index(4): 2}))), MultiIndex((Index(4),), {Index(4): 2})), Sum(Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((Index(5),), {Index(5): 2})), Indexed(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((FixedIndex(2),), {FixedIndex(2): 3}))), Sum(Product(Constant(Cell('triangle', Space(2)), 2), IndexSum(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((Index(7), Index(6)), {Index(7): 2, Index(6): 2})), MultiIndex((Index(8), Index(9)), {Index(8): 2, Index(9): 2})), Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(11),), {Index(11): 2})), MultiIndex((Index(11), Index(10)), {Index(11): 2, Index(10): 2})), MultiIndex((Index(8), Index(9)), {Index(8): 2, Index(9): 2}))), MultiIndex((Index(8),), {Index(8): 2})), MultiIndex((Index(9),), {Index(9): 2}))), Product(IntValue(-1, (), (), {}), Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((Index(12),), {Index(12): 2})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(2),), {FixedIndex(2): 3})))))))), Measure('cell', 0, None)), Integral(Product(IntValue(-1, (), (), {}), Product(Coefficient(FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), 1), IndexSum(Product(Indexed(FacetNormal(Cell('triangle', Space(2))), MultiIndex((Index(13),), {Index(13): 2})), Indexed(ListTensor(Indexed(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((FixedIndex(0),), {FixedIndex(0): 3})), Indexed(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((FixedIndex(1),), {FixedIndex(1): 3}))), MultiIndex((Index(13),), {Index(13): 2}))), MultiIndex((Index(13),), {Index(13): 2})))), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 0;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 4;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_11();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_9();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_3();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_11();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_9();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_3();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_cell_integral_6_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_6_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_7: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_7() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_7()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Product(Argument(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 0, None), 0), IndexSum(Product(Indexed(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(0),), {Index(0): 3})), Indexed(Sum(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 0), ComponentTensor(Product(IntValue(-1, (), (), {}), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(0),), {Index(0): 3}))), MultiIndex((Index(0),), {Index(0): 3}))), Measure('cell', 0, None)), Integral(Product(Product(FloatValue(0.500000000000000, (), (), {}), Sum(NegativeRestricted(Argument(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 0, None), 0)), PositiveRestricted(Argument(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 0, None), 0)))), Sum(IndexSum(Product(Indexed(NegativeRestricted(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 2)), MultiIndex((Index(2),), {Index(2): 3})), Indexed(NegativeRestricted(Sum(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 0), ComponentTensor(Product(IntValue(-1, (), (), {}), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(3),), {Index(3): 3}))), MultiIndex((Index(3),), {Index(3): 3})))), MultiIndex((Index(2),), {Index(2): 3}))), MultiIndex((Index(2),), {Index(2): 3})), IndexSum(Product(Indexed(PositiveRestricted(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 2)), MultiIndex((Index(4),), {Index(4): 3})), Indexed(PositiveRestricted(Sum(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 0), ComponentTensor(Product(IntValue(-1, (), (), {}), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(5),), {Index(5): 3}))), MultiIndex((Index(5),), {Index(5): 3})))), MultiIndex((Index(4),), {Index(4): 3}))), MultiIndex((Index(4),), {Index(4): 3})))), Measure('interior_facet', 0, None)), Integral(Product(Argument(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 0, None), 0), IndexSum(Product(Indexed(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 2), MultiIndex((Index(6),), {Index(6): 3})), Indexed(Sum(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 0), ComponentTensor(Product(IntValue(-1, (), (), {}), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(7),), {Index(7): 3}))), MultiIndex((Index(7),), {Index(7): 3}))), MultiIndex((Index(6),), {Index(6): 3}))), MultiIndex((Index(6),), {Index(6): 3}))), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 4;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 1;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_9();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_3();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_8();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_8();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_9();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_3();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_8();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_8();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_cell_integral_7_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_7_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_interior_facet_integral_7_0();
        break;
      }
    }
    
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_8: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_8() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_8()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Sum(IndexSum(Product(Indexed(ComponentTensor(IndexSum(Sum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((Index(1), Index(0)), {Index(0): 2, Index(1): 2})), MultiIndex((Index(2), Index(3)), {Index(2): 2, Index(3): 2})), Indexed(ListTensor(Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {FixedIndex(0): 3})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {FixedIndex(1): 3}))), MultiIndex((Index(3),), {Index(3): 2}))), Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((Index(1), Index(0)), {Index(0): 2, Index(1): 2})), MultiIndex((Index(2), Index(3)), {Index(2): 2, Index(3): 2})), Indexed(ListTensor(Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((FixedIndex(0),), {FixedIndex(0): 3})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((FixedIndex(1),), {FixedIndex(1): 3}))), MultiIndex((Index(3),), {Index(3): 2})))), MultiIndex((Index(3),), {Index(3): 2})), MultiIndex((Index(2),), {Index(2): 2})), MultiIndex((Index(4),), {Index(4): 2})), Indexed(ListTensor(Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {FixedIndex(0): 3})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {FixedIndex(1): 3}))), MultiIndex((Index(4),), {Index(4): 2}))), MultiIndex((Index(4),), {Index(4): 2})), Sum(Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((Index(5),), {Index(5): 2})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(2),), {FixedIndex(2): 3}))), Sum(Product(Constant(Cell('triangle', Space(2)), 1), IndexSum(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((Index(7), Index(6)), {Index(7): 2, Index(6): 2})), MultiIndex((Index(8), Index(9)), {Index(8): 2, Index(9): 2})), Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(11),), {Index(11): 2})), MultiIndex((Index(11), Index(10)), {Index(11): 2, Index(10): 2})), MultiIndex((Index(8), Index(9)), {Index(8): 2, Index(9): 2}))), MultiIndex((Index(8),), {Index(8): 2})), MultiIndex((Index(9),), {Index(9): 2}))), Product(IntValue(-1, (), (), {}), Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((Index(12),), {Index(12): 2})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((FixedIndex(2),), {FixedIndex(2): 3}))))))), Measure('cell', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 2;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_9();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_9();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_cell_integral_8_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_9: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_9() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_9()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Sum(IndexSum(Product(Indexed(ComponentTensor(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((Index(1), Index(0)), {Index(0): 2, Index(1): 2})), MultiIndex((Index(2), Index(3)), {Index(2): 2, Index(3): 2})), Indexed(ListTensor(Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {FixedIndex(0): 3})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {FixedIndex(1): 3}))), MultiIndex((Index(3),), {Index(3): 2}))), MultiIndex((Index(3),), {Index(3): 2})), MultiIndex((Index(2),), {Index(2): 2})), MultiIndex((Index(4),), {Index(4): 2})), Indexed(ListTensor(Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {FixedIndex(0): 3})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {FixedIndex(1): 3}))), MultiIndex((Index(4),), {Index(4): 2}))), MultiIndex((Index(4),), {Index(4): 2})), Sum(Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((Index(5),), {Index(5): 2})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(2),), {FixedIndex(2): 3}))), Sum(Product(Constant(Cell('triangle', Space(2)), 2), IndexSum(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((Index(7), Index(6)), {Index(7): 2, Index(6): 2})), MultiIndex((Index(8), Index(9)), {Index(8): 2, Index(9): 2})), Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(11),), {Index(11): 2})), MultiIndex((Index(11), Index(10)), {Index(11): 2, Index(10): 2})), MultiIndex((Index(8), Index(9)), {Index(8): 2, Index(9): 2}))), MultiIndex((Index(8),), {Index(8): 2})), MultiIndex((Index(9),), {Index(9): 2}))), Product(IntValue(-1, (), (), {}), Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((Index(12),), {Index(12): 2})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(2),), {FixedIndex(2): 3}))))))), Measure('cell', 0, None)), Integral(Product(Coefficient(FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), 1), IndexSum(Product(Indexed(FacetNormal(Cell('triangle', Space(2))), MultiIndex((Index(13),), {Index(13): 2})), Indexed(ListTensor(Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {FixedIndex(0): 3})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {FixedIndex(1): 3}))), MultiIndex((Index(13),), {Index(13): 2}))), MultiIndex((Index(13),), {Index(13): 2}))), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 3;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_11();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_9();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_11();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_9();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_cell_integral_9_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_9_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_10: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_10() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_10()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {FixedIndex(0): 3})), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 0;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 1;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_10_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

// DOLFIN wrappers

// Standard library includes
#include <string>

// DOLFIN includes
#include <dolfin/common/NoDeleter.h>
#include <dolfin/fem/FiniteElement.h>
#include <dolfin/fem/DofMap.h>
#include <dolfin/fem/Form.h>
#include <dolfin/function/FunctionSpace.h>
#include <dolfin/function/GenericFunction.h>
#include <dolfin/function/CoefficientAssigner.h>
#include <dolfin/adaptivity/ErrorControl.h>
#include <dolfin/adaptivity/GoalFunctional.h>

namespace AdaptiveNavierStokes
{

class CoefficientSpace___cell_bubble: public dolfin::FunctionSpace
{
public:

  CoefficientSpace___cell_bubble(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_4()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___cell_bubble(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_4()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___cell_bubble(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_4()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace___cell_bubble(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_4()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_4()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace___cell_bubble()
  {
  }

};

class CoefficientSpace___cell_cone: public dolfin::FunctionSpace
{
public:

  CoefficientSpace___cell_cone(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___cell_cone(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___cell_cone(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace___cell_cone(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace___cell_cone()
  {
  }

};

class CoefficientSpace___cell_residual: public dolfin::FunctionSpace
{
public:

  CoefficientSpace___cell_residual(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___cell_residual(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___cell_residual(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace___cell_residual(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace___cell_residual()
  {
  }

};

class CoefficientSpace___discrete_dual_solution: public dolfin::FunctionSpace
{
public:

  CoefficientSpace___discrete_dual_solution(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___discrete_dual_solution(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___discrete_dual_solution(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace___discrete_dual_solution(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace___discrete_dual_solution()
  {
  }

};

class CoefficientSpace___facet_residual: public dolfin::FunctionSpace
{
public:

  CoefficientSpace___facet_residual(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___facet_residual(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___facet_residual(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace___facet_residual(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace___facet_residual()
  {
  }

};

class CoefficientSpace___improved_dual: public dolfin::FunctionSpace
{
public:

  CoefficientSpace___improved_dual(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_3()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_3()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___improved_dual(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_3()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_3()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___improved_dual(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_3()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_3()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace___improved_dual(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_3()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_3()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace___improved_dual()
  {
  }

};

class CoefficientSpace_nu: public dolfin::FunctionSpace
{
public:

  CoefficientSpace_nu(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_nu(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_nu(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace_nu(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace_nu()
  {
  }

};

class CoefficientSpace_p0: public dolfin::FunctionSpace
{
public:

  CoefficientSpace_p0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_11()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_11()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_p0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_11()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_11()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_p0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_11()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_11()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace_p0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_11()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_11()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace_p0()
  {
  }

};

class CoefficientSpace_w: public dolfin::FunctionSpace
{
public:

  CoefficientSpace_w(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_w(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_w(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace_w(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace_w()
  {
  }

};

class Form_0_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_0_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  Form_0_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  ~Form_0_FunctionSpace_0()
  {
  }

};

class Form_0_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  Form_0_FunctionSpace_1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_1(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_1(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  Form_0_FunctionSpace_1(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  ~Form_0_FunctionSpace_1()
  {
  }

};

typedef CoefficientSpace_w Form_0_FunctionSpace_2;

typedef CoefficientSpace_nu Form_0_FunctionSpace_3;

class Form_0: public dolfin::Form
{
public:

  // Constructor
  Form_0(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Constructor
  Form_0(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->w = w;
    this->nu = nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Constructor
  Form_0(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->w = *w;
    this->nu = *nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Constructor
  Form_0(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Constructor
  Form_0(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->w = w;
    this->nu = nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Constructor
  Form_0(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->w = *w;
    this->nu = *nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Destructor
  ~Form_0()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "nu")
      return 1;

    dolfin::error("Invalid coefficient.");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "nu";
    }

    dolfin::error("Invalid coefficient.");
    return "unnamed";
  }

  // Typedefs
  typedef Form_0_FunctionSpace_0 TestSpace;
  typedef Form_0_FunctionSpace_1 TrialSpace;
  typedef Form_0_FunctionSpace_2 CoefficientSpace_w;
  typedef Form_0_FunctionSpace_3 CoefficientSpace_nu;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner nu;
};

class Form_1_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_1_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  Form_1_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  Form_1_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  Form_1_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  ~Form_1_FunctionSpace_0()
  {
  }

};

class Form_1: public dolfin::Form
{
public:

  // Constructor
  Form_1(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_1());
  }

  // Constructor
  Form_1(boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 0)
  {
    _function_spaces[0] = V0;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_1());
  }

  // Destructor
  ~Form_1()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {

    dolfin::error("No coefficients.");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {

    dolfin::error("No coefficients.");
    return "unnamed";
  }

  // Typedefs
  typedef Form_1_FunctionSpace_0 TestSpace;

  // Coefficients
};

class Form_2_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_2_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), mesh)))
  {
    // Do nothing
  }

  Form_2_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), mesh)))
  {
    // Do nothing
  }

  Form_2_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), *mesh)))
  {
      // Do nothing
  }

  Form_2_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), *mesh)))
  {
      // Do nothing
  }

  ~Form_2_FunctionSpace_0()
  {
  }

};

class Form_2_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  Form_2_FunctionSpace_1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), mesh)))
  {
    // Do nothing
  }

  Form_2_FunctionSpace_1(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), mesh)))
  {
    // Do nothing
  }

  Form_2_FunctionSpace_1(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), *mesh)))
  {
      // Do nothing
  }

  Form_2_FunctionSpace_1(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), *mesh)))
  {
      // Do nothing
  }

  ~Form_2_FunctionSpace_1()
  {
  }

};

typedef CoefficientSpace___cell_bubble Form_2_FunctionSpace_2;

class Form_2: public dolfin::Form
{
public:

  // Constructor
  Form_2(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Constructor
  Form_2(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& __cell_bubble):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->__cell_bubble = __cell_bubble;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Constructor
  Form_2(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> __cell_bubble):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->__cell_bubble = *__cell_bubble;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Constructor
  Form_2(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Constructor
  Form_2(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& __cell_bubble):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->__cell_bubble = __cell_bubble;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Constructor
  Form_2(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> __cell_bubble):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->__cell_bubble = *__cell_bubble;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Destructor
  ~Form_2()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "__cell_bubble")
      return 0;

    dolfin::error("Invalid coefficient.");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "__cell_bubble";
    }

    dolfin::error("Invalid coefficient.");
    return "unnamed";
  }

  // Typedefs
  typedef Form_2_FunctionSpace_0 TestSpace;
  typedef Form_2_FunctionSpace_1 TrialSpace;
  typedef Form_2_FunctionSpace_2 CoefficientSpace___cell_bubble;

  // Coefficients
  dolfin::CoefficientAssigner __cell_bubble;
};

class Form_3_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_3_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), mesh)))
  {
    // Do nothing
  }

  Form_3_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), mesh)))
  {
    // Do nothing
  }

  Form_3_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), *mesh)))
  {
      // Do nothing
  }

  Form_3_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), *mesh)))
  {
      // Do nothing
  }

  ~Form_3_FunctionSpace_0()
  {
  }

};

typedef CoefficientSpace_w Form_3_FunctionSpace_1;

typedef CoefficientSpace_p0 Form_3_FunctionSpace_2;

typedef CoefficientSpace_nu Form_3_FunctionSpace_3;

typedef CoefficientSpace___cell_bubble Form_3_FunctionSpace_4;

class Form_3: public dolfin::Form
{
public:

  // Constructor
  Form_3(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Constructor
  Form_3(const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __cell_bubble):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__cell_bubble = __cell_bubble;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Constructor
  Form_3(const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> p0, boost::shared_ptr<const dolfin::GenericFunction> nu, boost::shared_ptr<const dolfin::GenericFunction> __cell_bubble):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__cell_bubble = *__cell_bubble;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Constructor
  Form_3(boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = V0;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Constructor
  Form_3(boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __cell_bubble):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = V0;

    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__cell_bubble = __cell_bubble;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Constructor
  Form_3(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> p0, boost::shared_ptr<const dolfin::GenericFunction> nu, boost::shared_ptr<const dolfin::GenericFunction> __cell_bubble):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = V0;

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__cell_bubble = *__cell_bubble;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Destructor
  ~Form_3()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "p0")
      return 1;
    else if (name == "nu")
      return 2;
    else if (name == "__cell_bubble")
      return 3;

    dolfin::error("Invalid coefficient.");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "p0";
    case 2:
      return "nu";
    case 3:
      return "__cell_bubble";
    }

    dolfin::error("Invalid coefficient.");
    return "unnamed";
  }

  // Typedefs
  typedef Form_3_FunctionSpace_0 TestSpace;
  typedef Form_3_FunctionSpace_1 CoefficientSpace_w;
  typedef Form_3_FunctionSpace_2 CoefficientSpace_p0;
  typedef Form_3_FunctionSpace_3 CoefficientSpace_nu;
  typedef Form_3_FunctionSpace_4 CoefficientSpace___cell_bubble;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner p0;
  dolfin::CoefficientAssigner nu;
  dolfin::CoefficientAssigner __cell_bubble;
};

class Form_4_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_4_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), mesh)))
  {
    // Do nothing
  }

  Form_4_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), mesh)))
  {
    // Do nothing
  }

  Form_4_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), *mesh)))
  {
      // Do nothing
  }

  Form_4_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), *mesh)))
  {
      // Do nothing
  }

  ~Form_4_FunctionSpace_0()
  {
  }

};

class Form_4_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  Form_4_FunctionSpace_1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), mesh)))
  {
    // Do nothing
  }

  Form_4_FunctionSpace_1(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), mesh)))
  {
    // Do nothing
  }

  Form_4_FunctionSpace_1(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), *mesh)))
  {
      // Do nothing
  }

  Form_4_FunctionSpace_1(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), *mesh)))
  {
      // Do nothing
  }

  ~Form_4_FunctionSpace_1()
  {
  }

};

typedef CoefficientSpace___cell_cone Form_4_FunctionSpace_2;

class Form_4: public dolfin::Form
{
public:

  // Constructor
  Form_4(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Constructor
  Form_4(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& __cell_cone):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->__cell_cone = __cell_cone;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Constructor
  Form_4(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> __cell_cone):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->__cell_cone = *__cell_cone;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Constructor
  Form_4(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Constructor
  Form_4(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& __cell_cone):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->__cell_cone = __cell_cone;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Constructor
  Form_4(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> __cell_cone):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->__cell_cone = *__cell_cone;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Destructor
  ~Form_4()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "__cell_cone")
      return 0;

    dolfin::error("Invalid coefficient.");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "__cell_cone";
    }

    dolfin::error("Invalid coefficient.");
    return "unnamed";
  }

  // Typedefs
  typedef Form_4_FunctionSpace_0 TestSpace;
  typedef Form_4_FunctionSpace_1 TrialSpace;
  typedef Form_4_FunctionSpace_2 CoefficientSpace___cell_cone;

  // Coefficients
  dolfin::CoefficientAssigner __cell_cone;
};

class Form_5_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_5_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), mesh)))
  {
    // Do nothing
  }

  Form_5_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), mesh)))
  {
    // Do nothing
  }

  Form_5_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), *mesh)))
  {
      // Do nothing
  }

  Form_5_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_8()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_8()), *mesh)))
  {
      // Do nothing
  }

  ~Form_5_FunctionSpace_0()
  {
  }

};

typedef CoefficientSpace_w Form_5_FunctionSpace_1;

typedef CoefficientSpace_p0 Form_5_FunctionSpace_2;

typedef CoefficientSpace_nu Form_5_FunctionSpace_3;

typedef CoefficientSpace___cell_residual Form_5_FunctionSpace_4;

typedef CoefficientSpace___cell_cone Form_5_FunctionSpace_5;

class Form_5: public dolfin::Form
{
public:

  // Constructor
  Form_5(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Constructor
  Form_5(const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __cell_residual, const dolfin::GenericFunction& __cell_cone):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__cell_residual = __cell_residual;
    this->__cell_cone = __cell_cone;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Constructor
  Form_5(const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> p0, boost::shared_ptr<const dolfin::GenericFunction> nu, boost::shared_ptr<const dolfin::GenericFunction> __cell_residual, boost::shared_ptr<const dolfin::GenericFunction> __cell_cone):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__cell_residual = *__cell_residual;
    this->__cell_cone = *__cell_cone;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Constructor
  Form_5(boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = V0;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Constructor
  Form_5(boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __cell_residual, const dolfin::GenericFunction& __cell_cone):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = V0;

    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__cell_residual = __cell_residual;
    this->__cell_cone = __cell_cone;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Constructor
  Form_5(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> p0, boost::shared_ptr<const dolfin::GenericFunction> nu, boost::shared_ptr<const dolfin::GenericFunction> __cell_residual, boost::shared_ptr<const dolfin::GenericFunction> __cell_cone):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = V0;

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__cell_residual = *__cell_residual;
    this->__cell_cone = *__cell_cone;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Destructor
  ~Form_5()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "p0")
      return 1;
    else if (name == "nu")
      return 2;
    else if (name == "__cell_residual")
      return 3;
    else if (name == "__cell_cone")
      return 4;

    dolfin::error("Invalid coefficient.");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "p0";
    case 2:
      return "nu";
    case 3:
      return "__cell_residual";
    case 4:
      return "__cell_cone";
    }

    dolfin::error("Invalid coefficient.");
    return "unnamed";
  }

  // Typedefs
  typedef Form_5_FunctionSpace_0 TestSpace;
  typedef Form_5_FunctionSpace_1 CoefficientSpace_w;
  typedef Form_5_FunctionSpace_2 CoefficientSpace_p0;
  typedef Form_5_FunctionSpace_3 CoefficientSpace_nu;
  typedef Form_5_FunctionSpace_4 CoefficientSpace___cell_residual;
  typedef Form_5_FunctionSpace_5 CoefficientSpace___cell_cone;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner p0;
  dolfin::CoefficientAssigner nu;
  dolfin::CoefficientAssigner __cell_residual;
  dolfin::CoefficientAssigner __cell_cone;
};

typedef CoefficientSpace_w Form_6_FunctionSpace_0;

typedef CoefficientSpace_p0 Form_6_FunctionSpace_1;

typedef CoefficientSpace_nu Form_6_FunctionSpace_2;

typedef CoefficientSpace___improved_dual Form_6_FunctionSpace_3;

class Form_6: public dolfin::Form
{
public:

  // Constructor
  Form_6(const dolfin::Mesh& mesh):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Constructor
  Form_6(const dolfin::Mesh& mesh, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __improved_dual):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__improved_dual = __improved_dual;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Constructor
  Form_6(const dolfin::Mesh& mesh, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> p0, boost::shared_ptr<const dolfin::GenericFunction> nu, boost::shared_ptr<const dolfin::GenericFunction> __improved_dual):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__improved_dual = *__improved_dual;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Constructor
  Form_6(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = mesh;
    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Constructor
  Form_6(boost::shared_ptr<const dolfin::Mesh> mesh, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __improved_dual):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = mesh;
    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__improved_dual = __improved_dual;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Constructor
  Form_6(boost::shared_ptr<const dolfin::Mesh> mesh, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> p0, boost::shared_ptr<const dolfin::GenericFunction> nu, boost::shared_ptr<const dolfin::GenericFunction> __improved_dual):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = mesh;
    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__improved_dual = *__improved_dual;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Destructor
  ~Form_6()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "p0")
      return 1;
    else if (name == "nu")
      return 2;
    else if (name == "__improved_dual")
      return 3;

    dolfin::error("Invalid coefficient.");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "p0";
    case 2:
      return "nu";
    case 3:
      return "__improved_dual";
    }

    dolfin::error("Invalid coefficient.");
    return "unnamed";
  }

  // Typedefs
  typedef Form_6_FunctionSpace_0 CoefficientSpace_w;
  typedef Form_6_FunctionSpace_1 CoefficientSpace_p0;
  typedef Form_6_FunctionSpace_2 CoefficientSpace_nu;
  typedef Form_6_FunctionSpace_3 CoefficientSpace___improved_dual;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner p0;
  dolfin::CoefficientAssigner nu;
  dolfin::CoefficientAssigner __improved_dual;
};

class Form_7_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_7_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()), mesh)))
  {
    // Do nothing
  }

  Form_7_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()), mesh)))
  {
    // Do nothing
  }

  Form_7_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()), *mesh)))
  {
      // Do nothing
  }

  Form_7_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()), *mesh)))
  {
      // Do nothing
  }

  ~Form_7_FunctionSpace_0()
  {
  }

};

typedef CoefficientSpace___improved_dual Form_7_FunctionSpace_1;

typedef CoefficientSpace___cell_residual Form_7_FunctionSpace_2;

typedef CoefficientSpace___facet_residual Form_7_FunctionSpace_3;

typedef CoefficientSpace___discrete_dual_solution Form_7_FunctionSpace_4;

class Form_7: public dolfin::Form
{
public:

  // Constructor
  Form_7(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Constructor
  Form_7(const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& __improved_dual, const dolfin::GenericFunction& __cell_residual, const dolfin::GenericFunction& __facet_residual, const dolfin::GenericFunction& __discrete_dual_solution):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->__improved_dual = __improved_dual;
    this->__cell_residual = __cell_residual;
    this->__facet_residual = __facet_residual;
    this->__discrete_dual_solution = __discrete_dual_solution;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Constructor
  Form_7(const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> __improved_dual, boost::shared_ptr<const dolfin::GenericFunction> __cell_residual, boost::shared_ptr<const dolfin::GenericFunction> __facet_residual, boost::shared_ptr<const dolfin::GenericFunction> __discrete_dual_solution):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->__improved_dual = *__improved_dual;
    this->__cell_residual = *__cell_residual;
    this->__facet_residual = *__facet_residual;
    this->__discrete_dual_solution = *__discrete_dual_solution;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Constructor
  Form_7(boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = V0;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Constructor
  Form_7(boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& __improved_dual, const dolfin::GenericFunction& __cell_residual, const dolfin::GenericFunction& __facet_residual, const dolfin::GenericFunction& __discrete_dual_solution):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = V0;

    this->__improved_dual = __improved_dual;
    this->__cell_residual = __cell_residual;
    this->__facet_residual = __facet_residual;
    this->__discrete_dual_solution = __discrete_dual_solution;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Constructor
  Form_7(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> __improved_dual, boost::shared_ptr<const dolfin::GenericFunction> __cell_residual, boost::shared_ptr<const dolfin::GenericFunction> __facet_residual, boost::shared_ptr<const dolfin::GenericFunction> __discrete_dual_solution):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = V0;

    this->__improved_dual = *__improved_dual;
    this->__cell_residual = *__cell_residual;
    this->__facet_residual = *__facet_residual;
    this->__discrete_dual_solution = *__discrete_dual_solution;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Destructor
  ~Form_7()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "__improved_dual")
      return 0;
    else if (name == "__cell_residual")
      return 1;
    else if (name == "__facet_residual")
      return 2;
    else if (name == "__discrete_dual_solution")
      return 3;

    dolfin::error("Invalid coefficient.");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "__improved_dual";
    case 1:
      return "__cell_residual";
    case 2:
      return "__facet_residual";
    case 3:
      return "__discrete_dual_solution";
    }

    dolfin::error("Invalid coefficient.");
    return "unnamed";
  }

  // Typedefs
  typedef Form_7_FunctionSpace_0 TestSpace;
  typedef Form_7_FunctionSpace_1 CoefficientSpace___improved_dual;
  typedef Form_7_FunctionSpace_2 CoefficientSpace___cell_residual;
  typedef Form_7_FunctionSpace_3 CoefficientSpace___facet_residual;
  typedef Form_7_FunctionSpace_4 CoefficientSpace___discrete_dual_solution;

  // Coefficients
  dolfin::CoefficientAssigner __improved_dual;
  dolfin::CoefficientAssigner __cell_residual;
  dolfin::CoefficientAssigner __facet_residual;
  dolfin::CoefficientAssigner __discrete_dual_solution;
};

class Form_8_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_8_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  Form_8_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  Form_8_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  Form_8_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  ~Form_8_FunctionSpace_0()
  {
  }

};

class Form_8_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  Form_8_FunctionSpace_1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  Form_8_FunctionSpace_1(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  Form_8_FunctionSpace_1(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  Form_8_FunctionSpace_1(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  ~Form_8_FunctionSpace_1()
  {
  }

};

typedef CoefficientSpace_w Form_8_FunctionSpace_2;

typedef CoefficientSpace_nu Form_8_FunctionSpace_3;

class Form_8: public dolfin::Form
{
public:

  // Constructor
  Form_8(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Constructor
  Form_8(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->w = w;
    this->nu = nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Constructor
  Form_8(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->w = *w;
    this->nu = *nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Constructor
  Form_8(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Constructor
  Form_8(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->w = w;
    this->nu = nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Constructor
  Form_8(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->w = *w;
    this->nu = *nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Destructor
  ~Form_8()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "nu")
      return 1;

    dolfin::error("Invalid coefficient.");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "nu";
    }

    dolfin::error("Invalid coefficient.");
    return "unnamed";
  }

  // Typedefs
  typedef Form_8_FunctionSpace_0 TestSpace;
  typedef Form_8_FunctionSpace_1 TrialSpace;
  typedef Form_8_FunctionSpace_2 CoefficientSpace_w;
  typedef Form_8_FunctionSpace_3 CoefficientSpace_nu;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner nu;
};

class Form_9_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_9_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  Form_9_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  Form_9_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  Form_9_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  ~Form_9_FunctionSpace_0()
  {
  }

};

typedef CoefficientSpace_w Form_9_FunctionSpace_1;

typedef CoefficientSpace_p0 Form_9_FunctionSpace_2;

typedef CoefficientSpace_nu Form_9_FunctionSpace_3;

class Form_9: public dolfin::Form
{
public:

  // Constructor
  Form_9(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Constructor
  Form_9(const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = w;
    this->p0 = p0;
    this->nu = nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Constructor
  Form_9(const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> p0, boost::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Constructor
  Form_9(boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = V0;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Constructor
  Form_9(boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = V0;

    this->w = w;
    this->p0 = p0;
    this->nu = nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Constructor
  Form_9(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> p0, boost::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = V0;

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Destructor
  ~Form_9()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "p0")
      return 1;
    else if (name == "nu")
      return 2;

    dolfin::error("Invalid coefficient.");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "p0";
    case 2:
      return "nu";
    }

    dolfin::error("Invalid coefficient.");
    return "unnamed";
  }

  // Typedefs
  typedef Form_9_FunctionSpace_0 TestSpace;
  typedef Form_9_FunctionSpace_1 CoefficientSpace_w;
  typedef Form_9_FunctionSpace_2 CoefficientSpace_p0;
  typedef Form_9_FunctionSpace_3 CoefficientSpace_nu;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner p0;
  dolfin::CoefficientAssigner nu;
};

typedef CoefficientSpace_w Form_10_FunctionSpace_0;

class Form_10: public dolfin::GoalFunctional
{
public:

  // Constructor
  Form_10(const dolfin::Mesh& mesh):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Constructor
  Form_10(const dolfin::Mesh& mesh, const dolfin::GenericFunction& w):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    this->w = w;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Constructor
  Form_10(const dolfin::Mesh& mesh, boost::shared_ptr<const dolfin::GenericFunction> w):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    this->w = *w;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Constructor
  Form_10(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = mesh;
    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Constructor
  Form_10(boost::shared_ptr<const dolfin::Mesh> mesh, const dolfin::GenericFunction& w):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = mesh;
    this->w = w;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Constructor
  Form_10(boost::shared_ptr<const dolfin::Mesh> mesh, boost::shared_ptr<const dolfin::GenericFunction> w):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = mesh;
    this->w = *w;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Destructor
  ~Form_10()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;

    dolfin::error("Invalid coefficient.");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    }

    dolfin::error("Invalid coefficient.");
    return "unnamed";
  }

  // Typedefs
  typedef Form_10_FunctionSpace_0 CoefficientSpace_w;

  // Coefficients
  dolfin::CoefficientAssigner w;

  /// Initialize all error control forms, attach coefficients and
  /// (re-)set error control
  virtual void update_ec(const dolfin::Form& a, const dolfin::Form& L)
  {
    // This stuff is created here and shipped elsewhere
    boost::shared_ptr<dolfin::Form> a_star;           // Dual lhs
    boost::shared_ptr<dolfin::Form> L_star;           // Dual rhs
    boost::shared_ptr<dolfin::FunctionSpace> V_Ez_h;  // Extrapolation space
    boost::shared_ptr<dolfin::Function> Ez_h;         // Extrapolated dual
    boost::shared_ptr<dolfin::Form> residual;         // Residual (as functional)
    boost::shared_ptr<dolfin::FunctionSpace> V_R_T;   // Trial space for cell residual
    boost::shared_ptr<dolfin::Form> a_R_T;            // Cell residual lhs
    boost::shared_ptr<dolfin::Form> L_R_T;            // Cell residual rhs
    boost::shared_ptr<dolfin::FunctionSpace> V_b_T;   // Function space for cell bubble
    boost::shared_ptr<dolfin::Function> b_T;          // Cell bubble
    boost::shared_ptr<dolfin::FunctionSpace> V_R_dT;  // Trial space for facet residual
    boost::shared_ptr<dolfin::Form> a_R_dT;           // Facet residual lhs
    boost::shared_ptr<dolfin::Form> L_R_dT;           // Facet residual rhs
    boost::shared_ptr<dolfin::FunctionSpace> V_b_e;   // Function space for cell cone
    boost::shared_ptr<dolfin::Function> b_e;          // Cell cone
    boost::shared_ptr<dolfin::FunctionSpace> V_eta_T; // Function space for indicators
    boost::shared_ptr<dolfin::Form> eta_T;            // Indicator form

    // Some handy views
    const dolfin::FunctionSpace& Vhat(*(a.function_space(0))); // Primal test
    const dolfin::FunctionSpace& V(*(a.function_space(1)));    // Primal trial
    const dolfin::Mesh& mesh(V.mesh());
    std::string name;

    // Initialize dual forms
    a_star.reset(new Form_0(V, Vhat));
    L_star.reset(new Form_1(V));

    dolfin::uint coefficient_number = 0;
    
    // Attach coefficients from a to a_star
    for (dolfin::uint i = 0; i < a.num_coefficients(); i++)
    {
      name = a.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed.)
      if (name == "__discrete_primal_solution")
        continue;

      try {
        coefficient_number = a_star->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to a_star";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      a_star->set_coefficient(name, a.coefficient(i));
    }
    
    // Attach subdomains from a to a_star
    a_star->dx = a.cell_domains_shared_ptr();
    a_star->ds = a.exterior_facet_domains_shared_ptr();
    a_star->dS = a.interior_facet_domains_shared_ptr();

    
    // Attach coefficients from (*this) to L_star
    for (dolfin::uint i = 0; i < (*this).num_coefficients(); i++)
    {
      name = (*this).coefficient_name(i);
      // Don't attach discrete primal solution here (not computed.)
      if (name == "__discrete_primal_solution")
        continue;

      try {
        coefficient_number = L_star->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to L_star";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      L_star->set_coefficient(name, (*this).coefficient(i));
    }
    
    // Attach subdomains from (*this) to L_star
    L_star->dx = (*this).cell_domains_shared_ptr();
    L_star->ds = (*this).exterior_facet_domains_shared_ptr();
    L_star->dS = (*this).interior_facet_domains_shared_ptr();


    // Initialize residual
    residual.reset(new Form_6(mesh));
    
    // Attach coefficients from a to residual
    for (dolfin::uint i = 0; i < a.num_coefficients(); i++)
    {
      name = a.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed.)
      if (name == "__discrete_primal_solution")
        continue;

      try {
        coefficient_number = residual->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to residual";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      residual->set_coefficient(name, a.coefficient(i));
    }
    

    // Attach coefficients from L to residual
    for (dolfin::uint i = 0; i < L.num_coefficients(); i++)
    {
      name = L.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed.)
      if (name == "__discrete_primal_solution")
        continue;

      try {
        coefficient_number = residual->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to residual";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      residual->set_coefficient(name, L.coefficient(i));
    }
    
    // Attach subdomains from L to residual
    residual->dx = L.cell_domains_shared_ptr();
    residual->ds = L.exterior_facet_domains_shared_ptr();
    residual->dS = L.interior_facet_domains_shared_ptr();


    // Initialize extrapolation space and (fake) extrapolation
    V_Ez_h.reset(new CoefficientSpace___improved_dual(mesh));
    Ez_h.reset(new dolfin::Function(V_Ez_h));
    residual->set_coefficient("__improved_dual", Ez_h);

    // Create bilinear and linear form for computing cell residual R_T
    V_R_T.reset(new Form_3::TestSpace(mesh));
    a_R_T.reset(new Form_2(V_R_T, V_R_T));
    L_R_T.reset(new Form_3(V_R_T));

    // Initialize bubble and attach to a_R_T and L_R_T
    V_b_T.reset(new CoefficientSpace___cell_bubble(mesh));
    b_T.reset(new dolfin::Function(V_b_T));
    b_T->vector() = 1.0;
    
    // Attach coefficients from a to L_R_T
    for (dolfin::uint i = 0; i < a.num_coefficients(); i++)
    {
      name = a.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed.)
      if (name == "__discrete_primal_solution")
        continue;

      try {
        coefficient_number = L_R_T->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to L_R_T";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      L_R_T->set_coefficient(name, a.coefficient(i));
    }
    

    // Attach coefficients from L to L_R_T
    for (dolfin::uint i = 0; i < L.num_coefficients(); i++)
    {
      name = L.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed.)
      if (name == "__discrete_primal_solution")
        continue;

      try {
        coefficient_number = L_R_T->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to L_R_T";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      L_R_T->set_coefficient(name, L.coefficient(i));
    }
    
    // Attach subdomains from L to L_R_T
    L_R_T->dx = L.cell_domains_shared_ptr();
    L_R_T->ds = L.exterior_facet_domains_shared_ptr();
    L_R_T->dS = L.interior_facet_domains_shared_ptr();


    // Attach bubble function to _a_R_T and _L_R_T
    a_R_T->set_coefficient("__cell_bubble", b_T);
    L_R_T->set_coefficient("__cell_bubble", b_T);

    // Create bilinear and linear form for computing facet residual R_dT
    V_R_dT.reset(new Form_5::TestSpace(mesh));
    a_R_dT.reset(new Form_4(V_R_dT, V_R_dT));
    L_R_dT.reset(new Form_5(V_R_dT));
    
    // Attach coefficients from a to L_R_dT
    for (dolfin::uint i = 0; i < a.num_coefficients(); i++)
    {
      name = a.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed.)
      if (name == "__discrete_primal_solution")
        continue;

      try {
        coefficient_number = L_R_dT->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to L_R_dT";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      L_R_dT->set_coefficient(name, a.coefficient(i));
    }
    

    // Attach coefficients from L to L_R_dT
    for (dolfin::uint i = 0; i < L.num_coefficients(); i++)
    {
      name = L.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed.)
      if (name == "__discrete_primal_solution")
        continue;

      try {
        coefficient_number = L_R_dT->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to L_R_dT";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      L_R_dT->set_coefficient(name, L.coefficient(i));
    }
    
    // Attach subdomains from L to L_R_dT
    L_R_dT->dx = L.cell_domains_shared_ptr();
    L_R_dT->ds = L.exterior_facet_domains_shared_ptr();
    L_R_dT->dS = L.interior_facet_domains_shared_ptr();


    // Initialize (fake) cone and attach to a_R_dT and L_R_dT
    V_b_e.reset(new CoefficientSpace___cell_cone(mesh));
    b_e.reset(new dolfin::Function(V_b_e));
    a_R_dT->set_coefficient("__cell_cone", b_e);
    L_R_dT->set_coefficient("__cell_cone", b_e);

    // Create error indicator form
    V_eta_T.reset(new Form_7::TestSpace(mesh));
    eta_T.reset(new Form_7(V_eta_T));

    // Update error control
    _ec.reset(new dolfin::ErrorControl(a_star, L_star, residual,
                                       a_R_T, L_R_T, a_R_dT, L_R_dT, eta_T,
                                       false));

  }

};

// Class typedefs
typedef Form_8 BilinearForm;
typedef Form_9 LinearForm;
typedef Form_10 GoalFunctional;

}

#endif
