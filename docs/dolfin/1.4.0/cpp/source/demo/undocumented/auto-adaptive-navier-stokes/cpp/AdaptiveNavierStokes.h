// This code conforms with the UFC specification version 1.4.0
// and was automatically generated by FFC version 1.4.0.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
// 
// This code was generated with the following parameters:
// 
//   cache_dir:                      ''
//   convert_exceptions_to_warnings: False
//   cpp_optimize:                   True
//   cpp_optimize_flags:             '-O2'
//   epsilon:                        1e-14
//   error_control:                  True
//   form_postfix:                   True
//   format:                         'dolfin'
//   log_level:                      10
//   log_prefix:                     ''
//   no_ferari:                      True
//   optimize:                       True
//   output_dir:                     '.'
//   precision:                      15
//   quadrature_degree:              'auto'
//   quadrature_rule:                'auto'
//   representation:                 'auto'
//   restrict_keyword:               ''
//   split:                          False

#ifndef __ADAPTIVENAVIERSTOKES_H
#define __ADAPTIVENAVIERSTOKES_H

#include <cmath>
#include <stdexcept>
#include <fstream>
#include <ufc.h>

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_0: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_0()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Discontinuous Lagrange', Domain(Cell('triangle', 2)), 0, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 1;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    
    // Get coordinates and map to the reference (FIAT) element
    
    // Reset values
    *values = 0.0;
    
    // Array of basisvalues
    double basisvalues[1] = {0.0};
    
    // Declare helper variables
    
    // Compute basisvalues
    basisvalues[0] = 1.0;
    
    // Table(s) of coefficients
    static const double coefficients0[1] = \
    {1.0};
    
    // Compute value(s)
    for (unsigned int r = 0; r < 1; r++)
    {
      *values += coefficients0[r]*basisvalues[r];
    } // end loop over 'r'
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Element is constant, calling evaluate_basis.
    _evaluate_basis(0, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 0)
    {
    return ;
    }
    
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Element is constant, calling evaluate_basis_derivatives.
    _evaluate_basis_derivatives(0, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
    vertex_values[2] = dof_values[0];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_0();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_1: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_1()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Bubble', Domain(Cell('triangle', 2)), 3, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 1;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    *values = 0.0;
    
    // Array of basisvalues
    double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
    
    // Declare helper variables
    double tmp0 = (1.0 + Y + 2.0*X)/2.0;
    double tmp1 = (1.0 - Y)/2.0;
    double tmp2 = tmp1*tmp1;
    
    // Compute basisvalues
    basisvalues[0] = 1.0;
    basisvalues[1] = tmp0;
    basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
    basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
    basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
    basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
    basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
    basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
    basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
    basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
    basisvalues[0] *= std::sqrt(0.5);
    basisvalues[2] *= std::sqrt(1.0);
    basisvalues[5] *= std::sqrt(1.5);
    basisvalues[9] *= std::sqrt(2.0);
    basisvalues[1] *= std::sqrt(3.0);
    basisvalues[4] *= std::sqrt(4.5);
    basisvalues[8] *= std::sqrt(6.0);
    basisvalues[3] *= std::sqrt(7.5);
    basisvalues[7] *= std::sqrt(10.0);
    basisvalues[6] *= std::sqrt(14.0);
    
    // Table(s) of coefficients
    static const double coefficients0[10] = \
    {0.636396103067893, 0.0, 0.0, -0.234738238930785, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.090913729009699};
    
    // Compute value(s)
    for (unsigned int r = 0; r < 10; r++)
    {
      *values += coefficients0[r]*basisvalues[r];
    } // end loop over 'r'
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Element is constant, calling evaluate_basis.
    _evaluate_basis(0, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 3)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[8][3];
    for (unsigned int row = 0; row < 8; row++)
    {
      for (unsigned int col = 0; col < 3; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K[0], K[1]}, {K[2], K[3]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[8][8];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Array of basisvalues
    double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
    
    // Declare helper variables
    double tmp0 = (1.0 + Y + 2.0*X)/2.0;
    double tmp1 = (1.0 - Y)/2.0;
    double tmp2 = tmp1*tmp1;
    
    // Compute basisvalues
    basisvalues[0] = 1.0;
    basisvalues[1] = tmp0;
    basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
    basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
    basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
    basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
    basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
    basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
    basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
    basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
    basisvalues[0] *= std::sqrt(0.5);
    basisvalues[2] *= std::sqrt(1.0);
    basisvalues[5] *= std::sqrt(1.5);
    basisvalues[9] *= std::sqrt(2.0);
    basisvalues[1] *= std::sqrt(3.0);
    basisvalues[4] *= std::sqrt(4.5);
    basisvalues[8] *= std::sqrt(6.0);
    basisvalues[3] *= std::sqrt(7.5);
    basisvalues[7] *= std::sqrt(10.0);
    basisvalues[6] *= std::sqrt(14.0);
    
    // Table(s) of coefficients
    static const double coefficients0[10] = \
    {0.636396103067893, 0.0, 0.0, -0.234738238930785, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.090913729009699};
    
    // Tables of derivatives of the polynomial base (transpose).
    static const double dmats0[10][10] = \
    {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
    {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
    {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
    
    static const double dmats1[10][10] = \
    {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
    {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
    {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
    {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
    
    // Compute reference derivatives.
    // Declare array of derivatives on FIAT element.
    double derivatives[8];
    for (unsigned int r = 0; r < 8; r++)
    {
      derivatives[r] = 0.0;
    } // end loop over 'r'
    
    // Declare derivative matrix (of polynomial basis).
    double dmats[10][10] = \
    {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
    
    // Declare (auxiliary) derivative matrix (of polynomial basis).
    double dmats_old[10][10] = \
    {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
    
    // Loop possible derivatives.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      // Resetting dmats values to compute next derivative.
      for (unsigned int t = 0; t < 10; t++)
      {
        for (unsigned int u = 0; u < 10; u++)
        {
          dmats[t][u] = 0.0;
          if (t == u)
          {
          dmats[t][u] = 1.0;
          }
          
        } // end loop over 'u'
      } // end loop over 't'
      
      // Looping derivative order to generate dmats.
      for (unsigned int s = 0; s < n; s++)
      {
        // Updating dmats_old with new values and resetting dmats.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats_old[t][u] = dmats[t][u];
            dmats[t][u] = 0.0;
          } // end loop over 'u'
        } // end loop over 't'
        
        // Update dmats using an inner product.
        if (combinations[r][s] == 0)
        {
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            for (unsigned int tu = 0; tu < 10; tu++)
            {
              dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
            } // end loop over 'tu'
          } // end loop over 'u'
        } // end loop over 't'
        }
        
        if (combinations[r][s] == 1)
        {
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            for (unsigned int tu = 0; tu < 10; tu++)
            {
              dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
            } // end loop over 'tu'
          } // end loop over 'u'
        } // end loop over 't'
        }
        
      } // end loop over 's'
      for (unsigned int s = 0; s < 10; s++)
      {
        for (unsigned int t = 0; t < 10; t++)
        {
          derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
        } // end loop over 't'
      } // end loop over 's'
    } // end loop over 'r'
    
    // Transform derivatives back to physical element
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r] += transform[r][s]*derivatives[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Element is constant, calling evaluate_basis_derivatives.
    _evaluate_basis_derivatives(0, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = 0;
    vertex_values[1] = 0;
    vertex_values[2] = 0;
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_1();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_2: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_2() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_2()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Discontinuous Lagrange', Domain(Cell('triangle', 2)), 2, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 6;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 6; r++)
    {
      _evaluate_basis(r, &dof_values, x, vertex_coordinates, cell_orientation);
      values[r] = dof_values;
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[4][2];
    for (unsigned int row = 0; row < 4; row++)
    {
      for (unsigned int col = 0; col < 2; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K[0], K[1]}, {K[2], K[3]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[4][4];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 6; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[4];
    for (unsigned int r = 0; r < 4; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 6; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_2();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_3: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_3() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_3()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(FiniteElement('Discontinuous Lagrange', Domain(Cell('triangle', 2)), 2, None), FiniteElement('Discontinuous Lagrange', Domain(Cell('triangle', 2)), 2, None), **{'value_shape': (2,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 12;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    values[0] = 0.0;
    values[1] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {0.0, 0.0};
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 12; r++)
    {
      _evaluate_basis(r, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 2; s++)
      {
        values[r*2 + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[4][2];
    for (unsigned int row = 0; row < 4; row++)
    {
      for (unsigned int col = 0; col < 2; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K[0], K[1]}, {K[2], K[3]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[4][4];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 12; r++)
    {
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[8];
    for (unsigned int r = 0; r < 8; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 12; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[2];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[2];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[3] = dof_values[7];
    vertex_values[5] = dof_values[8];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_2();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_3();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_4: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_4() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_4()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Discontinuous Lagrange', Domain(Cell('triangle', 2)), 1, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 3;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 3; r++)
    {
      _evaluate_basis(r, &dof_values, x, vertex_coordinates, cell_orientation);
      values[r] = dof_values;
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[2][1];
    for (unsigned int row = 0; row < 2; row++)
    {
      for (unsigned int col = 0; col < 1; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K[0], K[1]}, {K[2], K[3]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[2][2];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[2];
      for (unsigned int r = 0; r < 2; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[2];
      for (unsigned int r = 0; r < 2; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[2];
      for (unsigned int r = 0; r < 2; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 3; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[2];
    for (unsigned int r = 0; r < 2; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 3; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_4();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_5: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_5() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_5()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(MixedElement(FiniteElement('Discontinuous Lagrange', Domain(Cell('triangle', 2)), 2, None), FiniteElement('Discontinuous Lagrange', Domain(Cell('triangle', 2)), 2, None), **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Domain(Cell('triangle', 2)), 1, None), **{'value_shape': (3,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    values[0] = 0.0;
    values[1] = 0.0;
    values[2] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.0, 0.0, 0.0};
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 15; r++)
    {
      _evaluate_basis(r, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[4][2];
    for (unsigned int row = 0; row < 4; row++)
    {
      for (unsigned int col = 0; col < 2; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K[0], K[1]}, {K[2], K[3]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[4][4];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 15; r++)
    {
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[12];
    for (unsigned int r = 0; r < 12; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 15; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 12:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 13:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 14:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[12] = vals[2];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[13] = vals[2];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[14] = vals[2];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[4] = dof_values[7];
    vertex_values[7] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[12];
    vertex_values[5] = dof_values[13];
    vertex_values[8] = dof_values[14];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_3();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_4();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_5();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_6: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_6() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_6()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 3, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 10;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.0909137290096989};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807678, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930785, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 10; r++)
    {
      _evaluate_basis(r, &dof_values, x, vertex_coordinates, cell_orientation);
      values[r] = dof_values;
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 3)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[8][3];
    for (unsigned int row = 0; row < 8; row++)
    {
      for (unsigned int col = 0; col < 3; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K[0], K[1]}, {K[2], K[3]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[8][8];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524248};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524248};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.0909137290096989};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807678, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524248};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930785, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 10; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 3)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[8];
    for (unsigned int r = 0; r < 8; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 10; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 7:
      {
        y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
      y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 8:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 9:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
    y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_6();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_7: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_7() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_7()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 3, None), FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 3, None), **{'value_shape': (2,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 20;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    values[0] = 0.0;
    values[1] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.0909137290096989};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807678, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930785, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.0909137290096989};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 15:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 16:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 17:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 18:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807678, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 19:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930785, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {0.0, 0.0};
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 20; r++)
    {
      _evaluate_basis(r, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 2; s++)
      {
        values[r*2 + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 3)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[8][3];
    for (unsigned int row = 0; row < 8; row++)
    {
      for (unsigned int col = 0; col < 3; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K[0], K[1]}, {K[2], K[3]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[8][8];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524248};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524248};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.0909137290096989};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807678, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524248};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930785, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524248};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524248};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.0909137290096989};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 15:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 16:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 17:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 18:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807678, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524248};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 19:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930785, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 20; r++)
    {
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 3)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[16];
    for (unsigned int r = 0; r < 16; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 20; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[2];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 7:
      {
        y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
      y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 8:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 9:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 10:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 12:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 13:
      {
        y[0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 14:
      {
        y[0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 15:
      {
        y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 16:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 17:
      {
        y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
      y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 18:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 19:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[2];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
    y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[12] = vals[1];
    y[0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[13] = vals[1];
    y[0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[14] = vals[1];
    y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[15] = vals[1];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[16] = vals[1];
    y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
    y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[17] = vals[1];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[18] = vals[1];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[19] = vals[1];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[10];
    vertex_values[3] = dof_values[11];
    vertex_values[5] = dof_values[12];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_6();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_6();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_7();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_8: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_8() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_8()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 2, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 6;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 6; r++)
    {
      _evaluate_basis(r, &dof_values, x, vertex_coordinates, cell_orientation);
      values[r] = dof_values;
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[4][2];
    for (unsigned int row = 0; row < 4; row++)
    {
      for (unsigned int col = 0; col < 2; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K[0], K[1]}, {K[2], K[3]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[4][4];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 6; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[4];
    for (unsigned int r = 0; r < 4; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 6; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_8();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_9: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_9() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_9()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(MixedElement(FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 3, None), FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 3, None), **{'value_shape': (2,) }), FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 2, None), **{'value_shape': (3,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 26;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    values[0] = 0.0;
    values[1] = 0.0;
    values[2] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.0909137290096989};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807678, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930785, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.0909137290096989};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 15:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 16:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 17:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 18:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807678, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524248};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 19:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930785, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.090913729009699};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 20:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 21:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 22:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 23:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 24:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 25:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.0, 0.0, 0.0};
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 26; r++)
    {
      _evaluate_basis(r, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 3)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[8][3];
    for (unsigned int row = 0; row < 8; row++)
    {
      for (unsigned int col = 0; col < 3; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K[0], K[1]}, {K[2], K[3]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[8][8];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524248};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524248};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.0909137290096989};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807678, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524248};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930785, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524248};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524248};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.0471404520791031, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.0909137290096989};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 15:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 16:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 17:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 18:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807678, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524248};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 19:
      {
        
      // Array of basisvalues
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930785, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050513, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660778, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872628, -1.49666295470957, 6.83130051063973, -1.05830052442584, 0.305505046330389, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002067, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756887, -5.09116882454314, 3.91918358845309, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 20:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 21:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 22:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 23:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 24:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 25:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[8];
      for (unsigned int r = 0; r < 8; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 26; r++)
    {
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 3)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[24];
    for (unsigned int r = 0; r < 24; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 26; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 7:
      {
        y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
      y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 8:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 9:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 10:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 12:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 13:
      {
        y[0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 14:
      {
        y[0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 15:
      {
        y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 16:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 17:
      {
        y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
      y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 18:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 19:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 20:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 21:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 22:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 23:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 24:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 25:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
    y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[12] = vals[1];
    y[0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[13] = vals[1];
    y[0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[14] = vals[1];
    y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[15] = vals[1];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[16] = vals[1];
    y[0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
    y[1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[17] = vals[1];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[18] = vals[1];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[19] = vals[1];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[20] = vals[2];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[21] = vals[2];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[22] = vals[2];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[23] = vals[2];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[24] = vals[2];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[25] = vals[2];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[10];
    vertex_values[4] = dof_values[11];
    vertex_values[7] = dof_values[12];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[20];
    vertex_values[5] = dof_values[21];
    vertex_values[8] = dof_values[22];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_7();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_8();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_9();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_10: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_10() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_10()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Real', Domain(Cell('triangle', 2)), 0, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 1;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    
    // Get coordinates and map to the reference (FIAT) element
    
    // Reset values
    *values = 0.0;
    
    // Array of basisvalues
    double basisvalues[1] = {0.0};
    
    // Declare helper variables
    
    // Compute basisvalues
    basisvalues[0] = 1.0;
    
    // Table(s) of coefficients
    static const double coefficients0[1] = \
    {1.0};
    
    // Compute value(s)
    for (unsigned int r = 0; r < 1; r++)
    {
      *values += coefficients0[r]*basisvalues[r];
    } // end loop over 'r'
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Element is constant, calling evaluate_basis.
    _evaluate_basis(0, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 0)
    {
    return ;
    }
    
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Element is constant, calling evaluate_basis_derivatives.
    _evaluate_basis_derivatives(0, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
      y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    y[1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
    vertex_values[2] = dof_values[0];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_10();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_11: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_11() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_11()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "VectorElement('Lagrange', Domain(Cell('triangle', 2)), 2, 2, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 12;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    values[0] = 0.0;
    values[1] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {0.0, 0.0};
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 12; r++)
    {
      _evaluate_basis(r, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 2; s++)
      {
        values[r*2 + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[4][2];
    for (unsigned int row = 0; row < 4; row++)
    {
      for (unsigned int col = 0; col < 2; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K[0], K[1]}, {K[2], K[3]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[4][4];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 12; r++)
    {
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[8];
    for (unsigned int r = 0; r < 8; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 12; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[2];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[2];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[3] = dof_values[7];
    vertex_values[5] = dof_values[8];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_8();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_8();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_11();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_12: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_12() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_12()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 1, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 3;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 3; r++)
    {
      _evaluate_basis(r, &dof_values, x, vertex_coordinates, cell_orientation);
      values[r] = dof_values;
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[2][1];
    for (unsigned int row = 0; row < 2; row++)
    {
      for (unsigned int col = 0; col < 1; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K[0], K[1]}, {K[2], K[3]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[2][2];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[2];
      for (unsigned int r = 0; r < 2; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[2];
      for (unsigned int r = 0; r < 2; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[2];
      for (unsigned int r = 0; r < 2; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 3; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 1)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[2];
    for (unsigned int r = 0; r < 2; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 3; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[1];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_12();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_13: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_13() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_13()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(VectorElement('Lagrange', Domain(Cell('triangle', 2)), 2, 2, None), FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 1, None), **{'value_shape': (3,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual std::size_t space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual std::size_t value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual std::size_t value_dimension(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation)
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Reset values
    values[0] = 0.0;
    values[1] = 0.0;
    values[2] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Compute value(s)
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis(std::size_t i,
                              double* values,
                              const double* x,
                              const double* vertex_coordinates,
                              int cell_orientation) const
  {
    _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation)
  {
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.0, 0.0, 0.0};
    
    // Loop dofs and call evaluate_basis
    for (unsigned int r = 0; r < 15; r++)
    {
      _evaluate_basis(r, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_all(double* values,
                                  const double* x,
                                  const double* vertex_coordinates,
                                  int cell_orientation) const
  {
    _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation)
  {
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      values[r] = 0.0;
    } // end loop over 'r'
    
    // Call evaluate_basis if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis(i, values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
    return ;
    }
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    // Compute constants
    const double C0 = vertex_coordinates[2] + vertex_coordinates[4];
    const double C1 = vertex_coordinates[3] + vertex_coordinates[5];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J[1]*(C1 - 2.0*x[1]) + J[3]*(2.0*x[0] - C0)) / detJ;
    double Y = (J[0]*(2.0*x[1] - C1) + J[2]*(C0 - 2.0*x[0])) / detJ;
    
    // Declare two dimensional array that holds combinations of derivatives and initialise
    unsigned int combinations[4][2];
    for (unsigned int row = 0; row < 4; row++)
    {
      for (unsigned int col = 0; col < 2; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K[0], K[1]}, {K[2], K[3]}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double transform[4][4];
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582063, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582064, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare array of derivatives on FIAT element.
      double derivatives[4];
      for (unsigned int r = 0; r < 4; r++)
      {
        derivatives[r] = 0.0;
      } // end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          } // end loop over 'u'
        } // end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            } // end loop over 'u'
          } // end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              } // end loop over 'tu'
            } // end loop over 'u'
          } // end loop over 't'
          }
          
        } // end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          } // end loop over 't'
        } // end loop over 's'
      } // end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        } // end loop over 's'
      } // end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of basis function i at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives(std::size_t i,
                                          std::size_t n,
                                          double* values,
                                          const double* x,
                                          const double* vertex_coordinates,
                                          int cell_orientation) const
  {
    _evaluate_basis_derivatives(i, n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (actual implementation)
  static void _evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation)
  {
    // Call evaluate_basis_all if order of derivatives is equal to zero.
    if (n == 0)
    {
      _evaluate_basis_all(values, x, vertex_coordinates, cell_orientation);
      return ;
    }
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    } // end loop over 'r'
    
    // Set values equal to zero.
    for (unsigned int r = 0; r < 15; r++)
    {
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = 0.0;
      } // end loop over 's'
    } // end loop over 'r'
    
    // If order of derivatives is greater than the maximum polynomial degree, return zeros.
    if (n > 2)
    {
      return ;
    }
    
    // Helper variable to hold values of a single dof.
    double dof_values[12];
    for (unsigned int r = 0; r < 12; r++)
    {
      dof_values[r] = 0.0;
    } // end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 15; r++)
    {
      _evaluate_basis_derivatives(r, n, dof_values, x, vertex_coordinates, cell_orientation);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      } // end loop over 's'
    } // end loop over 'r'
  }

  /// Evaluate order n derivatives of all basis functions at given point x in cell (non-static member function)
  virtual void evaluate_basis_derivatives_all(std::size_t n,
                                              double* values,
                                              const double* x,
                                              const double* vertex_coordinates,
                                              int cell_orientation) const
  {
    _evaluate_basis_derivatives_all(n, values, x, vertex_coordinates, cell_orientation);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(std::size_t i,
                              const ufc::function& f,
                              const double* vertex_coordinates,
                              int cell_orientation,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[2];
    switch (i)
    {
    case 0:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
      y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 12:
      {
        y[0] = vertex_coordinates[0];
      y[1] = vertex_coordinates[1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 13:
      {
        y[0] = vertex_coordinates[2];
      y[1] = vertex_coordinates[3];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 14:
      {
        y[0] = vertex_coordinates[4];
      y[1] = vertex_coordinates[5];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const double* vertex_coordinates,
                             int cell_orientation,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation
    double vals[3];
    
    // Declare variable for physical coordinates
    double y[2];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    y[1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = vertex_coordinates[0];
    y[1] = vertex_coordinates[1];
    f.evaluate(vals, y, c);
    values[12] = vals[2];
    y[0] = vertex_coordinates[2];
    y[1] = vertex_coordinates[3];
    f.evaluate(vals, y, c);
    values[13] = vals[2];
    y[0] = vertex_coordinates[4];
    y[1] = vertex_coordinates[5];
    f.evaluate(vals, y, c);
    values[14] = vals[2];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const double* vertex_coordinates,
                                         int cell_orientation,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[4] = dof_values[7];
    vertex_values[7] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[12];
    vertex_values[5] = dof_values[13];
    vertex_values[8] = dof_values[14];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented.");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented.");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual std::size_t num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_11();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_13();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_0: public ufc::dofmap
{
public:

  /// Constructor
  adaptivenavierstokes_dofmap_0() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_0()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Discontinuous Lagrange', Domain(Cell('triangle', 2)), 0, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return num_global_entities[2];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 1;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 1;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    dofs[0] = c.entity_indices[2][0];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[0][1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_0();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_1: public ufc::dofmap
{
public:

  /// Constructor
  adaptivenavierstokes_dofmap_1() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_1()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Bubble', Domain(Cell('triangle', 2)), 3, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return num_global_entities[2];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 1;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 1;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    dofs[0] = c.entity_indices[2][0];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[0][1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_1();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_2: public ufc::dofmap
{
public:

  /// Constructor
  adaptivenavierstokes_dofmap_2() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_2()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Discontinuous Lagrange', Domain(Cell('triangle', 2)), 2, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return 6*num_global_entities[2];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 6;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 6;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    dofs[0] = 6*c.entity_indices[2][0];
    dofs[1] = 6*c.entity_indices[2][0] + 1;
    dofs[2] = 6*c.entity_indices[2][0] + 2;
    dofs[3] = 6*c.entity_indices[2][0] + 3;
    dofs[4] = 6*c.entity_indices[2][0] + 4;
    dofs[5] = 6*c.entity_indices[2][0] + 5;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      dofs[3] = 3;
      dofs[4] = 4;
      dofs[5] = 5;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = vertex_coordinates[0];
    dof_coordinates[0][1] = vertex_coordinates[1];
    dof_coordinates[1][0] = vertex_coordinates[2];
    dof_coordinates[1][1] = vertex_coordinates[3];
    dof_coordinates[2][0] = vertex_coordinates[4];
    dof_coordinates[2][1] = vertex_coordinates[5];
    dof_coordinates[3][0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[3][1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[4][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[4][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[5][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[5][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_2();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_3: public ufc::dofmap
{
public:

  /// Constructor
  adaptivenavierstokes_dofmap_3() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_3()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(FiniteElement('Discontinuous Lagrange', Domain(Cell('triangle', 2)), 2, None), FiniteElement('Discontinuous Lagrange', Domain(Cell('triangle', 2)), 2, None), **{'value_shape': (2,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return 12*num_global_entities[2];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 12;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 12;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + 6*c.entity_indices[2][0];
    dofs[1] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[2] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[3] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[4] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[5] = offset + 6*c.entity_indices[2][0] + 5;
    offset += 6*num_global_entities[2];
    dofs[6] = offset + 6*c.entity_indices[2][0];
    dofs[7] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[8] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[9] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[10] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[11] = offset + 6*c.entity_indices[2][0] + 5;
    offset += 6*num_global_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      dofs[3] = 3;
      dofs[4] = 4;
      dofs[5] = 5;
      dofs[6] = 6;
      dofs[7] = 7;
      dofs[8] = 8;
      dofs[9] = 9;
      dofs[10] = 10;
      dofs[11] = 11;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = vertex_coordinates[0];
    dof_coordinates[0][1] = vertex_coordinates[1];
    dof_coordinates[1][0] = vertex_coordinates[2];
    dof_coordinates[1][1] = vertex_coordinates[3];
    dof_coordinates[2][0] = vertex_coordinates[4];
    dof_coordinates[2][1] = vertex_coordinates[5];
    dof_coordinates[3][0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[3][1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[4][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[4][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[5][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[5][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[6][0] = vertex_coordinates[0];
    dof_coordinates[6][1] = vertex_coordinates[1];
    dof_coordinates[7][0] = vertex_coordinates[2];
    dof_coordinates[7][1] = vertex_coordinates[3];
    dof_coordinates[8][0] = vertex_coordinates[4];
    dof_coordinates[8][1] = vertex_coordinates[5];
    dof_coordinates[9][0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[9][1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[10][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[10][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[11][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[11][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_2();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_3();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_4: public ufc::dofmap
{
public:

  /// Constructor
  adaptivenavierstokes_dofmap_4() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_4()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Discontinuous Lagrange', Domain(Cell('triangle', 2)), 1, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return 3*num_global_entities[2];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 3;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    dofs[0] = 3*c.entity_indices[2][0];
    dofs[1] = 3*c.entity_indices[2][0] + 1;
    dofs[2] = 3*c.entity_indices[2][0] + 2;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = vertex_coordinates[0];
    dof_coordinates[0][1] = vertex_coordinates[1];
    dof_coordinates[1][0] = vertex_coordinates[2];
    dof_coordinates[1][1] = vertex_coordinates[3];
    dof_coordinates[2][0] = vertex_coordinates[4];
    dof_coordinates[2][1] = vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_4();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_5: public ufc::dofmap
{
public:

  /// Constructor
  adaptivenavierstokes_dofmap_5() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_5()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(MixedElement(FiniteElement('Discontinuous Lagrange', Domain(Cell('triangle', 2)), 2, None), FiniteElement('Discontinuous Lagrange', Domain(Cell('triangle', 2)), 2, None), **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Domain(Cell('triangle', 2)), 1, None), **{'value_shape': (3,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return 15*num_global_entities[2];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 15;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 15;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + 6*c.entity_indices[2][0];
    dofs[1] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[2] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[3] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[4] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[5] = offset + 6*c.entity_indices[2][0] + 5;
    offset += 6*num_global_entities[2];
    dofs[6] = offset + 6*c.entity_indices[2][0];
    dofs[7] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[8] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[9] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[10] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[11] = offset + 6*c.entity_indices[2][0] + 5;
    offset += 6*num_global_entities[2];
    dofs[12] = offset + 3*c.entity_indices[2][0];
    dofs[13] = offset + 3*c.entity_indices[2][0] + 1;
    dofs[14] = offset + 3*c.entity_indices[2][0] + 2;
    offset += 3*num_global_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      dofs[3] = 3;
      dofs[4] = 4;
      dofs[5] = 5;
      dofs[6] = 6;
      dofs[7] = 7;
      dofs[8] = 8;
      dofs[9] = 9;
      dofs[10] = 10;
      dofs[11] = 11;
      dofs[12] = 12;
      dofs[13] = 13;
      dofs[14] = 14;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = vertex_coordinates[0];
    dof_coordinates[0][1] = vertex_coordinates[1];
    dof_coordinates[1][0] = vertex_coordinates[2];
    dof_coordinates[1][1] = vertex_coordinates[3];
    dof_coordinates[2][0] = vertex_coordinates[4];
    dof_coordinates[2][1] = vertex_coordinates[5];
    dof_coordinates[3][0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[3][1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[4][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[4][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[5][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[5][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[6][0] = vertex_coordinates[0];
    dof_coordinates[6][1] = vertex_coordinates[1];
    dof_coordinates[7][0] = vertex_coordinates[2];
    dof_coordinates[7][1] = vertex_coordinates[3];
    dof_coordinates[8][0] = vertex_coordinates[4];
    dof_coordinates[8][1] = vertex_coordinates[5];
    dof_coordinates[9][0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[9][1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[10][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[10][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[11][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[11][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[12][0] = vertex_coordinates[0];
    dof_coordinates[12][1] = vertex_coordinates[1];
    dof_coordinates[13][0] = vertex_coordinates[2];
    dof_coordinates[13][1] = vertex_coordinates[3];
    dof_coordinates[14][0] = vertex_coordinates[4];
    dof_coordinates[14][1] = vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_3();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_4();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_5();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_6: public ufc::dofmap
{
public:

  /// Constructor
  adaptivenavierstokes_dofmap_6() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_6()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 3, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return num_global_entities[0] + 2*num_global_entities[1] + num_global_entities[2];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 10;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 4;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 2;
        break;
      }
    case 2:
      {
        return 1;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + 2*c.entity_indices[1][0];
    dofs[4] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[5] = offset + 2*c.entity_indices[1][1];
    dofs[6] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[7] = offset + 2*c.entity_indices[1][2];
    dofs[8] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*num_global_entities[1];
    dofs[9] = offset + c.entity_indices[2][0];
    offset += num_global_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 5;
      dofs[3] = 6;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 7;
      dofs[3] = 8;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 4;
          break;
        }
      case 1:
        {
          dofs[0] = 5;
        dofs[1] = 6;
          break;
        }
      case 2:
        {
          dofs[0] = 7;
        dofs[1] = 8;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 9;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = vertex_coordinates[0];
    dof_coordinates[0][1] = vertex_coordinates[1];
    dof_coordinates[1][0] = vertex_coordinates[2];
    dof_coordinates[1][1] = vertex_coordinates[3];
    dof_coordinates[2][0] = vertex_coordinates[4];
    dof_coordinates[2][1] = vertex_coordinates[5];
    dof_coordinates[3][0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[3][1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[4][0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
    dof_coordinates[4][1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
    dof_coordinates[5][0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[5][1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[6][0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
    dof_coordinates[6][1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
    dof_coordinates[7][0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
    dof_coordinates[7][1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
    dof_coordinates[8][0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
    dof_coordinates[8][1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
    dof_coordinates[9][0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[9][1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_6();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_7: public ufc::dofmap
{
public:

  /// Constructor
  adaptivenavierstokes_dofmap_7() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_7()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 3, None), FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 3, None), **{'value_shape': (2,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return 2*num_global_entities[0] + 4*num_global_entities[1] + 2*num_global_entities[2];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 20;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 8;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 2;
        break;
      }
    case 1:
      {
        return 4;
        break;
      }
    case 2:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + 2*c.entity_indices[1][0];
    dofs[4] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[5] = offset + 2*c.entity_indices[1][1];
    dofs[6] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[7] = offset + 2*c.entity_indices[1][2];
    dofs[8] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*num_global_entities[1];
    dofs[9] = offset + c.entity_indices[2][0];
    offset += num_global_entities[2];
    dofs[10] = offset + c.entity_indices[0][0];
    dofs[11] = offset + c.entity_indices[0][1];
    dofs[12] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[13] = offset + 2*c.entity_indices[1][0];
    dofs[14] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[15] = offset + 2*c.entity_indices[1][1];
    dofs[16] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[17] = offset + 2*c.entity_indices[1][2];
    dofs[18] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*num_global_entities[1];
    dofs[19] = offset + c.entity_indices[2][0];
    offset += num_global_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 11;
      dofs[5] = 12;
      dofs[6] = 13;
      dofs[7] = 14;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 10;
      dofs[5] = 12;
      dofs[6] = 15;
      dofs[7] = 16;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 7;
      dofs[3] = 8;
      dofs[4] = 10;
      dofs[5] = 11;
      dofs[6] = 17;
      dofs[7] = 18;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 10;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 11;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 12;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 4;
        dofs[2] = 13;
        dofs[3] = 14;
          break;
        }
      case 1:
        {
          dofs[0] = 5;
        dofs[1] = 6;
        dofs[2] = 15;
        dofs[3] = 16;
          break;
        }
      case 2:
        {
          dofs[0] = 7;
        dofs[1] = 8;
        dofs[2] = 17;
        dofs[3] = 18;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 9;
      dofs[1] = 19;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = vertex_coordinates[0];
    dof_coordinates[0][1] = vertex_coordinates[1];
    dof_coordinates[1][0] = vertex_coordinates[2];
    dof_coordinates[1][1] = vertex_coordinates[3];
    dof_coordinates[2][0] = vertex_coordinates[4];
    dof_coordinates[2][1] = vertex_coordinates[5];
    dof_coordinates[3][0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[3][1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[4][0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
    dof_coordinates[4][1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
    dof_coordinates[5][0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[5][1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[6][0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
    dof_coordinates[6][1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
    dof_coordinates[7][0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
    dof_coordinates[7][1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
    dof_coordinates[8][0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
    dof_coordinates[8][1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
    dof_coordinates[9][0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[9][1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[10][0] = vertex_coordinates[0];
    dof_coordinates[10][1] = vertex_coordinates[1];
    dof_coordinates[11][0] = vertex_coordinates[2];
    dof_coordinates[11][1] = vertex_coordinates[3];
    dof_coordinates[12][0] = vertex_coordinates[4];
    dof_coordinates[12][1] = vertex_coordinates[5];
    dof_coordinates[13][0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[13][1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[14][0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
    dof_coordinates[14][1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
    dof_coordinates[15][0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[15][1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[16][0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
    dof_coordinates[16][1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
    dof_coordinates[17][0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
    dof_coordinates[17][1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
    dof_coordinates[18][0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
    dof_coordinates[18][1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
    dof_coordinates[19][0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[19][1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_6();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_6();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_7();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_8: public ufc::dofmap
{
public:

  /// Constructor
  adaptivenavierstokes_dofmap_8() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_8()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 2, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return num_global_entities[0] + num_global_entities[1];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 6;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 3;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 1;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += num_global_entities[1];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = vertex_coordinates[0];
    dof_coordinates[0][1] = vertex_coordinates[1];
    dof_coordinates[1][0] = vertex_coordinates[2];
    dof_coordinates[1][1] = vertex_coordinates[3];
    dof_coordinates[2][0] = vertex_coordinates[4];
    dof_coordinates[2][1] = vertex_coordinates[5];
    dof_coordinates[3][0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[3][1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[4][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[4][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[5][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[5][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_8();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_9: public ufc::dofmap
{
public:

  /// Constructor
  adaptivenavierstokes_dofmap_9() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_9()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(MixedElement(FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 3, None), FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 3, None), **{'value_shape': (2,) }), FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 2, None), **{'value_shape': (3,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return 3*num_global_entities[0] + 5*num_global_entities[1] + 2*num_global_entities[2];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 26;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 11;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 3;
        break;
      }
    case 1:
      {
        return 5;
        break;
      }
    case 2:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + 2*c.entity_indices[1][0];
    dofs[4] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[5] = offset + 2*c.entity_indices[1][1];
    dofs[6] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[7] = offset + 2*c.entity_indices[1][2];
    dofs[8] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*num_global_entities[1];
    dofs[9] = offset + c.entity_indices[2][0];
    offset += num_global_entities[2];
    dofs[10] = offset + c.entity_indices[0][0];
    dofs[11] = offset + c.entity_indices[0][1];
    dofs[12] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[13] = offset + 2*c.entity_indices[1][0];
    dofs[14] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[15] = offset + 2*c.entity_indices[1][1];
    dofs[16] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[17] = offset + 2*c.entity_indices[1][2];
    dofs[18] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*num_global_entities[1];
    dofs[19] = offset + c.entity_indices[2][0];
    offset += num_global_entities[2];
    dofs[20] = offset + c.entity_indices[0][0];
    dofs[21] = offset + c.entity_indices[0][1];
    dofs[22] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[23] = offset + c.entity_indices[1][0];
    dofs[24] = offset + c.entity_indices[1][1];
    dofs[25] = offset + c.entity_indices[1][2];
    offset += num_global_entities[1];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 11;
      dofs[5] = 12;
      dofs[6] = 13;
      dofs[7] = 14;
      dofs[8] = 21;
      dofs[9] = 22;
      dofs[10] = 23;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 10;
      dofs[5] = 12;
      dofs[6] = 15;
      dofs[7] = 16;
      dofs[8] = 20;
      dofs[9] = 22;
      dofs[10] = 24;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 7;
      dofs[3] = 8;
      dofs[4] = 10;
      dofs[5] = 11;
      dofs[6] = 17;
      dofs[7] = 18;
      dofs[8] = 20;
      dofs[9] = 21;
      dofs[10] = 25;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 10;
        dofs[2] = 20;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 11;
        dofs[2] = 21;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 12;
        dofs[2] = 22;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 4;
        dofs[2] = 13;
        dofs[3] = 14;
        dofs[4] = 23;
          break;
        }
      case 1:
        {
          dofs[0] = 5;
        dofs[1] = 6;
        dofs[2] = 15;
        dofs[3] = 16;
        dofs[4] = 24;
          break;
        }
      case 2:
        {
          dofs[0] = 7;
        dofs[1] = 8;
        dofs[2] = 17;
        dofs[3] = 18;
        dofs[4] = 25;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 9;
      dofs[1] = 19;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = vertex_coordinates[0];
    dof_coordinates[0][1] = vertex_coordinates[1];
    dof_coordinates[1][0] = vertex_coordinates[2];
    dof_coordinates[1][1] = vertex_coordinates[3];
    dof_coordinates[2][0] = vertex_coordinates[4];
    dof_coordinates[2][1] = vertex_coordinates[5];
    dof_coordinates[3][0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[3][1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[4][0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
    dof_coordinates[4][1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
    dof_coordinates[5][0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[5][1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[6][0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
    dof_coordinates[6][1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
    dof_coordinates[7][0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
    dof_coordinates[7][1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
    dof_coordinates[8][0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
    dof_coordinates[8][1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
    dof_coordinates[9][0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[9][1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[10][0] = vertex_coordinates[0];
    dof_coordinates[10][1] = vertex_coordinates[1];
    dof_coordinates[11][0] = vertex_coordinates[2];
    dof_coordinates[11][1] = vertex_coordinates[3];
    dof_coordinates[12][0] = vertex_coordinates[4];
    dof_coordinates[12][1] = vertex_coordinates[5];
    dof_coordinates[13][0] = 0.666666666666667*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[13][1] = 0.666666666666667*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[14][0] = 0.333333333333333*vertex_coordinates[2] + 0.666666666666667*vertex_coordinates[4];
    dof_coordinates[14][1] = 0.333333333333333*vertex_coordinates[3] + 0.666666666666667*vertex_coordinates[5];
    dof_coordinates[15][0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[15][1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[16][0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[4];
    dof_coordinates[16][1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[5];
    dof_coordinates[17][0] = 0.666666666666667*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2];
    dof_coordinates[17][1] = 0.666666666666667*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3];
    dof_coordinates[18][0] = 0.333333333333333*vertex_coordinates[0] + 0.666666666666667*vertex_coordinates[2];
    dof_coordinates[18][1] = 0.333333333333333*vertex_coordinates[1] + 0.666666666666667*vertex_coordinates[3];
    dof_coordinates[19][0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[19][1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
    dof_coordinates[20][0] = vertex_coordinates[0];
    dof_coordinates[20][1] = vertex_coordinates[1];
    dof_coordinates[21][0] = vertex_coordinates[2];
    dof_coordinates[21][1] = vertex_coordinates[3];
    dof_coordinates[22][0] = vertex_coordinates[4];
    dof_coordinates[22][1] = vertex_coordinates[5];
    dof_coordinates[23][0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[23][1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[24][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[24][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[25][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[25][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_7();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_8();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_9();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_10: public ufc::dofmap
{
public:

  /// Constructor
  adaptivenavierstokes_dofmap_10() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_10()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Real', Domain(Cell('triangle', 2)), 0, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return 1;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 1;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 1;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    dofs[0] = 0;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = 0.333333333333333*vertex_coordinates[0] + 0.333333333333333*vertex_coordinates[2] + 0.333333333333333*vertex_coordinates[4];
    dof_coordinates[0][1] = 0.333333333333333*vertex_coordinates[1] + 0.333333333333333*vertex_coordinates[3] + 0.333333333333333*vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_10();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_11: public ufc::dofmap
{
public:

  /// Constructor
  adaptivenavierstokes_dofmap_11() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_11()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for VectorElement('Lagrange', Domain(Cell('triangle', 2)), 2, 2, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return 2*num_global_entities[0] + 2*num_global_entities[1];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 12;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 6;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 2;
        break;
      }
    case 1:
      {
        return 2;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += num_global_entities[1];
    dofs[6] = offset + c.entity_indices[0][0];
    dofs[7] = offset + c.entity_indices[0][1];
    dofs[8] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[9] = offset + c.entity_indices[1][0];
    dofs[10] = offset + c.entity_indices[1][1];
    dofs[11] = offset + c.entity_indices[1][2];
    offset += num_global_entities[1];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 7;
      dofs[4] = 8;
      dofs[5] = 9;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
      dofs[3] = 6;
      dofs[4] = 8;
      dofs[5] = 10;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 7;
      dofs[5] = 11;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 6;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 7;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 8;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 9;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
        dofs[1] = 10;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
        dofs[1] = 11;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = vertex_coordinates[0];
    dof_coordinates[0][1] = vertex_coordinates[1];
    dof_coordinates[1][0] = vertex_coordinates[2];
    dof_coordinates[1][1] = vertex_coordinates[3];
    dof_coordinates[2][0] = vertex_coordinates[4];
    dof_coordinates[2][1] = vertex_coordinates[5];
    dof_coordinates[3][0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[3][1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[4][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[4][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[5][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[5][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[6][0] = vertex_coordinates[0];
    dof_coordinates[6][1] = vertex_coordinates[1];
    dof_coordinates[7][0] = vertex_coordinates[2];
    dof_coordinates[7][1] = vertex_coordinates[3];
    dof_coordinates[8][0] = vertex_coordinates[4];
    dof_coordinates[8][1] = vertex_coordinates[5];
    dof_coordinates[9][0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[9][1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[10][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[10][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[11][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[11][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_8();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_8();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_11();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_12: public ufc::dofmap
{
public:

  /// Constructor
  adaptivenavierstokes_dofmap_12() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_12()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 1, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return num_global_entities[0];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 3;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 2;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    dofs[0] = c.entity_indices[0][0];
    dofs[1] = c.entity_indices[0][1];
    dofs[2] = c.entity_indices[0][2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = vertex_coordinates[0];
    dof_coordinates[0][1] = vertex_coordinates[1];
    dof_coordinates[1][0] = vertex_coordinates[2];
    dof_coordinates[1][1] = vertex_coordinates[3];
    dof_coordinates[2][0] = vertex_coordinates[4];
    dof_coordinates[2][1] = vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_12();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_13: public ufc::dofmap
{
public:

  /// Constructor
  adaptivenavierstokes_dofmap_13() : ufc::dofmap()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_13()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(VectorElement('Lagrange', Domain(Cell('triangle', 2)), 2, 2, None), FiniteElement('Lagrange', Domain(Cell('triangle', 2)), 1, None), **{'value_shape': (3,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Return the topological dimension of the associated cell shape
  virtual std::size_t topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual std::size_t geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual std::size_t global_dimension(const std::vector<std::size_t>&
                                       num_global_entities) const
  {
    return 3*num_global_entities[0] + 2*num_global_entities[1];
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual std::size_t local_dimension() const
  {
    return 15;
  }

  /// Return the number of dofs on each cell facet
  virtual std::size_t num_facet_dofs() const
  {
    return 8;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual std::size_t num_entity_dofs(std::size_t d) const
  {
    switch (d)
    {
    case 0:
      {
        return 3;
        break;
      }
    case 1:
      {
        return 2;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(std::size_t* dofs,
                             const std::vector<std::size_t>& num_global_entities,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += num_global_entities[1];
    dofs[6] = offset + c.entity_indices[0][0];
    dofs[7] = offset + c.entity_indices[0][1];
    dofs[8] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
    dofs[9] = offset + c.entity_indices[1][0];
    dofs[10] = offset + c.entity_indices[1][1];
    dofs[11] = offset + c.entity_indices[1][2];
    offset += num_global_entities[1];
    dofs[12] = offset + c.entity_indices[0][0];
    dofs[13] = offset + c.entity_indices[0][1];
    dofs[14] = offset + c.entity_indices[0][2];
    offset += num_global_entities[0];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(std::size_t* dofs,
                                   std::size_t facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 7;
      dofs[4] = 8;
      dofs[5] = 9;
      dofs[6] = 13;
      dofs[7] = 14;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
      dofs[3] = 6;
      dofs[4] = 8;
      dofs[5] = 10;
      dofs[6] = 12;
      dofs[7] = 14;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 7;
      dofs[5] = 11;
      dofs[6] = 12;
      dofs[7] = 13;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(std::size_t* dofs,
                                    std::size_t d, std::size_t i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 6;
        dofs[2] = 12;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 7;
        dofs[2] = 13;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 8;
        dofs[2] = 14;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 9;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
        dofs[1] = 10;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
        dofs[1] = 11;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** dof_coordinates,
                                    const double* vertex_coordinates) const
  {
    dof_coordinates[0][0] = vertex_coordinates[0];
    dof_coordinates[0][1] = vertex_coordinates[1];
    dof_coordinates[1][0] = vertex_coordinates[2];
    dof_coordinates[1][1] = vertex_coordinates[3];
    dof_coordinates[2][0] = vertex_coordinates[4];
    dof_coordinates[2][1] = vertex_coordinates[5];
    dof_coordinates[3][0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[3][1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[4][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[4][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[5][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[5][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[6][0] = vertex_coordinates[0];
    dof_coordinates[6][1] = vertex_coordinates[1];
    dof_coordinates[7][0] = vertex_coordinates[2];
    dof_coordinates[7][1] = vertex_coordinates[3];
    dof_coordinates[8][0] = vertex_coordinates[4];
    dof_coordinates[8][1] = vertex_coordinates[5];
    dof_coordinates[9][0] = 0.5*vertex_coordinates[2] + 0.5*vertex_coordinates[4];
    dof_coordinates[9][1] = 0.5*vertex_coordinates[3] + 0.5*vertex_coordinates[5];
    dof_coordinates[10][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[4];
    dof_coordinates[10][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[5];
    dof_coordinates[11][0] = 0.5*vertex_coordinates[0] + 0.5*vertex_coordinates[2];
    dof_coordinates[11][1] = 0.5*vertex_coordinates[1] + 0.5*vertex_coordinates[3];
    dof_coordinates[12][0] = vertex_coordinates[0];
    dof_coordinates[12][1] = vertex_coordinates[1];
    dof_coordinates[13][0] = vertex_coordinates[2];
    dof_coordinates[13][1] = vertex_coordinates[3];
    dof_coordinates[14][0] = vertex_coordinates[4];
    dof_coordinates[14][1] = vertex_coordinates[5];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual std::size_t num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_11();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_13();
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_0_otherwise: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_0_otherwise() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_0_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({true, true});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               int cell_orientation) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      3
    // Number of operations (multiply-add pairs) for geometry tensor:    172
    // Number of operations (multiply-add pairs) for tensor contraction: 2992
    // Total number of operations (multiply-add pairs):                  3167
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0_0 = det*w[0][0]*K[0]*(1.0);
    const double G0_0_1 = det*w[0][0]*K[2]*(1.0);
    const double G0_1_0 = det*w[0][1]*K[0]*(1.0);
    const double G0_2_1 = det*w[0][2]*K[2]*(1.0);
    const double G0_3_0 = det*w[0][3]*K[0]*(1.0);
    const double G0_3_1 = det*w[0][3]*K[2]*(1.0);
    const double G0_4_0 = det*w[0][4]*K[0]*(1.0);
    const double G0_4_1 = det*w[0][4]*K[2]*(1.0);
    const double G0_5_0 = det*w[0][5]*K[0]*(1.0);
    const double G0_5_1 = det*w[0][5]*K[2]*(1.0);
    const double G1_0_0 = det*w[0][0]*K[0]*(1.0);
    const double G1_0_1 = det*w[0][0]*K[2]*(1.0);
    const double G1_1_0 = det*w[0][1]*K[0]*(1.0);
    const double G1_1_1 = det*w[0][1]*K[2]*(1.0);
    const double G1_2_0 = det*w[0][2]*K[0]*(1.0);
    const double G1_2_1 = det*w[0][2]*K[2]*(1.0);
    const double G1_3_0 = det*w[0][3]*K[0]*(1.0);
    const double G1_3_1 = det*w[0][3]*K[2]*(1.0);
    const double G1_4_0 = det*w[0][4]*K[0]*(1.0);
    const double G1_4_1 = det*w[0][4]*K[2]*(1.0);
    const double G1_5_0 = det*w[0][5]*K[0]*(1.0);
    const double G1_5_1 = det*w[0][5]*K[2]*(1.0);
    const double G2_0_0 = det*w[0][0]*K[1]*(1.0);
    const double G2_0_1 = det*w[0][0]*K[3]*(1.0);
    const double G2_1_0 = det*w[0][1]*K[1]*(1.0);
    const double G2_2_1 = det*w[0][2]*K[3]*(1.0);
    const double G2_3_0 = det*w[0][3]*K[1]*(1.0);
    const double G2_3_1 = det*w[0][3]*K[3]*(1.0);
    const double G2_4_0 = det*w[0][4]*K[1]*(1.0);
    const double G2_4_1 = det*w[0][4]*K[3]*(1.0);
    const double G2_5_0 = det*w[0][5]*K[1]*(1.0);
    const double G2_5_1 = det*w[0][5]*K[3]*(1.0);
    const double G3_6_0 = det*w[0][6]*K[1]*(1.0);
    const double G3_6_1 = det*w[0][6]*K[3]*(1.0);
    const double G3_7_0 = det*w[0][7]*K[1]*(1.0);
    const double G3_7_1 = det*w[0][7]*K[3]*(1.0);
    const double G3_8_0 = det*w[0][8]*K[1]*(1.0);
    const double G3_8_1 = det*w[0][8]*K[3]*(1.0);
    const double G3_9_0 = det*w[0][9]*K[1]*(1.0);
    const double G3_9_1 = det*w[0][9]*K[3]*(1.0);
    const double G3_10_0 = det*w[0][10]*K[1]*(1.0);
    const double G3_10_1 = det*w[0][10]*K[3]*(1.0);
    const double G3_11_0 = det*w[0][11]*K[1]*(1.0);
    const double G3_11_1 = det*w[0][11]*K[3]*(1.0);
    const double G4_6_0 = det*w[0][6]*K[0]*(1.0);
    const double G4_6_1 = det*w[0][6]*K[2]*(1.0);
    const double G4_7_0 = det*w[0][7]*K[0]*(1.0);
    const double G4_8_1 = det*w[0][8]*K[2]*(1.0);
    const double G4_9_0 = det*w[0][9]*K[0]*(1.0);
    const double G4_9_1 = det*w[0][9]*K[2]*(1.0);
    const double G4_10_0 = det*w[0][10]*K[0]*(1.0);
    const double G4_10_1 = det*w[0][10]*K[2]*(1.0);
    const double G4_11_0 = det*w[0][11]*K[0]*(1.0);
    const double G4_11_1 = det*w[0][11]*K[2]*(1.0);
    const double G5_0_0 = det*w[0][0]*K[0]*(1.0);
    const double G5_0_1 = det*w[0][0]*K[2]*(1.0);
    const double G5_1_0 = det*w[0][1]*K[0]*(1.0);
    const double G5_1_1 = det*w[0][1]*K[2]*(1.0);
    const double G5_2_0 = det*w[0][2]*K[0]*(1.0);
    const double G5_2_1 = det*w[0][2]*K[2]*(1.0);
    const double G5_3_0 = det*w[0][3]*K[0]*(1.0);
    const double G5_3_1 = det*w[0][3]*K[2]*(1.0);
    const double G5_4_0 = det*w[0][4]*K[0]*(1.0);
    const double G5_4_1 = det*w[0][4]*K[2]*(1.0);
    const double G5_5_0 = det*w[0][5]*K[0]*(1.0);
    const double G5_5_1 = det*w[0][5]*K[2]*(1.0);
    const double G6_6_0 = det*w[0][6]*K[1]*(1.0);
    const double G6_6_1 = det*w[0][6]*K[3]*(1.0);
    const double G6_7_0 = det*w[0][7]*K[1]*(1.0);
    const double G6_8_1 = det*w[0][8]*K[3]*(1.0);
    const double G6_9_0 = det*w[0][9]*K[1]*(1.0);
    const double G6_9_1 = det*w[0][9]*K[3]*(1.0);
    const double G6_10_0 = det*w[0][10]*K[1]*(1.0);
    const double G6_10_1 = det*w[0][10]*K[3]*(1.0);
    const double G6_11_0 = det*w[0][11]*K[1]*(1.0);
    const double G6_11_1 = det*w[0][11]*K[3]*(1.0);
    const double G7_6_0 = det*w[0][6]*K[1]*(1.0);
    const double G7_6_1 = det*w[0][6]*K[3]*(1.0);
    const double G7_7_0 = det*w[0][7]*K[1]*(1.0);
    const double G7_7_1 = det*w[0][7]*K[3]*(1.0);
    const double G7_8_0 = det*w[0][8]*K[1]*(1.0);
    const double G7_8_1 = det*w[0][8]*K[3]*(1.0);
    const double G7_9_0 = det*w[0][9]*K[1]*(1.0);
    const double G7_9_1 = det*w[0][9]*K[3]*(1.0);
    const double G7_10_0 = det*w[0][10]*K[1]*(1.0);
    const double G7_10_1 = det*w[0][10]*K[3]*(1.0);
    const double G7_11_0 = det*w[0][11]*K[1]*(1.0);
    const double G7_11_1 = det*w[0][11]*K[3]*(1.0);
    const double G8_0 = det*K[0]*(1.0);
    const double G8_1 = det*K[2]*(1.0);
    const double G9_0 = det*K[1]*(1.0);
    const double G9_1 = det*K[3]*(1.0);
    const double G10_0_0_0 = det*w[1][0]*K[0]*K[0]*(1.0);
    const double G10_0_0_1 = det*w[1][0]*K[0]*K[2]*(1.0);
    const double G10_0_1_0 = det*w[1][0]*K[2]*K[0]*(1.0);
    const double G10_0_1_1 = det*w[1][0]*K[2]*K[2]*(1.0);
    const double G11_0_0_0 = det*w[1][0]*K[0]*K[0]*(1.0);
    const double G11_0_0_1 = det*w[1][0]*K[0]*K[2]*(1.0);
    const double G11_0_1_0 = det*w[1][0]*K[2]*K[0]*(1.0);
    const double G11_0_1_1 = det*w[1][0]*K[2]*K[2]*(1.0);
    const double G12_0_0_0 = det*w[1][0]*K[1]*K[1]*(1.0);
    const double G12_0_0_1 = det*w[1][0]*K[1]*K[3]*(1.0);
    const double G12_0_1_0 = det*w[1][0]*K[3]*K[1]*(1.0);
    const double G12_0_1_1 = det*w[1][0]*K[3]*K[3]*(1.0);
    const double G13_0_0_0 = det*w[1][0]*K[1]*K[1]*(1.0);
    const double G13_0_0_1 = det*w[1][0]*K[1]*K[3]*(1.0);
    const double G13_0_1_0 = det*w[1][0]*K[3]*K[1]*(1.0);
    const double G13_0_1_1 = det*w[1][0]*K[3]*K[3]*(1.0);
    const double G14_0 = det*K[0]*(1.0);
    const double G14_1 = det*K[2]*(1.0);
    const double G15_0 = det*K[1]*(1.0);
    const double G15_1 = det*K[3]*(1.0);
    
    // Compute element tensor
    A[0] = -0.030952380952381*G0_0_0 - 0.030952380952381*G0_0_1 - 0.00714285714285715*G0_1_0 - 0.00714285714285715*G0_2_1 + 0.00952380952380951*G0_3_0 + 0.00952380952380951*G0_3_1 - 0.00952380952380951*G0_4_0 + 0.0380952380952381*G0_4_1 + 0.0380952380952381*G0_5_0 - 0.00952380952380952*G0_5_1 - 0.030952380952381*G1_0_0 - 0.030952380952381*G1_0_1 + 0.00357142857142857*G1_1_0 + 0.00357142857142857*G1_1_1 + 0.00357142857142857*G1_2_0 + 0.00357142857142857*G1_2_1 - 0.00476190476190477*G1_3_0 - 0.00476190476190477*G1_3_1 - 0.0190476190476191*G1_4_0 - 0.0190476190476191*G1_4_1 - 0.0190476190476191*G1_5_0 - 0.0190476190476191*G1_5_1 - 0.030952380952381*G3_6_0 - 0.030952380952381*G3_6_1 + 0.00357142857142857*G3_7_0 + 0.00357142857142857*G3_7_1 + 0.00357142857142857*G3_8_0 + 0.00357142857142857*G3_8_1 - 0.00476190476190477*G3_9_0 - 0.00476190476190477*G3_9_1 - 0.0190476190476191*G3_10_0 - 0.0190476190476191*G3_10_1 - 0.0190476190476191*G3_11_0 - 0.0190476190476191*G3_11_1 + 0.5*G10_0_0_0 + 0.5*G10_0_0_1 + 0.5*G10_0_1_0 + 0.5*G10_0_1_1 + 0.5*G12_0_0_0 + 0.5*G12_0_0_1 + 0.5*G12_0_1_0 + 0.5*G12_0_1_1;
    A[1] = 0.00357142857142857*G0_0_0 + 0.00357142857142857*G0_0_1 - 0.00357142857142857*G0_1_0 + 0.00436507936507936*G0_2_1 + 0.00158730158730159*G0_3_0 - 0.00634920634920634*G0_3_1 - 0.00158730158730159*G0_4_0 - 0.00793650793650793*G0_4_1 + 0.00634920634920635*G0_5_1 + 0.00357142857142857*G1_0_0 + 0.00357142857142857*G1_0_1 + 0.00714285714285713*G1_1_0 + 0.00714285714285714*G1_1_1 - 0.00436507936507936*G1_2_0 - 0.00436507936507936*G1_2_1 + 0.00634920634920634*G1_3_0 + 0.00634920634920634*G1_3_1 + 0.00793650793650793*G1_4_0 + 0.00793650793650793*G1_4_1 + 0.0126984126984127*G1_5_0 + 0.0126984126984127*G1_5_1 + 0.00357142857142857*G3_6_0 + 0.00357142857142857*G3_6_1 + 0.00714285714285713*G3_7_0 + 0.00714285714285714*G3_7_1 - 0.00436507936507936*G3_8_0 - 0.00436507936507936*G3_8_1 + 0.00634920634920634*G3_9_0 + 0.00634920634920634*G3_9_1 + 0.00793650793650793*G3_10_0 + 0.00793650793650793*G3_10_1 + 0.0126984126984127*G3_11_0 + 0.0126984126984127*G3_11_1 + 0.166666666666667*G10_0_0_0 + 0.166666666666667*G10_0_1_0 + 0.166666666666667*G12_0_0_0 + 0.166666666666667*G12_0_1_0;
    A[2] = 0.00357142857142857*G0_0_0 + 0.00357142857142857*G0_0_1 + 0.00436507936507936*G0_1_0 - 0.00357142857142857*G0_2_1 - 0.00634920634920634*G0_3_0 + 0.00158730158730159*G0_3_1 + 0.00634920634920634*G0_4_0 - 0.00793650793650793*G0_5_0 - 0.00158730158730159*G0_5_1 + 0.00357142857142857*G1_0_0 + 0.00357142857142857*G1_0_1 - 0.00436507936507936*G1_1_0 - 0.00436507936507936*G1_1_1 + 0.00714285714285714*G1_2_0 + 0.00714285714285713*G1_2_1 + 0.00634920634920635*G1_3_0 + 0.00634920634920634*G1_3_1 + 0.0126984126984127*G1_4_0 + 0.0126984126984127*G1_4_1 + 0.00793650793650793*G1_5_0 + 0.00793650793650793*G1_5_1 + 0.00357142857142857*G3_6_0 + 0.00357142857142857*G3_6_1 - 0.00436507936507936*G3_7_0 - 0.00436507936507936*G3_7_1 + 0.00714285714285714*G3_8_0 + 0.00714285714285713*G3_8_1 + 0.00634920634920635*G3_9_0 + 0.00634920634920634*G3_9_1 + 0.0126984126984127*G3_10_0 + 0.0126984126984127*G3_10_1 + 0.00793650793650793*G3_11_0 + 0.00793650793650793*G3_11_1 + 0.166666666666667*G10_0_0_1 + 0.166666666666667*G10_0_1_1 + 0.166666666666667*G12_0_0_1 + 0.166666666666667*G12_0_1_1;
    A[3] = -0.00476190476190476*G0_0_0 - 0.00476190476190477*G0_0_1 - 0.00793650793650793*G0_1_0 - 0.00793650793650793*G0_2_1 - 0.019047619047619*G0_3_0 - 0.019047619047619*G0_3_1 + 0.019047619047619*G0_4_0 + 0.0126984126984127*G0_4_1 + 0.0126984126984127*G0_5_0 + 0.019047619047619*G0_5_1 - 0.00476190476190476*G1_0_0 - 0.00476190476190477*G1_0_1 + 0.00634920634920634*G1_1_0 + 0.00634920634920634*G1_1_1 + 0.00634920634920635*G1_2_0 + 0.00634920634920634*G1_2_1 + 0.0380952380952381*G1_3_0 + 0.0380952380952381*G1_3_1 - 0.00634920634920633*G1_4_0 - 0.00634920634920632*G1_4_1 - 0.00634920634920633*G1_5_0 - 0.00634920634920632*G1_5_1 - 0.00476190476190476*G3_6_0 - 0.00476190476190477*G3_6_1 + 0.00634920634920634*G3_7_0 + 0.00634920634920634*G3_7_1 + 0.00634920634920635*G3_8_0 + 0.00634920634920634*G3_8_1 + 0.0380952380952381*G3_9_0 + 0.0380952380952381*G3_9_1 - 0.00634920634920633*G3_10_0 - 0.00634920634920632*G3_10_1 - 0.00634920634920633*G3_11_0 - 0.00634920634920632*G3_11_1;
    A[4] = -0.0190476190476191*G0_0_0 - 0.0190476190476191*G0_0_1 - 0.00634920634920636*G0_1_0 - 0.0126984126984127*G0_2_1 - 0.0126984126984127*G0_3_0 - 0.00634920634920634*G0_3_1 + 0.0126984126984127*G0_4_0 + 0.0317460317460318*G0_4_1 + 0.0253968253968254*G0_5_0 + 0.00634920634920634*G0_5_1 - 0.0190476190476191*G1_0_0 - 0.0190476190476191*G1_0_1 + 0.00793650793650793*G1_1_0 + 0.00793650793650793*G1_1_1 + 0.0126984126984127*G1_2_0 + 0.0126984126984127*G1_2_1 - 0.00634920634920633*G1_3_0 - 0.00634920634920632*G1_3_1 - 0.0634920634920635*G1_4_0 - 0.0634920634920635*G1_4_1 - 0.0317460317460317*G1_5_0 - 0.0317460317460317*G1_5_1 - 0.0190476190476191*G3_6_0 - 0.0190476190476191*G3_6_1 + 0.00793650793650793*G3_7_0 + 0.00793650793650793*G3_7_1 + 0.0126984126984127*G3_8_0 + 0.0126984126984127*G3_8_1 - 0.00634920634920633*G3_9_0 - 0.00634920634920632*G3_9_1 - 0.0634920634920635*G3_10_0 - 0.0634920634920635*G3_10_1 - 0.0317460317460317*G3_11_0 - 0.0317460317460317*G3_11_1 - 0.666666666666667*G10_0_0_1 - 0.666666666666666*G10_0_1_1 - 0.666666666666667*G12_0_0_1 - 0.666666666666666*G12_0_1_1;
    A[5] = -0.0190476190476191*G0_0_0 - 0.0190476190476191*G0_0_1 - 0.0126984126984127*G0_1_0 - 0.00634920634920635*G0_2_1 - 0.00634920634920635*G0_3_0 - 0.0126984126984127*G0_3_1 + 0.00634920634920635*G0_4_0 + 0.0253968253968254*G0_4_1 + 0.0317460317460318*G0_5_0 + 0.0126984126984127*G0_5_1 - 0.0190476190476191*G1_0_0 - 0.0190476190476191*G1_0_1 + 0.0126984126984127*G1_1_0 + 0.0126984126984127*G1_1_1 + 0.00793650793650793*G1_2_0 + 0.00793650793650793*G1_2_1 - 0.00634920634920633*G1_3_0 - 0.00634920634920632*G1_3_1 - 0.0317460317460317*G1_4_0 - 0.0317460317460317*G1_4_1 - 0.0634920634920635*G1_5_0 - 0.0634920634920635*G1_5_1 - 0.0190476190476191*G3_6_0 - 0.0190476190476191*G3_6_1 + 0.0126984126984127*G3_7_0 + 0.0126984126984127*G3_7_1 + 0.00793650793650793*G3_8_0 + 0.00793650793650793*G3_8_1 - 0.00634920634920633*G3_9_0 - 0.00634920634920632*G3_9_1 - 0.0317460317460317*G3_10_0 - 0.0317460317460317*G3_10_1 - 0.0634920634920635*G3_11_0 - 0.0634920634920635*G3_11_1 - 0.666666666666667*G10_0_0_0 - 0.666666666666667*G10_0_1_0 - 0.666666666666667*G12_0_0_0 - 0.666666666666667*G12_0_1_0;
    A[6] = -0.030952380952381*G4_6_0 - 0.030952380952381*G4_6_1 - 0.00714285714285715*G4_7_0 - 0.00714285714285715*G4_8_1 + 0.00952380952380951*G4_9_0 + 0.00952380952380951*G4_9_1 - 0.00952380952380951*G4_10_0 + 0.0380952380952381*G4_10_1 + 0.0380952380952381*G4_11_0 - 0.00952380952380952*G4_11_1;
    A[7] = 0.00357142857142857*G4_6_0 + 0.00357142857142857*G4_6_1 - 0.00357142857142857*G4_7_0 + 0.00436507936507936*G4_8_1 + 0.00158730158730159*G4_9_0 - 0.00634920634920634*G4_9_1 - 0.00158730158730159*G4_10_0 - 0.00793650793650793*G4_10_1 + 0.00634920634920635*G4_11_1;
    A[8] = 0.00357142857142857*G4_6_0 + 0.00357142857142857*G4_6_1 + 0.00436507936507936*G4_7_0 - 0.00357142857142857*G4_8_1 - 0.00634920634920634*G4_9_0 + 0.00158730158730159*G4_9_1 + 0.00634920634920634*G4_10_0 - 0.00793650793650793*G4_11_0 - 0.00158730158730159*G4_11_1;
    A[9] = -0.00476190476190476*G4_6_0 - 0.00476190476190477*G4_6_1 - 0.00793650793650793*G4_7_0 - 0.00793650793650793*G4_8_1 - 0.019047619047619*G4_9_0 - 0.019047619047619*G4_9_1 + 0.019047619047619*G4_10_0 + 0.0126984126984127*G4_10_1 + 0.0126984126984127*G4_11_0 + 0.019047619047619*G4_11_1;
    A[10] = -0.0190476190476191*G4_6_0 - 0.0190476190476191*G4_6_1 - 0.00634920634920636*G4_7_0 - 0.0126984126984127*G4_8_1 - 0.0126984126984127*G4_9_0 - 0.00634920634920634*G4_9_1 + 0.0126984126984127*G4_10_0 + 0.0317460317460318*G4_10_1 + 0.0253968253968254*G4_11_0 + 0.00634920634920634*G4_11_1;
    A[11] = -0.0190476190476191*G4_6_0 - 0.0190476190476191*G4_6_1 - 0.0126984126984127*G4_7_0 - 0.00634920634920635*G4_8_1 - 0.00634920634920635*G4_9_0 - 0.0126984126984127*G4_9_1 + 0.00634920634920635*G4_10_0 + 0.0253968253968254*G4_10_1 + 0.0317460317460318*G4_11_0 + 0.0126984126984127*G4_11_1;
    A[12] = -0.166666666666667*G8_0 - 0.166666666666667*G8_1;
    A[13] = 0.0;
    A[14] = 0.0;
    A[15] = 0.00357142857142857*G0_0_0 + 0.00357142857142857*G0_0_1 - 0.00357142857142857*G0_1_0 + 0.00436507936507936*G0_2_1 + 0.00158730158730159*G0_3_0 - 0.00634920634920634*G0_3_1 - 0.00158730158730159*G0_4_0 - 0.00793650793650793*G0_4_1 + 0.00634920634920635*G0_5_1 - 0.00714285714285715*G1_0_0 - 0.00357142857142857*G1_1_0 + 0.00436507936507936*G1_2_0 - 0.00793650793650793*G1_3_0 - 0.00634920634920636*G1_4_0 - 0.0126984126984127*G1_5_0 - 0.00714285714285715*G3_6_0 - 0.00357142857142857*G3_7_0 + 0.00436507936507936*G3_8_0 - 0.00793650793650793*G3_9_0 - 0.00634920634920636*G3_10_0 - 0.0126984126984127*G3_11_0 + 0.166666666666667*G10_0_0_0 + 0.166666666666667*G10_0_0_1 + 0.166666666666667*G12_0_0_0 + 0.166666666666667*G12_0_0_1;
    A[16] = 0.00714285714285713*G0_0_0 + 0.00714285714285714*G0_0_1 + 0.0309523809523809*G0_1_0 - 0.00714285714285713*G0_2_1 + 0.0095238095238095*G0_3_0 + 0.0476190476190476*G0_3_1 - 0.0095238095238095*G0_4_0 - 0.0380952380952381*G0_5_0 - 0.0476190476190476*G0_5_1 - 0.00357142857142857*G1_0_0 + 0.0309523809523809*G1_1_0 - 0.00357142857142856*G1_2_0 + 0.019047619047619*G1_3_0 + 0.00476190476190476*G1_4_0 + 0.019047619047619*G1_5_0 - 0.00357142857142857*G3_6_0 + 0.0309523809523809*G3_7_0 - 0.00357142857142856*G3_8_0 + 0.019047619047619*G3_9_0 + 0.00476190476190476*G3_10_0 + 0.019047619047619*G3_11_0 + 0.5*G10_0_0_0 + 0.5*G12_0_0_0;
    A[17] = -0.00436507936507936*G0_0_0 - 0.00436507936507936*G0_0_1 - 0.00357142857142857*G0_1_0 - 0.00357142857142857*G0_2_1 - 0.00634920634920634*G0_3_0 - 0.00634920634920634*G0_3_1 + 0.00634920634920634*G0_4_0 + 0.00793650793650792*G0_4_1 + 0.00793650793650793*G0_5_0 + 0.00634920634920634*G0_5_1 + 0.00436507936507936*G1_0_0 - 0.00357142857142857*G1_1_0 - 0.00714285714285714*G1_2_0 - 0.0126984126984127*G1_3_0 - 0.00634920634920635*G1_4_0 - 0.00793650793650793*G1_5_0 + 0.00436507936507936*G3_6_0 - 0.00357142857142857*G3_7_0 - 0.00714285714285714*G3_8_0 - 0.0126984126984127*G3_9_0 - 0.00634920634920635*G3_10_0 - 0.00793650793650793*G3_11_0 - 0.166666666666667*G10_0_0_1 - 0.166666666666667*G12_0_0_1;
    A[18] = 0.00634920634920634*G0_0_0 + 0.00634920634920634*G0_0_1 + 0.019047619047619*G0_1_0 - 0.0126984126984127*G0_2_1 - 0.0126984126984127*G0_3_0 + 0.019047619047619*G0_3_1 + 0.0126984126984127*G0_4_0 + 0.00634920634920636*G0_4_1 - 0.0253968253968254*G0_5_0 - 0.019047619047619*G0_5_1 - 0.00793650793650793*G1_0_0 + 0.019047619047619*G1_1_0 - 0.0126984126984127*G1_2_0 + 0.0634920634920634*G1_3_0 + 0.00634920634920634*G1_4_0 + 0.0317460317460317*G1_5_0 - 0.00793650793650793*G3_6_0 + 0.019047619047619*G3_7_0 - 0.0126984126984127*G3_8_0 + 0.0634920634920634*G3_9_0 + 0.00634920634920634*G3_10_0 + 0.0317460317460317*G3_11_0 + 0.666666666666666*G10_0_0_1 + 0.666666666666666*G12_0_0_1;
    A[19] = 0.00793650793650793*G0_0_0 + 0.00793650793650793*G0_0_1 + 0.00476190476190476*G0_1_0 - 0.00793650793650794*G0_2_1 - 0.019047619047619*G0_3_0 - 0.00634920634920634*G0_3_1 + 0.019047619047619*G0_4_0 - 0.0126984126984127*G0_5_0 + 0.00634920634920634*G0_5_1 - 0.00634920634920636*G1_0_0 + 0.00476190476190476*G1_1_0 - 0.00634920634920635*G1_2_0 + 0.00634920634920634*G1_3_0 - 0.0380952380952381*G1_4_0 + 0.00634920634920634*G1_5_0 - 0.00634920634920636*G3_6_0 + 0.00476190476190476*G3_7_0 - 0.00634920634920635*G3_8_0 + 0.00634920634920634*G3_9_0 - 0.0380952380952381*G3_10_0 + 0.00634920634920634*G3_11_0;
    A[20] = 0.0126984126984127*G0_0_0 + 0.0126984126984127*G0_0_1 + 0.019047619047619*G0_1_0 - 0.00634920634920636*G0_2_1 - 0.00634920634920635*G0_3_0 + 0.019047619047619*G0_3_1 + 0.00634920634920635*G0_4_0 - 0.00634920634920633*G0_4_1 - 0.0317460317460317*G0_5_0 - 0.0190476190476191*G0_5_1 - 0.0126984126984127*G1_0_0 + 0.019047619047619*G1_1_0 - 0.00793650793650793*G1_2_0 + 0.0317460317460317*G1_3_0 + 0.00634920634920634*G1_4_0 + 0.0634920634920635*G1_5_0 - 0.0126984126984127*G3_6_0 + 0.019047619047619*G3_7_0 - 0.00793650793650793*G3_8_0 + 0.0317460317460317*G3_9_0 + 0.00634920634920634*G3_10_0 + 0.0634920634920635*G3_11_0 - 0.666666666666667*G10_0_0_0 - 0.666666666666666*G10_0_0_1 - 0.666666666666667*G12_0_0_0 - 0.666666666666666*G12_0_0_1;
    A[21] = 0.00357142857142857*G4_6_0 + 0.00357142857142857*G4_6_1 - 0.00357142857142857*G4_7_0 + 0.00436507936507936*G4_8_1 + 0.00158730158730159*G4_9_0 - 0.00634920634920634*G4_9_1 - 0.00158730158730159*G4_10_0 - 0.00793650793650793*G4_10_1 + 0.00634920634920635*G4_11_1;
    A[22] = 0.00714285714285713*G4_6_0 + 0.00714285714285714*G4_6_1 + 0.0309523809523809*G4_7_0 - 0.00714285714285713*G4_8_1 + 0.0095238095238095*G4_9_0 + 0.0476190476190476*G4_9_1 - 0.0095238095238095*G4_10_0 - 0.0380952380952381*G4_11_0 - 0.0476190476190476*G4_11_1;
    A[23] = -0.00436507936507936*G4_6_0 - 0.00436507936507936*G4_6_1 - 0.00357142857142857*G4_7_0 - 0.00357142857142857*G4_8_1 - 0.00634920634920634*G4_9_0 - 0.00634920634920634*G4_9_1 + 0.00634920634920634*G4_10_0 + 0.00793650793650792*G4_10_1 + 0.00793650793650793*G4_11_0 + 0.00634920634920634*G4_11_1;
    A[24] = 0.00634920634920634*G4_6_0 + 0.00634920634920634*G4_6_1 + 0.019047619047619*G4_7_0 - 0.0126984126984127*G4_8_1 - 0.0126984126984127*G4_9_0 + 0.019047619047619*G4_9_1 + 0.0126984126984127*G4_10_0 + 0.00634920634920636*G4_10_1 - 0.0253968253968254*G4_11_0 - 0.019047619047619*G4_11_1;
    A[25] = 0.00793650793650793*G4_6_0 + 0.00793650793650793*G4_6_1 + 0.00476190476190476*G4_7_0 - 0.00793650793650794*G4_8_1 - 0.019047619047619*G4_9_0 - 0.00634920634920634*G4_9_1 + 0.019047619047619*G4_10_0 - 0.0126984126984127*G4_11_0 + 0.00634920634920634*G4_11_1;
    A[26] = 0.0126984126984127*G4_6_0 + 0.0126984126984127*G4_6_1 + 0.019047619047619*G4_7_0 - 0.00634920634920636*G4_8_1 - 0.00634920634920635*G4_9_0 + 0.019047619047619*G4_9_1 + 0.00634920634920635*G4_10_0 - 0.00634920634920633*G4_10_1 - 0.0317460317460317*G4_11_0 - 0.0190476190476191*G4_11_1;
    A[27] = 0.0;
    A[28] = 0.166666666666667*G8_0;
    A[29] = 0.0;
    A[30] = 0.00357142857142857*G0_0_0 + 0.00357142857142857*G0_0_1 + 0.00436507936507936*G0_1_0 - 0.00357142857142857*G0_2_1 - 0.00634920634920634*G0_3_0 + 0.00158730158730159*G0_3_1 + 0.00634920634920634*G0_4_0 - 0.00793650793650793*G0_5_0 - 0.00158730158730159*G0_5_1 - 0.00714285714285715*G1_0_1 + 0.00436507936507936*G1_1_1 - 0.00357142857142857*G1_2_1 - 0.00793650793650793*G1_3_1 - 0.0126984126984127*G1_4_1 - 0.00634920634920635*G1_5_1 - 0.00714285714285715*G3_6_1 + 0.00436507936507936*G3_7_1 - 0.00357142857142857*G3_8_1 - 0.00793650793650793*G3_9_1 - 0.0126984126984127*G3_10_1 - 0.00634920634920635*G3_11_1 + 0.166666666666667*G10_0_1_0 + 0.166666666666667*G10_0_1_1 + 0.166666666666667*G12_0_1_0 + 0.166666666666667*G12_0_1_1;
    A[31] = -0.00436507936507936*G0_0_0 - 0.00436507936507936*G0_0_1 - 0.00357142857142856*G0_1_0 - 0.00357142857142857*G0_2_1 - 0.00634920634920633*G0_3_0 - 0.00634920634920634*G0_3_1 + 0.00634920634920633*G0_4_0 + 0.00793650793650792*G0_4_1 + 0.00793650793650793*G0_5_0 + 0.00634920634920634*G0_5_1 + 0.00436507936507936*G1_0_1 - 0.00714285714285713*G1_1_1 - 0.00357142857142857*G1_2_1 - 0.0126984126984127*G1_3_1 - 0.00793650793650794*G1_4_1 - 0.00634920634920636*G1_5_1 + 0.00436507936507936*G3_6_1 - 0.00714285714285713*G3_7_1 - 0.00357142857142857*G3_8_1 - 0.0126984126984127*G3_9_1 - 0.00793650793650794*G3_10_1 - 0.00634920634920636*G3_11_1 - 0.166666666666667*G10_0_1_0 - 0.166666666666667*G12_0_1_0;
    A[32] = 0.00714285714285714*G0_0_0 + 0.00714285714285713*G0_0_1 - 0.00714285714285714*G0_1_0 + 0.0309523809523809*G0_2_1 + 0.0476190476190475*G0_3_0 + 0.0095238095238095*G0_3_1 - 0.0476190476190475*G0_4_0 - 0.038095238095238*G0_4_1 - 0.00952380952380951*G0_5_1 - 0.00357142857142857*G1_0_1 - 0.00357142857142857*G1_1_1 + 0.0309523809523809*G1_2_1 + 0.019047619047619*G1_3_1 + 0.019047619047619*G1_4_1 + 0.00476190476190476*G1_5_1 - 0.00357142857142857*G3_6_1 - 0.00357142857142857*G3_7_1 + 0.0309523809523809*G3_8_1 + 0.019047619047619*G3_9_1 + 0.019047619047619*G3_10_1 + 0.00476190476190476*G3_11_1 + 0.5*G10_0_1_1 + 0.5*G12_0_1_1;
    A[33] = 0.00634920634920635*G0_0_0 + 0.00634920634920634*G0_0_1 - 0.0126984126984127*G0_1_0 + 0.019047619047619*G0_2_1 + 0.019047619047619*G0_3_0 - 0.0126984126984127*G0_3_1 - 0.019047619047619*G0_4_0 - 0.0253968253968254*G0_4_1 + 0.00634920634920634*G0_5_0 + 0.0126984126984127*G0_5_1 - 0.00793650793650793*G1_0_1 - 0.0126984126984127*G1_1_1 + 0.019047619047619*G1_2_1 + 0.0634920634920634*G1_3_1 + 0.0317460317460317*G1_4_1 + 0.00634920634920636*G1_5_1 - 0.00793650793650793*G3_6_1 - 0.0126984126984127*G3_7_1 + 0.019047619047619*G3_8_1 + 0.0634920634920634*G3_9_1 + 0.0317460317460317*G3_10_1 + 0.00634920634920636*G3_11_1 + 0.666666666666666*G10_0_1_0 + 0.666666666666666*G12_0_1_0;
    A[34] = 0.0126984126984127*G0_0_0 + 0.0126984126984127*G0_0_1 - 0.00634920634920635*G0_1_0 + 0.019047619047619*G0_2_1 + 0.019047619047619*G0_3_0 - 0.00634920634920634*G0_3_1 - 0.019047619047619*G0_4_0 - 0.0317460317460317*G0_4_1 - 0.00634920634920635*G0_5_0 + 0.00634920634920634*G0_5_1 - 0.0126984126984127*G1_0_1 - 0.00793650793650794*G1_1_1 + 0.019047619047619*G1_2_1 + 0.0317460317460317*G1_3_1 + 0.0634920634920635*G1_4_1 + 0.00634920634920636*G1_5_1 - 0.0126984126984127*G3_6_1 - 0.00793650793650794*G3_7_1 + 0.019047619047619*G3_8_1 + 0.0317460317460317*G3_9_1 + 0.0634920634920635*G3_10_1 + 0.00634920634920636*G3_11_1 - 0.666666666666666*G10_0_1_0 - 0.666666666666666*G10_0_1_1 - 0.666666666666666*G12_0_1_0 - 0.666666666666666*G12_0_1_1;
    A[35] = 0.00793650793650793*G0_0_0 + 0.00793650793650793*G0_0_1 - 0.00793650793650793*G0_1_0 + 0.00476190476190476*G0_2_1 - 0.00634920634920633*G0_3_0 - 0.019047619047619*G0_3_1 + 0.00634920634920633*G0_4_0 - 0.0126984126984127*G0_4_1 + 0.019047619047619*G0_5_1 - 0.00634920634920635*G1_0_1 - 0.00634920634920636*G1_1_1 + 0.00476190476190476*G1_2_1 + 0.00634920634920636*G1_3_1 + 0.00634920634920636*G1_4_1 - 0.0380952380952381*G1_5_1 - 0.00634920634920635*G3_6_1 - 0.00634920634920636*G3_7_1 + 0.00476190476190476*G3_8_1 + 0.00634920634920636*G3_9_1 + 0.00634920634920636*G3_10_1 - 0.0380952380952381*G3_11_1;
    A[36] = 0.00357142857142857*G4_6_0 + 0.00357142857142857*G4_6_1 + 0.00436507936507936*G4_7_0 - 0.00357142857142857*G4_8_1 - 0.00634920634920634*G4_9_0 + 0.00158730158730159*G4_9_1 + 0.00634920634920634*G4_10_0 - 0.00793650793650793*G4_11_0 - 0.00158730158730159*G4_11_1;
    A[37] = -0.00436507936507936*G4_6_0 - 0.00436507936507936*G4_6_1 - 0.00357142857142856*G4_7_0 - 0.00357142857142857*G4_8_1 - 0.00634920634920633*G4_9_0 - 0.00634920634920634*G4_9_1 + 0.00634920634920633*G4_10_0 + 0.00793650793650792*G4_10_1 + 0.00793650793650793*G4_11_0 + 0.00634920634920634*G4_11_1;
    A[38] = 0.00714285714285714*G4_6_0 + 0.00714285714285713*G4_6_1 - 0.00714285714285714*G4_7_0 + 0.0309523809523809*G4_8_1 + 0.0476190476190475*G4_9_0 + 0.0095238095238095*G4_9_1 - 0.0476190476190475*G4_10_0 - 0.038095238095238*G4_10_1 - 0.00952380952380951*G4_11_1;
    A[39] = 0.00634920634920635*G4_6_0 + 0.00634920634920634*G4_6_1 - 0.0126984126984127*G4_7_0 + 0.019047619047619*G4_8_1 + 0.019047619047619*G4_9_0 - 0.0126984126984127*G4_9_1 - 0.019047619047619*G4_10_0 - 0.0253968253968254*G4_10_1 + 0.00634920634920634*G4_11_0 + 0.0126984126984127*G4_11_1;
    A[40] = 0.0126984126984127*G4_6_0 + 0.0126984126984127*G4_6_1 - 0.00634920634920635*G4_7_0 + 0.019047619047619*G4_8_1 + 0.019047619047619*G4_9_0 - 0.00634920634920634*G4_9_1 - 0.019047619047619*G4_10_0 - 0.0317460317460317*G4_10_1 - 0.00634920634920635*G4_11_0 + 0.00634920634920634*G4_11_1;
    A[41] = 0.00793650793650793*G4_6_0 + 0.00793650793650793*G4_6_1 - 0.00793650793650793*G4_7_0 + 0.00476190476190476*G4_8_1 - 0.00634920634920633*G4_9_0 - 0.019047619047619*G4_9_1 + 0.00634920634920633*G4_10_0 - 0.0126984126984127*G4_10_1 + 0.019047619047619*G4_11_1;
    A[42] = 0.0;
    A[43] = 0.0;
    A[44] = 0.166666666666667*G8_1;
    A[45] = -0.00476190476190477*G0_0_0 - 0.00476190476190477*G0_0_1 - 0.00793650793650793*G0_1_0 - 0.00793650793650793*G0_2_1 - 0.019047619047619*G0_3_0 - 0.019047619047619*G0_3_1 + 0.019047619047619*G0_4_0 + 0.0126984126984127*G0_4_1 + 0.0126984126984127*G0_5_0 + 0.019047619047619*G0_5_1 + 0.00952380952380951*G1_0_0 + 0.00952380952380951*G1_0_1 + 0.00158730158730159*G1_1_0 - 0.00634920634920634*G1_1_1 - 0.00634920634920634*G1_2_0 + 0.00158730158730159*G1_2_1 - 0.019047619047619*G1_3_0 - 0.019047619047619*G1_3_1 - 0.0126984126984127*G1_4_0 - 0.00634920634920634*G1_4_1 - 0.00634920634920635*G1_5_0 - 0.0126984126984127*G1_5_1 + 0.00952380952380951*G3_6_0 + 0.00952380952380951*G3_6_1 + 0.00158730158730159*G3_7_0 - 0.00634920634920634*G3_7_1 - 0.00634920634920634*G3_8_0 + 0.00158730158730159*G3_8_1 - 0.019047619047619*G3_9_0 - 0.019047619047619*G3_9_1 - 0.0126984126984127*G3_10_0 - 0.00634920634920634*G3_10_1 - 0.00634920634920635*G3_11_0 - 0.0126984126984127*G3_11_1;
    A[46] = 0.00634920634920634*G0_0_0 + 0.00634920634920634*G0_0_1 + 0.019047619047619*G0_1_0 - 0.0126984126984127*G0_2_1 - 0.0126984126984127*G0_3_0 + 0.019047619047619*G0_3_1 + 0.0126984126984127*G0_4_0 + 0.00634920634920636*G0_4_1 - 0.0253968253968254*G0_5_0 - 0.019047619047619*G0_5_1 + 0.00158730158730159*G1_0_0 - 0.00634920634920634*G1_0_1 + 0.0095238095238095*G1_1_0 + 0.0476190476190476*G1_1_1 - 0.00634920634920633*G1_2_0 - 0.00634920634920634*G1_2_1 - 0.0126984126984127*G1_3_0 + 0.019047619047619*G1_3_1 - 0.019047619047619*G1_4_0 - 0.00634920634920634*G1_4_1 - 0.00634920634920635*G1_5_0 + 0.019047619047619*G1_5_1 + 0.00158730158730159*G3_6_0 - 0.00634920634920634*G3_6_1 + 0.0095238095238095*G3_7_0 + 0.0476190476190476*G3_7_1 - 0.00634920634920633*G3_8_0 - 0.00634920634920634*G3_8_1 - 0.0126984126984127*G3_9_0 + 0.019047619047619*G3_9_1 - 0.019047619047619*G3_10_0 - 0.00634920634920634*G3_10_1 - 0.00634920634920635*G3_11_0 + 0.019047619047619*G3_11_1 + 0.666666666666666*G10_0_1_0 + 0.666666666666666*G12_0_1_0;
    A[47] = 0.00634920634920635*G0_0_0 + 0.00634920634920634*G0_0_1 - 0.0126984126984127*G0_1_0 + 0.019047619047619*G0_2_1 + 0.019047619047619*G0_3_0 - 0.0126984126984127*G0_3_1 - 0.019047619047619*G0_4_0 - 0.0253968253968254*G0_4_1 + 0.00634920634920634*G0_5_0 + 0.0126984126984127*G0_5_1 - 0.00634920634920634*G1_0_0 + 0.00158730158730159*G1_0_1 - 0.00634920634920634*G1_1_0 - 0.00634920634920634*G1_1_1 + 0.0476190476190475*G1_2_0 + 0.0095238095238095*G1_2_1 + 0.019047619047619*G1_3_0 - 0.0126984126984127*G1_3_1 + 0.019047619047619*G1_4_0 - 0.00634920634920634*G1_4_1 - 0.00634920634920633*G1_5_0 - 0.019047619047619*G1_5_1 - 0.00634920634920634*G3_6_0 + 0.00158730158730159*G3_6_1 - 0.00634920634920634*G3_7_0 - 0.00634920634920634*G3_7_1 + 0.0476190476190475*G3_8_0 + 0.0095238095238095*G3_8_1 + 0.019047619047619*G3_9_0 - 0.0126984126984127*G3_9_1 + 0.019047619047619*G3_10_0 - 0.00634920634920634*G3_10_1 - 0.00634920634920633*G3_11_0 - 0.019047619047619*G3_11_1 + 0.666666666666666*G10_0_0_1 + 0.666666666666666*G12_0_0_1;
    A[48] = 0.0380952380952381*G0_0_0 + 0.0380952380952381*G0_0_1 + 0.0634920634920634*G0_1_0 + 0.0634920634920634*G0_2_1 + 0.152380952380952*G0_3_0 + 0.152380952380952*G0_3_1 - 0.152380952380952*G0_4_0 - 0.101587301587301*G0_4_1 - 0.101587301587302*G0_5_0 - 0.152380952380952*G0_5_1 - 0.019047619047619*G1_0_0 - 0.019047619047619*G1_0_1 - 0.0126984126984127*G1_1_0 + 0.019047619047619*G1_1_1 + 0.019047619047619*G1_2_0 - 0.0126984126984127*G1_2_1 + 0.152380952380952*G1_3_0 + 0.152380952380952*G1_3_1 + 0.0761904761904761*G1_4_0 + 0.0507936507936507*G1_4_1 + 0.0507936507936508*G1_5_0 + 0.0761904761904761*G1_5_1 - 0.019047619047619*G3_6_0 - 0.019047619047619*G3_6_1 - 0.0126984126984127*G3_7_0 + 0.019047619047619*G3_7_1 + 0.019047619047619*G3_8_0 - 0.0126984126984127*G3_8_1 + 0.152380952380952*G3_9_0 + 0.152380952380952*G3_9_1 + 0.0761904761904761*G3_10_0 + 0.0507936507936507*G3_10_1 + 0.0507936507936508*G3_11_0 + 0.0761904761904761*G3_11_1 + 1.33333333333333*G10_0_0_0 + 0.666666666666665*G10_0_0_1 + 0.666666666666665*G10_0_1_0 + 1.33333333333333*G10_0_1_1 + 1.33333333333333*G12_0_0_0 + 0.666666666666665*G12_0_0_1 + 0.666666666666665*G12_0_1_0 + 1.33333333333333*G12_0_1_1;
    A[49] = -0.00634920634920633*G0_0_0 - 0.00634920634920632*G0_0_1 + 0.00634920634920634*G0_1_0 + 0.0317460317460317*G0_2_1 + 0.0761904761904761*G0_3_0 + 0.0507936507936507*G0_3_1 - 0.0761904761904761*G0_4_0 - 0.0253968253968254*G0_4_1 - 0.0507936507936508*G0_5_1 - 0.0126984126984127*G1_0_0 - 0.00634920634920634*G1_0_1 - 0.019047619047619*G1_1_0 - 0.00634920634920634*G1_1_1 + 0.019047619047619*G1_2_0 - 0.00634920634920634*G1_2_1 + 0.0761904761904761*G1_3_0 + 0.0507936507936507*G1_3_1 + 0.152380952380952*G1_4_0 + 0.0507936507936507*G1_4_1 + 0.0507936507936508*G1_5_0 + 0.0507936507936507*G1_5_1 - 0.0126984126984127*G3_6_0 - 0.00634920634920634*G3_6_1 - 0.019047619047619*G3_7_0 - 0.00634920634920634*G3_7_1 + 0.019047619047619*G3_8_0 - 0.00634920634920634*G3_8_1 + 0.0761904761904761*G3_9_0 + 0.0507936507936507*G3_9_1 + 0.152380952380952*G3_10_0 + 0.0507936507936507*G3_10_1 + 0.0507936507936508*G3_11_0 + 0.0507936507936507*G3_11_1 - 1.33333333333333*G10_0_0_0 - 0.666666666666666*G10_0_0_1 - 0.666666666666665*G10_0_1_0 - 1.33333333333333*G12_0_0_0 - 0.666666666666666*G12_0_0_1 - 0.666666666666665*G12_0_1_0;
    A[50] = -0.00634920634920633*G0_0_0 - 0.00634920634920632*G0_0_1 + 0.0317460317460317*G0_1_0 + 0.00634920634920636*G0_2_1 + 0.0507936507936508*G0_3_0 + 0.0761904761904761*G0_3_1 - 0.0507936507936508*G0_4_0 - 0.0253968253968254*G0_5_0 - 0.0761904761904762*G0_5_1 - 0.00634920634920635*G1_0_0 - 0.0126984126984127*G1_0_1 - 0.00634920634920635*G1_1_0 + 0.019047619047619*G1_1_1 - 0.00634920634920633*G1_2_0 - 0.019047619047619*G1_2_1 + 0.0507936507936508*G1_3_0 + 0.0761904761904761*G1_3_1 + 0.0507936507936507*G1_4_0 + 0.0507936507936507*G1_4_1 + 0.0507936507936507*G1_5_0 + 0.152380952380952*G1_5_1 - 0.00634920634920635*G3_6_0 - 0.0126984126984127*G3_6_1 - 0.00634920634920635*G3_7_0 + 0.019047619047619*G3_7_1 - 0.00634920634920633*G3_8_0 - 0.019047619047619*G3_8_1 + 0.0507936507936508*G3_9_0 + 0.0761904761904761*G3_9_1 + 0.0507936507936507*G3_10_0 + 0.0507936507936507*G3_10_1 + 0.0507936507936507*G3_11_0 + 0.152380952380952*G3_11_1 - 0.666666666666665*G10_0_0_1 - 0.666666666666667*G10_0_1_0 - 1.33333333333333*G10_0_1_1 - 0.666666666666665*G12_0_0_1 - 0.666666666666667*G12_0_1_0 - 1.33333333333333*G12_0_1_1;
    A[51] = -0.00476190476190477*G4_6_0 - 0.00476190476190477*G4_6_1 - 0.00793650793650793*G4_7_0 - 0.00793650793650793*G4_8_1 - 0.019047619047619*G4_9_0 - 0.019047619047619*G4_9_1 + 0.019047619047619*G4_10_0 + 0.0126984126984127*G4_10_1 + 0.0126984126984127*G4_11_0 + 0.019047619047619*G4_11_1;
    A[52] = 0.00634920634920634*G4_6_0 + 0.00634920634920634*G4_6_1 + 0.019047619047619*G4_7_0 - 0.0126984126984127*G4_8_1 - 0.0126984126984127*G4_9_0 + 0.019047619047619*G4_9_1 + 0.0126984126984127*G4_10_0 + 0.00634920634920636*G4_10_1 - 0.0253968253968254*G4_11_0 - 0.019047619047619*G4_11_1;
    A[53] = 0.00634920634920635*G4_6_0 + 0.00634920634920634*G4_6_1 - 0.0126984126984127*G4_7_0 + 0.019047619047619*G4_8_1 + 0.019047619047619*G4_9_0 - 0.0126984126984127*G4_9_1 - 0.019047619047619*G4_10_0 - 0.0253968253968254*G4_10_1 + 0.00634920634920634*G4_11_0 + 0.0126984126984127*G4_11_1;
    A[54] = 0.0380952380952381*G4_6_0 + 0.0380952380952381*G4_6_1 + 0.0634920634920634*G4_7_0 + 0.0634920634920634*G4_8_1 + 0.152380952380952*G4_9_0 + 0.152380952380952*G4_9_1 - 0.152380952380952*G4_10_0 - 0.101587301587301*G4_10_1 - 0.101587301587302*G4_11_0 - 0.152380952380952*G4_11_1;
    A[55] = -0.00634920634920633*G4_6_0 - 0.00634920634920632*G4_6_1 + 0.00634920634920634*G4_7_0 + 0.0317460317460317*G4_8_1 + 0.0761904761904761*G4_9_0 + 0.0507936507936507*G4_9_1 - 0.0761904761904761*G4_10_0 - 0.0253968253968254*G4_10_1 - 0.0507936507936508*G4_11_1;
    A[56] = -0.00634920634920633*G4_6_0 - 0.00634920634920632*G4_6_1 + 0.0317460317460317*G4_7_0 + 0.00634920634920636*G4_8_1 + 0.0507936507936508*G4_9_0 + 0.0761904761904761*G4_9_1 - 0.0507936507936508*G4_10_0 - 0.0253968253968254*G4_11_0 - 0.0761904761904762*G4_11_1;
    A[57] = 0.166666666666667*G8_0 + 0.166666666666667*G8_1;
    A[58] = 0.166666666666667*G8_0 + 0.333333333333333*G8_1;
    A[59] = 0.333333333333333*G8_0 + 0.166666666666666*G8_1;
    A[60] = -0.0190476190476191*G0_0_0 - 0.0190476190476191*G0_0_1 - 0.00634920634920636*G0_1_0 - 0.0126984126984127*G0_2_1 - 0.0126984126984127*G0_3_0 - 0.00634920634920634*G0_3_1 + 0.0126984126984127*G0_4_0 + 0.0317460317460318*G0_4_1 + 0.0253968253968254*G0_5_0 + 0.00634920634920634*G0_5_1 - 0.00952380952380951*G1_0_0 + 0.0380952380952381*G1_0_1 - 0.00158730158730159*G1_1_0 - 0.00793650793650793*G1_1_1 + 0.00634920634920634*G1_2_0 + 0.019047619047619*G1_3_0 + 0.0126984126984127*G1_3_1 + 0.0126984126984127*G1_4_0 + 0.0317460317460318*G1_4_1 + 0.00634920634920635*G1_5_0 + 0.0253968253968254*G1_5_1 - 0.00952380952380951*G3_6_0 + 0.0380952380952381*G3_6_1 - 0.00158730158730159*G3_7_0 - 0.00793650793650793*G3_7_1 + 0.00634920634920634*G3_8_0 + 0.019047619047619*G3_9_0 + 0.0126984126984127*G3_9_1 + 0.0126984126984127*G3_10_0 + 0.0317460317460318*G3_10_1 + 0.00634920634920635*G3_11_0 + 0.0253968253968254*G3_11_1 - 0.666666666666667*G10_0_1_0 - 0.666666666666666*G10_0_1_1 - 0.666666666666667*G12_0_1_0 - 0.666666666666666*G12_0_1_1;
    A[61] = 0.00793650793650793*G0_0_0 + 0.00793650793650793*G0_0_1 + 0.00476190476190476*G0_1_0 - 0.00793650793650794*G0_2_1 - 0.019047619047619*G0_3_0 - 0.00634920634920634*G0_3_1 + 0.019047619047619*G0_4_0 - 0.0126984126984127*G0_5_0 + 0.00634920634920634*G0_5_1 - 0.00158730158730159*G1_0_0 - 0.00793650793650793*G1_0_1 - 0.0095238095238095*G1_1_0 + 0.00634920634920633*G1_2_0 + 0.00793650793650792*G1_2_1 + 0.0126984126984127*G1_3_0 + 0.00634920634920636*G1_3_1 + 0.019047619047619*G1_4_0 + 0.00634920634920635*G1_5_0 - 0.00634920634920633*G1_5_1 - 0.00158730158730159*G3_6_0 - 0.00793650793650793*G3_6_1 - 0.0095238095238095*G3_7_0 + 0.00634920634920633*G3_8_0 + 0.00793650793650792*G3_8_1 + 0.0126984126984127*G3_9_0 + 0.00634920634920636*G3_9_1 + 0.019047619047619*G3_10_0 + 0.00634920634920635*G3_11_0 - 0.00634920634920633*G3_11_1;
    A[62] = 0.0126984126984127*G0_0_0 + 0.0126984126984127*G0_0_1 - 0.00634920634920635*G0_1_0 + 0.019047619047619*G0_2_1 + 0.019047619047619*G0_3_0 - 0.00634920634920634*G0_3_1 - 0.019047619047619*G0_4_0 - 0.0317460317460317*G0_4_1 - 0.00634920634920635*G0_5_0 + 0.00634920634920634*G0_5_1 + 0.00634920634920634*G1_0_0 + 0.00634920634920634*G1_1_0 + 0.00793650793650792*G1_1_1 - 0.0476190476190475*G1_2_0 - 0.038095238095238*G1_2_1 - 0.019047619047619*G1_3_0 - 0.0253968253968254*G1_3_1 - 0.019047619047619*G1_4_0 - 0.0317460317460317*G1_4_1 + 0.00634920634920633*G1_5_0 - 0.0126984126984127*G1_5_1 + 0.00634920634920634*G3_6_0 + 0.00634920634920634*G3_7_0 + 0.00793650793650792*G3_7_1 - 0.0476190476190475*G3_8_0 - 0.038095238095238*G3_8_1 - 0.019047619047619*G3_9_0 - 0.0253968253968254*G3_9_1 - 0.019047619047619*G3_10_0 - 0.0317460317460317*G3_10_1 + 0.00634920634920633*G3_11_0 - 0.0126984126984127*G3_11_1 - 0.666666666666666*G10_0_0_1 - 0.666666666666666*G10_0_1_1 - 0.666666666666666*G12_0_0_1 - 0.666666666666666*G12_0_1_1;
    A[63] = -0.00634920634920633*G0_0_0 - 0.00634920634920632*G0_0_1 + 0.00634920634920634*G0_1_0 + 0.0317460317460317*G0_2_1 + 0.0761904761904761*G0_3_0 + 0.0507936507936507*G0_3_1 - 0.0761904761904761*G0_4_0 - 0.0253968253968254*G0_4_1 - 0.0507936507936508*G0_5_1 + 0.019047619047619*G1_0_0 + 0.0126984126984127*G1_0_1 + 0.0126984126984127*G1_1_0 + 0.00634920634920636*G1_1_1 - 0.019047619047619*G1_2_0 - 0.0253968253968254*G1_2_1 - 0.152380952380952*G1_3_0 - 0.101587301587301*G1_3_1 - 0.0761904761904761*G1_4_0 - 0.0253968253968254*G1_4_1 - 0.0507936507936508*G1_5_0 + 0.019047619047619*G3_6_0 + 0.0126984126984127*G3_6_1 + 0.0126984126984127*G3_7_0 + 0.00634920634920636*G3_7_1 - 0.019047619047619*G3_8_0 - 0.0253968253968254*G3_8_1 - 0.152380952380952*G3_9_0 - 0.101587301587301*G3_9_1 - 0.0761904761904761*G3_10_0 - 0.0253968253968254*G3_10_1 - 0.0507936507936508*G3_11_0 - 1.33333333333333*G10_0_0_0 - 0.666666666666665*G10_0_0_1 - 0.666666666666666*G10_0_1_0 - 1.33333333333333*G12_0_0_0 - 0.666666666666665*G12_0_0_1 - 0.666666666666666*G12_0_1_0;
    A[64] = -0.0634920634920635*G0_0_0 - 0.0634920634920635*G0_0_1 - 0.0380952380952381*G0_1_0 + 0.0634920634920635*G0_2_1 + 0.152380952380952*G0_3_0 + 0.0507936507936507*G0_3_1 - 0.152380952380952*G0_4_0 + 0.101587301587302*G0_5_0 - 0.0507936507936507*G0_5_1 + 0.0126984126984127*G1_0_0 + 0.0317460317460318*G1_0_1 + 0.019047619047619*G1_1_0 - 0.019047619047619*G1_2_0 - 0.0317460317460317*G1_2_1 - 0.0761904761904761*G1_3_0 - 0.0253968253968254*G1_3_1 - 0.152380952380952*G1_4_0 - 0.0507936507936508*G1_5_0 + 0.0253968253968254*G1_5_1 + 0.0126984126984127*G3_6_0 + 0.0317460317460318*G3_6_1 + 0.019047619047619*G3_7_0 - 0.019047619047619*G3_8_0 - 0.0317460317460317*G3_8_1 - 0.0761904761904761*G3_9_0 - 0.0253968253968254*G3_9_1 - 0.152380952380952*G3_10_0 - 0.0507936507936508*G3_11_0 + 0.0253968253968254*G3_11_1 + 1.33333333333333*G10_0_0_0 + 0.666666666666666*G10_0_0_1 + 0.666666666666666*G10_0_1_0 + 1.33333333333333*G10_0_1_1 + 1.33333333333333*G12_0_0_0 + 0.666666666666666*G12_0_0_1 + 0.666666666666666*G12_0_1_0 + 1.33333333333333*G12_0_1_1;
    A[65] = -0.0317460317460317*G0_0_0 - 0.0317460317460317*G0_0_1 + 0.00634920634920634*G0_1_0 + 0.00634920634920636*G0_2_1 + 0.0507936507936507*G0_3_0 + 0.0507936507936507*G0_3_1 - 0.0507936507936507*G0_4_0 + 0.0253968253968254*G0_4_1 + 0.0253968253968254*G0_5_0 - 0.0507936507936508*G0_5_1 + 0.00634920634920635*G1_0_0 + 0.0253968253968254*G1_0_1 + 0.00634920634920635*G1_1_0 - 0.00634920634920633*G1_1_1 + 0.00634920634920633*G1_2_0 - 0.0126984126984127*G1_2_1 - 0.0507936507936508*G1_3_0 - 0.0507936507936507*G1_4_0 + 0.0253968253968254*G1_4_1 - 0.0507936507936507*G1_5_0 + 0.101587301587302*G1_5_1 + 0.00634920634920635*G3_6_0 + 0.0253968253968254*G3_6_1 + 0.00634920634920635*G3_7_0 - 0.00634920634920633*G3_7_1 + 0.00634920634920633*G3_8_0 - 0.0126984126984127*G3_8_1 - 0.0507936507936508*G3_9_0 - 0.0507936507936507*G3_10_0 + 0.0253968253968254*G3_10_1 - 0.0507936507936507*G3_11_0 + 0.101587301587302*G3_11_1 + 0.666666666666665*G10_0_0_1 + 0.666666666666667*G10_0_1_0 + 0.666666666666665*G12_0_0_1 + 0.666666666666667*G12_0_1_0;
    A[66] = -0.0190476190476191*G4_6_0 - 0.0190476190476191*G4_6_1 - 0.00634920634920636*G4_7_0 - 0.0126984126984127*G4_8_1 - 0.0126984126984127*G4_9_0 - 0.00634920634920634*G4_9_1 + 0.0126984126984127*G4_10_0 + 0.0317460317460318*G4_10_1 + 0.0253968253968254*G4_11_0 + 0.00634920634920634*G4_11_1;
    A[67] = 0.00793650793650793*G4_6_0 + 0.00793650793650793*G4_6_1 + 0.00476190476190476*G4_7_0 - 0.00793650793650794*G4_8_1 - 0.019047619047619*G4_9_0 - 0.00634920634920634*G4_9_1 + 0.019047619047619*G4_10_0 - 0.0126984126984127*G4_11_0 + 0.00634920634920634*G4_11_1;
    A[68] = 0.0126984126984127*G4_6_0 + 0.0126984126984127*G4_6_1 - 0.00634920634920635*G4_7_0 + 0.019047619047619*G4_8_1 + 0.019047619047619*G4_9_0 - 0.00634920634920634*G4_9_1 - 0.019047619047619*G4_10_0 - 0.0317460317460317*G4_10_1 - 0.00634920634920635*G4_11_0 + 0.00634920634920634*G4_11_1;
    A[69] = -0.00634920634920633*G4_6_0 - 0.00634920634920632*G4_6_1 + 0.00634920634920634*G4_7_0 + 0.0317460317460317*G4_8_1 + 0.0761904761904761*G4_9_0 + 0.0507936507936507*G4_9_1 - 0.0761904761904761*G4_10_0 - 0.0253968253968254*G4_10_1 - 0.0507936507936508*G4_11_1;
    A[70] = -0.0634920634920635*G4_6_0 - 0.0634920634920635*G4_6_1 - 0.0380952380952381*G4_7_0 + 0.0634920634920635*G4_8_1 + 0.152380952380952*G4_9_0 + 0.0507936507936507*G4_9_1 - 0.152380952380952*G4_10_0 + 0.101587301587302*G4_11_0 - 0.0507936507936507*G4_11_1;
    A[71] = -0.0317460317460317*G4_6_0 - 0.0317460317460317*G4_6_1 + 0.00634920634920634*G4_7_0 + 0.00634920634920636*G4_8_1 + 0.0507936507936507*G4_9_0 + 0.0507936507936507*G4_9_1 - 0.0507936507936507*G4_10_0 + 0.0253968253968254*G4_10_1 + 0.0253968253968254*G4_11_0 - 0.0507936507936508*G4_11_1;
    A[72] = -0.166666666666667*G8_0 + 0.166666666666667*G8_1;
    A[73] = -0.166666666666667*G8_0;
    A[74] = -0.333333333333333*G8_0 - 0.166666666666667*G8_1;
    A[75] = -0.0190476190476191*G0_0_0 - 0.0190476190476191*G0_0_1 - 0.0126984126984127*G0_1_0 - 0.00634920634920635*G0_2_1 - 0.00634920634920635*G0_3_0 - 0.0126984126984127*G0_3_1 + 0.00634920634920635*G0_4_0 + 0.0253968253968254*G0_4_1 + 0.0317460317460318*G0_5_0 + 0.0126984126984127*G0_5_1 + 0.0380952380952381*G1_0_0 - 0.00952380952380952*G1_0_1 + 0.00634920634920635*G1_1_1 - 0.00793650793650793*G1_2_0 - 0.00158730158730159*G1_2_1 + 0.0126984126984127*G1_3_0 + 0.019047619047619*G1_3_1 + 0.0253968253968254*G1_4_0 + 0.00634920634920634*G1_4_1 + 0.0317460317460318*G1_5_0 + 0.0126984126984127*G1_5_1 + 0.0380952380952381*G3_6_0 - 0.00952380952380952*G3_6_1 + 0.00634920634920635*G3_7_1 - 0.00793650793650793*G3_8_0 - 0.00158730158730159*G3_8_1 + 0.0126984126984127*G3_9_0 + 0.019047619047619*G3_9_1 + 0.0253968253968254*G3_10_0 + 0.00634920634920634*G3_10_1 + 0.0317460317460318*G3_11_0 + 0.0126984126984127*G3_11_1 - 0.666666666666667*G10_0_0_0 - 0.666666666666667*G10_0_0_1 - 0.666666666666667*G12_0_0_0 - 0.666666666666667*G12_0_0_1;
    A[76] = 0.0126984126984127*G0_0_0 + 0.0126984126984127*G0_0_1 + 0.019047619047619*G0_1_0 - 0.00634920634920636*G0_2_1 - 0.00634920634920635*G0_3_0 + 0.019047619047619*G0_3_1 + 0.00634920634920635*G0_4_0 - 0.00634920634920633*G0_4_1 - 0.0317460317460317*G0_5_0 - 0.0190476190476191*G0_5_1 + 0.00634920634920635*G1_0_1 - 0.0380952380952381*G1_1_0 - 0.0476190476190476*G1_1_1 + 0.00793650793650793*G1_2_0 + 0.00634920634920634*G1_2_1 - 0.0253968253968254*G1_3_0 - 0.019047619047619*G1_3_1 - 0.0126984126984127*G1_4_0 + 0.00634920634920634*G1_4_1 - 0.0317460317460317*G1_5_0 - 0.0190476190476191*G1_5_1 + 0.00634920634920635*G3_6_1 - 0.0380952380952381*G3_7_0 - 0.0476190476190476*G3_7_1 + 0.00793650793650793*G3_8_0 + 0.00634920634920634*G3_8_1 - 0.0253968253968254*G3_9_0 - 0.019047619047619*G3_9_1 - 0.0126984126984127*G3_10_0 + 0.00634920634920634*G3_10_1 - 0.0317460317460317*G3_11_0 - 0.0190476190476191*G3_11_1 - 0.666666666666667*G10_0_0_0 - 0.666666666666667*G10_0_1_0 - 0.666666666666667*G12_0_0_0 - 0.666666666666667*G12_0_1_0;
    A[77] = 0.00793650793650793*G0_0_0 + 0.00793650793650793*G0_0_1 - 0.00793650793650793*G0_1_0 + 0.00476190476190476*G0_2_1 - 0.00634920634920633*G0_3_0 - 0.019047619047619*G0_3_1 + 0.00634920634920633*G0_4_0 - 0.0126984126984127*G0_4_1 + 0.019047619047619*G0_5_1 - 0.00793650793650793*G1_0_0 - 0.00158730158730159*G1_0_1 + 0.00793650793650793*G1_1_0 + 0.00634920634920634*G1_1_1 - 0.00952380952380951*G1_2_1 + 0.00634920634920634*G1_3_0 + 0.0126984126984127*G1_3_1 - 0.00634920634920635*G1_4_0 + 0.00634920634920634*G1_4_1 + 0.019047619047619*G1_5_1 - 0.00793650793650793*G3_6_0 - 0.00158730158730159*G3_6_1 + 0.00793650793650793*G3_7_0 + 0.00634920634920634*G3_7_1 - 0.00952380952380951*G3_8_1 + 0.00634920634920634*G3_9_0 + 0.0126984126984127*G3_9_1 - 0.00634920634920635*G3_10_0 + 0.00634920634920634*G3_10_1 + 0.019047619047619*G3_11_1;
    A[78] = -0.00634920634920633*G0_0_0 - 0.00634920634920632*G0_0_1 + 0.0317460317460317*G0_1_0 + 0.00634920634920636*G0_2_1 + 0.0507936507936508*G0_3_0 + 0.0761904761904761*G0_3_1 - 0.0507936507936508*G0_4_0 - 0.0253968253968254*G0_5_0 - 0.0761904761904762*G0_5_1 + 0.0126984126984127*G1_0_0 + 0.019047619047619*G1_0_1 - 0.0253968253968254*G1_1_0 - 0.019047619047619*G1_1_1 + 0.00634920634920634*G1_2_0 + 0.0126984126984127*G1_2_1 - 0.101587301587302*G1_3_0 - 0.152380952380952*G1_3_1 - 0.0507936507936508*G1_4_1 - 0.0253968253968254*G1_5_0 - 0.0761904761904762*G1_5_1 + 0.0126984126984127*G3_6_0 + 0.019047619047619*G3_6_1 - 0.0253968253968254*G3_7_0 - 0.019047619047619*G3_7_1 + 0.00634920634920634*G3_8_0 + 0.0126984126984127*G3_8_1 - 0.101587301587302*G3_9_0 - 0.152380952380952*G3_9_1 - 0.0507936507936508*G3_10_1 - 0.0253968253968254*G3_11_0 - 0.0761904761904762*G3_11_1 - 0.666666666666667*G10_0_0_1 - 0.666666666666666*G10_0_1_0 - 1.33333333333333*G10_0_1_1 - 0.666666666666667*G12_0_0_1 - 0.666666666666666*G12_0_1_0 - 1.33333333333333*G12_0_1_1;
    A[79] = -0.0317460317460317*G0_0_0 - 0.0317460317460317*G0_0_1 + 0.00634920634920634*G0_1_0 + 0.00634920634920636*G0_2_1 + 0.0507936507936508*G0_3_0 + 0.0507936507936507*G0_3_1 - 0.0507936507936508*G0_4_0 + 0.0253968253968254*G0_4_1 + 0.0253968253968254*G0_5_0 - 0.0507936507936508*G0_5_1 + 0.0253968253968254*G1_0_0 + 0.00634920634920634*G1_0_1 - 0.0126984126984127*G1_1_0 + 0.00634920634920634*G1_1_1 - 0.00634920634920635*G1_2_0 + 0.00634920634920634*G1_2_1 - 0.0507936507936508*G1_3_1 + 0.101587301587302*G1_4_0 - 0.0507936507936507*G1_4_1 + 0.0253968253968254*G1_5_0 - 0.0507936507936508*G1_5_1 + 0.0253968253968254*G3_6_0 + 0.00634920634920634*G3_6_1 - 0.0126984126984127*G3_7_0 + 0.00634920634920634*G3_7_1 - 0.00634920634920635*G3_8_0 + 0.00634920634920634*G3_8_1 - 0.0507936507936508*G3_9_1 + 0.101587301587302*G3_10_0 - 0.0507936507936507*G3_10_1 + 0.0253968253968254*G3_11_0 - 0.0507936507936508*G3_11_1 + 0.666666666666667*G10_0_0_1 + 0.666666666666666*G10_0_1_0 + 0.666666666666667*G12_0_0_1 + 0.666666666666666*G12_0_1_0;
    A[80] = -0.0634920634920635*G0_0_0 - 0.0634920634920635*G0_0_1 + 0.0634920634920635*G0_1_0 - 0.0380952380952381*G0_2_1 + 0.0507936507936507*G0_3_0 + 0.152380952380952*G0_3_1 - 0.0507936507936507*G0_4_0 + 0.101587301587302*G0_4_1 - 0.152380952380952*G0_5_1 + 0.0317460317460318*G1_0_0 + 0.0126984126984127*G1_0_1 - 0.0317460317460317*G1_1_0 - 0.0190476190476191*G1_1_1 + 0.019047619047619*G1_2_1 - 0.0253968253968254*G1_3_0 - 0.0761904761904762*G1_3_1 + 0.0253968253968254*G1_4_0 - 0.0507936507936508*G1_4_1 - 0.152380952380952*G1_5_1 + 0.0317460317460318*G3_6_0 + 0.0126984126984127*G3_6_1 - 0.0317460317460317*G3_7_0 - 0.0190476190476191*G3_7_1 + 0.019047619047619*G3_8_1 - 0.0253968253968254*G3_9_0 - 0.0761904761904762*G3_9_1 + 0.0253968253968254*G3_10_0 - 0.0507936507936508*G3_10_1 - 0.152380952380952*G3_11_1 + 1.33333333333333*G10_0_0_0 + 0.666666666666667*G10_0_0_1 + 0.666666666666667*G10_0_1_0 + 1.33333333333333*G10_0_1_1 + 1.33333333333333*G12_0_0_0 + 0.666666666666667*G12_0_0_1 + 0.666666666666667*G12_0_1_0 + 1.33333333333333*G12_0_1_1;
    A[81] = -0.0190476190476191*G4_6_0 - 0.0190476190476191*G4_6_1 - 0.0126984126984127*G4_7_0 - 0.00634920634920635*G4_8_1 - 0.00634920634920635*G4_9_0 - 0.0126984126984127*G4_9_1 + 0.00634920634920635*G4_10_0 + 0.0253968253968254*G4_10_1 + 0.0317460317460318*G4_11_0 + 0.0126984126984127*G4_11_1;
    A[82] = 0.0126984126984127*G4_6_0 + 0.0126984126984127*G4_6_1 + 0.019047619047619*G4_7_0 - 0.00634920634920636*G4_8_1 - 0.00634920634920635*G4_9_0 + 0.019047619047619*G4_9_1 + 0.00634920634920635*G4_10_0 - 0.00634920634920633*G4_10_1 - 0.0317460317460317*G4_11_0 - 0.0190476190476191*G4_11_1;
    A[83] = 0.00793650793650793*G4_6_0 + 0.00793650793650793*G4_6_1 - 0.00793650793650793*G4_7_0 + 0.00476190476190476*G4_8_1 - 0.00634920634920633*G4_9_0 - 0.019047619047619*G4_9_1 + 0.00634920634920633*G4_10_0 - 0.0126984126984127*G4_10_1 + 0.019047619047619*G4_11_1;
    A[84] = -0.00634920634920633*G4_6_0 - 0.00634920634920632*G4_6_1 + 0.0317460317460317*G4_7_0 + 0.00634920634920636*G4_8_1 + 0.0507936507936508*G4_9_0 + 0.0761904761904761*G4_9_1 - 0.0507936507936508*G4_10_0 - 0.0253968253968254*G4_11_0 - 0.0761904761904762*G4_11_1;
    A[85] = -0.0317460317460317*G4_6_0 - 0.0317460317460317*G4_6_1 + 0.00634920634920634*G4_7_0 + 0.00634920634920636*G4_8_1 + 0.0507936507936508*G4_9_0 + 0.0507936507936507*G4_9_1 - 0.0507936507936508*G4_10_0 + 0.0253968253968254*G4_10_1 + 0.0253968253968254*G4_11_0 - 0.0507936507936508*G4_11_1;
    A[86] = -0.0634920634920635*G4_6_0 - 0.0634920634920635*G4_6_1 + 0.0634920634920635*G4_7_0 - 0.0380952380952381*G4_8_1 + 0.0507936507936507*G4_9_0 + 0.152380952380952*G4_9_1 - 0.0507936507936507*G4_10_0 + 0.101587301587302*G4_10_1 - 0.152380952380952*G4_11_1;
    A[87] = 0.166666666666667*G8_0 - 0.166666666666667*G8_1;
    A[88] = -0.166666666666667*G8_0 - 0.333333333333333*G8_1;
    A[89] = -0.166666666666667*G8_1;
    A[90] = -0.030952380952381*G2_0_0 - 0.030952380952381*G2_0_1 - 0.00714285714285715*G2_1_0 - 0.00714285714285715*G2_2_1 + 0.00952380952380951*G2_3_0 + 0.00952380952380951*G2_3_1 - 0.00952380952380951*G2_4_0 + 0.0380952380952381*G2_4_1 + 0.0380952380952381*G2_5_0 - 0.00952380952380952*G2_5_1;
    A[91] = 0.00357142857142857*G2_0_0 + 0.00357142857142857*G2_0_1 - 0.00357142857142857*G2_1_0 + 0.00436507936507936*G2_2_1 + 0.00158730158730159*G2_3_0 - 0.00634920634920634*G2_3_1 - 0.00158730158730159*G2_4_0 - 0.00793650793650793*G2_4_1 + 0.00634920634920635*G2_5_1;
    A[92] = 0.00357142857142857*G2_0_0 + 0.00357142857142857*G2_0_1 + 0.00436507936507936*G2_1_0 - 0.00357142857142857*G2_2_1 - 0.00634920634920634*G2_3_0 + 0.00158730158730159*G2_3_1 + 0.00634920634920634*G2_4_0 - 0.00793650793650793*G2_5_0 - 0.00158730158730159*G2_5_1;
    A[93] = -0.00476190476190476*G2_0_0 - 0.00476190476190477*G2_0_1 - 0.00793650793650793*G2_1_0 - 0.00793650793650793*G2_2_1 - 0.019047619047619*G2_3_0 - 0.019047619047619*G2_3_1 + 0.019047619047619*G2_4_0 + 0.0126984126984127*G2_4_1 + 0.0126984126984127*G2_5_0 + 0.019047619047619*G2_5_1;
    A[94] = -0.0190476190476191*G2_0_0 - 0.0190476190476191*G2_0_1 - 0.00634920634920636*G2_1_0 - 0.0126984126984127*G2_2_1 - 0.0126984126984127*G2_3_0 - 0.00634920634920634*G2_3_1 + 0.0126984126984127*G2_4_0 + 0.0317460317460318*G2_4_1 + 0.0253968253968254*G2_5_0 + 0.00634920634920634*G2_5_1;
    A[95] = -0.0190476190476191*G2_0_0 - 0.0190476190476191*G2_0_1 - 0.0126984126984127*G2_1_0 - 0.00634920634920635*G2_2_1 - 0.00634920634920635*G2_3_0 - 0.0126984126984127*G2_3_1 + 0.00634920634920635*G2_4_0 + 0.0253968253968254*G2_4_1 + 0.0317460317460318*G2_5_0 + 0.0126984126984127*G2_5_1;
    A[96] = -0.030952380952381*G5_0_0 - 0.030952380952381*G5_0_1 + 0.00357142857142857*G5_1_0 + 0.00357142857142857*G5_1_1 + 0.00357142857142857*G5_2_0 + 0.00357142857142857*G5_2_1 - 0.00476190476190477*G5_3_0 - 0.00476190476190477*G5_3_1 - 0.0190476190476191*G5_4_0 - 0.0190476190476191*G5_4_1 - 0.0190476190476191*G5_5_0 - 0.0190476190476191*G5_5_1 - 0.030952380952381*G6_6_0 - 0.030952380952381*G6_6_1 - 0.00714285714285715*G6_7_0 - 0.00714285714285715*G6_8_1 + 0.00952380952380951*G6_9_0 + 0.00952380952380951*G6_9_1 - 0.00952380952380951*G6_10_0 + 0.0380952380952381*G6_10_1 + 0.0380952380952381*G6_11_0 - 0.00952380952380952*G6_11_1 - 0.030952380952381*G7_6_0 - 0.030952380952381*G7_6_1 + 0.00357142857142857*G7_7_0 + 0.00357142857142857*G7_7_1 + 0.00357142857142857*G7_8_0 + 0.00357142857142857*G7_8_1 - 0.00476190476190477*G7_9_0 - 0.00476190476190477*G7_9_1 - 0.0190476190476191*G7_10_0 - 0.0190476190476191*G7_10_1 - 0.0190476190476191*G7_11_0 - 0.0190476190476191*G7_11_1 + 0.5*G11_0_0_0 + 0.5*G11_0_0_1 + 0.5*G11_0_1_0 + 0.5*G11_0_1_1 + 0.5*G13_0_0_0 + 0.5*G13_0_0_1 + 0.5*G13_0_1_0 + 0.5*G13_0_1_1;
    A[97] = 0.00357142857142857*G5_0_0 + 0.00357142857142857*G5_0_1 + 0.00714285714285713*G5_1_0 + 0.00714285714285714*G5_1_1 - 0.00436507936507936*G5_2_0 - 0.00436507936507936*G5_2_1 + 0.00634920634920634*G5_3_0 + 0.00634920634920634*G5_3_1 + 0.00793650793650793*G5_4_0 + 0.00793650793650793*G5_4_1 + 0.0126984126984127*G5_5_0 + 0.0126984126984127*G5_5_1 + 0.00357142857142857*G6_6_0 + 0.00357142857142857*G6_6_1 - 0.00357142857142857*G6_7_0 + 0.00436507936507936*G6_8_1 + 0.00158730158730159*G6_9_0 - 0.00634920634920634*G6_9_1 - 0.00158730158730159*G6_10_0 - 0.00793650793650793*G6_10_1 + 0.00634920634920635*G6_11_1 + 0.00357142857142857*G7_6_0 + 0.00357142857142857*G7_6_1 + 0.00714285714285713*G7_7_0 + 0.00714285714285714*G7_7_1 - 0.00436507936507936*G7_8_0 - 0.00436507936507936*G7_8_1 + 0.00634920634920634*G7_9_0 + 0.00634920634920634*G7_9_1 + 0.00793650793650793*G7_10_0 + 0.00793650793650793*G7_10_1 + 0.0126984126984127*G7_11_0 + 0.0126984126984127*G7_11_1 + 0.166666666666667*G11_0_0_0 + 0.166666666666667*G11_0_1_0 + 0.166666666666667*G13_0_0_0 + 0.166666666666667*G13_0_1_0;
    A[98] = 0.00357142857142857*G5_0_0 + 0.00357142857142857*G5_0_1 - 0.00436507936507936*G5_1_0 - 0.00436507936507936*G5_1_1 + 0.00714285714285714*G5_2_0 + 0.00714285714285713*G5_2_1 + 0.00634920634920635*G5_3_0 + 0.00634920634920634*G5_3_1 + 0.0126984126984127*G5_4_0 + 0.0126984126984127*G5_4_1 + 0.00793650793650793*G5_5_0 + 0.00793650793650793*G5_5_1 + 0.00357142857142857*G6_6_0 + 0.00357142857142857*G6_6_1 + 0.00436507936507936*G6_7_0 - 0.00357142857142857*G6_8_1 - 0.00634920634920634*G6_9_0 + 0.00158730158730159*G6_9_1 + 0.00634920634920634*G6_10_0 - 0.00793650793650793*G6_11_0 - 0.00158730158730159*G6_11_1 + 0.00357142857142857*G7_6_0 + 0.00357142857142857*G7_6_1 - 0.00436507936507936*G7_7_0 - 0.00436507936507936*G7_7_1 + 0.00714285714285714*G7_8_0 + 0.00714285714285713*G7_8_1 + 0.00634920634920635*G7_9_0 + 0.00634920634920634*G7_9_1 + 0.0126984126984127*G7_10_0 + 0.0126984126984127*G7_10_1 + 0.00793650793650793*G7_11_0 + 0.00793650793650793*G7_11_1 + 0.166666666666667*G11_0_0_1 + 0.166666666666667*G11_0_1_1 + 0.166666666666667*G13_0_0_1 + 0.166666666666667*G13_0_1_1;
    A[99] = -0.00476190476190476*G5_0_0 - 0.00476190476190477*G5_0_1 + 0.00634920634920634*G5_1_0 + 0.00634920634920634*G5_1_1 + 0.00634920634920635*G5_2_0 + 0.00634920634920634*G5_2_1 + 0.0380952380952381*G5_3_0 + 0.0380952380952381*G5_3_1 - 0.00634920634920633*G5_4_0 - 0.00634920634920632*G5_4_1 - 0.00634920634920633*G5_5_0 - 0.00634920634920632*G5_5_1 - 0.00476190476190476*G6_6_0 - 0.00476190476190477*G6_6_1 - 0.00793650793650793*G6_7_0 - 0.00793650793650793*G6_8_1 - 0.019047619047619*G6_9_0 - 0.019047619047619*G6_9_1 + 0.019047619047619*G6_10_0 + 0.0126984126984127*G6_10_1 + 0.0126984126984127*G6_11_0 + 0.019047619047619*G6_11_1 - 0.00476190476190476*G7_6_0 - 0.00476190476190477*G7_6_1 + 0.00634920634920634*G7_7_0 + 0.00634920634920634*G7_7_1 + 0.00634920634920635*G7_8_0 + 0.00634920634920634*G7_8_1 + 0.0380952380952381*G7_9_0 + 0.0380952380952381*G7_9_1 - 0.00634920634920633*G7_10_0 - 0.00634920634920632*G7_10_1 - 0.00634920634920633*G7_11_0 - 0.00634920634920632*G7_11_1;
    A[100] = -0.0190476190476191*G5_0_0 - 0.0190476190476191*G5_0_1 + 0.00793650793650793*G5_1_0 + 0.00793650793650793*G5_1_1 + 0.0126984126984127*G5_2_0 + 0.0126984126984127*G5_2_1 - 0.00634920634920633*G5_3_0 - 0.00634920634920632*G5_3_1 - 0.0634920634920635*G5_4_0 - 0.0634920634920635*G5_4_1 - 0.0317460317460317*G5_5_0 - 0.0317460317460317*G5_5_1 - 0.0190476190476191*G6_6_0 - 0.0190476190476191*G6_6_1 - 0.00634920634920636*G6_7_0 - 0.0126984126984127*G6_8_1 - 0.0126984126984127*G6_9_0 - 0.00634920634920634*G6_9_1 + 0.0126984126984127*G6_10_0 + 0.0317460317460318*G6_10_1 + 0.0253968253968254*G6_11_0 + 0.00634920634920634*G6_11_1 - 0.0190476190476191*G7_6_0 - 0.0190476190476191*G7_6_1 + 0.00793650793650793*G7_7_0 + 0.00793650793650793*G7_7_1 + 0.0126984126984127*G7_8_0 + 0.0126984126984127*G7_8_1 - 0.00634920634920633*G7_9_0 - 0.00634920634920632*G7_9_1 - 0.0634920634920635*G7_10_0 - 0.0634920634920635*G7_10_1 - 0.0317460317460317*G7_11_0 - 0.0317460317460317*G7_11_1 - 0.666666666666667*G11_0_0_1 - 0.666666666666666*G11_0_1_1 - 0.666666666666667*G13_0_0_1 - 0.666666666666666*G13_0_1_1;
    A[101] = -0.0190476190476191*G5_0_0 - 0.0190476190476191*G5_0_1 + 0.0126984126984127*G5_1_0 + 0.0126984126984127*G5_1_1 + 0.00793650793650793*G5_2_0 + 0.00793650793650793*G5_2_1 - 0.00634920634920633*G5_3_0 - 0.00634920634920632*G5_3_1 - 0.0317460317460317*G5_4_0 - 0.0317460317460317*G5_4_1 - 0.0634920634920635*G5_5_0 - 0.0634920634920635*G5_5_1 - 0.0190476190476191*G6_6_0 - 0.0190476190476191*G6_6_1 - 0.0126984126984127*G6_7_0 - 0.00634920634920635*G6_8_1 - 0.00634920634920635*G6_9_0 - 0.0126984126984127*G6_9_1 + 0.00634920634920635*G6_10_0 + 0.0253968253968254*G6_10_1 + 0.0317460317460318*G6_11_0 + 0.0126984126984127*G6_11_1 - 0.0190476190476191*G7_6_0 - 0.0190476190476191*G7_6_1 + 0.0126984126984127*G7_7_0 + 0.0126984126984127*G7_7_1 + 0.00793650793650793*G7_8_0 + 0.00793650793650793*G7_8_1 - 0.00634920634920633*G7_9_0 - 0.00634920634920632*G7_9_1 - 0.0317460317460317*G7_10_0 - 0.0317460317460317*G7_10_1 - 0.0634920634920635*G7_11_0 - 0.0634920634920635*G7_11_1 - 0.666666666666667*G11_0_0_0 - 0.666666666666667*G11_0_1_0 - 0.666666666666667*G13_0_0_0 - 0.666666666666667*G13_0_1_0;
    A[102] = -0.166666666666667*G9_0 - 0.166666666666667*G9_1;
    A[103] = 0.0;
    A[104] = 0.0;
    A[105] = 0.00357142857142857*G2_0_0 + 0.00357142857142857*G2_0_1 - 0.00357142857142857*G2_1_0 + 0.00436507936507936*G2_2_1 + 0.00158730158730159*G2_3_0 - 0.00634920634920634*G2_3_1 - 0.00158730158730159*G2_4_0 - 0.00793650793650793*G2_4_1 + 0.00634920634920635*G2_5_1;
    A[106] = 0.00714285714285713*G2_0_0 + 0.00714285714285714*G2_0_1 + 0.0309523809523809*G2_1_0 - 0.00714285714285713*G2_2_1 + 0.0095238095238095*G2_3_0 + 0.0476190476190476*G2_3_1 - 0.0095238095238095*G2_4_0 - 0.0380952380952381*G2_5_0 - 0.0476190476190476*G2_5_1;
    A[107] = -0.00436507936507936*G2_0_0 - 0.00436507936507936*G2_0_1 - 0.00357142857142857*G2_1_0 - 0.00357142857142857*G2_2_1 - 0.00634920634920634*G2_3_0 - 0.00634920634920634*G2_3_1 + 0.00634920634920634*G2_4_0 + 0.00793650793650792*G2_4_1 + 0.00793650793650793*G2_5_0 + 0.00634920634920634*G2_5_1;
    A[108] = 0.00634920634920634*G2_0_0 + 0.00634920634920634*G2_0_1 + 0.019047619047619*G2_1_0 - 0.0126984126984127*G2_2_1 - 0.0126984126984127*G2_3_0 + 0.019047619047619*G2_3_1 + 0.0126984126984127*G2_4_0 + 0.00634920634920636*G2_4_1 - 0.0253968253968254*G2_5_0 - 0.019047619047619*G2_5_1;
    A[109] = 0.00793650793650793*G2_0_0 + 0.00793650793650793*G2_0_1 + 0.00476190476190476*G2_1_0 - 0.00793650793650794*G2_2_1 - 0.019047619047619*G2_3_0 - 0.00634920634920634*G2_3_1 + 0.019047619047619*G2_4_0 - 0.0126984126984127*G2_5_0 + 0.00634920634920634*G2_5_1;
    A[110] = 0.0126984126984127*G2_0_0 + 0.0126984126984127*G2_0_1 + 0.019047619047619*G2_1_0 - 0.00634920634920636*G2_2_1 - 0.00634920634920635*G2_3_0 + 0.019047619047619*G2_3_1 + 0.00634920634920635*G2_4_0 - 0.00634920634920633*G2_4_1 - 0.0317460317460317*G2_5_0 - 0.0190476190476191*G2_5_1;
    A[111] = -0.00714285714285715*G5_0_0 - 0.00357142857142857*G5_1_0 + 0.00436507936507936*G5_2_0 - 0.00793650793650793*G5_3_0 - 0.00634920634920636*G5_4_0 - 0.0126984126984127*G5_5_0 + 0.00357142857142857*G6_6_0 + 0.00357142857142857*G6_6_1 - 0.00357142857142857*G6_7_0 + 0.00436507936507936*G6_8_1 + 0.00158730158730159*G6_9_0 - 0.00634920634920634*G6_9_1 - 0.00158730158730159*G6_10_0 - 0.00793650793650793*G6_10_1 + 0.00634920634920635*G6_11_1 - 0.00714285714285715*G7_6_0 - 0.00357142857142857*G7_7_0 + 0.00436507936507936*G7_8_0 - 0.00793650793650793*G7_9_0 - 0.00634920634920636*G7_10_0 - 0.0126984126984127*G7_11_0 + 0.166666666666667*G11_0_0_0 + 0.166666666666667*G11_0_0_1 + 0.166666666666667*G13_0_0_0 + 0.166666666666667*G13_0_0_1;
    A[112] = -0.00357142857142857*G5_0_0 + 0.0309523809523809*G5_1_0 - 0.00357142857142856*G5_2_0 + 0.019047619047619*G5_3_0 + 0.00476190476190476*G5_4_0 + 0.019047619047619*G5_5_0 + 0.00714285714285713*G6_6_0 + 0.00714285714285714*G6_6_1 + 0.0309523809523809*G6_7_0 - 0.00714285714285713*G6_8_1 + 0.0095238095238095*G6_9_0 + 0.0476190476190476*G6_9_1 - 0.0095238095238095*G6_10_0 - 0.0380952380952381*G6_11_0 - 0.0476190476190476*G6_11_1 - 0.00357142857142857*G7_6_0 + 0.0309523809523809*G7_7_0 - 0.00357142857142856*G7_8_0 + 0.019047619047619*G7_9_0 + 0.00476190476190476*G7_10_0 + 0.019047619047619*G7_11_0 + 0.5*G11_0_0_0 + 0.5*G13_0_0_0;
    A[113] = 0.00436507936507936*G5_0_0 - 0.00357142857142857*G5_1_0 - 0.00714285714285714*G5_2_0 - 0.0126984126984127*G5_3_0 - 0.00634920634920635*G5_4_0 - 0.00793650793650793*G5_5_0 - 0.00436507936507936*G6_6_0 - 0.00436507936507936*G6_6_1 - 0.00357142857142857*G6_7_0 - 0.00357142857142857*G6_8_1 - 0.00634920634920634*G6_9_0 - 0.00634920634920634*G6_9_1 + 0.00634920634920634*G6_10_0 + 0.00793650793650792*G6_10_1 + 0.00793650793650793*G6_11_0 + 0.00634920634920634*G6_11_1 + 0.00436507936507936*G7_6_0 - 0.00357142857142857*G7_7_0 - 0.00714285714285714*G7_8_0 - 0.0126984126984127*G7_9_0 - 0.00634920634920635*G7_10_0 - 0.00793650793650793*G7_11_0 - 0.166666666666667*G11_0_0_1 - 0.166666666666667*G13_0_0_1;
    A[114] = -0.00793650793650793*G5_0_0 + 0.019047619047619*G5_1_0 - 0.0126984126984127*G5_2_0 + 0.0634920634920634*G5_3_0 + 0.00634920634920634*G5_4_0 + 0.0317460317460317*G5_5_0 + 0.00634920634920634*G6_6_0 + 0.00634920634920634*G6_6_1 + 0.019047619047619*G6_7_0 - 0.0126984126984127*G6_8_1 - 0.0126984126984127*G6_9_0 + 0.019047619047619*G6_9_1 + 0.0126984126984127*G6_10_0 + 0.00634920634920636*G6_10_1 - 0.0253968253968254*G6_11_0 - 0.019047619047619*G6_11_1 - 0.00793650793650793*G7_6_0 + 0.019047619047619*G7_7_0 - 0.0126984126984127*G7_8_0 + 0.0634920634920634*G7_9_0 + 0.00634920634920634*G7_10_0 + 0.0317460317460317*G7_11_0 + 0.666666666666666*G11_0_0_1 + 0.666666666666666*G13_0_0_1;
    A[115] = -0.00634920634920636*G5_0_0 + 0.00476190476190476*G5_1_0 - 0.00634920634920635*G5_2_0 + 0.00634920634920634*G5_3_0 - 0.0380952380952381*G5_4_0 + 0.00634920634920634*G5_5_0 + 0.00793650793650793*G6_6_0 + 0.00793650793650793*G6_6_1 + 0.00476190476190476*G6_7_0 - 0.00793650793650794*G6_8_1 - 0.019047619047619*G6_9_0 - 0.00634920634920634*G6_9_1 + 0.019047619047619*G6_10_0 - 0.0126984126984127*G6_11_0 + 0.00634920634920634*G6_11_1 - 0.00634920634920636*G7_6_0 + 0.00476190476190476*G7_7_0 - 0.00634920634920635*G7_8_0 + 0.00634920634920634*G7_9_0 - 0.0380952380952381*G7_10_0 + 0.00634920634920634*G7_11_0;
    A[116] = -0.0126984126984127*G5_0_0 + 0.019047619047619*G5_1_0 - 0.00793650793650793*G5_2_0 + 0.0317460317460317*G5_3_0 + 0.00634920634920634*G5_4_0 + 0.0634920634920635*G5_5_0 + 0.0126984126984127*G6_6_0 + 0.0126984126984127*G6_6_1 + 0.019047619047619*G6_7_0 - 0.00634920634920636*G6_8_1 - 0.00634920634920635*G6_9_0 + 0.019047619047619*G6_9_1 + 0.00634920634920635*G6_10_0 - 0.00634920634920633*G6_10_1 - 0.0317460317460317*G6_11_0 - 0.0190476190476191*G6_11_1 - 0.0126984126984127*G7_6_0 + 0.019047619047619*G7_7_0 - 0.00793650793650793*G7_8_0 + 0.0317460317460317*G7_9_0 + 0.00634920634920634*G7_10_0 + 0.0634920634920635*G7_11_0 - 0.666666666666667*G11_0_0_0 - 0.666666666666666*G11_0_0_1 - 0.666666666666667*G13_0_0_0 - 0.666666666666666*G13_0_0_1;
    A[117] = 0.0;
    A[118] = 0.166666666666667*G9_0;
    A[119] = 0.0;
    A[120] = 0.00357142857142857*G2_0_0 + 0.00357142857142857*G2_0_1 + 0.00436507936507936*G2_1_0 - 0.00357142857142857*G2_2_1 - 0.00634920634920634*G2_3_0 + 0.00158730158730159*G2_3_1 + 0.00634920634920634*G2_4_0 - 0.00793650793650793*G2_5_0 - 0.00158730158730159*G2_5_1;
    A[121] = -0.00436507936507936*G2_0_0 - 0.00436507936507936*G2_0_1 - 0.00357142857142856*G2_1_0 - 0.00357142857142857*G2_2_1 - 0.00634920634920633*G2_3_0 - 0.00634920634920634*G2_3_1 + 0.00634920634920633*G2_4_0 + 0.00793650793650792*G2_4_1 + 0.00793650793650793*G2_5_0 + 0.00634920634920634*G2_5_1;
    A[122] = 0.00714285714285714*G2_0_0 + 0.00714285714285713*G2_0_1 - 0.00714285714285714*G2_1_0 + 0.0309523809523809*G2_2_1 + 0.0476190476190475*G2_3_0 + 0.0095238095238095*G2_3_1 - 0.0476190476190475*G2_4_0 - 0.038095238095238*G2_4_1 - 0.00952380952380951*G2_5_1;
    A[123] = 0.00634920634920635*G2_0_0 + 0.00634920634920634*G2_0_1 - 0.0126984126984127*G2_1_0 + 0.019047619047619*G2_2_1 + 0.019047619047619*G2_3_0 - 0.0126984126984127*G2_3_1 - 0.019047619047619*G2_4_0 - 0.0253968253968254*G2_4_1 + 0.00634920634920634*G2_5_0 + 0.0126984126984127*G2_5_1;
    A[124] = 0.0126984126984127*G2_0_0 + 0.0126984126984127*G2_0_1 - 0.00634920634920635*G2_1_0 + 0.019047619047619*G2_2_1 + 0.019047619047619*G2_3_0 - 0.00634920634920634*G2_3_1 - 0.019047619047619*G2_4_0 - 0.0317460317460317*G2_4_1 - 0.00634920634920635*G2_5_0 + 0.00634920634920634*G2_5_1;
    A[125] = 0.00793650793650793*G2_0_0 + 0.00793650793650793*G2_0_1 - 0.00793650793650793*G2_1_0 + 0.00476190476190476*G2_2_1 - 0.00634920634920633*G2_3_0 - 0.019047619047619*G2_3_1 + 0.00634920634920633*G2_4_0 - 0.0126984126984127*G2_4_1 + 0.019047619047619*G2_5_1;
    A[126] = -0.00714285714285715*G5_0_1 + 0.00436507936507936*G5_1_1 - 0.00357142857142857*G5_2_1 - 0.00793650793650793*G5_3_1 - 0.0126984126984127*G5_4_1 - 0.00634920634920635*G5_5_1 + 0.00357142857142857*G6_6_0 + 0.00357142857142857*G6_6_1 + 0.00436507936507936*G6_7_0 - 0.00357142857142857*G6_8_1 - 0.00634920634920634*G6_9_0 + 0.00158730158730159*G6_9_1 + 0.00634920634920634*G6_10_0 - 0.00793650793650793*G6_11_0 - 0.00158730158730159*G6_11_1 - 0.00714285714285715*G7_6_1 + 0.00436507936507936*G7_7_1 - 0.00357142857142857*G7_8_1 - 0.00793650793650793*G7_9_1 - 0.0126984126984127*G7_10_1 - 0.00634920634920635*G7_11_1 + 0.166666666666667*G11_0_1_0 + 0.166666666666667*G11_0_1_1 + 0.166666666666667*G13_0_1_0 + 0.166666666666667*G13_0_1_1;
    A[127] = 0.00436507936507936*G5_0_1 - 0.00714285714285713*G5_1_1 - 0.00357142857142857*G5_2_1 - 0.0126984126984127*G5_3_1 - 0.00793650793650794*G5_4_1 - 0.00634920634920636*G5_5_1 - 0.00436507936507936*G6_6_0 - 0.00436507936507936*G6_6_1 - 0.00357142857142856*G6_7_0 - 0.00357142857142857*G6_8_1 - 0.00634920634920633*G6_9_0 - 0.00634920634920634*G6_9_1 + 0.00634920634920633*G6_10_0 + 0.00793650793650792*G6_10_1 + 0.00793650793650793*G6_11_0 + 0.00634920634920634*G6_11_1 + 0.00436507936507936*G7_6_1 - 0.00714285714285713*G7_7_1 - 0.00357142857142857*G7_8_1 - 0.0126984126984127*G7_9_1 - 0.00793650793650794*G7_10_1 - 0.00634920634920636*G7_11_1 - 0.166666666666667*G11_0_1_0 - 0.166666666666667*G13_0_1_0;
    A[128] = -0.00357142857142857*G5_0_1 - 0.00357142857142857*G5_1_1 + 0.0309523809523809*G5_2_1 + 0.019047619047619*G5_3_1 + 0.019047619047619*G5_4_1 + 0.00476190476190476*G5_5_1 + 0.00714285714285714*G6_6_0 + 0.00714285714285713*G6_6_1 - 0.00714285714285714*G6_7_0 + 0.0309523809523809*G6_8_1 + 0.0476190476190475*G6_9_0 + 0.0095238095238095*G6_9_1 - 0.0476190476190475*G6_10_0 - 0.038095238095238*G6_10_1 - 0.00952380952380951*G6_11_1 - 0.00357142857142857*G7_6_1 - 0.00357142857142857*G7_7_1 + 0.0309523809523809*G7_8_1 + 0.019047619047619*G7_9_1 + 0.019047619047619*G7_10_1 + 0.00476190476190476*G7_11_1 + 0.5*G11_0_1_1 + 0.5*G13_0_1_1;
    A[129] = -0.00793650793650793*G5_0_1 - 0.0126984126984127*G5_1_1 + 0.019047619047619*G5_2_1 + 0.0634920634920634*G5_3_1 + 0.0317460317460317*G5_4_1 + 0.00634920634920636*G5_5_1 + 0.00634920634920635*G6_6_0 + 0.00634920634920634*G6_6_1 - 0.0126984126984127*G6_7_0 + 0.019047619047619*G6_8_1 + 0.019047619047619*G6_9_0 - 0.0126984126984127*G6_9_1 - 0.019047619047619*G6_10_0 - 0.0253968253968254*G6_10_1 + 0.00634920634920634*G6_11_0 + 0.0126984126984127*G6_11_1 - 0.00793650793650793*G7_6_1 - 0.0126984126984127*G7_7_1 + 0.019047619047619*G7_8_1 + 0.0634920634920634*G7_9_1 + 0.0317460317460317*G7_10_1 + 0.00634920634920636*G7_11_1 + 0.666666666666666*G11_0_1_0 + 0.666666666666666*G13_0_1_0;
    A[130] = -0.0126984126984127*G5_0_1 - 0.00793650793650794*G5_1_1 + 0.019047619047619*G5_2_1 + 0.0317460317460317*G5_3_1 + 0.0634920634920635*G5_4_1 + 0.00634920634920636*G5_5_1 + 0.0126984126984127*G6_6_0 + 0.0126984126984127*G6_6_1 - 0.00634920634920635*G6_7_0 + 0.019047619047619*G6_8_1 + 0.019047619047619*G6_9_0 - 0.00634920634920634*G6_9_1 - 0.019047619047619*G6_10_0 - 0.0317460317460317*G6_10_1 - 0.00634920634920635*G6_11_0 + 0.00634920634920634*G6_11_1 - 0.0126984126984127*G7_6_1 - 0.00793650793650794*G7_7_1 + 0.019047619047619*G7_8_1 + 0.0317460317460317*G7_9_1 + 0.0634920634920635*G7_10_1 + 0.00634920634920636*G7_11_1 - 0.666666666666666*G11_0_1_0 - 0.666666666666666*G11_0_1_1 - 0.666666666666666*G13_0_1_0 - 0.666666666666666*G13_0_1_1;
    A[131] = -0.00634920634920635*G5_0_1 - 0.00634920634920636*G5_1_1 + 0.00476190476190476*G5_2_1 + 0.00634920634920636*G5_3_1 + 0.00634920634920636*G5_4_1 - 0.0380952380952381*G5_5_1 + 0.00793650793650793*G6_6_0 + 0.00793650793650793*G6_6_1 - 0.00793650793650793*G6_7_0 + 0.00476190476190476*G6_8_1 - 0.00634920634920633*G6_9_0 - 0.019047619047619*G6_9_1 + 0.00634920634920633*G6_10_0 - 0.0126984126984127*G6_10_1 + 0.019047619047619*G6_11_1 - 0.00634920634920635*G7_6_1 - 0.00634920634920636*G7_7_1 + 0.00476190476190476*G7_8_1 + 0.00634920634920636*G7_9_1 + 0.00634920634920636*G7_10_1 - 0.0380952380952381*G7_11_1;
    A[132] = 0.0;
    A[133] = 0.0;
    A[134] = 0.166666666666667*G9_1;
    A[135] = -0.00476190476190477*G2_0_0 - 0.00476190476190477*G2_0_1 - 0.00793650793650793*G2_1_0 - 0.00793650793650793*G2_2_1 - 0.019047619047619*G2_3_0 - 0.019047619047619*G2_3_1 + 0.019047619047619*G2_4_0 + 0.0126984126984127*G2_4_1 + 0.0126984126984127*G2_5_0 + 0.019047619047619*G2_5_1;
    A[136] = 0.00634920634920634*G2_0_0 + 0.00634920634920634*G2_0_1 + 0.019047619047619*G2_1_0 - 0.0126984126984127*G2_2_1 - 0.0126984126984127*G2_3_0 + 0.019047619047619*G2_3_1 + 0.0126984126984127*G2_4_0 + 0.00634920634920636*G2_4_1 - 0.0253968253968254*G2_5_0 - 0.019047619047619*G2_5_1;
    A[137] = 0.00634920634920635*G2_0_0 + 0.00634920634920634*G2_0_1 - 0.0126984126984127*G2_1_0 + 0.019047619047619*G2_2_1 + 0.019047619047619*G2_3_0 - 0.0126984126984127*G2_3_1 - 0.019047619047619*G2_4_0 - 0.0253968253968254*G2_4_1 + 0.00634920634920634*G2_5_0 + 0.0126984126984127*G2_5_1;
    A[138] = 0.0380952380952381*G2_0_0 + 0.0380952380952381*G2_0_1 + 0.0634920634920634*G2_1_0 + 0.0634920634920634*G2_2_1 + 0.152380952380952*G2_3_0 + 0.152380952380952*G2_3_1 - 0.152380952380952*G2_4_0 - 0.101587301587301*G2_4_1 - 0.101587301587302*G2_5_0 - 0.152380952380952*G2_5_1;
    A[139] = -0.00634920634920633*G2_0_0 - 0.00634920634920632*G2_0_1 + 0.00634920634920634*G2_1_0 + 0.0317460317460317*G2_2_1 + 0.0761904761904761*G2_3_0 + 0.0507936507936507*G2_3_1 - 0.0761904761904761*G2_4_0 - 0.0253968253968254*G2_4_1 - 0.0507936507936508*G2_5_1;
    A[140] = -0.00634920634920633*G2_0_0 - 0.00634920634920632*G2_0_1 + 0.0317460317460317*G2_1_0 + 0.00634920634920636*G2_2_1 + 0.0507936507936508*G2_3_0 + 0.0761904761904761*G2_3_1 - 0.0507936507936508*G2_4_0 - 0.0253968253968254*G2_5_0 - 0.0761904761904762*G2_5_1;
    A[141] = 0.00952380952380951*G5_0_0 + 0.00952380952380951*G5_0_1 + 0.00158730158730159*G5_1_0 - 0.00634920634920634*G5_1_1 - 0.00634920634920634*G5_2_0 + 0.00158730158730159*G5_2_1 - 0.019047619047619*G5_3_0 - 0.019047619047619*G5_3_1 - 0.0126984126984127*G5_4_0 - 0.00634920634920634*G5_4_1 - 0.00634920634920635*G5_5_0 - 0.0126984126984127*G5_5_1 - 0.00476190476190477*G6_6_0 - 0.00476190476190477*G6_6_1 - 0.00793650793650793*G6_7_0 - 0.00793650793650793*G6_8_1 - 0.019047619047619*G6_9_0 - 0.019047619047619*G6_9_1 + 0.019047619047619*G6_10_0 + 0.0126984126984127*G6_10_1 + 0.0126984126984127*G6_11_0 + 0.019047619047619*G6_11_1 + 0.00952380952380951*G7_6_0 + 0.00952380952380951*G7_6_1 + 0.00158730158730159*G7_7_0 - 0.00634920634920634*G7_7_1 - 0.00634920634920634*G7_8_0 + 0.00158730158730159*G7_8_1 - 0.019047619047619*G7_9_0 - 0.019047619047619*G7_9_1 - 0.0126984126984127*G7_10_0 - 0.00634920634920634*G7_10_1 - 0.00634920634920635*G7_11_0 - 0.0126984126984127*G7_11_1;
    A[142] = 0.00158730158730159*G5_0_0 - 0.00634920634920634*G5_0_1 + 0.0095238095238095*G5_1_0 + 0.0476190476190476*G5_1_1 - 0.00634920634920633*G5_2_0 - 0.00634920634920634*G5_2_1 - 0.0126984126984127*G5_3_0 + 0.019047619047619*G5_3_1 - 0.019047619047619*G5_4_0 - 0.00634920634920634*G5_4_1 - 0.00634920634920635*G5_5_0 + 0.019047619047619*G5_5_1 + 0.00634920634920634*G6_6_0 + 0.00634920634920634*G6_6_1 + 0.019047619047619*G6_7_0 - 0.0126984126984127*G6_8_1 - 0.0126984126984127*G6_9_0 + 0.019047619047619*G6_9_1 + 0.0126984126984127*G6_10_0 + 0.00634920634920636*G6_10_1 - 0.0253968253968254*G6_11_0 - 0.019047619047619*G6_11_1 + 0.00158730158730159*G7_6_0 - 0.00634920634920634*G7_6_1 + 0.0095238095238095*G7_7_0 + 0.0476190476190476*G7_7_1 - 0.00634920634920633*G7_8_0 - 0.00634920634920634*G7_8_1 - 0.0126984126984127*G7_9_0 + 0.019047619047619*G7_9_1 - 0.019047619047619*G7_10_0 - 0.00634920634920634*G7_10_1 - 0.00634920634920635*G7_11_0 + 0.019047619047619*G7_11_1 + 0.666666666666666*G11_0_1_0 + 0.666666666666666*G13_0_1_0;
    A[143] = -0.00634920634920634*G5_0_0 + 0.00158730158730159*G5_0_1 - 0.00634920634920634*G5_1_0 - 0.00634920634920634*G5_1_1 + 0.0476190476190475*G5_2_0 + 0.0095238095238095*G5_2_1 + 0.019047619047619*G5_3_0 - 0.0126984126984127*G5_3_1 + 0.019047619047619*G5_4_0 - 0.00634920634920634*G5_4_1 - 0.00634920634920633*G5_5_0 - 0.019047619047619*G5_5_1 + 0.00634920634920635*G6_6_0 + 0.00634920634920634*G6_6_1 - 0.0126984126984127*G6_7_0 + 0.019047619047619*G6_8_1 + 0.019047619047619*G6_9_0 - 0.0126984126984127*G6_9_1 - 0.019047619047619*G6_10_0 - 0.0253968253968254*G6_10_1 + 0.00634920634920634*G6_11_0 + 0.0126984126984127*G6_11_1 - 0.00634920634920634*G7_6_0 + 0.00158730158730159*G7_6_1 - 0.00634920634920634*G7_7_0 - 0.00634920634920634*G7_7_1 + 0.0476190476190475*G7_8_0 + 0.0095238095238095*G7_8_1 + 0.019047619047619*G7_9_0 - 0.0126984126984127*G7_9_1 + 0.019047619047619*G7_10_0 - 0.00634920634920634*G7_10_1 - 0.00634920634920633*G7_11_0 - 0.019047619047619*G7_11_1 + 0.666666666666666*G11_0_0_1 + 0.666666666666666*G13_0_0_1;
    A[144] = -0.019047619047619*G5_0_0 - 0.019047619047619*G5_0_1 - 0.0126984126984127*G5_1_0 + 0.019047619047619*G5_1_1 + 0.019047619047619*G5_2_0 - 0.0126984126984127*G5_2_1 + 0.152380952380952*G5_3_0 + 0.152380952380952*G5_3_1 + 0.0761904761904761*G5_4_0 + 0.0507936507936507*G5_4_1 + 0.0507936507936508*G5_5_0 + 0.0761904761904761*G5_5_1 + 0.0380952380952381*G6_6_0 + 0.0380952380952381*G6_6_1 + 0.0634920634920634*G6_7_0 + 0.0634920634920634*G6_8_1 + 0.152380952380952*G6_9_0 + 0.152380952380952*G6_9_1 - 0.152380952380952*G6_10_0 - 0.101587301587301*G6_10_1 - 0.101587301587302*G6_11_0 - 0.152380952380952*G6_11_1 - 0.019047619047619*G7_6_0 - 0.019047619047619*G7_6_1 - 0.0126984126984127*G7_7_0 + 0.019047619047619*G7_7_1 + 0.019047619047619*G7_8_0 - 0.0126984126984127*G7_8_1 + 0.152380952380952*G7_9_0 + 0.152380952380952*G7_9_1 + 0.0761904761904761*G7_10_0 + 0.0507936507936507*G7_10_1 + 0.0507936507936508*G7_11_0 + 0.0761904761904761*G7_11_1 + 1.33333333333333*G11_0_0_0 + 0.666666666666665*G11_0_0_1 + 0.666666666666665*G11_0_1_0 + 1.33333333333333*G11_0_1_1 + 1.33333333333333*G13_0_0_0 + 0.666666666666665*G13_0_0_1 + 0.666666666666665*G13_0_1_0 + 1.33333333333333*G13_0_1_1;
    A[145] = -0.0126984126984127*G5_0_0 - 0.00634920634920634*G5_0_1 - 0.019047619047619*G5_1_0 - 0.00634920634920634*G5_1_1 + 0.019047619047619*G5_2_0 - 0.00634920634920634*G5_2_1 + 0.0761904761904761*G5_3_0 + 0.0507936507936507*G5_3_1 + 0.152380952380952*G5_4_0 + 0.0507936507936507*G5_4_1 + 0.0507936507936508*G5_5_0 + 0.0507936507936507*G5_5_1 - 0.00634920634920633*G6_6_0 - 0.00634920634920632*G6_6_1 + 0.00634920634920634*G6_7_0 + 0.0317460317460317*G6_8_1 + 0.0761904761904761*G6_9_0 + 0.0507936507936507*G6_9_1 - 0.0761904761904761*G6_10_0 - 0.0253968253968254*G6_10_1 - 0.0507936507936508*G6_11_1 - 0.0126984126984127*G7_6_0 - 0.00634920634920634*G7_6_1 - 0.019047619047619*G7_7_0 - 0.00634920634920634*G7_7_1 + 0.019047619047619*G7_8_0 - 0.00634920634920634*G7_8_1 + 0.0761904761904761*G7_9_0 + 0.0507936507936507*G7_9_1 + 0.152380952380952*G7_10_0 + 0.0507936507936507*G7_10_1 + 0.0507936507936508*G7_11_0 + 0.0507936507936507*G7_11_1 - 1.33333333333333*G11_0_0_0 - 0.666666666666666*G11_0_0_1 - 0.666666666666665*G11_0_1_0 - 1.33333333333333*G13_0_0_0 - 0.666666666666666*G13_0_0_1 - 0.666666666666665*G13_0_1_0;
    A[146] = -0.00634920634920635*G5_0_0 - 0.0126984126984127*G5_0_1 - 0.00634920634920635*G5_1_0 + 0.019047619047619*G5_1_1 - 0.00634920634920633*G5_2_0 - 0.019047619047619*G5_2_1 + 0.0507936507936508*G5_3_0 + 0.0761904761904761*G5_3_1 + 0.0507936507936507*G5_4_0 + 0.0507936507936507*G5_4_1 + 0.0507936507936507*G5_5_0 + 0.152380952380952*G5_5_1 - 0.00634920634920633*G6_6_0 - 0.00634920634920632*G6_6_1 + 0.0317460317460317*G6_7_0 + 0.00634920634920636*G6_8_1 + 0.0507936507936508*G6_9_0 + 0.0761904761904761*G6_9_1 - 0.0507936507936508*G6_10_0 - 0.0253968253968254*G6_11_0 - 0.0761904761904762*G6_11_1 - 0.00634920634920635*G7_6_0 - 0.0126984126984127*G7_6_1 - 0.00634920634920635*G7_7_0 + 0.019047619047619*G7_7_1 - 0.00634920634920633*G7_8_0 - 0.019047619047619*G7_8_1 + 0.0507936507936508*G7_9_0 + 0.0761904761904761*G7_9_1 + 0.0507936507936507*G7_10_0 + 0.0507936507936507*G7_10_1 + 0.0507936507936507*G7_11_0 + 0.152380952380952*G7_11_1 - 0.666666666666665*G11_0_0_1 - 0.666666666666667*G11_0_1_0 - 1.33333333333333*G11_0_1_1 - 0.666666666666665*G13_0_0_1 - 0.666666666666667*G13_0_1_0 - 1.33333333333333*G13_0_1_1;
    A[147] = 0.166666666666667*G9_0 + 0.166666666666667*G9_1;
    A[148] = 0.166666666666667*G9_0 + 0.333333333333333*G9_1;
    A[149] = 0.333333333333333*G9_0 + 0.166666666666666*G9_1;
    A[150] = -0.0190476190476191*G2_0_0 - 0.0190476190476191*G2_0_1 - 0.00634920634920636*G2_1_0 - 0.0126984126984127*G2_2_1 - 0.0126984126984127*G2_3_0 - 0.00634920634920634*G2_3_1 + 0.0126984126984127*G2_4_0 + 0.0317460317460318*G2_4_1 + 0.0253968253968254*G2_5_0 + 0.00634920634920634*G2_5_1;
    A[151] = 0.00793650793650793*G2_0_0 + 0.00793650793650793*G2_0_1 + 0.00476190476190476*G2_1_0 - 0.00793650793650794*G2_2_1 - 0.019047619047619*G2_3_0 - 0.00634920634920634*G2_3_1 + 0.019047619047619*G2_4_0 - 0.0126984126984127*G2_5_0 + 0.00634920634920634*G2_5_1;
    A[152] = 0.0126984126984127*G2_0_0 + 0.0126984126984127*G2_0_1 - 0.00634920634920635*G2_1_0 + 0.019047619047619*G2_2_1 + 0.019047619047619*G2_3_0 - 0.00634920634920634*G2_3_1 - 0.019047619047619*G2_4_0 - 0.0317460317460317*G2_4_1 - 0.00634920634920635*G2_5_0 + 0.00634920634920634*G2_5_1;
    A[153] = -0.00634920634920633*G2_0_0 - 0.00634920634920632*G2_0_1 + 0.00634920634920634*G2_1_0 + 0.0317460317460317*G2_2_1 + 0.0761904761904761*G2_3_0 + 0.0507936507936507*G2_3_1 - 0.0761904761904761*G2_4_0 - 0.0253968253968254*G2_4_1 - 0.0507936507936508*G2_5_1;
    A[154] = -0.0634920634920635*G2_0_0 - 0.0634920634920635*G2_0_1 - 0.0380952380952381*G2_1_0 + 0.0634920634920635*G2_2_1 + 0.152380952380952*G2_3_0 + 0.0507936507936507*G2_3_1 - 0.152380952380952*G2_4_0 + 0.101587301587302*G2_5_0 - 0.0507936507936507*G2_5_1;
    A[155] = -0.0317460317460317*G2_0_0 - 0.0317460317460317*G2_0_1 + 0.00634920634920634*G2_1_0 + 0.00634920634920636*G2_2_1 + 0.0507936507936507*G2_3_0 + 0.0507936507936507*G2_3_1 - 0.0507936507936507*G2_4_0 + 0.0253968253968254*G2_4_1 + 0.0253968253968254*G2_5_0 - 0.0507936507936508*G2_5_1;
    A[156] = -0.00952380952380951*G5_0_0 + 0.0380952380952381*G5_0_1 - 0.00158730158730159*G5_1_0 - 0.00793650793650793*G5_1_1 + 0.00634920634920634*G5_2_0 + 0.019047619047619*G5_3_0 + 0.0126984126984127*G5_3_1 + 0.0126984126984127*G5_4_0 + 0.0317460317460318*G5_4_1 + 0.00634920634920635*G5_5_0 + 0.0253968253968254*G5_5_1 - 0.0190476190476191*G6_6_0 - 0.0190476190476191*G6_6_1 - 0.00634920634920636*G6_7_0 - 0.0126984126984127*G6_8_1 - 0.0126984126984127*G6_9_0 - 0.00634920634920634*G6_9_1 + 0.0126984126984127*G6_10_0 + 0.0317460317460318*G6_10_1 + 0.0253968253968254*G6_11_0 + 0.00634920634920634*G6_11_1 - 0.00952380952380951*G7_6_0 + 0.0380952380952381*G7_6_1 - 0.00158730158730159*G7_7_0 - 0.00793650793650793*G7_7_1 + 0.00634920634920634*G7_8_0 + 0.019047619047619*G7_9_0 + 0.0126984126984127*G7_9_1 + 0.0126984126984127*G7_10_0 + 0.0317460317460318*G7_10_1 + 0.00634920634920635*G7_11_0 + 0.0253968253968254*G7_11_1 - 0.666666666666667*G11_0_1_0 - 0.666666666666666*G11_0_1_1 - 0.666666666666667*G13_0_1_0 - 0.666666666666666*G13_0_1_1;
    A[157] = -0.00158730158730159*G5_0_0 - 0.00793650793650793*G5_0_1 - 0.0095238095238095*G5_1_0 + 0.00634920634920633*G5_2_0 + 0.00793650793650792*G5_2_1 + 0.0126984126984127*G5_3_0 + 0.00634920634920636*G5_3_1 + 0.019047619047619*G5_4_0 + 0.00634920634920635*G5_5_0 - 0.00634920634920633*G5_5_1 + 0.00793650793650793*G6_6_0 + 0.00793650793650793*G6_6_1 + 0.00476190476190476*G6_7_0 - 0.00793650793650794*G6_8_1 - 0.019047619047619*G6_9_0 - 0.00634920634920634*G6_9_1 + 0.019047619047619*G6_10_0 - 0.0126984126984127*G6_11_0 + 0.00634920634920634*G6_11_1 - 0.00158730158730159*G7_6_0 - 0.00793650793650793*G7_6_1 - 0.0095238095238095*G7_7_0 + 0.00634920634920633*G7_8_0 + 0.00793650793650792*G7_8_1 + 0.0126984126984127*G7_9_0 + 0.00634920634920636*G7_9_1 + 0.019047619047619*G7_10_0 + 0.00634920634920635*G7_11_0 - 0.00634920634920633*G7_11_1;
    A[158] = 0.00634920634920634*G5_0_0 + 0.00634920634920634*G5_1_0 + 0.00793650793650792*G5_1_1 - 0.0476190476190475*G5_2_0 - 0.038095238095238*G5_2_1 - 0.019047619047619*G5_3_0 - 0.0253968253968254*G5_3_1 - 0.019047619047619*G5_4_0 - 0.0317460317460317*G5_4_1 + 0.00634920634920633*G5_5_0 - 0.0126984126984127*G5_5_1 + 0.0126984126984127*G6_6_0 + 0.0126984126984127*G6_6_1 - 0.00634920634920635*G6_7_0 + 0.019047619047619*G6_8_1 + 0.019047619047619*G6_9_0 - 0.00634920634920634*G6_9_1 - 0.019047619047619*G6_10_0 - 0.0317460317460317*G6_10_1 - 0.00634920634920635*G6_11_0 + 0.00634920634920634*G6_11_1 + 0.00634920634920634*G7_6_0 + 0.00634920634920634*G7_7_0 + 0.00793650793650792*G7_7_1 - 0.0476190476190475*G7_8_0 - 0.038095238095238*G7_8_1 - 0.019047619047619*G7_9_0 - 0.0253968253968254*G7_9_1 - 0.019047619047619*G7_10_0 - 0.0317460317460317*G7_10_1 + 0.00634920634920633*G7_11_0 - 0.0126984126984127*G7_11_1 - 0.666666666666666*G11_0_0_1 - 0.666666666666666*G11_0_1_1 - 0.666666666666666*G13_0_0_1 - 0.666666666666666*G13_0_1_1;
    A[159] = 0.019047619047619*G5_0_0 + 0.0126984126984127*G5_0_1 + 0.0126984126984127*G5_1_0 + 0.00634920634920636*G5_1_1 - 0.019047619047619*G5_2_0 - 0.0253968253968254*G5_2_1 - 0.152380952380952*G5_3_0 - 0.101587301587301*G5_3_1 - 0.0761904761904761*G5_4_0 - 0.0253968253968254*G5_4_1 - 0.0507936507936508*G5_5_0 - 0.00634920634920633*G6_6_0 - 0.00634920634920632*G6_6_1 + 0.00634920634920634*G6_7_0 + 0.0317460317460317*G6_8_1 + 0.0761904761904761*G6_9_0 + 0.0507936507936507*G6_9_1 - 0.0761904761904761*G6_10_0 - 0.0253968253968254*G6_10_1 - 0.0507936507936508*G6_11_1 + 0.019047619047619*G7_6_0 + 0.0126984126984127*G7_6_1 + 0.0126984126984127*G7_7_0 + 0.00634920634920636*G7_7_1 - 0.019047619047619*G7_8_0 - 0.0253968253968254*G7_8_1 - 0.152380952380952*G7_9_0 - 0.101587301587301*G7_9_1 - 0.0761904761904761*G7_10_0 - 0.0253968253968254*G7_10_1 - 0.0507936507936508*G7_11_0 - 1.33333333333333*G11_0_0_0 - 0.666666666666665*G11_0_0_1 - 0.666666666666666*G11_0_1_0 - 1.33333333333333*G13_0_0_0 - 0.666666666666665*G13_0_0_1 - 0.666666666666666*G13_0_1_0;
    A[160] = 0.0126984126984127*G5_0_0 + 0.0317460317460318*G5_0_1 + 0.019047619047619*G5_1_0 - 0.019047619047619*G5_2_0 - 0.0317460317460317*G5_2_1 - 0.0761904761904761*G5_3_0 - 0.0253968253968254*G5_3_1 - 0.152380952380952*G5_4_0 - 0.0507936507936508*G5_5_0 + 0.0253968253968254*G5_5_1 - 0.0634920634920635*G6_6_0 - 0.0634920634920635*G6_6_1 - 0.0380952380952381*G6_7_0 + 0.0634920634920635*G6_8_1 + 0.152380952380952*G6_9_0 + 0.0507936507936507*G6_9_1 - 0.152380952380952*G6_10_0 + 0.101587301587302*G6_11_0 - 0.0507936507936507*G6_11_1 + 0.0126984126984127*G7_6_0 + 0.0317460317460318*G7_6_1 + 0.019047619047619*G7_7_0 - 0.019047619047619*G7_8_0 - 0.0317460317460317*G7_8_1 - 0.0761904761904761*G7_9_0 - 0.0253968253968254*G7_9_1 - 0.152380952380952*G7_10_0 - 0.0507936507936508*G7_11_0 + 0.0253968253968254*G7_11_1 + 1.33333333333333*G11_0_0_0 + 0.666666666666666*G11_0_0_1 + 0.666666666666666*G11_0_1_0 + 1.33333333333333*G11_0_1_1 + 1.33333333333333*G13_0_0_0 + 0.666666666666666*G13_0_0_1 + 0.666666666666666*G13_0_1_0 + 1.33333333333333*G13_0_1_1;
    A[161] = 0.00634920634920635*G5_0_0 + 0.0253968253968254*G5_0_1 + 0.00634920634920635*G5_1_0 - 0.00634920634920633*G5_1_1 + 0.00634920634920633*G5_2_0 - 0.0126984126984127*G5_2_1 - 0.0507936507936508*G5_3_0 - 0.0507936507936507*G5_4_0 + 0.0253968253968254*G5_4_1 - 0.0507936507936507*G5_5_0 + 0.101587301587302*G5_5_1 - 0.0317460317460317*G6_6_0 - 0.0317460317460317*G6_6_1 + 0.00634920634920634*G6_7_0 + 0.00634920634920636*G6_8_1 + 0.0507936507936507*G6_9_0 + 0.0507936507936507*G6_9_1 - 0.0507936507936507*G6_10_0 + 0.0253968253968254*G6_10_1 + 0.0253968253968254*G6_11_0 - 0.0507936507936508*G6_11_1 + 0.00634920634920635*G7_6_0 + 0.0253968253968254*G7_6_1 + 0.00634920634920635*G7_7_0 - 0.00634920634920633*G7_7_1 + 0.00634920634920633*G7_8_0 - 0.0126984126984127*G7_8_1 - 0.0507936507936508*G7_9_0 - 0.0507936507936507*G7_10_0 + 0.0253968253968254*G7_10_1 - 0.0507936507936507*G7_11_0 + 0.101587301587302*G7_11_1 + 0.666666666666665*G11_0_0_1 + 0.666666666666667*G11_0_1_0 + 0.666666666666665*G13_0_0_1 + 0.666666666666667*G13_0_1_0;
    A[162] = -0.166666666666667*G9_0 + 0.166666666666667*G9_1;
    A[163] = -0.166666666666667*G9_0;
    A[164] = -0.333333333333333*G9_0 - 0.166666666666667*G9_1;
    A[165] = -0.0190476190476191*G2_0_0 - 0.0190476190476191*G2_0_1 - 0.0126984126984127*G2_1_0 - 0.00634920634920635*G2_2_1 - 0.00634920634920635*G2_3_0 - 0.0126984126984127*G2_3_1 + 0.00634920634920635*G2_4_0 + 0.0253968253968254*G2_4_1 + 0.0317460317460318*G2_5_0 + 0.0126984126984127*G2_5_1;
    A[166] = 0.0126984126984127*G2_0_0 + 0.0126984126984127*G2_0_1 + 0.019047619047619*G2_1_0 - 0.00634920634920636*G2_2_1 - 0.00634920634920635*G2_3_0 + 0.019047619047619*G2_3_1 + 0.00634920634920635*G2_4_0 - 0.00634920634920633*G2_4_1 - 0.0317460317460317*G2_5_0 - 0.0190476190476191*G2_5_1;
    A[167] = 0.00793650793650793*G2_0_0 + 0.00793650793650793*G2_0_1 - 0.00793650793650793*G2_1_0 + 0.00476190476190476*G2_2_1 - 0.00634920634920633*G2_3_0 - 0.019047619047619*G2_3_1 + 0.00634920634920633*G2_4_0 - 0.0126984126984127*G2_4_1 + 0.019047619047619*G2_5_1;
    A[168] = -0.00634920634920633*G2_0_0 - 0.00634920634920632*G2_0_1 + 0.0317460317460317*G2_1_0 + 0.00634920634920636*G2_2_1 + 0.0507936507936508*G2_3_0 + 0.0761904761904761*G2_3_1 - 0.0507936507936508*G2_4_0 - 0.0253968253968254*G2_5_0 - 0.0761904761904762*G2_5_1;
    A[169] = -0.0317460317460317*G2_0_0 - 0.0317460317460317*G2_0_1 + 0.00634920634920634*G2_1_0 + 0.00634920634920636*G2_2_1 + 0.0507936507936508*G2_3_0 + 0.0507936507936507*G2_3_1 - 0.0507936507936508*G2_4_0 + 0.0253968253968254*G2_4_1 + 0.0253968253968254*G2_5_0 - 0.0507936507936508*G2_5_1;
    A[170] = -0.0634920634920635*G2_0_0 - 0.0634920634920635*G2_0_1 + 0.0634920634920635*G2_1_0 - 0.0380952380952381*G2_2_1 + 0.0507936507936507*G2_3_0 + 0.152380952380952*G2_3_1 - 0.0507936507936507*G2_4_0 + 0.101587301587302*G2_4_1 - 0.152380952380952*G2_5_1;
    A[171] = 0.0380952380952381*G5_0_0 - 0.00952380952380952*G5_0_1 + 0.00634920634920635*G5_1_1 - 0.00793650793650793*G5_2_0 - 0.00158730158730159*G5_2_1 + 0.0126984126984127*G5_3_0 + 0.019047619047619*G5_3_1 + 0.0253968253968254*G5_4_0 + 0.00634920634920634*G5_4_1 + 0.0317460317460318*G5_5_0 + 0.0126984126984127*G5_5_1 - 0.0190476190476191*G6_6_0 - 0.0190476190476191*G6_6_1 - 0.0126984126984127*G6_7_0 - 0.00634920634920635*G6_8_1 - 0.00634920634920635*G6_9_0 - 0.0126984126984127*G6_9_1 + 0.00634920634920635*G6_10_0 + 0.0253968253968254*G6_10_1 + 0.0317460317460318*G6_11_0 + 0.0126984126984127*G6_11_1 + 0.0380952380952381*G7_6_0 - 0.00952380952380952*G7_6_1 + 0.00634920634920635*G7_7_1 - 0.00793650793650793*G7_8_0 - 0.00158730158730159*G7_8_1 + 0.0126984126984127*G7_9_0 + 0.019047619047619*G7_9_1 + 0.0253968253968254*G7_10_0 + 0.00634920634920634*G7_10_1 + 0.0317460317460318*G7_11_0 + 0.0126984126984127*G7_11_1 - 0.666666666666667*G11_0_0_0 - 0.666666666666667*G11_0_0_1 - 0.666666666666667*G13_0_0_0 - 0.666666666666667*G13_0_0_1;
    A[172] = 0.00634920634920635*G5_0_1 - 0.0380952380952381*G5_1_0 - 0.0476190476190476*G5_1_1 + 0.00793650793650793*G5_2_0 + 0.00634920634920634*G5_2_1 - 0.0253968253968254*G5_3_0 - 0.019047619047619*G5_3_1 - 0.0126984126984127*G5_4_0 + 0.00634920634920634*G5_4_1 - 0.0317460317460317*G5_5_0 - 0.0190476190476191*G5_5_1 + 0.0126984126984127*G6_6_0 + 0.0126984126984127*G6_6_1 + 0.019047619047619*G6_7_0 - 0.00634920634920636*G6_8_1 - 0.00634920634920635*G6_9_0 + 0.019047619047619*G6_9_1 + 0.00634920634920635*G6_10_0 - 0.00634920634920633*G6_10_1 - 0.0317460317460317*G6_11_0 - 0.0190476190476191*G6_11_1 + 0.00634920634920635*G7_6_1 - 0.0380952380952381*G7_7_0 - 0.0476190476190476*G7_7_1 + 0.00793650793650793*G7_8_0 + 0.00634920634920634*G7_8_1 - 0.0253968253968254*G7_9_0 - 0.019047619047619*G7_9_1 - 0.0126984126984127*G7_10_0 + 0.00634920634920634*G7_10_1 - 0.0317460317460317*G7_11_0 - 0.0190476190476191*G7_11_1 - 0.666666666666667*G11_0_0_0 - 0.666666666666667*G11_0_1_0 - 0.666666666666667*G13_0_0_0 - 0.666666666666667*G13_0_1_0;
    A[173] = -0.00793650793650793*G5_0_0 - 0.00158730158730159*G5_0_1 + 0.00793650793650793*G5_1_0 + 0.00634920634920634*G5_1_1 - 0.00952380952380951*G5_2_1 + 0.00634920634920634*G5_3_0 + 0.0126984126984127*G5_3_1 - 0.00634920634920635*G5_4_0 + 0.00634920634920634*G5_4_1 + 0.019047619047619*G5_5_1 + 0.00793650793650793*G6_6_0 + 0.00793650793650793*G6_6_1 - 0.00793650793650793*G6_7_0 + 0.00476190476190476*G6_8_1 - 0.00634920634920633*G6_9_0 - 0.019047619047619*G6_9_1 + 0.00634920634920633*G6_10_0 - 0.0126984126984127*G6_10_1 + 0.019047619047619*G6_11_1 - 0.00793650793650793*G7_6_0 - 0.00158730158730159*G7_6_1 + 0.00793650793650793*G7_7_0 + 0.00634920634920634*G7_7_1 - 0.00952380952380951*G7_8_1 + 0.00634920634920634*G7_9_0 + 0.0126984126984127*G7_9_1 - 0.00634920634920635*G7_10_0 + 0.00634920634920634*G7_10_1 + 0.019047619047619*G7_11_1;
    A[174] = 0.0126984126984127*G5_0_0 + 0.019047619047619*G5_0_1 - 0.0253968253968254*G5_1_0 - 0.019047619047619*G5_1_1 + 0.00634920634920634*G5_2_0 + 0.0126984126984127*G5_2_1 - 0.101587301587302*G5_3_0 - 0.152380952380952*G5_3_1 - 0.0507936507936508*G5_4_1 - 0.0253968253968254*G5_5_0 - 0.0761904761904762*G5_5_1 - 0.00634920634920633*G6_6_0 - 0.00634920634920632*G6_6_1 + 0.0317460317460317*G6_7_0 + 0.00634920634920636*G6_8_1 + 0.0507936507936508*G6_9_0 + 0.0761904761904761*G6_9_1 - 0.0507936507936508*G6_10_0 - 0.0253968253968254*G6_11_0 - 0.0761904761904762*G6_11_1 + 0.0126984126984127*G7_6_0 + 0.019047619047619*G7_6_1 - 0.0253968253968254*G7_7_0 - 0.019047619047619*G7_7_1 + 0.00634920634920634*G7_8_0 + 0.0126984126984127*G7_8_1 - 0.101587301587302*G7_9_0 - 0.152380952380952*G7_9_1 - 0.0507936507936508*G7_10_1 - 0.0253968253968254*G7_11_0 - 0.0761904761904762*G7_11_1 - 0.666666666666667*G11_0_0_1 - 0.666666666666666*G11_0_1_0 - 1.33333333333333*G11_0_1_1 - 0.666666666666667*G13_0_0_1 - 0.666666666666666*G13_0_1_0 - 1.33333333333333*G13_0_1_1;
    A[175] = 0.0253968253968254*G5_0_0 + 0.00634920634920634*G5_0_1 - 0.0126984126984127*G5_1_0 + 0.00634920634920634*G5_1_1 - 0.00634920634920635*G5_2_0 + 0.00634920634920634*G5_2_1 - 0.0507936507936508*G5_3_1 + 0.101587301587302*G5_4_0 - 0.0507936507936507*G5_4_1 + 0.0253968253968254*G5_5_0 - 0.0507936507936508*G5_5_1 - 0.0317460317460317*G6_6_0 - 0.0317460317460317*G6_6_1 + 0.00634920634920634*G6_7_0 + 0.00634920634920636*G6_8_1 + 0.0507936507936508*G6_9_0 + 0.0507936507936507*G6_9_1 - 0.0507936507936508*G6_10_0 + 0.0253968253968254*G6_10_1 + 0.0253968253968254*G6_11_0 - 0.0507936507936508*G6_11_1 + 0.0253968253968254*G7_6_0 + 0.00634920634920634*G7_6_1 - 0.0126984126984127*G7_7_0 + 0.00634920634920634*G7_7_1 - 0.00634920634920635*G7_8_0 + 0.00634920634920634*G7_8_1 - 0.0507936507936508*G7_9_1 + 0.101587301587302*G7_10_0 - 0.0507936507936507*G7_10_1 + 0.0253968253968254*G7_11_0 - 0.0507936507936508*G7_11_1 + 0.666666666666667*G11_0_0_1 + 0.666666666666666*G11_0_1_0 + 0.666666666666667*G13_0_0_1 + 0.666666666666666*G13_0_1_0;
    A[176] = 0.0317460317460318*G5_0_0 + 0.0126984126984127*G5_0_1 - 0.0317460317460317*G5_1_0 - 0.0190476190476191*G5_1_1 + 0.019047619047619*G5_2_1 - 0.0253968253968254*G5_3_0 - 0.0761904761904762*G5_3_1 + 0.0253968253968254*G5_4_0 - 0.0507936507936508*G5_4_1 - 0.152380952380952*G5_5_1 - 0.0634920634920635*G6_6_0 - 0.0634920634920635*G6_6_1 + 0.0634920634920635*G6_7_0 - 0.0380952380952381*G6_8_1 + 0.0507936507936507*G6_9_0 + 0.152380952380952*G6_9_1 - 0.0507936507936507*G6_10_0 + 0.101587301587302*G6_10_1 - 0.152380952380952*G6_11_1 + 0.0317460317460318*G7_6_0 + 0.0126984126984127*G7_6_1 - 0.0317460317460317*G7_7_0 - 0.0190476190476191*G7_7_1 + 0.019047619047619*G7_8_1 - 0.0253968253968254*G7_9_0 - 0.0761904761904762*G7_9_1 + 0.0253968253968254*G7_10_0 - 0.0507936507936508*G7_10_1 - 0.152380952380952*G7_11_1 + 1.33333333333333*G11_0_0_0 + 0.666666666666667*G11_0_0_1 + 0.666666666666667*G11_0_1_0 + 1.33333333333333*G11_0_1_1 + 1.33333333333333*G13_0_0_0 + 0.666666666666667*G13_0_0_1 + 0.666666666666667*G13_0_1_0 + 1.33333333333333*G13_0_1_1;
    A[177] = 0.166666666666667*G9_0 - 0.166666666666667*G9_1;
    A[178] = -0.166666666666667*G9_0 - 0.333333333333333*G9_1;
    A[179] = -0.166666666666667*G9_1;
    A[180] = 0.166666666666667*G14_0 + 0.166666666666667*G14_1;
    A[181] = 0.0;
    A[182] = 0.0;
    A[183] = -0.166666666666667*G14_0 - 0.166666666666667*G14_1;
    A[184] = 0.166666666666667*G14_0 - 0.166666666666667*G14_1;
    A[185] = -0.166666666666667*G14_0 + 0.166666666666667*G14_1;
    A[186] = 0.166666666666667*G15_0 + 0.166666666666667*G15_1;
    A[187] = 0.0;
    A[188] = 0.0;
    A[189] = -0.166666666666667*G15_0 - 0.166666666666667*G15_1;
    A[190] = 0.166666666666667*G15_0 - 0.166666666666667*G15_1;
    A[191] = -0.166666666666667*G15_0 + 0.166666666666667*G15_1;
    A[192] = 0.0;
    A[193] = 0.0;
    A[194] = 0.0;
    A[195] = 0.0;
    A[196] = -0.166666666666667*G14_0;
    A[197] = 0.0;
    A[198] = -0.166666666666667*G14_0 - 0.333333333333333*G14_1;
    A[199] = 0.166666666666667*G14_0;
    A[200] = 0.166666666666667*G14_0 + 0.333333333333333*G14_1;
    A[201] = 0.0;
    A[202] = -0.166666666666667*G15_0;
    A[203] = 0.0;
    A[204] = -0.166666666666667*G15_0 - 0.333333333333333*G15_1;
    A[205] = 0.166666666666667*G15_0;
    A[206] = 0.166666666666667*G15_0 + 0.333333333333333*G15_1;
    A[207] = 0.0;
    A[208] = 0.0;
    A[209] = 0.0;
    A[210] = 0.0;
    A[211] = 0.0;
    A[212] = -0.166666666666667*G14_1;
    A[213] = -0.333333333333333*G14_0 - 0.166666666666666*G14_1;
    A[214] = 0.333333333333333*G14_0 + 0.166666666666667*G14_1;
    A[215] = 0.166666666666667*G14_1;
    A[216] = 0.0;
    A[217] = 0.0;
    A[218] = -0.166666666666667*G15_1;
    A[219] = -0.333333333333333*G15_0 - 0.166666666666666*G15_1;
    A[220] = 0.333333333333333*G15_0 + 0.166666666666667*G15_1;
    A[221] = 0.166666666666667*G15_1;
    A[222] = 0.0;
    A[223] = 0.0;
    A[224] = 0.0;
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_1_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_1_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_1_0()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               std::size_t facet,
                               int cell_orientation) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      10
    // Number of operations (multiply-add pairs) for geometry tensor:    0
    // Number of operations (multiply-add pairs) for tensor contraction: 4
    // Total number of operations (multiply-add pairs):                  14
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = vertex_coordinates[2*v1 + 0] - vertex_coordinates[2*v0 + 0];
    const double dx1 = vertex_coordinates[2*v1 + 1] - vertex_coordinates[2*v0 + 1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    
    // Compute geometry tensor
    const double G0_ = det;
    
    // Compute element tensor
    switch (facet)
    {
    case 0:
      {
        A[0] = 0.0;
      A[1] = 0.166666666666666*G0_;
      A[2] = 0.166666666666667*G0_;
      A[3] = 0.666666666666666*G0_;
      A[4] = 0.0;
      A[5] = 0.0;
      A[6] = 0.0;
      A[7] = 0.0;
      A[8] = 0.0;
      A[9] = 0.0;
      A[10] = 0.0;
      A[11] = 0.0;
      A[12] = 0.0;
      A[13] = 0.0;
      A[14] = 0.0;
        break;
      }
    case 1:
      {
        A[0] = 0.166666666666667*G0_;
      A[1] = 0.0;
      A[2] = 0.166666666666667*G0_;
      A[3] = 0.0;
      A[4] = 0.666666666666666*G0_;
      A[5] = 0.0;
      A[6] = 0.0;
      A[7] = 0.0;
      A[8] = 0.0;
      A[9] = 0.0;
      A[10] = 0.0;
      A[11] = 0.0;
      A[12] = 0.0;
      A[13] = 0.0;
      A[14] = 0.0;
        break;
      }
    case 2:
      {
        A[0] = 0.166666666666667*G0_;
      A[1] = 0.166666666666667*G0_;
      A[2] = 0.0;
      A[3] = 0.0;
      A[4] = 0.0;
      A[5] = 0.666666666666666*G0_;
      A[6] = 0.0;
      A[7] = 0.0;
      A[8] = 0.0;
      A[9] = 0.0;
      A[10] = 0.0;
      A[11] = 0.0;
      A[12] = 0.0;
      A[13] = 0.0;
      A[14] = 0.0;
        break;
      }
    }
    
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_2_otherwise: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_2_otherwise() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_2_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({true, false, true, true});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               int cell_orientation) const
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius of triangle in 2D
    
    
    // Array of quadrature weights.
    static const double W12[12] = {0.0254224531851035, 0.0254224531851035, 0.0254224531851035, 0.0583931378631895, 0.0583931378631895, 0.0583931378631895, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187};
    // Quadrature points on the UFC reference element: (0.873821971016996, 0.063089014491502), (0.063089014491502, 0.873821971016996), (0.063089014491502, 0.063089014491502), (0.501426509658179, 0.24928674517091), (0.24928674517091, 0.501426509658179), (0.24928674517091, 0.24928674517091), (0.636502499121399, 0.310352451033785), (0.636502499121399, 0.053145049844816), (0.310352451033785, 0.636502499121399), (0.310352451033785, 0.053145049844816), (0.053145049844816, 0.636502499121399), (0.053145049844816, 0.310352451033785)
    
    // Values of basis functions at quadrature points.
    static const double FE0_C0[12][3] = \
    {{0.0630890144915021, 0.873821971016996, 0.063089014491502},
    {0.0630890144915021, 0.0630890144915021, 0.873821971016996},
    {0.873821971016996, 0.0630890144915021, 0.063089014491502},
    {0.249286745170911, 0.501426509658179, 0.24928674517091},
    {0.249286745170911, 0.24928674517091, 0.501426509658179},
    {0.50142650965818, 0.24928674517091, 0.24928674517091},
    {0.053145049844816, 0.636502499121399, 0.310352451033785},
    {0.310352451033785, 0.636502499121399, 0.053145049844816},
    {0.0531450498448161, 0.310352451033785, 0.636502499121399},
    {0.636502499121399, 0.310352451033785, 0.053145049844816},
    {0.310352451033785, 0.0531450498448161, 0.636502499121399},
    {0.636502499121399, 0.053145049844816, 0.310352451033785}};
    
    // Array of non-zero columns
    static const unsigned int nzc12[3] = {12, 13, 14};
    
    static const double FE1_C0[12][6] = \
    {{-0.0551285669924841, 0.653307703047059, -0.0551285669924841, 0.220514267969936, 0.0159208949980358, 0.220514267969936},
    {-0.055128566992484, -0.055128566992484, 0.65330770304706, 0.220514267969936, 0.220514267969936, 0.0159208949980358},
    {0.65330770304706, -0.0551285669924841, -0.0551285669924841, 0.0159208949980358, 0.220514267969936, 0.220514267969936},
    {-0.124998982535098, 0.00143057951778876, -0.124998982535098, 0.499995930140389, 0.248575525271626, 0.499995930140391},
    {-0.124998982535098, -0.124998982535098, 0.00143057951778887, 0.499995930140389, 0.499995930140391, 0.248575525271626},
    {0.00143057951778986, -0.124998982535098, -0.124998982535098, 0.248575525271625, 0.49999593014039, 0.49999593014039},
    {-0.0474962571988001, 0.173768363654174, -0.117715163308429, 0.790160442765823, 0.0659747859186054, 0.135307828168627},
    {-0.117715163308429, 0.173768363654174, -0.0474962571988, 0.135307828168627, 0.0659747859186052, 0.790160442765823},
    {-0.0474962571988, -0.117715163308429, 0.173768363654174, 0.790160442765823, 0.135307828168627, 0.0659747859186053},
    {0.173768363654174, -0.117715163308429, -0.0474962571988, 0.0659747859186052, 0.135307828168627, 0.790160442765823},
    {-0.117715163308429, -0.0474962571988, 0.173768363654174, 0.135307828168627, 0.790160442765823, 0.0659747859186053},
    {0.173768363654174, -0.0474962571988001, -0.117715163308429, 0.0659747859186054, 0.790160442765823, 0.135307828168627}};
    
    // Array of non-zero columns
    static const unsigned int nzc21[6] = {20, 21, 22, 23, 24, 25};
    
    // Array of non-zero columns
    static const unsigned int nzc6[6] = {0, 1, 2, 3, 4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc9[6] = {6, 7, 8, 9, 10, 11};
    
    static const double FE1_C0_D01[12][5] = \
    {{0.747643942033993, -0.747643942033992, 3.49528788406798, 0.0, -3.49528788406798},
    {0.747643942033992, 2.49528788406798, 0.252356057966007, -3.24293182610197, -0.252356057966008},
    {-2.49528788406798, -0.747643942033992, 0.252356057966008, 3.24293182610197, -0.252356057966008},
    {0.00285301931635651, -0.00285301931635973, 2.00570603863272, 0.0, -2.00570603863272},
    {0.00285301931635637, 1.00570603863272, 0.997146980683639, -1.00855905794907, -0.997146980683639},
    {-1.00570603863272, -0.00285301931635984, 0.997146980683639, 1.00855905794908, -0.997146980683639},
    {0.787419800620737, 0.24140980413514, 2.54600999648559, -1.02882960475588, -2.5460099964856},
    {-0.241409804135139, -0.787419800620735, 2.5460099964856, 1.02882960475588, -2.5460099964856},
    {0.787419800620736, 1.5460099964856, 1.24140980413514, -2.33342979710633, -1.24140980413514},
    {-1.5460099964856, -0.787419800620735, 1.24140980413514, 2.33342979710633, -1.24140980413514},
    {-0.24140980413514, 1.5460099964856, 0.212580199379263, -1.30460019235046, -0.212580199379263},
    {-1.5460099964856, 0.24140980413514, 0.212580199379263, 1.30460019235046, -0.212580199379263}};
    
    // Array of non-zero columns
    static const unsigned int nzc7[5] = {0, 2, 3, 4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc10[5] = {6, 8, 9, 10, 11};
    
    static const double FE1_C0_D10[12][5] = \
    {{0.747643942033992, 2.49528788406798, 0.252356057966007, -0.252356057966007, -3.24293182610198},
    {0.747643942033993, -0.747643942033992, 3.49528788406798, -3.49528788406798, 0.0},
    {-2.49528788406798, -0.747643942033992, 0.252356057966007, -0.252356057966007, 3.24293182610198},
    {0.00285301931635634, 1.00570603863272, 0.997146980683639, -0.997146980683639, -1.00855905794907},
    {0.00285301931635651, -0.00285301931636039, 2.00570603863272, -2.00570603863272, 0.0},
    {-1.00570603863272, -0.00285301931636026, 0.997146980683639, -0.997146980683639, 1.00855905794908},
    {0.787419800620737, 1.5460099964856, 1.24140980413514, -1.24140980413514, -2.33342979710633},
    {-0.24140980413514, 1.5460099964856, 0.212580199379263, -0.212580199379263, -1.30460019235046},
    {0.787419800620737, 0.24140980413514, 2.54600999648559, -2.54600999648559, -1.02882960475588},
    {-1.5460099964856, 0.24140980413514, 0.212580199379263, -0.212580199379263, 1.30460019235046},
    {-0.24140980413514, -0.787419800620737, 2.54600999648559, -2.54600999648559, 1.02882960475588},
    {-1.5460099964856, -0.787419800620737, 1.24140980413514, -1.24140980413514, 2.33342979710633}};
    
    // Array of non-zero columns
    static const unsigned int nzc11[5] = {6, 7, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc8[5] = {0, 1, 3, 4, 5};
    
    static const double FE2_C0[12][10] = \
    {{0.0463079953908665, 0.440268993398561, 0.0463079953908666, 0.402250914961474, -0.201125457480737, -0.0145210435563255, -0.0145210435563258, -0.201125457480737, 0.402250914961474, 0.0939061879708835},
    {0.0463079953908666, 0.0463079953908666, 0.440268993398561, -0.201125457480737, 0.402250914961474, -0.201125457480737, 0.402250914961474, -0.0145210435563257, -0.0145210435563255, 0.0939061879708831},
    {0.440268993398561, 0.0463079953908666, 0.0463079953908666, -0.0145210435563257, -0.0145210435563258, 0.402250914961474, -0.201125457480737, 0.402250914961474, -0.201125457480737, 0.0939061879708837},
    {0.0393516858174583, -0.0626737220523998, 0.0393516858174587, 0.283654926157929, -0.141827463078965, -0.0705102461991971, -0.0705102461991981, -0.141827463078964, 0.28365492615793, 0.841335916657949},
    {0.0393516858174583, 0.0393516858174588, -0.0626737220523998, -0.141827463078965, 0.283654926157929, -0.141827463078964, 0.28365492615793, -0.0705102461991973, -0.070510246199198, 0.841335916657949},
    {-0.0626737220524, 0.0393516858174588, 0.0393516858174587, -0.0705102461991977, -0.0705102461991979, 0.283654926157931, -0.141827463078965, 0.283654926157931, -0.141827463078965, 0.841335916657947},
    {0.041110728466435, -0.0261932265993555, 0.0114358260653798, 0.808488952668146, -0.0612852214487413, -0.0623880968176902, -0.00511703591602521, -0.127951879895303, 0.138446419692862, 0.283453533784293},
    {0.0114358260653798, -0.0261932265993554, 0.041110728466435, 0.138446419692862, -0.127951879895303, -0.00511703591602502, -0.0623880968176904, -0.0612852214487413, 0.808488952668146, 0.283453533784293},
    {0.041110728466435, 0.0114358260653799, -0.0261932265993555, -0.0612852214487411, 0.808488952668146, -0.127951879895303, 0.138446419692862, -0.0623880968176904, -0.00511703591602494, 0.283453533784293},
    {-0.0261932265993555, 0.0114358260653798, 0.041110728466435, -0.00511703591602513, -0.0623880968176903, 0.138446419692862, -0.127951879895303, 0.808488952668146, -0.0612852214487411, 0.283453533784293},
    {0.0114358260653798, 0.0411107284664351, -0.0261932265993555, -0.127951879895303, 0.138446419692862, -0.0612852214487413, 0.808488952668146, -0.00511703591602512, -0.0623880968176902, 0.283453533784293},
    {-0.0261932265993556, 0.0411107284664352, 0.0114358260653798, -0.0623880968176903, -0.00511703591602509, 0.808488952668146, -0.0612852214487412, 0.138446419692862, -0.127951879895303, 0.283453533784293}};
    
    // Array of non-zero columns
    static const unsigned int nzc18[10] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc15[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    static const double FE2_C0_D01[12][9] = \
    {{-0.485931890194852, 0.485931890194852, 6.37592643035589, -2.44372756077941, -0.0537330206183706, 0.0537330206183702, 2.44372756077941, -6.37592643035589, 0.0},
    {-0.485931890194854, 3.44372756077941, -0.230167544593387, 1.20457074358531, 2.21356001618603, -5.17135568677059, 0.176434523975019, 0.230167544593388, -1.38100526756033},
    {-3.44372756077941, 0.485931890194852, -0.230167544593386, -0.176434523975019, 5.17135568677058, -2.21356001618602, -1.20457074358531, 0.230167544593385, 1.38100526756033},
    {0.404638308746458, -0.404638308746456, 1.13786605847598, 1.11855323498582, -0.838942397791738, 0.838942397791737, -1.11855323498583, -1.13786605847598, 1.14908083048704e-14},
    {0.404638308746458, -0.118553234985829, -0.282847955477361, 2.25318217517853, -1.40140119046319, 1.11531611670257, -0.55609444231438, 0.282847955477361, -1.69708773286415},
    {0.118553234985824, -0.404638308746456, -0.282847955477361, 0.556094442314373, -1.11531611670255, 1.40140119046319, -2.25318217517854, 0.282847955477361, 1.69708773286417},
    {-0.559823901757263, -0.492870367157913, 2.60506707768882, 2.46932174262301, 0.750232850760382, 0.302461418154794, 1.95093340590807, -2.60506707768882, -4.42025514853108},
    {0.492870367157913, 0.559823901757264, 2.60506707768882, -1.95093340590807, -0.302461418154794, -0.750232850760383, -2.46932174262301, -2.60506707768882, 4.42025514853108},
    {-0.559823901757263, 0.740805831642527, -0.0962843375058833, 3.93699695901727, 1.749910031967, -1.93089196185226, 0.951256224701446, 0.0962843375058839, -4.88825318371872},
    {-0.740805831642527, 0.559823901757263, -0.0962843375058788, -0.95125622470145, 1.93089196185226, -1.749910031967, -3.93699695901727, 0.0962843375058796, 4.88825318371872},
    {0.492870367157913, 0.740805831642527, -0.201023373941063, 0.674175115836557, -2.56560608012889, 1.33192988132845, -0.206177080648913, 0.201023373941064, -0.467998035187646},
    {-0.740805831642527, -0.492870367157913, -0.201023373941065, 0.206177080648914, -1.33192988132845, 2.56560608012889, -0.674175115836559, 0.201023373941066, 0.467998035187645}};
    
    // Array of non-zero columns
    static const unsigned int nzc19[9] = {10, 12, 13, 14, 15, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc16[9] = {0, 2, 3, 4, 5, 6, 7, 8, 9};
    
    static const double FE2_C0_D10[12][9] = \
    {{-0.485931890194853, 3.44372756077941, 1.20457074358531, -0.23016754459339, 0.176434523975015, 0.230167544593389, 2.21356001618602, -5.17135568677058, -1.38100526756033},
    {-0.485931890194854, 0.485931890194854, -2.44372756077941, 6.3759264303559, 2.44372756077941, -6.3759264303559, -0.0537330206183693, 0.0537330206183686, 0.0},
    {-3.44372756077941, 0.485931890194853, -0.176434523975017, -0.23016754459339, -1.20457074358531, 0.23016754459339, 5.17135568677058, -2.21356001618602, 1.38100526756033},
    {0.404638308746458, -0.118553234985829, 2.25318217517853, -0.282847955477361, -0.556094442314378, 0.282847955477361, -1.40140119046319, 1.11531611670256, -1.69708773286415},
    {0.404638308746458, -0.404638308746456, 1.11855323498582, 1.13786605847598, -1.11855323498584, -1.13786605847598, -0.838942397791738, 0.838942397791735, 1.51461450489301e-14},
    {0.118553234985824, -0.404638308746456, 0.556094442314373, -0.282847955477361, -2.25318217517854, 0.282847955477361, -1.11531611670255, 1.40140119046318, 1.69708773286417},
    {-0.559823901757263, 0.740805831642527, 3.93699695901727, -0.0962843375058792, 0.951256224701449, 0.0962843375058786, 1.749910031967, -1.93089196185226, -4.88825318371872},
    {0.492870367157913, 0.740805831642526, 0.674175115836557, -0.201023373941065, -0.206177080648913, 0.201023373941065, -2.56560608012889, 1.33192988132845, -0.467998035187644},
    {-0.559823901757263, -0.492870367157914, 2.46932174262301, 2.60506707768882, 1.95093340590806, -2.60506707768882, 0.750232850760383, 0.302461418154794, -4.42025514853107},
    {-0.740805831642527, -0.492870367157914, 0.206177080648913, -0.201023373941065, -0.674175115836558, 0.201023373941065, -1.33192988132845, 2.56560608012889, 0.467998035187645},
    {0.492870367157913, 0.559823901757263, -1.95093340590806, 2.60506707768882, -2.46932174262301, -2.60506707768882, -0.302461418154794, -0.750232850760383, 4.42025514853107},
    {-0.740805831642527, 0.559823901757263, -0.951256224701447, -0.0962843375058807, -3.93699695901727, 0.0962843375058803, 1.93089196185226, -1.749910031967, 4.88825318371872}};
    
    // Array of non-zero columns
    static const unsigned int nzc20[9] = {10, 11, 13, 14, 15, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc17[9] = {0, 1, 3, 4, 5, 6, 7, 8, 9};
    
    // Reset values in the element tensor.
    A[0] = 0.0;
    // Number of operations to compute geometry constants: 23.
    double G[11];
    G[0] =  - det*w[2][0]*(K[0]*K[2] + K[1]*K[3]);
    G[1] =  - K[0]*det;
    G[2] =  - K[1]*det;
    G[3] =  - det*w[2][0]*(K[0]*K[0] + K[1]*K[1]);
    G[4] =  - det*w[2][0]*(K[2]*K[2] + K[3]*K[3]);
    G[5] =  - K[2]*det;
    G[6] =  - K[3]*det;
    G[7] = K[2]*det;
    G[8] = K[1]*det;
    G[9] = K[3]*det;
    G[10] = K[0]*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 3024
    for (unsigned int ip = 0; ip < 12; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      double F10 = 0.0;
      double F11 = 0.0;
      double F12 = 0.0;
      double F13 = 0.0;
      
      // Total number of operations to compute function values = 72
      for (unsigned int r = 0; r < 9; r++)
      {
        F9 += FE2_C0_D10[ip][r]*w[3][nzc17[r]];
        F10 += FE2_C0_D01[ip][r]*w[3][nzc16[r]];
        F11 += FE2_C0_D10[ip][r]*w[3][nzc20[r]];
        F12 += FE2_C0_D01[ip][r]*w[3][nzc19[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 40
      for (unsigned int r = 0; r < 10; r++)
      {
        F4 += FE2_C0[ip][r]*w[3][nzc15[r]];
        F7 += FE2_C0[ip][r]*w[3][nzc18[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 6
      for (unsigned int r = 0; r < 3; r++)
      {
        F13 += FE0_C0[ip][r]*w[0][nzc12[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 40
      for (unsigned int r = 0; r < 5; r++)
      {
        F0 += FE1_C0_D10[ip][r]*w[0][nzc8[r]];
        F1 += FE1_C0_D01[ip][r]*w[0][nzc7[r]];
        F5 += FE1_C0_D10[ip][r]*w[0][nzc11[r]];
        F6 += FE1_C0_D01[ip][r]*w[0][nzc10[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 36
      for (unsigned int r = 0; r < 6; r++)
      {
        F2 += FE1_C0[ip][r]*w[0][nzc6[r]];
        F3 += FE1_C0[ip][r]*w[0][nzc9[r]];
        F8 += FE1_C0[ip][r]*w[3][nzc21[r]];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 57
      double I[1];
      // Number of operations: 57
      I[0] = W12[ip]*(F0*(F10*G[0] + F3*F4*G[2] + F9*G[3] + G[1]*(F8 + F2*F4)) + F1*(F10*G[4] + F3*F4*G[6] + F9*G[0] + G[5]*(F8 + F2*F4)) + F13*(F10*G[7] + F11*G[8] + F12*G[9] + F9*G[10]) + F5*(F11*G[3] + F12*G[0] + F2*F7*G[1] + G[2]*(F8 + F3*F7)) + F6*(F11*G[0] + F12*G[4] + F2*F7*G[5] + G[6]*(F8 + F3*F7)));
      
      
      // Number of operations for primary indices: 1
      // Number of operations to compute entry: 1
      A[0] += I[0];
    } // end loop over 'ip'
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_2_otherwise: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_2_otherwise() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_2_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({false, true, false, true});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               std::size_t facet,
                               int cell_orientation) const
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = vertex_coordinates[2*v1 + 0] - vertex_coordinates[2*v0 + 0];
    const double dx1 = vertex_coordinates[2*v1 + 1] - vertex_coordinates[2*v0 + 1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    
    const bool direction = dx1*(vertex_coordinates[2*facet] - vertex_coordinates[2*v0]) - dx0*(vertex_coordinates[2*facet + 1] - vertex_coordinates[2*v0 + 1]) < 0;
    // Compute facet normals from the facet scale factor constants
    const double n0 = direction ? dx1 / det : -dx1 / det;
    const double n1 = direction ? -dx0 / det : dx0 / det;
    
    // Facet area
    
    // Compute cell volume
    
    
    // Compute circumradius of triangle in 2D
    
    
    // Array of quadrature weights.
    static const double W3[3] = {0.277777777777778, 0.444444444444444, 0.277777777777778};
    // Quadrature points on the UFC reference element: (0.112701665379258), (0.5), (0.887298334620742)
    
    // Values of basis functions at quadrature points.
    static const double FE0_f0[3][2] = \
    {{0.887298334620742, 0.112701665379258},
    {0.5, 0.5},
    {0.112701665379258, 0.887298334620742}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[2] = {1, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 2};
    
    static const double FE2_f0_C0[3][4] = \
    {{0.488014084041408, 0.061985915958592, 0.747852751738001, -0.297852751738001},
    {-0.0625, -0.0625, 0.5625, 0.5625},
    {0.0619859159585921, 0.488014084041408, -0.297852751738001, 0.747852751738001}};
    
    // Array of non-zero columns
    static const unsigned int nzc14[4] = {11, 12, 13, 14};
    
    // Array of non-zero columns
    static const unsigned int nzc13[4] = {1, 2, 3, 4};
    
    // Array of non-zero columns
    static const unsigned int nzc20[4] = {10, 11, 17, 18};
    
    // Array of non-zero columns
    static const unsigned int nzc19[4] = {0, 1, 7, 8};
    
    // Array of non-zero columns
    static const unsigned int nzc16[4] = {0, 2, 5, 6};
    
    // Array of non-zero columns
    static const unsigned int nzc17[4] = {10, 12, 15, 16};
    
    // Reset values in the element tensor.
    A[0] = 0.0;
    // Number of operations to compute geometry constants: 2.
    double G[2];
    G[0] =  - det*n0;
    G[1] =  - det*n1;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    switch (facet)
    {
    case 0:
      {
        // Total number of operations to compute element tensor (from this point): 78
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 78
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        double F1 = 0.0;
        double F2 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc0[r]];
        } // end loop over 'r'
        
        // Total number of operations to compute function values = 16
        for (unsigned int r = 0; r < 4; r++)
        {
          F1 += FE2_f0_C0[ip][r]*w[3][nzc13[r]];
          F2 += FE2_f0_C0[ip][r]*w[3][nzc14[r]];
        } // end loop over 'r'
        
        // Number of operations to compute ip constants: 5
        double I[1];
        // Number of operations: 5
        I[0] = F0*W3[ip]*(F1*G[0] + F2*G[1]);
        
        
        // Number of operations for primary indices: 1
        // Number of operations to compute entry: 1
        A[0] += I[0];
      } // end loop over 'ip'
        break;
      }
    case 1:
      {
        // Total number of operations to compute element tensor (from this point): 78
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 78
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        double F1 = 0.0;
        double F2 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc1[r]];
        } // end loop over 'r'
        
        // Total number of operations to compute function values = 16
        for (unsigned int r = 0; r < 4; r++)
        {
          F1 += FE2_f0_C0[ip][r]*w[3][nzc16[r]];
          F2 += FE2_f0_C0[ip][r]*w[3][nzc17[r]];
        } // end loop over 'r'
        
        // Number of operations to compute ip constants: 5
        double I[1];
        // Number of operations: 5
        I[0] = F0*W3[ip]*(F1*G[0] + F2*G[1]);
        
        
        // Number of operations for primary indices: 1
        // Number of operations to compute entry: 1
        A[0] += I[0];
      } // end loop over 'ip'
        break;
      }
    case 2:
      {
        // Total number of operations to compute element tensor (from this point): 78
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 78
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        double F1 = 0.0;
        double F2 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc2[r]];
        } // end loop over 'r'
        
        // Total number of operations to compute function values = 16
        for (unsigned int r = 0; r < 4; r++)
        {
          F1 += FE2_f0_C0[ip][r]*w[3][nzc19[r]];
          F2 += FE2_f0_C0[ip][r]*w[3][nzc20[r]];
        } // end loop over 'r'
        
        // Number of operations to compute ip constants: 5
        double I[1];
        // Number of operations: 5
        I[0] = F0*W3[ip]*(F1*G[0] + F2*G[1]);
        
        
        // Number of operations for primary indices: 1
        // Number of operations to compute entry: 1
        A[0] += I[0];
      } // end loop over 'ip'
        break;
      }
    }
    
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_3_otherwise: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_3_otherwise() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_3_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({true});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               int cell_orientation) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      3
    // Number of operations (multiply-add pairs) for geometry tensor:    1
    // Number of operations (multiply-add pairs) for tensor contraction: 34
    // Total number of operations (multiply-add pairs):                  38
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0 = det*w[0][0]*(1.0);
    
    // Compute element tensor
    A[0] = 0.00357142857142857*G0_0;
    A[1] = 0.0;
    A[2] = 0.0;
    A[3] = -0.00714285714285713*G0_0;
    A[4] = -0.00357142857142856*G0_0;
    A[5] = -0.00357142857142856*G0_0;
    A[6] = 0.0;
    A[7] = 0.0;
    A[8] = 0.0;
    A[9] = 0.0;
    A[10] = 0.0;
    A[11] = 0.0;
    A[12] = 0.0;
    A[13] = 0.0;
    A[14] = 0.0;
    A[15] = 0.0;
    A[16] = 0.00357142857142857*G0_0;
    A[17] = 0.0;
    A[18] = -0.00357142857142857*G0_0;
    A[19] = -0.00714285714285713*G0_0;
    A[20] = -0.00357142857142857*G0_0;
    A[21] = 0.0;
    A[22] = 0.0;
    A[23] = 0.0;
    A[24] = 0.0;
    A[25] = 0.0;
    A[26] = 0.0;
    A[27] = 0.0;
    A[28] = 0.0;
    A[29] = 0.0;
    A[30] = 0.0;
    A[31] = 0.0;
    A[32] = 0.00357142857142856*G0_0;
    A[33] = -0.00357142857142857*G0_0;
    A[34] = -0.00357142857142857*G0_0;
    A[35] = -0.00714285714285714*G0_0;
    A[36] = 0.0;
    A[37] = 0.0;
    A[38] = 0.0;
    A[39] = 0.0;
    A[40] = 0.0;
    A[41] = 0.0;
    A[42] = 0.0;
    A[43] = 0.0;
    A[44] = 0.0;
    A[45] = -0.00714285714285713*G0_0;
    A[46] = -0.00357142857142857*G0_0;
    A[47] = -0.00357142857142857*G0_0;
    A[48] = 0.0428571428571428*G0_0;
    A[49] = 0.0285714285714285*G0_0;
    A[50] = 0.0285714285714285*G0_0;
    A[51] = 0.0;
    A[52] = 0.0;
    A[53] = 0.0;
    A[54] = 0.0;
    A[55] = 0.0;
    A[56] = 0.0;
    A[57] = 0.0;
    A[58] = 0.0;
    A[59] = 0.0;
    A[60] = -0.00357142857142856*G0_0;
    A[61] = -0.00714285714285713*G0_0;
    A[62] = -0.00357142857142856*G0_0;
    A[63] = 0.0285714285714285*G0_0;
    A[64] = 0.0428571428571428*G0_0;
    A[65] = 0.0285714285714285*G0_0;
    A[66] = 0.0;
    A[67] = 0.0;
    A[68] = 0.0;
    A[69] = 0.0;
    A[70] = 0.0;
    A[71] = 0.0;
    A[72] = 0.0;
    A[73] = 0.0;
    A[74] = 0.0;
    A[75] = -0.00357142857142856*G0_0;
    A[76] = -0.00357142857142857*G0_0;
    A[77] = -0.00714285714285713*G0_0;
    A[78] = 0.0285714285714285*G0_0;
    A[79] = 0.0285714285714285*G0_0;
    A[80] = 0.0428571428571428*G0_0;
    A[81] = 0.0;
    A[82] = 0.0;
    A[83] = 0.0;
    A[84] = 0.0;
    A[85] = 0.0;
    A[86] = 0.0;
    A[87] = 0.0;
    A[88] = 0.0;
    A[89] = 0.0;
    A[90] = 0.0;
    A[91] = 0.0;
    A[92] = 0.0;
    A[93] = 0.0;
    A[94] = 0.0;
    A[95] = 0.0;
    A[96] = 0.00357142857142857*G0_0;
    A[97] = 0.0;
    A[98] = 0.0;
    A[99] = -0.00714285714285713*G0_0;
    A[100] = -0.00357142857142856*G0_0;
    A[101] = -0.00357142857142856*G0_0;
    A[102] = 0.0;
    A[103] = 0.0;
    A[104] = 0.0;
    A[105] = 0.0;
    A[106] = 0.0;
    A[107] = 0.0;
    A[108] = 0.0;
    A[109] = 0.0;
    A[110] = 0.0;
    A[111] = 0.0;
    A[112] = 0.00357142857142857*G0_0;
    A[113] = 0.0;
    A[114] = -0.00357142857142857*G0_0;
    A[115] = -0.00714285714285713*G0_0;
    A[116] = -0.00357142857142857*G0_0;
    A[117] = 0.0;
    A[118] = 0.0;
    A[119] = 0.0;
    A[120] = 0.0;
    A[121] = 0.0;
    A[122] = 0.0;
    A[123] = 0.0;
    A[124] = 0.0;
    A[125] = 0.0;
    A[126] = 0.0;
    A[127] = 0.0;
    A[128] = 0.00357142857142856*G0_0;
    A[129] = -0.00357142857142857*G0_0;
    A[130] = -0.00357142857142857*G0_0;
    A[131] = -0.00714285714285714*G0_0;
    A[132] = 0.0;
    A[133] = 0.0;
    A[134] = 0.0;
    A[135] = 0.0;
    A[136] = 0.0;
    A[137] = 0.0;
    A[138] = 0.0;
    A[139] = 0.0;
    A[140] = 0.0;
    A[141] = -0.00714285714285713*G0_0;
    A[142] = -0.00357142857142857*G0_0;
    A[143] = -0.00357142857142857*G0_0;
    A[144] = 0.0428571428571428*G0_0;
    A[145] = 0.0285714285714285*G0_0;
    A[146] = 0.0285714285714285*G0_0;
    A[147] = 0.0;
    A[148] = 0.0;
    A[149] = 0.0;
    A[150] = 0.0;
    A[151] = 0.0;
    A[152] = 0.0;
    A[153] = 0.0;
    A[154] = 0.0;
    A[155] = 0.0;
    A[156] = -0.00357142857142856*G0_0;
    A[157] = -0.00714285714285713*G0_0;
    A[158] = -0.00357142857142856*G0_0;
    A[159] = 0.0285714285714285*G0_0;
    A[160] = 0.0428571428571428*G0_0;
    A[161] = 0.0285714285714285*G0_0;
    A[162] = 0.0;
    A[163] = 0.0;
    A[164] = 0.0;
    A[165] = 0.0;
    A[166] = 0.0;
    A[167] = 0.0;
    A[168] = 0.0;
    A[169] = 0.0;
    A[170] = 0.0;
    A[171] = -0.00357142857142856*G0_0;
    A[172] = -0.00357142857142857*G0_0;
    A[173] = -0.00714285714285713*G0_0;
    A[174] = 0.0285714285714285*G0_0;
    A[175] = 0.0285714285714285*G0_0;
    A[176] = 0.0428571428571428*G0_0;
    A[177] = 0.0;
    A[178] = 0.0;
    A[179] = 0.0;
    A[180] = 0.0;
    A[181] = 0.0;
    A[182] = 0.0;
    A[183] = 0.0;
    A[184] = 0.0;
    A[185] = 0.0;
    A[186] = 0.0;
    A[187] = 0.0;
    A[188] = 0.0;
    A[189] = 0.0;
    A[190] = 0.0;
    A[191] = 0.0;
    A[192] = 0.0321428571428571*G0_0;
    A[193] = 0.0214285714285714*G0_0;
    A[194] = 0.0214285714285714*G0_0;
    A[195] = 0.0;
    A[196] = 0.0;
    A[197] = 0.0;
    A[198] = 0.0;
    A[199] = 0.0;
    A[200] = 0.0;
    A[201] = 0.0;
    A[202] = 0.0;
    A[203] = 0.0;
    A[204] = 0.0;
    A[205] = 0.0;
    A[206] = 0.0;
    A[207] = 0.0214285714285714*G0_0;
    A[208] = 0.0321428571428571*G0_0;
    A[209] = 0.0214285714285714*G0_0;
    A[210] = 0.0;
    A[211] = 0.0;
    A[212] = 0.0;
    A[213] = 0.0;
    A[214] = 0.0;
    A[215] = 0.0;
    A[216] = 0.0;
    A[217] = 0.0;
    A[218] = 0.0;
    A[219] = 0.0;
    A[220] = 0.0;
    A[221] = 0.0;
    A[222] = 0.0214285714285714*G0_0;
    A[223] = 0.0214285714285714*G0_0;
    A[224] = 0.0321428571428571*G0_0;
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_4_otherwise: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_4_otherwise() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_4_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({true, false, true, true});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               int cell_orientation) const
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius of triangle in 2D
    
    
    // Array of quadrature weights.
    static const double W25[25] = {0.0114650803515925, 0.0198040831320473, 0.0173415064313656, 0.0087554991821638, 0.00186555216687783, 0.0231612219294983, 0.0400072873861603, 0.0350325045033716, 0.0176874521104834, 0.0037687016953276, 0.0275289856644697, 0.0475518970579538, 0.0416389652151948, 0.021022967487322, 0.00447940679728133, 0.0231612219294983, 0.0400072873861603, 0.0350325045033716, 0.0176874521104834, 0.0037687016953276, 0.0114650803515925, 0.0198040831320473, 0.0173415064313656, 0.0087554991821638, 0.00186555216687783};
    // Quadrature points on the UFC reference element: (0.0450425935698037, 0.0398098570514687), (0.0376212523451112, 0.198013417873608), (0.0263646449444709, 0.437974810247386), (0.0142857943955714, 0.695464273353636), (0.00462228846504642, 0.901464914201174), (0.221578609552379, 0.0398098570514687), (0.185070710267389, 0.198013417873608), (0.129695936782254, 0.437974810247386), (0.0702762920082817, 0.695464273353636), (0.022738483063764, 0.901464914201174), (0.480095071474266, 0.0398098570514687), (0.400993291063196, 0.198013417873608), (0.281012594876307, 0.437974810247386), (0.152267863323182, 0.695464273353636), (0.0492675428994132, 0.901464914201174), (0.738611533396152, 0.0398098570514687), (0.616915871859002, 0.198013417873608), (0.43232925297036, 0.437974810247386), (0.234259434638082, 0.695464273353636), (0.0757966027350624, 0.901464914201174), (0.915147549378728, 0.0398098570514687), (0.764365329781281, 0.198013417873608), (0.535660544808143, 0.437974810247386), (0.290249932250792, 0.695464273353636), (0.09391279733378, 0.901464914201174)
    
    // Values of basis functions at quadrature points.
    static const double FE0[25][1] = \
    {{0.0443066477812843},
    {0.153742030524499},
    {0.167003080840912},
    {0.0778601276421668},
    {0.0105656060730507},
    {0.175913147778989},
    {0.610410534080673},
    {0.663061619658879},
    {0.309132394931335},
    {0.0419492133929458},
    {0.247747270005307},
    {0.859671635180817},
    {0.933822788062264},
    {0.435366587895191},
    {0.0590791718992464},
    {0.175913147778989},
    {0.610410534080673},
    {0.663061619658879},
    {0.309132394931336},
    {0.0419492133929458},
    {0.0443066477812842},
    {0.153742030524499},
    {0.167003080840912},
    {0.0778601276421677},
    {0.0105656060730508}};
    
    static const double FE0_D01[25][1] = \
    {{1.06454195761932},
    {0.575285441238399},
    {0.0695371421115221},
    {-0.156297836604569},
    {-0.100783948537443},
    {4.18066660252782},
    {2.09321751667939},
    {-0.0197695576719489},
    {-0.875117679872582},
    {-0.506910012747091},
    {5.70722656015913},
    {2.19762631898684},
    {-1.19092570485194},
    {-2.23320663144433},
    {-1.13361310483317},
    {3.62492541922149},
    {-0.215583167171879},
    {-3.59850532693656},
    {-3.95431694241714},
    {-1.79832091177048},
    {0.129295602035074},
    {-3.31015168346013},
    {-5.95304978565769},
    {-5.33822419894345},
    {-2.27407499327841}};
    
    static const double FE0_D10[25][1] = \
    {{0.93524635558425},
    {3.88543712469853},
    {6.02258692776922},
    {5.18192636233889},
    {2.17329104474096},
    {0.555741183306335},
    {2.30880068385127},
    {3.57873576926462},
    {3.07919926254456},
    {1.29141089902339},
    {0.0},
    {0.0},
    {0.0},
    {0.0},
    {0.0},
    {-0.555741183306332},
    {-2.30880068385127},
    {-3.57873576926461},
    {-3.07919926254455},
    {-1.29141089902339},
    {-0.935246355584244},
    {-3.88543712469853},
    {-6.02258692776921},
    {-5.18192636233888},
    {-2.17329104474096}};
    
    static const double FE1_C0[25][3] = \
    {{0.915147549378728, 0.0450425935698037, 0.0398098570514687},
    {0.764365329781281, 0.0376212523451112, 0.198013417873608},
    {0.535660544808143, 0.026364644944471, 0.437974810247386},
    {0.290249932250793, 0.0142857943955714, 0.695464273353636},
    {0.0939127973337801, 0.00462228846504648, 0.901464914201173},
    {0.738611533396152, 0.221578609552379, 0.0398098570514687},
    {0.616915871859002, 0.185070710267389, 0.198013417873608},
    {0.43232925297036, 0.129695936782254, 0.437974810247386},
    {0.234259434638082, 0.0702762920082818, 0.695464273353636},
    {0.0757966027350624, 0.0227384830637641, 0.901464914201173},
    {0.480095071474266, 0.480095071474266, 0.0398098570514687},
    {0.400993291063196, 0.400993291063196, 0.198013417873608},
    {0.281012594876307, 0.281012594876307, 0.437974810247386},
    {0.152267863323182, 0.152267863323182, 0.695464273353636},
    {0.0492675428994133, 0.0492675428994133, 0.901464914201173},
    {0.221578609552379, 0.738611533396152, 0.0398098570514687},
    {0.185070710267389, 0.616915871859002, 0.198013417873608},
    {0.129695936782254, 0.43232925297036, 0.437974810247386},
    {0.0702762920082818, 0.234259434638082, 0.695464273353636},
    {0.0227384830637641, 0.0757966027350624, 0.901464914201173},
    {0.0450425935698037, 0.915147549378728, 0.0398098570514687},
    {0.0376212523451112, 0.764365329781281, 0.198013417873608},
    {0.026364644944471, 0.535660544808143, 0.437974810247386},
    {0.0142857943955715, 0.290249932250793, 0.695464273353636},
    {0.00462228846504648, 0.0939127973337801, 0.901464914201173}};
    
    // Array of non-zero columns
    static const unsigned int nzc12[3] = {12, 13, 14};
    
    static const double FE2_C0[25][6] = \
    {{0.759842524889054, -0.0409849230988147, -0.036640207614552, 0.00717255684496523, 0.145727572487076, 0.164882476492272},
    {0.404143384962011, -0.0347905350890822, -0.119594790557632, 0.0297980510461639, 0.605418365816316, 0.115025523822223},
    {0.0382038937201701, -0.0249744559383748, -0.0543309414249183, 0.0461882014671775, 0.938423301877431, 0.0564900002985142},
    {-0.121759885907613, -0.0138776265525463, 0.271876837668966, 0.0397410384743819, 0.807433832894958, 0.0165858034218534},
    {-0.0762735703276687, -0.00457955736373819, 0.723813068870285, 0.0166673234982246, 0.338636367163553, 0.00173636815934466},
    {0.352482461135478, -0.123384449130048, -0.036640207614552, 0.0352840510877737, 0.117616078244268, 0.65464206627708},
    {0.144254514044104, -0.116568374669637, -0.119594790557632, 0.146585935553368, 0.488630481309112, 0.456692234320685},
    {-0.0585120870225411, -0.0960538647466012, -0.0543309414249183, 0.227214213208259, 0.75739729013635, 0.224285389849452},
    {-0.124504469204174, -0.0603987775714151, 0.271876837668966, 0.19549860142211, 0.65167626994723, 0.0658515377372834},
    {-0.0643063527627087, -0.0217044058396818, 0.723813068870285, 0.0819917787365634, 0.273311911925214, 0.00689399907032823},
    {-0.0191125161665052, -0.0191125161665052, -0.036640207614552, 0.0764500646660207, 0.0764500646660207, 0.921965110615521},
    {-0.07940205210781, -0.07940205210781, -0.119594790557632, 0.31760820843124, 0.31760820843124, 0.643182477910772},
    {-0.123076437918076, -0.123076437918076, -0.0543309414249183, 0.492305751672304, 0.492305751672304, 0.315872313916462},
    {-0.105896858921167, -0.105896858921168, 0.271876837668966, 0.42358743568467, 0.42358743568467, 0.0927420088040289},
    {-0.0444129613327222, -0.0444129613327222, 0.723813068870285, 0.177651845330889, 0.177651845330889, 0.00970916313338205},
    {-0.123384449130048, 0.352482461135478, -0.036640207614552, 0.117616078244268, 0.0352840510877737, 0.65464206627708},
    {-0.116568374669637, 0.144254514044104, -0.119594790557632, 0.488630481309112, 0.146585935553368, 0.456692234320686},
    {-0.0960538647466012, -0.0585120870225412, -0.0543309414249183, 0.75739729013635, 0.227214213208259, 0.224285389849452},
    {-0.0603987775714152, -0.124504469204174, 0.271876837668966, 0.651676269947229, 0.19549860142211, 0.0658515377372834},
    {-0.0217044058396818, -0.0643063527627086, 0.723813068870285, 0.273311911925214, 0.0819917787365634, 0.00689399907032823},
    {-0.0409849230988147, 0.759842524889054, -0.036640207614552, 0.145727572487076, 0.00717255684496515, 0.164882476492272},
    {-0.0347905350890822, 0.404143384962011, -0.119594790557632, 0.605418365816316, 0.0297980510461639, 0.115025523822223},
    {-0.0249744559383749, 0.0382038937201699, -0.0543309414249183, 0.938423301877431, 0.0461882014671776, 0.0564900002985143},
    {-0.0138776265525464, -0.121759885907613, 0.271876837668966, 0.807433832894958, 0.0397410384743823, 0.0165858034218535},
    {-0.00457955736373816, -0.0762735703276687, 0.723813068870285, 0.338636367163553, 0.0166673234982245, 0.00173636815934466}};
    
    // Array of non-zero columns
    static const unsigned int nzc9[6] = {6, 7, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc6[6] = {0, 1, 2, 3, 4, 5};
    
    static const double FE2_C0_D01[25][5] = \
    {{-2.66059019751491, -0.840760571794125, 0.180170374279214, 3.50135076930903, -0.180170374279214},
    {-2.05746131912512, -0.207946328505567, 0.150485009380444, 2.26540764763069, -0.150485009380444},
    {-1.14264217923257, 0.751899240989544, 0.105458579777883, 0.390742938243027, -0.105458579777883},
    {-0.16099972900317, 1.78185709341454, 0.0571431775822844, -1.62085736441137, -0.0571431775822845},
    {0.62434881066488, 2.60585965680469, 0.0184891538601843, -3.23020846746957, -0.0184891538601851},
    {-1.95444613358461, -0.840760571794125, 0.886314438209516, 2.79520670537873, -0.886314438209517},
    {-1.46766348743601, -0.207946328505567, 0.740282841069557, 1.67560981594158, -0.740282841069557},
    {-0.729317011881439, 0.751899240989545, 0.518783747129015, -0.0225822291081059, -0.518783747129016},
    {0.0629622614476711, 1.78185709341454, 0.281105168033126, -1.84481935486221, -0.281105168033126},
    {0.696813589059751, 2.60585965680469, 0.0909539322550552, -3.30267324586444, -0.0909539322550557},
    {-0.920380285897062, -0.840760571794124, 1.92038028589706, 1.76114085769119, -1.92038028589706},
    {-0.603973164252783, -0.207946328505567, 1.60397316425278, 0.81191949275835, -1.60397316425278},
    {-0.124050379505227, 0.751899240989545, 1.12405037950523, -0.627848861484317, -1.12405037950523},
    {0.390928546707272, 1.78185709341454, 0.609071453292727, -2.17278564012182, -0.609071453292727},
    {0.802929828402347, 2.60585965680469, 0.197070171597652, -3.40878948520704, -0.197070171597652},
    {0.113685561790484, -0.840760571794124, 2.95444613358461, 0.727075010003642, -2.95444613358461},
    {0.259717158930443, -0.207946328505567, 2.46766348743601, -0.051770830424875, -2.46766348743601},
    {0.481216252870984, 0.751899240989545, 1.72931701188144, -1.23311549386053, -1.72931701188144},
    {0.718894831966873, 1.78185709341454, 0.937037738552328, -2.50075192538142, -0.937037738552328},
    {0.909046067744944, 2.60585965680469, 0.303186410940248, -3.51490572454964, -0.303186410940249},
    {0.819829625720786, -0.840760571794125, 3.66059019751491, 0.0209309460733402, -3.66059019751491},
    {0.849514990619556, -0.207946328505567, 3.05746131912512, -0.641568662113988, -3.05746131912512},
    {0.894541420222117, 0.751899240989544, 2.14264217923257, -1.64644066121166, -2.14264217923257},
    {0.942856822417715, 1.78185709341454, 1.16099972900317, -2.72471391583226, -1.16099972900317},
    {0.981510846139814, 2.60585965680469, 0.375651189335119, -3.58737050294451, -0.37565118933512}};
    
    // Array of non-zero columns
    static const unsigned int nzc10[5] = {6, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc7[5] = {0, 2, 3, 4, 5};
    
    static const double FE2_C0_D10[25][5] = \
    {{-2.66059019751491, -0.819829625720786, 0.159239428205873, -0.159239428205873, 3.4804198232357},
    {-2.05746131912512, -0.849514990619556, 0.792053671494432, -0.792053671494432, 2.90697630974468},
    {-1.14264217923257, -0.894541420222117, 1.75189924098954, -1.75189924098954, 2.03718359945469},
    {-0.16099972900317, -0.942856822417715, 2.78185709341454, -2.78185709341454, 1.10385655142088},
    {0.624348810664881, -0.981510846139815, 3.60585965680469, -3.60585965680469, 0.357162035474933},
    {-1.95444613358461, -0.113685561790483, 0.159239428205874, -0.159239428205874, 2.06813169537509},
    {-1.46766348743601, -0.259717158930443, 0.792053671494432, -0.792053671494432, 1.72738064636645},
    {-0.729317011881439, -0.481216252870984, 1.75189924098954, -1.75189924098954, 1.21053326475242},
    {0.0629622614476715, -0.718894831966874, 2.78185709341454, -2.78185709341454, 0.655932570519202},
    {0.696813589059751, -0.909046067744945, 3.60585965680469, -3.60585965680469, 0.212232478685192},
    {-0.920380285897062, 0.920380285897063, 0.159239428205874, -0.159239428205874, 0.0},
    {-0.603973164252783, 0.603973164252784, 0.792053671494432, -0.792053671494432, 0.0},
    {-0.124050379505227, 0.124050379505227, 1.75189924098954, -1.75189924098954, 0.0},
    {0.390928546707273, -0.390928546707273, 2.78185709341454, -2.78185709341454, 0.0},
    {0.802929828402348, -0.802929828402348, 3.60585965680469, -3.60585965680469, 0.0},
    {0.113685561790483, 1.95444613358461, 0.159239428205874, -0.159239428205874, -2.06813169537509},
    {0.259717158930443, 1.46766348743601, 0.792053671494432, -0.792053671494432, -1.72738064636645},
    {0.481216252870984, 0.729317011881438, 1.75189924098954, -1.75189924098954, -1.21053326475242},
    {0.718894831966874, -0.0629622614476716, 2.78185709341454, -2.78185709341454, -0.655932570519203},
    {0.909046067744945, -0.696813589059751, 3.60585965680469, -3.60585965680469, -0.212232478685195},
    {0.819829625720785, 2.66059019751491, 0.159239428205873, -0.159239428205873, -3.48041982323569},
    {0.849514990619556, 2.05746131912512, 0.792053671494432, -0.792053671494432, -2.90697630974468},
    {0.894541420222117, 1.14264217923257, 1.75189924098954, -1.75189924098954, -2.03718359945469},
    {0.942856822417715, 0.16099972900317, 2.78185709341454, -2.78185709341454, -1.10385655142089},
    {0.981510846139816, -0.62434881066488, 3.60585965680469, -3.60585965680469, -0.357162035474936}};
    
    // Array of non-zero columns
    static const unsigned int nzc11[5] = {6, 7, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc8[5] = {0, 1, 3, 4, 5};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 23.
    double G[11];
    G[0] =  - K[0]*det;
    G[1] =  - K[2]*det;
    G[2] =  - K[1]*det;
    G[3] =  - K[3]*det;
    G[4] =  - det*w[2][0]*(K[0]*K[2] + K[1]*K[3]);
    G[5] =  - det*w[2][0]*(K[2]*K[2] + K[3]*K[3]);
    G[6] = K[3]*det;
    G[7] =  - det*w[2][0]*(K[0]*K[0] + K[1]*K[1]);
    G[8] = K[1]*det;
    G[9] = K[2]*det;
    G[10] = K[0]*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 5825
    for (unsigned int ip = 0; ip < 25; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      
      // Total number of operations to compute function values = 6
      for (unsigned int r = 0; r < 1; r++)
      {
        F4 += FE0[ip][0]*w[3][0];
        F7 += FE0_D10[ip][0]*w[3][0];
        F8 += FE0_D01[ip][0]*w[3][0];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 6
      for (unsigned int r = 0; r < 3; r++)
      {
        F9 += FE1_C0[ip][r]*w[0][nzc12[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 40
      for (unsigned int r = 0; r < 5; r++)
      {
        F0 += FE2_C0_D10[ip][r]*w[0][nzc8[r]];
        F1 += FE2_C0_D01[ip][r]*w[0][nzc7[r]];
        F5 += FE2_C0_D10[ip][r]*w[0][nzc11[r]];
        F6 += FE2_C0_D01[ip][r]*w[0][nzc10[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 24
      for (unsigned int r = 0; r < 6; r++)
      {
        F2 += FE2_C0[ip][r]*w[0][nzc6[r]];
        F3 += FE2_C0[ip][r]*w[0][nzc9[r]];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 87
      double I[7];
      // Number of operations: 9
      I[0] = F4*W25[ip]*(F0*G[0] + F1*G[1] + F5*G[2] + F6*G[3]);
      
      // Number of operations: 7
      I[1] = F4*W25[ip]*(F5*G[4] + F6*G[5] + F9*G[6]);
      
      // Number of operations: 7
      I[2] = F4*W25[ip]*(F5*G[7] + F6*G[4] + F9*G[8]);
      
      // Number of operations: 7
      I[3] = F4*W25[ip]*(F0*G[4] + F1*G[5] + F9*G[9]);
      
      // Number of operations: 7
      I[4] = F4*W25[ip]*(F0*G[7] + F1*G[4] + F9*G[10]);
      
      // Number of operations: 25
      I[5] = W25[ip]*(F4*(F2*(F0*G[0] + F1*G[1]) + F3*(F0*G[2] + F1*G[3])) + F7*(F0*G[7] + F1*G[4] + F9*G[10]) + F8*(F0*G[4] + F1*G[5] + F9*G[9]));
      
      // Number of operations: 25
      I[6] = W25[ip]*(F5*(F4*(F2*G[0] + F3*G[2]) + F7*G[7] + F8*G[4]) + F6*(F4*(F2*G[1] + F3*G[3]) + F7*G[4] + F8*G[5]) + F9*(F7*G[8] + F8*G[6]));
      
      
      // Number of operations for primary indices: 6
      for (unsigned int j = 0; j < 3; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc12[j]] += FE1_C0[ip][j]*I[0];
      } // end loop over 'j'
      
      // Number of operations for primary indices: 40
      for (unsigned int j = 0; j < 5; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc10[j]] += FE2_C0_D01[ip][j]*I[1];
        // Number of operations to compute entry: 2
        A[nzc11[j]] += FE2_C0_D10[ip][j]*I[2];
        // Number of operations to compute entry: 2
        A[nzc7[j]] += FE2_C0_D01[ip][j]*I[3];
        // Number of operations to compute entry: 2
        A[nzc8[j]] += FE2_C0_D10[ip][j]*I[4];
      } // end loop over 'j'
      
      // Number of operations for primary indices: 24
      for (unsigned int j = 0; j < 6; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc6[j]] += FE2_C0[ip][j]*I[5];
        // Number of operations to compute entry: 2
        A[nzc9[j]] += FE2_C0[ip][j]*I[6];
      } // end loop over 'j'
    } // end loop over 'ip'
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_4_otherwise: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_4_otherwise() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_4_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({false, true, false, true});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               std::size_t facet,
                               int cell_orientation) const
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    
    // Get vertices on edge
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    
    
    // Compute facet normals from the facet scale factor constants
    
    // Facet area
    
    // Compute cell volume
    
    
    // Compute circumradius of triangle in 2D
    
    
    // Array of quadrature weights.
    // Values of basis functions at quadrature points.
    static const double FE1_f0[4][2] = \
    {{0.930568155797026, 0.0694318442029737},
    {0.669990521792428, 0.330009478207572},
    {0.330009478207572, 0.669990521792428},
    {0.0694318442029738, 0.930568155797026}};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc0[2] = {1, 2};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    switch (facet)
    {
    case 0:
      {
        // Total number of operations to compute element tensor (from this point): 16
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 16
      for (unsigned int ip = 0; ip < 4; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE1_f0[ip][r]*w[1][nzc0[r]];
        } // end loop over 'r'
      } // end loop over 'ip'
        break;
      }
    case 1:
      {
        // Total number of operations to compute element tensor (from this point): 16
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 16
      for (unsigned int ip = 0; ip < 4; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE1_f0[ip][r]*w[1][nzc1[r]];
        } // end loop over 'r'
      } // end loop over 'ip'
        break;
      }
    case 2:
      {
        // Total number of operations to compute element tensor (from this point): 16
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 16
      for (unsigned int ip = 0; ip < 4; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE1_f0[ip][r]*w[1][nzc2[r]];
        } // end loop over 'r'
      } // end loop over 'ip'
        break;
      }
    }
    
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_5_otherwise: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_5_otherwise() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_5_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({true});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               std::size_t facet,
                               int cell_orientation) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      10
    // Number of operations (multiply-add pairs) for geometry tensor:    6
    // Number of operations (multiply-add pairs) for tensor contraction: 165
    // Total number of operations (multiply-add pairs):                  181
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = vertex_coordinates[2*v1 + 0] - vertex_coordinates[2*v0 + 0];
    const double dx1 = vertex_coordinates[2*v1 + 1] - vertex_coordinates[2*v0 + 1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    
    // Compute geometry tensor
    const double G0_0 = det*w[0][0]*(1.0);
    const double G0_1 = det*w[0][1]*(1.0);
    const double G0_2 = det*w[0][2]*(1.0);
    const double G0_3 = det*w[0][3]*(1.0);
    const double G0_4 = det*w[0][4]*(1.0);
    const double G0_5 = det*w[0][5]*(1.0);
    
    // Compute element tensor
    switch (facet)
    {
    case 0:
      {
        A[0] = 0.0;
      A[1] = 0.0;
      A[2] = 0.0;
      A[3] = 0.0;
      A[4] = 0.0;
      A[5] = 0.0;
      A[6] = 0.0;
      A[7] = 0.0;
      A[8] = 0.0;
      A[9] = 0.0;
      A[10] = 0.0;
      A[11] = 0.0;
      A[12] = 0.0;
      A[13] = 0.0;
      A[14] = 0.0;
      A[15] = 0.0;
      A[16] = 0.0928571428571428*G0_1 - 0.00714285714285713*G0_2 + 0.0476190476190476*G0_3;
      A[17] = -0.00714285714285713*G0_1 - 0.00714285714285714*G0_2 - 0.019047619047619*G0_3;
      A[18] = 0.0476190476190476*G0_1 - 0.019047619047619*G0_2 + 0.038095238095238*G0_3;
      A[19] = 0.0;
      A[20] = 0.0;
      A[21] = 0.0;
      A[22] = 0.0;
      A[23] = 0.0;
      A[24] = 0.0;
      A[25] = 0.0;
      A[26] = 0.0;
      A[27] = 0.0;
      A[28] = 0.0;
      A[29] = 0.0;
      A[30] = 0.0;
      A[31] = -0.00714285714285713*G0_1 - 0.00714285714285714*G0_2 - 0.019047619047619*G0_3;
      A[32] = -0.00714285714285714*G0_1 + 0.0928571428571428*G0_2 + 0.0476190476190476*G0_3;
      A[33] = -0.019047619047619*G0_1 + 0.0476190476190476*G0_2 + 0.0380952380952381*G0_3;
      A[34] = 0.0;
      A[35] = 0.0;
      A[36] = 0.0;
      A[37] = 0.0;
      A[38] = 0.0;
      A[39] = 0.0;
      A[40] = 0.0;
      A[41] = 0.0;
      A[42] = 0.0;
      A[43] = 0.0;
      A[44] = 0.0;
      A[45] = 0.0;
      A[46] = 0.0476190476190476*G0_1 - 0.019047619047619*G0_2 + 0.038095238095238*G0_3;
      A[47] = -0.019047619047619*G0_1 + 0.0476190476190476*G0_2 + 0.0380952380952381*G0_3;
      A[48] = 0.038095238095238*G0_1 + 0.0380952380952381*G0_2 + 0.457142857142857*G0_3;
      A[49] = 0.0;
      A[50] = 0.0;
      A[51] = 0.0;
      A[52] = 0.0;
      A[53] = 0.0;
      A[54] = 0.0;
      A[55] = 0.0;
      A[56] = 0.0;
      A[57] = 0.0;
      A[58] = 0.0;
      A[59] = 0.0;
      A[60] = 0.0;
      A[61] = 0.0;
      A[62] = 0.0;
      A[63] = 0.0;
      A[64] = 0.0;
      A[65] = 0.0;
      A[66] = 0.0;
      A[67] = 0.0;
      A[68] = 0.0;
      A[69] = 0.0;
      A[70] = 0.0;
      A[71] = 0.0;
      A[72] = 0.0;
      A[73] = 0.0;
      A[74] = 0.0;
      A[75] = 0.0;
      A[76] = 0.0;
      A[77] = 0.0;
      A[78] = 0.0;
      A[79] = 0.0;
      A[80] = 0.0;
      A[81] = 0.0;
      A[82] = 0.0;
      A[83] = 0.0;
      A[84] = 0.0;
      A[85] = 0.0;
      A[86] = 0.0;
      A[87] = 0.0;
      A[88] = 0.0;
      A[89] = 0.0;
      A[90] = 0.0;
      A[91] = 0.0;
      A[92] = 0.0;
      A[93] = 0.0;
      A[94] = 0.0;
      A[95] = 0.0;
      A[96] = 0.0;
      A[97] = 0.0;
      A[98] = 0.0;
      A[99] = 0.0;
      A[100] = 0.0;
      A[101] = 0.0;
      A[102] = 0.0;
      A[103] = 0.0;
      A[104] = 0.0;
      A[105] = 0.0;
      A[106] = 0.0;
      A[107] = 0.0;
      A[108] = 0.0;
      A[109] = 0.0;
      A[110] = 0.0;
      A[111] = 0.0;
      A[112] = 0.0928571428571428*G0_1 - 0.00714285714285713*G0_2 + 0.0476190476190476*G0_3;
      A[113] = -0.00714285714285713*G0_1 - 0.00714285714285714*G0_2 - 0.019047619047619*G0_3;
      A[114] = 0.0476190476190476*G0_1 - 0.019047619047619*G0_2 + 0.038095238095238*G0_3;
      A[115] = 0.0;
      A[116] = 0.0;
      A[117] = 0.0;
      A[118] = 0.0;
      A[119] = 0.0;
      A[120] = 0.0;
      A[121] = 0.0;
      A[122] = 0.0;
      A[123] = 0.0;
      A[124] = 0.0;
      A[125] = 0.0;
      A[126] = 0.0;
      A[127] = -0.00714285714285713*G0_1 - 0.00714285714285714*G0_2 - 0.019047619047619*G0_3;
      A[128] = -0.00714285714285714*G0_1 + 0.0928571428571428*G0_2 + 0.0476190476190476*G0_3;
      A[129] = -0.019047619047619*G0_1 + 0.0476190476190476*G0_2 + 0.0380952380952381*G0_3;
      A[130] = 0.0;
      A[131] = 0.0;
      A[132] = 0.0;
      A[133] = 0.0;
      A[134] = 0.0;
      A[135] = 0.0;
      A[136] = 0.0;
      A[137] = 0.0;
      A[138] = 0.0;
      A[139] = 0.0;
      A[140] = 0.0;
      A[141] = 0.0;
      A[142] = 0.0476190476190476*G0_1 - 0.019047619047619*G0_2 + 0.038095238095238*G0_3;
      A[143] = -0.019047619047619*G0_1 + 0.0476190476190476*G0_2 + 0.0380952380952381*G0_3;
      A[144] = 0.038095238095238*G0_1 + 0.0380952380952381*G0_2 + 0.457142857142857*G0_3;
      A[145] = 0.0;
      A[146] = 0.0;
      A[147] = 0.0;
      A[148] = 0.0;
      A[149] = 0.0;
      A[150] = 0.0;
      A[151] = 0.0;
      A[152] = 0.0;
      A[153] = 0.0;
      A[154] = 0.0;
      A[155] = 0.0;
      A[156] = 0.0;
      A[157] = 0.0;
      A[158] = 0.0;
      A[159] = 0.0;
      A[160] = 0.0;
      A[161] = 0.0;
      A[162] = 0.0;
      A[163] = 0.0;
      A[164] = 0.0;
      A[165] = 0.0;
      A[166] = 0.0;
      A[167] = 0.0;
      A[168] = 0.0;
      A[169] = 0.0;
      A[170] = 0.0;
      A[171] = 0.0;
      A[172] = 0.0;
      A[173] = 0.0;
      A[174] = 0.0;
      A[175] = 0.0;
      A[176] = 0.0;
      A[177] = 0.0;
      A[178] = 0.0;
      A[179] = 0.0;
      A[180] = 0.0;
      A[181] = 0.0;
      A[182] = 0.0;
      A[183] = 0.0;
      A[184] = 0.0;
      A[185] = 0.0;
      A[186] = 0.0;
      A[187] = 0.0;
      A[188] = 0.0;
      A[189] = 0.0;
      A[190] = 0.0;
      A[191] = 0.0;
      A[192] = 0.0;
      A[193] = 0.0;
      A[194] = 0.0;
      A[195] = 0.0;
      A[196] = 0.0;
      A[197] = 0.0;
      A[198] = 0.0;
      A[199] = 0.0;
      A[200] = 0.0;
      A[201] = 0.0;
      A[202] = 0.0;
      A[203] = 0.0;
      A[204] = 0.0;
      A[205] = 0.0;
      A[206] = 0.0;
      A[207] = 0.0;
      A[208] = 0.15*G0_1 - 0.0166666666666666*G0_2 + 0.2*G0_3;
      A[209] = 0.0166666666666666*G0_1 + 0.0166666666666667*G0_2 + 0.133333333333333*G0_3;
      A[210] = 0.0;
      A[211] = 0.0;
      A[212] = 0.0;
      A[213] = 0.0;
      A[214] = 0.0;
      A[215] = 0.0;
      A[216] = 0.0;
      A[217] = 0.0;
      A[218] = 0.0;
      A[219] = 0.0;
      A[220] = 0.0;
      A[221] = 0.0;
      A[222] = 0.0;
      A[223] = 0.0166666666666666*G0_1 + 0.0166666666666667*G0_2 + 0.133333333333333*G0_3;
      A[224] = -0.0166666666666666*G0_1 + 0.15*G0_2 + 0.2*G0_3;
        break;
      }
    case 1:
      {
        A[0] = 0.0928571428571428*G0_0 - 0.00714285714285714*G0_2 + 0.0476190476190476*G0_4;
      A[1] = 0.0;
      A[2] = -0.00714285714285714*G0_0 - 0.00714285714285713*G0_2 - 0.019047619047619*G0_4;
      A[3] = 0.0;
      A[4] = 0.0476190476190476*G0_0 - 0.019047619047619*G0_2 + 0.0380952380952381*G0_4;
      A[5] = 0.0;
      A[6] = 0.0;
      A[7] = 0.0;
      A[8] = 0.0;
      A[9] = 0.0;
      A[10] = 0.0;
      A[11] = 0.0;
      A[12] = 0.0;
      A[13] = 0.0;
      A[14] = 0.0;
      A[15] = 0.0;
      A[16] = 0.0;
      A[17] = 0.0;
      A[18] = 0.0;
      A[19] = 0.0;
      A[20] = 0.0;
      A[21] = 0.0;
      A[22] = 0.0;
      A[23] = 0.0;
      A[24] = 0.0;
      A[25] = 0.0;
      A[26] = 0.0;
      A[27] = 0.0;
      A[28] = 0.0;
      A[29] = 0.0;
      A[30] = -0.00714285714285714*G0_0 - 0.00714285714285713*G0_2 - 0.019047619047619*G0_4;
      A[31] = 0.0;
      A[32] = -0.00714285714285713*G0_0 + 0.0928571428571428*G0_2 + 0.0476190476190476*G0_4;
      A[33] = 0.0;
      A[34] = -0.019047619047619*G0_0 + 0.0476190476190476*G0_2 + 0.0380952380952381*G0_4;
      A[35] = 0.0;
      A[36] = 0.0;
      A[37] = 0.0;
      A[38] = 0.0;
      A[39] = 0.0;
      A[40] = 0.0;
      A[41] = 0.0;
      A[42] = 0.0;
      A[43] = 0.0;
      A[44] = 0.0;
      A[45] = 0.0;
      A[46] = 0.0;
      A[47] = 0.0;
      A[48] = 0.0;
      A[49] = 0.0;
      A[50] = 0.0;
      A[51] = 0.0;
      A[52] = 0.0;
      A[53] = 0.0;
      A[54] = 0.0;
      A[55] = 0.0;
      A[56] = 0.0;
      A[57] = 0.0;
      A[58] = 0.0;
      A[59] = 0.0;
      A[60] = 0.0476190476190476*G0_0 - 0.019047619047619*G0_2 + 0.0380952380952381*G0_4;
      A[61] = 0.0;
      A[62] = -0.019047619047619*G0_0 + 0.0476190476190476*G0_2 + 0.0380952380952381*G0_4;
      A[63] = 0.0;
      A[64] = 0.0380952380952381*G0_0 + 0.0380952380952381*G0_2 + 0.457142857142857*G0_4;
      A[65] = 0.0;
      A[66] = 0.0;
      A[67] = 0.0;
      A[68] = 0.0;
      A[69] = 0.0;
      A[70] = 0.0;
      A[71] = 0.0;
      A[72] = 0.0;
      A[73] = 0.0;
      A[74] = 0.0;
      A[75] = 0.0;
      A[76] = 0.0;
      A[77] = 0.0;
      A[78] = 0.0;
      A[79] = 0.0;
      A[80] = 0.0;
      A[81] = 0.0;
      A[82] = 0.0;
      A[83] = 0.0;
      A[84] = 0.0;
      A[85] = 0.0;
      A[86] = 0.0;
      A[87] = 0.0;
      A[88] = 0.0;
      A[89] = 0.0;
      A[90] = 0.0;
      A[91] = 0.0;
      A[92] = 0.0;
      A[93] = 0.0;
      A[94] = 0.0;
      A[95] = 0.0;
      A[96] = 0.0928571428571428*G0_0 - 0.00714285714285714*G0_2 + 0.0476190476190476*G0_4;
      A[97] = 0.0;
      A[98] = -0.00714285714285714*G0_0 - 0.00714285714285713*G0_2 - 0.019047619047619*G0_4;
      A[99] = 0.0;
      A[100] = 0.0476190476190476*G0_0 - 0.019047619047619*G0_2 + 0.0380952380952381*G0_4;
      A[101] = 0.0;
      A[102] = 0.0;
      A[103] = 0.0;
      A[104] = 0.0;
      A[105] = 0.0;
      A[106] = 0.0;
      A[107] = 0.0;
      A[108] = 0.0;
      A[109] = 0.0;
      A[110] = 0.0;
      A[111] = 0.0;
      A[112] = 0.0;
      A[113] = 0.0;
      A[114] = 0.0;
      A[115] = 0.0;
      A[116] = 0.0;
      A[117] = 0.0;
      A[118] = 0.0;
      A[119] = 0.0;
      A[120] = 0.0;
      A[121] = 0.0;
      A[122] = 0.0;
      A[123] = 0.0;
      A[124] = 0.0;
      A[125] = 0.0;
      A[126] = -0.00714285714285714*G0_0 - 0.00714285714285713*G0_2 - 0.019047619047619*G0_4;
      A[127] = 0.0;
      A[128] = -0.00714285714285713*G0_0 + 0.0928571428571428*G0_2 + 0.0476190476190476*G0_4;
      A[129] = 0.0;
      A[130] = -0.019047619047619*G0_0 + 0.0476190476190476*G0_2 + 0.0380952380952381*G0_4;
      A[131] = 0.0;
      A[132] = 0.0;
      A[133] = 0.0;
      A[134] = 0.0;
      A[135] = 0.0;
      A[136] = 0.0;
      A[137] = 0.0;
      A[138] = 0.0;
      A[139] = 0.0;
      A[140] = 0.0;
      A[141] = 0.0;
      A[142] = 0.0;
      A[143] = 0.0;
      A[144] = 0.0;
      A[145] = 0.0;
      A[146] = 0.0;
      A[147] = 0.0;
      A[148] = 0.0;
      A[149] = 0.0;
      A[150] = 0.0;
      A[151] = 0.0;
      A[152] = 0.0;
      A[153] = 0.0;
      A[154] = 0.0;
      A[155] = 0.0;
      A[156] = 0.0476190476190476*G0_0 - 0.019047619047619*G0_2 + 0.0380952380952381*G0_4;
      A[157] = 0.0;
      A[158] = -0.019047619047619*G0_0 + 0.0476190476190476*G0_2 + 0.0380952380952381*G0_4;
      A[159] = 0.0;
      A[160] = 0.0380952380952381*G0_0 + 0.0380952380952381*G0_2 + 0.457142857142857*G0_4;
      A[161] = 0.0;
      A[162] = 0.0;
      A[163] = 0.0;
      A[164] = 0.0;
      A[165] = 0.0;
      A[166] = 0.0;
      A[167] = 0.0;
      A[168] = 0.0;
      A[169] = 0.0;
      A[170] = 0.0;
      A[171] = 0.0;
      A[172] = 0.0;
      A[173] = 0.0;
      A[174] = 0.0;
      A[175] = 0.0;
      A[176] = 0.0;
      A[177] = 0.0;
      A[178] = 0.0;
      A[179] = 0.0;
      A[180] = 0.0;
      A[181] = 0.0;
      A[182] = 0.0;
      A[183] = 0.0;
      A[184] = 0.0;
      A[185] = 0.0;
      A[186] = 0.0;
      A[187] = 0.0;
      A[188] = 0.0;
      A[189] = 0.0;
      A[190] = 0.0;
      A[191] = 0.0;
      A[192] = 0.15*G0_0 - 0.0166666666666666*G0_2 + 0.2*G0_4;
      A[193] = 0.0;
      A[194] = 0.0166666666666667*G0_0 + 0.0166666666666667*G0_2 + 0.133333333333333*G0_4;
      A[195] = 0.0;
      A[196] = 0.0;
      A[197] = 0.0;
      A[198] = 0.0;
      A[199] = 0.0;
      A[200] = 0.0;
      A[201] = 0.0;
      A[202] = 0.0;
      A[203] = 0.0;
      A[204] = 0.0;
      A[205] = 0.0;
      A[206] = 0.0;
      A[207] = 0.0;
      A[208] = 0.0;
      A[209] = 0.0;
      A[210] = 0.0;
      A[211] = 0.0;
      A[212] = 0.0;
      A[213] = 0.0;
      A[214] = 0.0;
      A[215] = 0.0;
      A[216] = 0.0;
      A[217] = 0.0;
      A[218] = 0.0;
      A[219] = 0.0;
      A[220] = 0.0;
      A[221] = 0.0;
      A[222] = 0.0166666666666667*G0_0 + 0.0166666666666667*G0_2 + 0.133333333333333*G0_4;
      A[223] = 0.0;
      A[224] = -0.0166666666666666*G0_0 + 0.15*G0_2 + 0.2*G0_4;
        break;
      }
    case 2:
      {
        A[0] = 0.0928571428571428*G0_0 - 0.00714285714285714*G0_1 + 0.0476190476190476*G0_5;
      A[1] = -0.00714285714285714*G0_0 - 0.00714285714285714*G0_1 - 0.019047619047619*G0_5;
      A[2] = 0.0;
      A[3] = 0.0;
      A[4] = 0.0;
      A[5] = 0.0476190476190476*G0_0 - 0.019047619047619*G0_1 + 0.0380952380952381*G0_5;
      A[6] = 0.0;
      A[7] = 0.0;
      A[8] = 0.0;
      A[9] = 0.0;
      A[10] = 0.0;
      A[11] = 0.0;
      A[12] = 0.0;
      A[13] = 0.0;
      A[14] = 0.0;
      A[15] = -0.00714285714285714*G0_0 - 0.00714285714285714*G0_1 - 0.019047619047619*G0_5;
      A[16] = -0.00714285714285714*G0_0 + 0.0928571428571428*G0_1 + 0.0476190476190476*G0_5;
      A[17] = 0.0;
      A[18] = 0.0;
      A[19] = 0.0;
      A[20] = -0.019047619047619*G0_0 + 0.0476190476190476*G0_1 + 0.0380952380952381*G0_5;
      A[21] = 0.0;
      A[22] = 0.0;
      A[23] = 0.0;
      A[24] = 0.0;
      A[25] = 0.0;
      A[26] = 0.0;
      A[27] = 0.0;
      A[28] = 0.0;
      A[29] = 0.0;
      A[30] = 0.0;
      A[31] = 0.0;
      A[32] = 0.0;
      A[33] = 0.0;
      A[34] = 0.0;
      A[35] = 0.0;
      A[36] = 0.0;
      A[37] = 0.0;
      A[38] = 0.0;
      A[39] = 0.0;
      A[40] = 0.0;
      A[41] = 0.0;
      A[42] = 0.0;
      A[43] = 0.0;
      A[44] = 0.0;
      A[45] = 0.0;
      A[46] = 0.0;
      A[47] = 0.0;
      A[48] = 0.0;
      A[49] = 0.0;
      A[50] = 0.0;
      A[51] = 0.0;
      A[52] = 0.0;
      A[53] = 0.0;
      A[54] = 0.0;
      A[55] = 0.0;
      A[56] = 0.0;
      A[57] = 0.0;
      A[58] = 0.0;
      A[59] = 0.0;
      A[60] = 0.0;
      A[61] = 0.0;
      A[62] = 0.0;
      A[63] = 0.0;
      A[64] = 0.0;
      A[65] = 0.0;
      A[66] = 0.0;
      A[67] = 0.0;
      A[68] = 0.0;
      A[69] = 0.0;
      A[70] = 0.0;
      A[71] = 0.0;
      A[72] = 0.0;
      A[73] = 0.0;
      A[74] = 0.0;
      A[75] = 0.0476190476190476*G0_0 - 0.019047619047619*G0_1 + 0.0380952380952381*G0_5;
      A[76] = -0.019047619047619*G0_0 + 0.0476190476190476*G0_1 + 0.0380952380952381*G0_5;
      A[77] = 0.0;
      A[78] = 0.0;
      A[79] = 0.0;
      A[80] = 0.0380952380952381*G0_0 + 0.0380952380952381*G0_1 + 0.457142857142857*G0_5;
      A[81] = 0.0;
      A[82] = 0.0;
      A[83] = 0.0;
      A[84] = 0.0;
      A[85] = 0.0;
      A[86] = 0.0;
      A[87] = 0.0;
      A[88] = 0.0;
      A[89] = 0.0;
      A[90] = 0.0;
      A[91] = 0.0;
      A[92] = 0.0;
      A[93] = 0.0;
      A[94] = 0.0;
      A[95] = 0.0;
      A[96] = 0.0928571428571428*G0_0 - 0.00714285714285714*G0_1 + 0.0476190476190476*G0_5;
      A[97] = -0.00714285714285714*G0_0 - 0.00714285714285714*G0_1 - 0.019047619047619*G0_5;
      A[98] = 0.0;
      A[99] = 0.0;
      A[100] = 0.0;
      A[101] = 0.0476190476190476*G0_0 - 0.019047619047619*G0_1 + 0.0380952380952381*G0_5;
      A[102] = 0.0;
      A[103] = 0.0;
      A[104] = 0.0;
      A[105] = 0.0;
      A[106] = 0.0;
      A[107] = 0.0;
      A[108] = 0.0;
      A[109] = 0.0;
      A[110] = 0.0;
      A[111] = -0.00714285714285714*G0_0 - 0.00714285714285714*G0_1 - 0.019047619047619*G0_5;
      A[112] = -0.00714285714285714*G0_0 + 0.0928571428571428*G0_1 + 0.0476190476190476*G0_5;
      A[113] = 0.0;
      A[114] = 0.0;
      A[115] = 0.0;
      A[116] = -0.019047619047619*G0_0 + 0.0476190476190476*G0_1 + 0.0380952380952381*G0_5;
      A[117] = 0.0;
      A[118] = 0.0;
      A[119] = 0.0;
      A[120] = 0.0;
      A[121] = 0.0;
      A[122] = 0.0;
      A[123] = 0.0;
      A[124] = 0.0;
      A[125] = 0.0;
      A[126] = 0.0;
      A[127] = 0.0;
      A[128] = 0.0;
      A[129] = 0.0;
      A[130] = 0.0;
      A[131] = 0.0;
      A[132] = 0.0;
      A[133] = 0.0;
      A[134] = 0.0;
      A[135] = 0.0;
      A[136] = 0.0;
      A[137] = 0.0;
      A[138] = 0.0;
      A[139] = 0.0;
      A[140] = 0.0;
      A[141] = 0.0;
      A[142] = 0.0;
      A[143] = 0.0;
      A[144] = 0.0;
      A[145] = 0.0;
      A[146] = 0.0;
      A[147] = 0.0;
      A[148] = 0.0;
      A[149] = 0.0;
      A[150] = 0.0;
      A[151] = 0.0;
      A[152] = 0.0;
      A[153] = 0.0;
      A[154] = 0.0;
      A[155] = 0.0;
      A[156] = 0.0;
      A[157] = 0.0;
      A[158] = 0.0;
      A[159] = 0.0;
      A[160] = 0.0;
      A[161] = 0.0;
      A[162] = 0.0;
      A[163] = 0.0;
      A[164] = 0.0;
      A[165] = 0.0;
      A[166] = 0.0;
      A[167] = 0.0;
      A[168] = 0.0;
      A[169] = 0.0;
      A[170] = 0.0;
      A[171] = 0.0476190476190476*G0_0 - 0.019047619047619*G0_1 + 0.0380952380952381*G0_5;
      A[172] = -0.019047619047619*G0_0 + 0.0476190476190476*G0_1 + 0.0380952380952381*G0_5;
      A[173] = 0.0;
      A[174] = 0.0;
      A[175] = 0.0;
      A[176] = 0.0380952380952381*G0_0 + 0.0380952380952381*G0_1 + 0.457142857142857*G0_5;
      A[177] = 0.0;
      A[178] = 0.0;
      A[179] = 0.0;
      A[180] = 0.0;
      A[181] = 0.0;
      A[182] = 0.0;
      A[183] = 0.0;
      A[184] = 0.0;
      A[185] = 0.0;
      A[186] = 0.0;
      A[187] = 0.0;
      A[188] = 0.0;
      A[189] = 0.0;
      A[190] = 0.0;
      A[191] = 0.0;
      A[192] = 0.15*G0_0 - 0.0166666666666667*G0_1 + 0.2*G0_5;
      A[193] = 0.0166666666666667*G0_0 + 0.0166666666666667*G0_1 + 0.133333333333333*G0_5;
      A[194] = 0.0;
      A[195] = 0.0;
      A[196] = 0.0;
      A[197] = 0.0;
      A[198] = 0.0;
      A[199] = 0.0;
      A[200] = 0.0;
      A[201] = 0.0;
      A[202] = 0.0;
      A[203] = 0.0;
      A[204] = 0.0;
      A[205] = 0.0;
      A[206] = 0.0;
      A[207] = 0.0166666666666666*G0_0 + 0.0166666666666667*G0_1 + 0.133333333333333*G0_5;
      A[208] = -0.0166666666666667*G0_0 + 0.15*G0_1 + 0.2*G0_5;
      A[209] = 0.0;
      A[210] = 0.0;
      A[211] = 0.0;
      A[212] = 0.0;
      A[213] = 0.0;
      A[214] = 0.0;
      A[215] = 0.0;
      A[216] = 0.0;
      A[217] = 0.0;
      A[218] = 0.0;
      A[219] = 0.0;
      A[220] = 0.0;
      A[221] = 0.0;
      A[222] = 0.0;
      A[223] = 0.0;
      A[224] = 0.0;
        break;
      }
    }
    
  }

};

/// This class defines the interface for the tabulation of the
/// interior facet tensor corresponding to the local contribution to
/// a form from the integral over an interior facet.

class adaptivenavierstokes_interior_facet_integral_5_otherwise: public ufc::interior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_interior_facet_integral_5_otherwise() : ufc::interior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_interior_facet_integral_5_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({true});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local interior facet
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates_0,
                               const double*  vertex_coordinates_1,
                               std::size_t facet_0,
                               std::size_t facet_1,
                               int cell_orientation_0,
                               int cell_orientation_1) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      12
    // Number of operations (multiply-add pairs) for geometry tensor:    12
    // Number of operations (multiply-add pairs) for tensor contraction: 990
    // Total number of operations (multiply-add pairs):                  1014
    
    // Compute Jacobian
    double J_0[4];
    compute_jacobian_triangle_2d(J_0, vertex_coordinates_0);
    
    // Compute Jacobian inverse and determinant
    double K_0[4];
    double detJ_0;
    compute_jacobian_inverse_triangle_2d(K_0, detJ_0, J_0);
    
    // Compute Jacobian
    double J_1[4];
    compute_jacobian_triangle_2d(J_1, vertex_coordinates_1);
    
    // Compute Jacobian inverse and determinant
    double K_1[4];
    double detJ_1;
    compute_jacobian_inverse_triangle_2d(K_1, detJ_1, J_1);
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet_0][0];
    const unsigned int v1 = edge_vertices[facet_0][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = vertex_coordinates_0[2*v1 + 0] - vertex_coordinates_0[2*v0 + 0];
    const double dx1 = vertex_coordinates_0[2*v1 + 1] - vertex_coordinates_0[2*v0 + 1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    
    
    // Compute geometry tensor
    const double G0_6 = det*w[0][6]*(1.0);
    const double G0_7 = det*w[0][7]*(1.0);
    const double G0_8 = det*w[0][8]*(1.0);
    const double G0_9 = det*w[0][9]*(1.0);
    const double G0_10 = det*w[0][10]*(1.0);
    const double G0_11 = det*w[0][11]*(1.0);
    const double G1_0 = det*w[0][0]*(1.0);
    const double G1_1 = det*w[0][1]*(1.0);
    const double G1_2 = det*w[0][2]*(1.0);
    const double G1_3 = det*w[0][3]*(1.0);
    const double G1_4 = det*w[0][4]*(1.0);
    const double G1_5 = det*w[0][5]*(1.0);
    
    // Compute element tensor
    switch (facet_0)
    {
    case 0:
      {
        switch (facet_1)
      {
      case 0:
        {
          A[0] = 0.0;
        A[1] = 0.0;
        A[2] = 0.0;
        A[3] = 0.0;
        A[4] = 0.0;
        A[5] = 0.0;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = 0.0;
        A[31] = 0.0928571428571428*G1_1 - 0.00714285714285713*G1_2 + 0.0476190476190476*G1_3;
        A[32] = -0.00714285714285713*G1_1 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_3;
        A[33] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[34] = 0.0;
        A[35] = 0.0;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = 0.0;
        A[61] = -0.00714285714285713*G1_1 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_3;
        A[62] = -0.00714285714285714*G1_1 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_3;
        A[63] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[64] = 0.0;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[92] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[93] = 0.038095238095238*G1_1 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_3;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0;
        A[121] = 0.0;
        A[122] = 0.0;
        A[123] = 0.0;
        A[124] = 0.0;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0;
        A[151] = 0.0;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.0;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0;
        A[187] = 0.0;
        A[188] = 0.0;
        A[189] = 0.0;
        A[190] = 0.0;
        A[191] = 0.0;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = 0.0;
        A[217] = 0.0928571428571428*G1_1 - 0.00714285714285713*G1_2 + 0.0476190476190476*G1_3;
        A[218] = -0.00714285714285713*G1_1 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_3;
        A[219] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[220] = 0.0;
        A[221] = 0.0;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = 0.0;
        A[247] = -0.00714285714285713*G1_1 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_3;
        A[248] = -0.00714285714285714*G1_1 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_3;
        A[249] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[250] = 0.0;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[278] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[279] = 0.038095238095238*G1_1 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_3;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0;
        A[307] = 0.0;
        A[308] = 0.0;
        A[309] = 0.0;
        A[310] = 0.0;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0;
        A[337] = 0.0;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.0;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.0;
        A[373] = 0.0;
        A[374] = 0.0;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0;
        A[403] = 0.15*G1_1 - 0.0166666666666666*G1_2 + 0.2*G1_3;
        A[404] = 0.0166666666666666*G1_1 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_3;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0;
        A[433] = 0.0166666666666666*G1_1 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_3;
        A[434] = -0.0166666666666666*G1_1 + 0.15*G1_2 + 0.2*G1_3;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0;
        A[466] = 0.0;
        A[467] = 0.0;
        A[468] = 0.0;
        A[469] = 0.0;
        A[470] = 0.0;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = 0.0;
        A[496] = 0.0928571428571428*G0_7 - 0.00714285714285713*G0_8 + 0.0476190476190476*G0_9;
        A[497] = -0.00714285714285713*G0_7 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_9;
        A[498] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[499] = 0.0;
        A[500] = 0.0;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = 0.0;
        A[526] = -0.00714285714285713*G0_7 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_9;
        A[527] = -0.00714285714285714*G0_7 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_9;
        A[528] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[529] = 0.0;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[557] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[558] = 0.038095238095238*G0_7 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_9;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0;
        A[586] = 0.0;
        A[587] = 0.0;
        A[588] = 0.0;
        A[589] = 0.0;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0;
        A[616] = 0.0;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.0;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0;
        A[652] = 0.0;
        A[653] = 0.0;
        A[654] = 0.0;
        A[655] = 0.0;
        A[656] = 0.0;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = 0.0;
        A[682] = 0.0928571428571428*G0_7 - 0.00714285714285713*G0_8 + 0.0476190476190476*G0_9;
        A[683] = -0.00714285714285713*G0_7 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_9;
        A[684] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[685] = 0.0;
        A[686] = 0.0;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = 0.0;
        A[712] = -0.00714285714285713*G0_7 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_9;
        A[713] = -0.00714285714285714*G0_7 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_9;
        A[714] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[715] = 0.0;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[743] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[744] = 0.038095238095238*G0_7 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_9;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0;
        A[772] = 0.0;
        A[773] = 0.0;
        A[774] = 0.0;
        A[775] = 0.0;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0;
        A[802] = 0.0;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.0;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.0;
        A[838] = 0.0;
        A[839] = 0.0;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0;
        A[868] = 0.15*G0_7 - 0.0166666666666666*G0_8 + 0.2*G0_9;
        A[869] = 0.0166666666666666*G0_7 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_9;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0;
        A[898] = 0.0166666666666666*G0_7 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_9;
        A[899] = -0.0166666666666666*G0_7 + 0.15*G0_8 + 0.2*G0_9;
          break;
        }
      case 1:
        {
          A[0] = 0.0;
        A[1] = 0.0;
        A[2] = 0.0;
        A[3] = 0.0;
        A[4] = 0.0;
        A[5] = 0.0;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = 0.0;
        A[31] = 0.0928571428571428*G1_1 - 0.00714285714285713*G1_2 + 0.0476190476190476*G1_3;
        A[32] = -0.00714285714285713*G1_1 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_3;
        A[33] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[34] = 0.0;
        A[35] = 0.0;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = 0.0;
        A[61] = -0.00714285714285713*G1_1 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_3;
        A[62] = -0.00714285714285714*G1_1 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_3;
        A[63] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[64] = 0.0;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[92] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[93] = 0.038095238095238*G1_1 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_3;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0;
        A[121] = 0.0;
        A[122] = 0.0;
        A[123] = 0.0;
        A[124] = 0.0;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0;
        A[151] = 0.0;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.0;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0;
        A[187] = 0.0;
        A[188] = 0.0;
        A[189] = 0.0;
        A[190] = 0.0;
        A[191] = 0.0;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = 0.0;
        A[217] = 0.0928571428571428*G1_1 - 0.00714285714285713*G1_2 + 0.0476190476190476*G1_3;
        A[218] = -0.00714285714285713*G1_1 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_3;
        A[219] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[220] = 0.0;
        A[221] = 0.0;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = 0.0;
        A[247] = -0.00714285714285713*G1_1 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_3;
        A[248] = -0.00714285714285714*G1_1 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_3;
        A[249] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[250] = 0.0;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[278] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[279] = 0.038095238095238*G1_1 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_3;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0;
        A[307] = 0.0;
        A[308] = 0.0;
        A[309] = 0.0;
        A[310] = 0.0;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0;
        A[337] = 0.0;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.0;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.0;
        A[373] = 0.0;
        A[374] = 0.0;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0;
        A[403] = 0.15*G1_1 - 0.0166666666666666*G1_2 + 0.2*G1_3;
        A[404] = 0.0166666666666666*G1_1 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_3;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0;
        A[433] = 0.0166666666666666*G1_1 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_3;
        A[434] = -0.0166666666666666*G1_1 + 0.15*G1_2 + 0.2*G1_3;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_10;
        A[466] = 0.0;
        A[467] = -0.00714285714285714*G0_6 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_10;
        A[468] = 0.0;
        A[469] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[470] = 0.0;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = 0.0;
        A[496] = 0.0;
        A[497] = 0.0;
        A[498] = 0.0;
        A[499] = 0.0;
        A[500] = 0.0;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = -0.00714285714285714*G0_6 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_10;
        A[526] = 0.0;
        A[527] = -0.00714285714285713*G0_6 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_10;
        A[528] = 0.0;
        A[529] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0;
        A[557] = 0.0;
        A[558] = 0.0;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[586] = 0.0;
        A[587] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[588] = 0.0;
        A[589] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_10;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0;
        A[616] = 0.0;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.0;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_10;
        A[652] = 0.0;
        A[653] = -0.00714285714285714*G0_6 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_10;
        A[654] = 0.0;
        A[655] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[656] = 0.0;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = 0.0;
        A[682] = 0.0;
        A[683] = 0.0;
        A[684] = 0.0;
        A[685] = 0.0;
        A[686] = 0.0;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = -0.00714285714285714*G0_6 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_10;
        A[712] = 0.0;
        A[713] = -0.00714285714285713*G0_6 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_10;
        A[714] = 0.0;
        A[715] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0;
        A[743] = 0.0;
        A[744] = 0.0;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[772] = 0.0;
        A[773] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[774] = 0.0;
        A[775] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_10;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0;
        A[802] = 0.0;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.0;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.15*G0_6 - 0.0166666666666666*G0_8 + 0.2*G0_10;
        A[838] = 0.0;
        A[839] = 0.0166666666666667*G0_6 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_10;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0;
        A[868] = 0.0;
        A[869] = 0.0;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0166666666666667*G0_6 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_10;
        A[898] = 0.0;
        A[899] = -0.0166666666666666*G0_6 + 0.15*G0_8 + 0.2*G0_10;
          break;
        }
      case 2:
        {
          A[0] = 0.0;
        A[1] = 0.0;
        A[2] = 0.0;
        A[3] = 0.0;
        A[4] = 0.0;
        A[5] = 0.0;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = 0.0;
        A[31] = 0.0928571428571428*G1_1 - 0.00714285714285713*G1_2 + 0.0476190476190476*G1_3;
        A[32] = -0.00714285714285713*G1_1 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_3;
        A[33] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[34] = 0.0;
        A[35] = 0.0;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = 0.0;
        A[61] = -0.00714285714285713*G1_1 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_3;
        A[62] = -0.00714285714285714*G1_1 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_3;
        A[63] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[64] = 0.0;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[92] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[93] = 0.038095238095238*G1_1 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_3;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0;
        A[121] = 0.0;
        A[122] = 0.0;
        A[123] = 0.0;
        A[124] = 0.0;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0;
        A[151] = 0.0;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.0;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0;
        A[187] = 0.0;
        A[188] = 0.0;
        A[189] = 0.0;
        A[190] = 0.0;
        A[191] = 0.0;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = 0.0;
        A[217] = 0.0928571428571428*G1_1 - 0.00714285714285713*G1_2 + 0.0476190476190476*G1_3;
        A[218] = -0.00714285714285713*G1_1 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_3;
        A[219] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[220] = 0.0;
        A[221] = 0.0;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = 0.0;
        A[247] = -0.00714285714285713*G1_1 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_3;
        A[248] = -0.00714285714285714*G1_1 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_3;
        A[249] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[250] = 0.0;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.038095238095238*G1_3;
        A[278] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[279] = 0.038095238095238*G1_1 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_3;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0;
        A[307] = 0.0;
        A[308] = 0.0;
        A[309] = 0.0;
        A[310] = 0.0;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0;
        A[337] = 0.0;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.0;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.0;
        A[373] = 0.0;
        A[374] = 0.0;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0;
        A[403] = 0.15*G1_1 - 0.0166666666666666*G1_2 + 0.2*G1_3;
        A[404] = 0.0166666666666666*G1_1 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_3;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0;
        A[433] = 0.0166666666666666*G1_1 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_3;
        A[434] = -0.0166666666666666*G1_1 + 0.15*G1_2 + 0.2*G1_3;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_7 + 0.0476190476190476*G0_11;
        A[466] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_7 - 0.019047619047619*G0_11;
        A[467] = 0.0;
        A[468] = 0.0;
        A[469] = 0.0;
        A[470] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.0380952380952381*G0_11;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_7 - 0.019047619047619*G0_11;
        A[496] = -0.00714285714285714*G0_6 + 0.0928571428571428*G0_7 + 0.0476190476190476*G0_11;
        A[497] = 0.0;
        A[498] = 0.0;
        A[499] = 0.0;
        A[500] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = 0.0;
        A[526] = 0.0;
        A[527] = 0.0;
        A[528] = 0.0;
        A[529] = 0.0;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0;
        A[557] = 0.0;
        A[558] = 0.0;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0;
        A[586] = 0.0;
        A[587] = 0.0;
        A[588] = 0.0;
        A[589] = 0.0;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.0380952380952381*G0_11;
        A[616] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_7 + 0.457142857142857*G0_11;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_7 + 0.0476190476190476*G0_11;
        A[652] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_7 - 0.019047619047619*G0_11;
        A[653] = 0.0;
        A[654] = 0.0;
        A[655] = 0.0;
        A[656] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.0380952380952381*G0_11;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_7 - 0.019047619047619*G0_11;
        A[682] = -0.00714285714285714*G0_6 + 0.0928571428571428*G0_7 + 0.0476190476190476*G0_11;
        A[683] = 0.0;
        A[684] = 0.0;
        A[685] = 0.0;
        A[686] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = 0.0;
        A[712] = 0.0;
        A[713] = 0.0;
        A[714] = 0.0;
        A[715] = 0.0;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0;
        A[743] = 0.0;
        A[744] = 0.0;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0;
        A[772] = 0.0;
        A[773] = 0.0;
        A[774] = 0.0;
        A[775] = 0.0;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.0380952380952381*G0_11;
        A[802] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_7 + 0.457142857142857*G0_11;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.15*G0_6 - 0.0166666666666667*G0_7 + 0.2*G0_11;
        A[838] = 0.0166666666666666*G0_6 + 0.0166666666666667*G0_7 + 0.133333333333333*G0_11;
        A[839] = 0.0;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0166666666666667*G0_6 + 0.0166666666666667*G0_7 + 0.133333333333333*G0_11;
        A[868] = -0.0166666666666667*G0_6 + 0.15*G0_7 + 0.2*G0_11;
        A[869] = 0.0;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0;
        A[898] = 0.0;
        A[899] = 0.0;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        switch (facet_1)
      {
      case 0:
        {
          A[0] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_4;
        A[1] = 0.0;
        A[2] = -0.00714285714285714*G1_0 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_4;
        A[3] = 0.0;
        A[4] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[5] = 0.0;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = 0.0;
        A[31] = 0.0;
        A[32] = 0.0;
        A[33] = 0.0;
        A[34] = 0.0;
        A[35] = 0.0;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = -0.00714285714285714*G1_0 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_4;
        A[61] = 0.0;
        A[62] = -0.00714285714285713*G1_0 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_4;
        A[63] = 0.0;
        A[64] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0;
        A[92] = 0.0;
        A[93] = 0.0;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[121] = 0.0;
        A[122] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[123] = 0.0;
        A[124] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_4;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0;
        A[151] = 0.0;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.0;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_4;
        A[187] = 0.0;
        A[188] = -0.00714285714285714*G1_0 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_4;
        A[189] = 0.0;
        A[190] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[191] = 0.0;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = 0.0;
        A[217] = 0.0;
        A[218] = 0.0;
        A[219] = 0.0;
        A[220] = 0.0;
        A[221] = 0.0;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = -0.00714285714285714*G1_0 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_4;
        A[247] = 0.0;
        A[248] = -0.00714285714285713*G1_0 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_4;
        A[249] = 0.0;
        A[250] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0;
        A[278] = 0.0;
        A[279] = 0.0;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[307] = 0.0;
        A[308] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[309] = 0.0;
        A[310] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_4;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0;
        A[337] = 0.0;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.0;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.15*G1_0 - 0.0166666666666666*G1_2 + 0.2*G1_4;
        A[373] = 0.0;
        A[374] = 0.0166666666666667*G1_0 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_4;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0;
        A[403] = 0.0;
        A[404] = 0.0;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0166666666666667*G1_0 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_4;
        A[433] = 0.0;
        A[434] = -0.0166666666666666*G1_0 + 0.15*G1_2 + 0.2*G1_4;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0;
        A[466] = 0.0;
        A[467] = 0.0;
        A[468] = 0.0;
        A[469] = 0.0;
        A[470] = 0.0;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = 0.0;
        A[496] = 0.0928571428571428*G0_7 - 0.00714285714285713*G0_8 + 0.0476190476190476*G0_9;
        A[497] = -0.00714285714285713*G0_7 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_9;
        A[498] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[499] = 0.0;
        A[500] = 0.0;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = 0.0;
        A[526] = -0.00714285714285713*G0_7 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_9;
        A[527] = -0.00714285714285714*G0_7 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_9;
        A[528] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[529] = 0.0;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[557] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[558] = 0.038095238095238*G0_7 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_9;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0;
        A[586] = 0.0;
        A[587] = 0.0;
        A[588] = 0.0;
        A[589] = 0.0;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0;
        A[616] = 0.0;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.0;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0;
        A[652] = 0.0;
        A[653] = 0.0;
        A[654] = 0.0;
        A[655] = 0.0;
        A[656] = 0.0;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = 0.0;
        A[682] = 0.0928571428571428*G0_7 - 0.00714285714285713*G0_8 + 0.0476190476190476*G0_9;
        A[683] = -0.00714285714285713*G0_7 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_9;
        A[684] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[685] = 0.0;
        A[686] = 0.0;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = 0.0;
        A[712] = -0.00714285714285713*G0_7 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_9;
        A[713] = -0.00714285714285714*G0_7 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_9;
        A[714] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[715] = 0.0;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[743] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[744] = 0.038095238095238*G0_7 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_9;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0;
        A[772] = 0.0;
        A[773] = 0.0;
        A[774] = 0.0;
        A[775] = 0.0;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0;
        A[802] = 0.0;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.0;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.0;
        A[838] = 0.0;
        A[839] = 0.0;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0;
        A[868] = 0.15*G0_7 - 0.0166666666666666*G0_8 + 0.2*G0_9;
        A[869] = 0.0166666666666666*G0_7 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_9;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0;
        A[898] = 0.0166666666666666*G0_7 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_9;
        A[899] = -0.0166666666666666*G0_7 + 0.15*G0_8 + 0.2*G0_9;
          break;
        }
      case 1:
        {
          A[0] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_4;
        A[1] = 0.0;
        A[2] = -0.00714285714285714*G1_0 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_4;
        A[3] = 0.0;
        A[4] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[5] = 0.0;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = 0.0;
        A[31] = 0.0;
        A[32] = 0.0;
        A[33] = 0.0;
        A[34] = 0.0;
        A[35] = 0.0;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = -0.00714285714285714*G1_0 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_4;
        A[61] = 0.0;
        A[62] = -0.00714285714285713*G1_0 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_4;
        A[63] = 0.0;
        A[64] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0;
        A[92] = 0.0;
        A[93] = 0.0;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[121] = 0.0;
        A[122] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[123] = 0.0;
        A[124] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_4;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0;
        A[151] = 0.0;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.0;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_4;
        A[187] = 0.0;
        A[188] = -0.00714285714285714*G1_0 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_4;
        A[189] = 0.0;
        A[190] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[191] = 0.0;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = 0.0;
        A[217] = 0.0;
        A[218] = 0.0;
        A[219] = 0.0;
        A[220] = 0.0;
        A[221] = 0.0;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = -0.00714285714285714*G1_0 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_4;
        A[247] = 0.0;
        A[248] = -0.00714285714285713*G1_0 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_4;
        A[249] = 0.0;
        A[250] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0;
        A[278] = 0.0;
        A[279] = 0.0;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[307] = 0.0;
        A[308] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[309] = 0.0;
        A[310] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_4;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0;
        A[337] = 0.0;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.0;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.15*G1_0 - 0.0166666666666666*G1_2 + 0.2*G1_4;
        A[373] = 0.0;
        A[374] = 0.0166666666666667*G1_0 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_4;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0;
        A[403] = 0.0;
        A[404] = 0.0;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0166666666666667*G1_0 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_4;
        A[433] = 0.0;
        A[434] = -0.0166666666666666*G1_0 + 0.15*G1_2 + 0.2*G1_4;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_10;
        A[466] = 0.0;
        A[467] = -0.00714285714285714*G0_6 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_10;
        A[468] = 0.0;
        A[469] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[470] = 0.0;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = 0.0;
        A[496] = 0.0;
        A[497] = 0.0;
        A[498] = 0.0;
        A[499] = 0.0;
        A[500] = 0.0;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = -0.00714285714285714*G0_6 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_10;
        A[526] = 0.0;
        A[527] = -0.00714285714285713*G0_6 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_10;
        A[528] = 0.0;
        A[529] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0;
        A[557] = 0.0;
        A[558] = 0.0;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[586] = 0.0;
        A[587] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[588] = 0.0;
        A[589] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_10;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0;
        A[616] = 0.0;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.0;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_10;
        A[652] = 0.0;
        A[653] = -0.00714285714285714*G0_6 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_10;
        A[654] = 0.0;
        A[655] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[656] = 0.0;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = 0.0;
        A[682] = 0.0;
        A[683] = 0.0;
        A[684] = 0.0;
        A[685] = 0.0;
        A[686] = 0.0;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = -0.00714285714285714*G0_6 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_10;
        A[712] = 0.0;
        A[713] = -0.00714285714285713*G0_6 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_10;
        A[714] = 0.0;
        A[715] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0;
        A[743] = 0.0;
        A[744] = 0.0;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[772] = 0.0;
        A[773] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[774] = 0.0;
        A[775] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_10;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0;
        A[802] = 0.0;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.0;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.15*G0_6 - 0.0166666666666666*G0_8 + 0.2*G0_10;
        A[838] = 0.0;
        A[839] = 0.0166666666666667*G0_6 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_10;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0;
        A[868] = 0.0;
        A[869] = 0.0;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0166666666666667*G0_6 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_10;
        A[898] = 0.0;
        A[899] = -0.0166666666666666*G0_6 + 0.15*G0_8 + 0.2*G0_10;
          break;
        }
      case 2:
        {
          A[0] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_4;
        A[1] = 0.0;
        A[2] = -0.00714285714285714*G1_0 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_4;
        A[3] = 0.0;
        A[4] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[5] = 0.0;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = 0.0;
        A[31] = 0.0;
        A[32] = 0.0;
        A[33] = 0.0;
        A[34] = 0.0;
        A[35] = 0.0;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = -0.00714285714285714*G1_0 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_4;
        A[61] = 0.0;
        A[62] = -0.00714285714285713*G1_0 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_4;
        A[63] = 0.0;
        A[64] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0;
        A[92] = 0.0;
        A[93] = 0.0;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[121] = 0.0;
        A[122] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[123] = 0.0;
        A[124] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_4;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0;
        A[151] = 0.0;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.0;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_4;
        A[187] = 0.0;
        A[188] = -0.00714285714285714*G1_0 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_4;
        A[189] = 0.0;
        A[190] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[191] = 0.0;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = 0.0;
        A[217] = 0.0;
        A[218] = 0.0;
        A[219] = 0.0;
        A[220] = 0.0;
        A[221] = 0.0;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = -0.00714285714285714*G1_0 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_4;
        A[247] = 0.0;
        A[248] = -0.00714285714285713*G1_0 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_4;
        A[249] = 0.0;
        A[250] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0;
        A[278] = 0.0;
        A[279] = 0.0;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[307] = 0.0;
        A[308] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[309] = 0.0;
        A[310] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_4;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0;
        A[337] = 0.0;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.0;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.15*G1_0 - 0.0166666666666666*G1_2 + 0.2*G1_4;
        A[373] = 0.0;
        A[374] = 0.0166666666666667*G1_0 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_4;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0;
        A[403] = 0.0;
        A[404] = 0.0;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0166666666666667*G1_0 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_4;
        A[433] = 0.0;
        A[434] = -0.0166666666666666*G1_0 + 0.15*G1_2 + 0.2*G1_4;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_7 + 0.0476190476190476*G0_11;
        A[466] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_7 - 0.019047619047619*G0_11;
        A[467] = 0.0;
        A[468] = 0.0;
        A[469] = 0.0;
        A[470] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.0380952380952381*G0_11;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_7 - 0.019047619047619*G0_11;
        A[496] = -0.00714285714285714*G0_6 + 0.0928571428571428*G0_7 + 0.0476190476190476*G0_11;
        A[497] = 0.0;
        A[498] = 0.0;
        A[499] = 0.0;
        A[500] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = 0.0;
        A[526] = 0.0;
        A[527] = 0.0;
        A[528] = 0.0;
        A[529] = 0.0;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0;
        A[557] = 0.0;
        A[558] = 0.0;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0;
        A[586] = 0.0;
        A[587] = 0.0;
        A[588] = 0.0;
        A[589] = 0.0;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.0380952380952381*G0_11;
        A[616] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_7 + 0.457142857142857*G0_11;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_7 + 0.0476190476190476*G0_11;
        A[652] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_7 - 0.019047619047619*G0_11;
        A[653] = 0.0;
        A[654] = 0.0;
        A[655] = 0.0;
        A[656] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.0380952380952381*G0_11;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_7 - 0.019047619047619*G0_11;
        A[682] = -0.00714285714285714*G0_6 + 0.0928571428571428*G0_7 + 0.0476190476190476*G0_11;
        A[683] = 0.0;
        A[684] = 0.0;
        A[685] = 0.0;
        A[686] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = 0.0;
        A[712] = 0.0;
        A[713] = 0.0;
        A[714] = 0.0;
        A[715] = 0.0;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0;
        A[743] = 0.0;
        A[744] = 0.0;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0;
        A[772] = 0.0;
        A[773] = 0.0;
        A[774] = 0.0;
        A[775] = 0.0;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.0380952380952381*G0_11;
        A[802] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_7 + 0.457142857142857*G0_11;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.15*G0_6 - 0.0166666666666667*G0_7 + 0.2*G0_11;
        A[838] = 0.0166666666666666*G0_6 + 0.0166666666666667*G0_7 + 0.133333333333333*G0_11;
        A[839] = 0.0;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0166666666666667*G0_6 + 0.0166666666666667*G0_7 + 0.133333333333333*G0_11;
        A[868] = -0.0166666666666667*G0_6 + 0.15*G0_7 + 0.2*G0_11;
        A[869] = 0.0;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0;
        A[898] = 0.0;
        A[899] = 0.0;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        switch (facet_1)
      {
      case 0:
        {
          A[0] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_1 + 0.0476190476190476*G1_5;
        A[1] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_1 - 0.019047619047619*G1_5;
        A[2] = 0.0;
        A[3] = 0.0;
        A[4] = 0.0;
        A[5] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.0380952380952381*G1_5;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_1 - 0.019047619047619*G1_5;
        A[31] = -0.00714285714285714*G1_0 + 0.0928571428571428*G1_1 + 0.0476190476190476*G1_5;
        A[32] = 0.0;
        A[33] = 0.0;
        A[34] = 0.0;
        A[35] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = 0.0;
        A[61] = 0.0;
        A[62] = 0.0;
        A[63] = 0.0;
        A[64] = 0.0;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0;
        A[92] = 0.0;
        A[93] = 0.0;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0;
        A[121] = 0.0;
        A[122] = 0.0;
        A[123] = 0.0;
        A[124] = 0.0;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.0380952380952381*G1_5;
        A[151] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_1 + 0.457142857142857*G1_5;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_1 + 0.0476190476190476*G1_5;
        A[187] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_1 - 0.019047619047619*G1_5;
        A[188] = 0.0;
        A[189] = 0.0;
        A[190] = 0.0;
        A[191] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.0380952380952381*G1_5;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_1 - 0.019047619047619*G1_5;
        A[217] = -0.00714285714285714*G1_0 + 0.0928571428571428*G1_1 + 0.0476190476190476*G1_5;
        A[218] = 0.0;
        A[219] = 0.0;
        A[220] = 0.0;
        A[221] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = 0.0;
        A[247] = 0.0;
        A[248] = 0.0;
        A[249] = 0.0;
        A[250] = 0.0;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0;
        A[278] = 0.0;
        A[279] = 0.0;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0;
        A[307] = 0.0;
        A[308] = 0.0;
        A[309] = 0.0;
        A[310] = 0.0;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.0380952380952381*G1_5;
        A[337] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_1 + 0.457142857142857*G1_5;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.15*G1_0 - 0.0166666666666667*G1_1 + 0.2*G1_5;
        A[373] = 0.0166666666666666*G1_0 + 0.0166666666666667*G1_1 + 0.133333333333333*G1_5;
        A[374] = 0.0;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0166666666666667*G1_0 + 0.0166666666666667*G1_1 + 0.133333333333333*G1_5;
        A[403] = -0.0166666666666667*G1_0 + 0.15*G1_1 + 0.2*G1_5;
        A[404] = 0.0;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0;
        A[433] = 0.0;
        A[434] = 0.0;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0;
        A[466] = 0.0;
        A[467] = 0.0;
        A[468] = 0.0;
        A[469] = 0.0;
        A[470] = 0.0;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = 0.0;
        A[496] = 0.0928571428571428*G0_7 - 0.00714285714285713*G0_8 + 0.0476190476190476*G0_9;
        A[497] = -0.00714285714285713*G0_7 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_9;
        A[498] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[499] = 0.0;
        A[500] = 0.0;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = 0.0;
        A[526] = -0.00714285714285713*G0_7 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_9;
        A[527] = -0.00714285714285714*G0_7 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_9;
        A[528] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[529] = 0.0;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[557] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[558] = 0.038095238095238*G0_7 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_9;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0;
        A[586] = 0.0;
        A[587] = 0.0;
        A[588] = 0.0;
        A[589] = 0.0;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0;
        A[616] = 0.0;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.0;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0;
        A[652] = 0.0;
        A[653] = 0.0;
        A[654] = 0.0;
        A[655] = 0.0;
        A[656] = 0.0;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = 0.0;
        A[682] = 0.0928571428571428*G0_7 - 0.00714285714285713*G0_8 + 0.0476190476190476*G0_9;
        A[683] = -0.00714285714285713*G0_7 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_9;
        A[684] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[685] = 0.0;
        A[686] = 0.0;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = 0.0;
        A[712] = -0.00714285714285713*G0_7 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_9;
        A[713] = -0.00714285714285714*G0_7 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_9;
        A[714] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[715] = 0.0;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.038095238095238*G0_9;
        A[743] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[744] = 0.038095238095238*G0_7 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_9;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0;
        A[772] = 0.0;
        A[773] = 0.0;
        A[774] = 0.0;
        A[775] = 0.0;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0;
        A[802] = 0.0;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.0;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.0;
        A[838] = 0.0;
        A[839] = 0.0;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0;
        A[868] = 0.15*G0_7 - 0.0166666666666666*G0_8 + 0.2*G0_9;
        A[869] = 0.0166666666666666*G0_7 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_9;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0;
        A[898] = 0.0166666666666666*G0_7 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_9;
        A[899] = -0.0166666666666666*G0_7 + 0.15*G0_8 + 0.2*G0_9;
          break;
        }
      case 1:
        {
          A[0] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_1 + 0.0476190476190476*G1_5;
        A[1] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_1 - 0.019047619047619*G1_5;
        A[2] = 0.0;
        A[3] = 0.0;
        A[4] = 0.0;
        A[5] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.0380952380952381*G1_5;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_1 - 0.019047619047619*G1_5;
        A[31] = -0.00714285714285714*G1_0 + 0.0928571428571428*G1_1 + 0.0476190476190476*G1_5;
        A[32] = 0.0;
        A[33] = 0.0;
        A[34] = 0.0;
        A[35] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = 0.0;
        A[61] = 0.0;
        A[62] = 0.0;
        A[63] = 0.0;
        A[64] = 0.0;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0;
        A[92] = 0.0;
        A[93] = 0.0;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0;
        A[121] = 0.0;
        A[122] = 0.0;
        A[123] = 0.0;
        A[124] = 0.0;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.0380952380952381*G1_5;
        A[151] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_1 + 0.457142857142857*G1_5;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_1 + 0.0476190476190476*G1_5;
        A[187] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_1 - 0.019047619047619*G1_5;
        A[188] = 0.0;
        A[189] = 0.0;
        A[190] = 0.0;
        A[191] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.0380952380952381*G1_5;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_1 - 0.019047619047619*G1_5;
        A[217] = -0.00714285714285714*G1_0 + 0.0928571428571428*G1_1 + 0.0476190476190476*G1_5;
        A[218] = 0.0;
        A[219] = 0.0;
        A[220] = 0.0;
        A[221] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = 0.0;
        A[247] = 0.0;
        A[248] = 0.0;
        A[249] = 0.0;
        A[250] = 0.0;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0;
        A[278] = 0.0;
        A[279] = 0.0;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0;
        A[307] = 0.0;
        A[308] = 0.0;
        A[309] = 0.0;
        A[310] = 0.0;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.0380952380952381*G1_5;
        A[337] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_1 + 0.457142857142857*G1_5;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.15*G1_0 - 0.0166666666666667*G1_1 + 0.2*G1_5;
        A[373] = 0.0166666666666666*G1_0 + 0.0166666666666667*G1_1 + 0.133333333333333*G1_5;
        A[374] = 0.0;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0166666666666667*G1_0 + 0.0166666666666667*G1_1 + 0.133333333333333*G1_5;
        A[403] = -0.0166666666666667*G1_0 + 0.15*G1_1 + 0.2*G1_5;
        A[404] = 0.0;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0;
        A[433] = 0.0;
        A[434] = 0.0;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_10;
        A[466] = 0.0;
        A[467] = -0.00714285714285714*G0_6 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_10;
        A[468] = 0.0;
        A[469] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[470] = 0.0;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = 0.0;
        A[496] = 0.0;
        A[497] = 0.0;
        A[498] = 0.0;
        A[499] = 0.0;
        A[500] = 0.0;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = -0.00714285714285714*G0_6 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_10;
        A[526] = 0.0;
        A[527] = -0.00714285714285713*G0_6 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_10;
        A[528] = 0.0;
        A[529] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0;
        A[557] = 0.0;
        A[558] = 0.0;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[586] = 0.0;
        A[587] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[588] = 0.0;
        A[589] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_10;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0;
        A[616] = 0.0;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.0;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_10;
        A[652] = 0.0;
        A[653] = -0.00714285714285714*G0_6 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_10;
        A[654] = 0.0;
        A[655] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[656] = 0.0;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = 0.0;
        A[682] = 0.0;
        A[683] = 0.0;
        A[684] = 0.0;
        A[685] = 0.0;
        A[686] = 0.0;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = -0.00714285714285714*G0_6 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_10;
        A[712] = 0.0;
        A[713] = -0.00714285714285713*G0_6 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_10;
        A[714] = 0.0;
        A[715] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0;
        A[743] = 0.0;
        A[744] = 0.0;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[772] = 0.0;
        A[773] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[774] = 0.0;
        A[775] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_10;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0;
        A[802] = 0.0;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.0;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.15*G0_6 - 0.0166666666666666*G0_8 + 0.2*G0_10;
        A[838] = 0.0;
        A[839] = 0.0166666666666667*G0_6 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_10;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0;
        A[868] = 0.0;
        A[869] = 0.0;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0166666666666667*G0_6 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_10;
        A[898] = 0.0;
        A[899] = -0.0166666666666666*G0_6 + 0.15*G0_8 + 0.2*G0_10;
          break;
        }
      case 2:
        {
          A[0] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_1 + 0.0476190476190476*G1_5;
        A[1] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_1 - 0.019047619047619*G1_5;
        A[2] = 0.0;
        A[3] = 0.0;
        A[4] = 0.0;
        A[5] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.0380952380952381*G1_5;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_1 - 0.019047619047619*G1_5;
        A[31] = -0.00714285714285714*G1_0 + 0.0928571428571428*G1_1 + 0.0476190476190476*G1_5;
        A[32] = 0.0;
        A[33] = 0.0;
        A[34] = 0.0;
        A[35] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = 0.0;
        A[61] = 0.0;
        A[62] = 0.0;
        A[63] = 0.0;
        A[64] = 0.0;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0;
        A[92] = 0.0;
        A[93] = 0.0;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0;
        A[121] = 0.0;
        A[122] = 0.0;
        A[123] = 0.0;
        A[124] = 0.0;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.0380952380952381*G1_5;
        A[151] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_1 + 0.457142857142857*G1_5;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_1 + 0.0476190476190476*G1_5;
        A[187] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_1 - 0.019047619047619*G1_5;
        A[188] = 0.0;
        A[189] = 0.0;
        A[190] = 0.0;
        A[191] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.0380952380952381*G1_5;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_1 - 0.019047619047619*G1_5;
        A[217] = -0.00714285714285714*G1_0 + 0.0928571428571428*G1_1 + 0.0476190476190476*G1_5;
        A[218] = 0.0;
        A[219] = 0.0;
        A[220] = 0.0;
        A[221] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = 0.0;
        A[247] = 0.0;
        A[248] = 0.0;
        A[249] = 0.0;
        A[250] = 0.0;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0;
        A[278] = 0.0;
        A[279] = 0.0;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0;
        A[307] = 0.0;
        A[308] = 0.0;
        A[309] = 0.0;
        A[310] = 0.0;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.0380952380952381*G1_5;
        A[337] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_1 + 0.457142857142857*G1_5;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.15*G1_0 - 0.0166666666666667*G1_1 + 0.2*G1_5;
        A[373] = 0.0166666666666666*G1_0 + 0.0166666666666667*G1_1 + 0.133333333333333*G1_5;
        A[374] = 0.0;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0166666666666667*G1_0 + 0.0166666666666667*G1_1 + 0.133333333333333*G1_5;
        A[403] = -0.0166666666666667*G1_0 + 0.15*G1_1 + 0.2*G1_5;
        A[404] = 0.0;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0;
        A[433] = 0.0;
        A[434] = 0.0;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_7 + 0.0476190476190476*G0_11;
        A[466] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_7 - 0.019047619047619*G0_11;
        A[467] = 0.0;
        A[468] = 0.0;
        A[469] = 0.0;
        A[470] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.0380952380952381*G0_11;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_7 - 0.019047619047619*G0_11;
        A[496] = -0.00714285714285714*G0_6 + 0.0928571428571428*G0_7 + 0.0476190476190476*G0_11;
        A[497] = 0.0;
        A[498] = 0.0;
        A[499] = 0.0;
        A[500] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = 0.0;
        A[526] = 0.0;
        A[527] = 0.0;
        A[528] = 0.0;
        A[529] = 0.0;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0;
        A[557] = 0.0;
        A[558] = 0.0;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0;
        A[586] = 0.0;
        A[587] = 0.0;
        A[588] = 0.0;
        A[589] = 0.0;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.0380952380952381*G0_11;
        A[616] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_7 + 0.457142857142857*G0_11;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_7 + 0.0476190476190476*G0_11;
        A[652] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_7 - 0.019047619047619*G0_11;
        A[653] = 0.0;
        A[654] = 0.0;
        A[655] = 0.0;
        A[656] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.0380952380952381*G0_11;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_7 - 0.019047619047619*G0_11;
        A[682] = -0.00714285714285714*G0_6 + 0.0928571428571428*G0_7 + 0.0476190476190476*G0_11;
        A[683] = 0.0;
        A[684] = 0.0;
        A[685] = 0.0;
        A[686] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = 0.0;
        A[712] = 0.0;
        A[713] = 0.0;
        A[714] = 0.0;
        A[715] = 0.0;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0;
        A[743] = 0.0;
        A[744] = 0.0;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0;
        A[772] = 0.0;
        A[773] = 0.0;
        A[774] = 0.0;
        A[775] = 0.0;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.0380952380952381*G0_11;
        A[802] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_7 + 0.457142857142857*G0_11;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.15*G0_6 - 0.0166666666666667*G0_7 + 0.2*G0_11;
        A[838] = 0.0166666666666666*G0_6 + 0.0166666666666667*G0_7 + 0.133333333333333*G0_11;
        A[839] = 0.0;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0166666666666667*G0_6 + 0.0166666666666667*G0_7 + 0.133333333333333*G0_11;
        A[868] = -0.0166666666666667*G0_6 + 0.15*G0_7 + 0.2*G0_11;
        A[869] = 0.0;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0;
        A[898] = 0.0;
        A[899] = 0.0;
          break;
        }
      }
      
        break;
      }
    }
    
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_6_otherwise: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_6_otherwise() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_6_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({true, false, true, true, true});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               int cell_orientation) const
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius of triangle in 2D
    
    
    // Array of quadrature weights.
    static const double W16[16] = {0.0235683681933823, 0.0353880678980859, 0.0225840492823699, 0.00542322591052525, 0.0441850885223617, 0.0663442161070497, 0.0423397245217463, 0.0101672595644788, 0.0441850885223617, 0.0663442161070497, 0.0423397245217463, 0.0101672595644788, 0.0235683681933823, 0.0353880678980859, 0.0225840492823699, 0.00542322591052525};
    // Quadrature points on the UFC reference element: (0.0654669945550145, 0.0571041961145177), (0.0502101232113698, 0.276843013638124), (0.028912084224389, 0.583590432368917), (0.00970378512694614, 0.860240135656219), (0.311164552244357, 0.0571041961145177), (0.238648659731443, 0.276843013638124), (0.137419104134574, 0.583590432368917), (0.0461220799064521, 0.860240135656219), (0.631731251641125, 0.0571041961145177), (0.484508326630433, 0.276843013638124), (0.278990463496509, 0.583590432368917), (0.0936377844373285, 0.860240135656219), (0.877428809330468, 0.0571041961145177), (0.672946863150506, 0.276843013638124), (0.387497483406694, 0.583590432368917), (0.130056079216834, 0.860240135656219)
    
    // Values of basis functions at quadrature points.
    static const double FE0[16][6] = \
    {{0.662333821555697, -0.0568951398028818, -0.0505824176867471, 0.0149537603843903, 0.200419467218139, 0.229770508331402},
    {0.232768098097707, -0.0451680102655678, -0.123558905237647, 0.0556012872999084, 0.745202550451633, 0.135154979653967},
    {-0.0871888841136516, -0.0272402669959926, 0.0975651531361618, 0.0674912629327908, 0.904559295532719, 0.0448134395079725},
    {-0.0962269117343233, -0.0095154582353662, 0.619786046331442, 0.0333903417359317, 0.447517836913622, 0.00504814498869295},
    {0.166437496959, -0.117517795097495, -0.0505824176867471, 0.0710752064609913, 0.144298021141538, 0.786289488222712},
    {-0.0150116894819879, -0.124742294148215, -0.123558905237647, 0.264272856643007, 0.536530981108534, 0.462509051116308},
    {-0.123319106052515, -0.0996510837722764, 0.0975651531361618, 0.320785897590582, 0.651264660874928, 0.15335447822312},
    {-0.0761017150886652, -0.0418675873966577, 0.619786046331442, 0.158704257101893, 0.322203921547661, 0.0172750775043263},
    {-0.117517795097495, 0.166437496959, -0.0505824176867471, 0.144298021141538, 0.0710752064609913, 0.786289488222712},
    {-0.124742294148215, -0.0150116894819881, -0.123558905237647, 0.536530981108534, 0.264272856643007, 0.462509051116308},
    {-0.0996510837722763, -0.123319106052515, 0.0975651531361618, 0.651264660874928, 0.320785897590582, 0.15335447822312},
    {-0.0418675873966577, -0.0761017150886653, 0.619786046331442, 0.322203921547661, 0.158704257101893, 0.0172750775043263},
    {-0.0568951398028819, 0.662333821555697, -0.0505824176867471, 0.200419467218139, 0.0149537603843903, 0.229770508331402},
    {-0.0451680102655678, 0.232768098097706, -0.123558905237647, 0.745202550451633, 0.0556012872999085, 0.135154979653967},
    {-0.0272402669959926, -0.0871888841136518, 0.0975651531361618, 0.904559295532719, 0.0674912629327909, 0.0448134395079725},
    {-0.00951545823536613, -0.0962269117343234, 0.619786046331442, 0.447517836913623, 0.0333903417359314, 0.0050481449886929}};
    
    // Array of non-zero columns
    static const unsigned int nzc11[6] = {6, 7, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc8[6] = {0, 1, 2, 3, 4, 5};
    
    static const double FE0_D01[16][5] = \
    {{-2.50971523732187, -0.771583215541929, 0.261867978220058, 3.2812984528638, -0.261867978220057},
    {-1.69178745260203, 0.107372054552495, 0.200840492845478, 1.58441539804953, -0.200840492845478},
    {-0.549989933626777, 1.33436172947567, 0.115648336897555, -0.78437179584889, -0.115648336897555},
    {0.479775683132663, 2.44096054262488, 0.0388151405077832, -2.92073622575754, -0.038815140507784},
    {-1.5269250065645, -0.771583215541929, 1.24465820897743, 2.29850822210643, -1.24465820897743},
    {-0.938033306521733, 0.107372054552495, 0.954594638925771, 0.830661251969238, -0.954594638925771},
    {-0.115961853986035, 1.33436172947567, 0.549676416538296, -1.21839987548963, -0.549676416538296},
    {0.625448862250686, 2.44096054262488, 0.184488319625807, -3.06640940487556, -0.184488319625808},
    {-0.244658208977428, -0.771583215541929, 2.5269250065645, 1.01624142451936, -2.5269250065645},
    {0.0454053610742289, 0.107372054552495, 1.93803330652173, -0.152777415626724, -1.93803330652173},
    {0.450323583461703, 1.33436172947567, 1.11596185398603, -1.78468531293737, -1.11596185398603},
    {0.815511680374192, 2.44096054262488, 0.374551137749312, -3.25647222299907, -0.374551137749314},
    {0.738132021779943, -0.771583215541929, 3.50971523732187, 0.0334511937619875, -3.50971523732187},
    {0.799159507154522, 0.107372054552495, 2.69178745260202, -0.906531561707016, -2.69178745260202},
    {0.884351663102444, 1.33436172947567, 1.54998993362678, -2.21871339257811, -1.54998993362678},
    {0.961184859492216, 2.44096054262488, 0.520224316867337, -3.40214540211709, -0.520224316867338}};
    
    // Array of non-zero columns
    static const unsigned int nzc12[5] = {6, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc0[5] = {0, 2, 3, 4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc9[5] = {0, 2, 3, 4, 5};
    
    static const double FE0_D10[16][5] = \
    {{-2.50971523732187, -0.738132021779943, 0.228416784458069, -0.228416784458069, 3.24784725910181},
    {-1.69178745260203, -0.799159507154522, 1.10737205455249, -1.10737205455249, 2.49094695975655},
    {-0.549989933626777, -0.884351663102445, 2.33436172947567, -2.33436172947567, 1.43434159672922},
    {0.479775683132663, -0.961184859492216, 3.44096054262487, -3.44096054262487, 0.481409176359552},
    {-1.5269250065645, 0.244658208977429, 0.228416784458069, -0.228416784458069, 1.28226679758707},
    {-0.938033306521733, -0.0454053610742286, 1.10737205455249, -1.10737205455249, 0.983438667595961},
    {-0.115961853986035, -0.450323583461703, 2.33436172947567, -2.33436172947567, 0.566285437447738},
    {0.625448862250687, -0.815511680374192, 3.44096054262487, -3.44096054262487, 0.190062818123505},
    {-0.244658208977428, 1.5269250065645, 0.228416784458069, -0.228416784458069, -1.28226679758707},
    {0.0454053610742286, 0.938033306521733, 1.10737205455249, -1.10737205455249, -0.983438667595962},
    {0.450323583461703, 0.115961853986035, 2.33436172947567, -2.33436172947567, -0.566285437447738},
    {0.815511680374193, -0.625448862250686, 3.44096054262487, -3.44096054262487, -0.190062818123507},
    {0.738132021779942, 2.50971523732187, 0.228416784458069, -0.228416784458069, -3.24784725910181},
    {0.799159507154521, 1.69178745260203, 1.10737205455249, -1.10737205455249, -2.49094695975655},
    {0.884351663102445, 0.549989933626777, 2.33436172947567, -2.33436172947567, -1.43434159672922},
    {0.961184859492217, -0.479775683132662, 3.44096054262487, -3.44096054262487, -0.481409176359555}};
    
    // Array of non-zero columns
    static const unsigned int nzc1[5] = {0, 1, 3, 4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc13[5] = {6, 7, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc10[5] = {0, 1, 3, 4, 5};
    
    static const double FE1_C0[16][3] = \
    {{0.877428809330468, 0.0654669945550145, 0.0571041961145176},
    {0.672946863150506, 0.0502101232113698, 0.276843013638124},
    {0.387497483406694, 0.028912084224389, 0.583590432368917},
    {0.130056079216834, 0.0097037851269462, 0.860240135656219},
    {0.631731251641125, 0.311164552244357, 0.0571041961145176},
    {0.484508326630433, 0.238648659731443, 0.276843013638124},
    {0.278990463496509, 0.137419104134574, 0.583590432368917},
    {0.0936377844373285, 0.0461220799064521, 0.860240135656219},
    {0.311164552244357, 0.631731251641125, 0.0571041961145176},
    {0.238648659731443, 0.484508326630433, 0.276843013638124},
    {0.137419104134574, 0.278990463496509, 0.583590432368917},
    {0.0461220799064521, 0.0936377844373286, 0.860240135656219},
    {0.0654669945550145, 0.877428809330468, 0.0571041961145176},
    {0.0502101232113698, 0.672946863150506, 0.276843013638124},
    {0.028912084224389, 0.387497483406694, 0.583590432368917},
    {0.00970378512694609, 0.130056079216835, 0.860240135656219}};
    
    // Array of non-zero columns
    static const unsigned int nzc14[3] = {12, 13, 14};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 23.
    double G[11];
    G[0] =  - K[0]*det;
    G[1] =  - K[2]*det;
    G[2] =  - K[1]*det;
    G[3] =  - K[3]*det;
    G[4] = K[0]*det;
    G[5] =  - det*w[2][0]*(K[0]*K[0] + K[1]*K[1]);
    G[6] =  - det*w[2][0]*(K[0]*K[2] + K[1]*K[3]);
    G[7] = K[3]*det;
    G[8] =  - det*w[2][0]*(K[2]*K[2] + K[3]*K[3]);
    G[9] = K[1]*det;
    G[10] = K[2]*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 4720
    for (unsigned int ip = 0; ip < 16; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      double F10 = 0.0;
      double F11 = 0.0;
      double F12 = 0.0;
      
      // Total number of operations to compute function values = 12
      for (unsigned int r = 0; r < 3; r++)
      {
        F3 += FE1_C0[ip][r]*w[3][nzc14[r]];
        F12 += FE1_C0[ip][r]*w[0][nzc14[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 60
      for (unsigned int r = 0; r < 5; r++)
      {
        F4 += FE0_D10[ip][r]*w[0][nzc10[r]];
        F5 += FE0_D01[ip][r]*w[0][nzc9[r]];
        F8 += FE0_D10[ip][r]*w[0][nzc13[r]];
        F9 += FE0_D01[ip][r]*w[0][nzc12[r]];
        F10 += FE0_D10[ip][r]*w[4][nzc1[r]];
        F11 += FE0_D01[ip][r]*w[4][nzc0[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 60
      for (unsigned int r = 0; r < 6; r++)
      {
        F0 += FE0[ip][r]*w[3][nzc8[r]];
        F1 += FE0[ip][r]*w[4][r];
        F2 += FE0[ip][r]*w[3][nzc11[r]];
        F6 += FE0[ip][r]*w[0][nzc8[r]];
        F7 += FE0[ip][r]*w[0][nzc11[r]];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 93
      double I[7];
      // Number of operations: 11
      I[0] = F1*W16[ip]*(F4*G[0] + F5*G[1] + F8*G[2] + F9*G[3] - F3*det);
      
      // Number of operations: 7
      I[1] = F1*W16[ip]*(F12*G[4] + F4*G[5] + F5*G[6]);
      
      // Number of operations: 7
      I[2] = F1*W16[ip]*(F12*G[7] + F8*G[6] + F9*G[8]);
      
      // Number of operations: 7
      I[3] = F1*W16[ip]*(F12*G[9] + F8*G[5] + F9*G[6]);
      
      // Number of operations: 7
      I[4] = F1*W16[ip]*(F12*G[10] + F4*G[6] + F5*G[8]);
      
      // Number of operations: 27
      I[5] = W16[ip]*(F1*(F8*(F6*G[0] + F7*G[2]) + F9*(F6*G[1] + F7*G[3]) - F2*det) + F10*(F12*G[9] + F8*G[5] + F9*G[6]) + F11*(F12*G[7] + F8*G[6] + F9*G[8]));
      
      // Number of operations: 27
      I[6] = W16[ip]*(F1*(F6*(F4*G[0] + F5*G[1]) + F7*(F4*G[2] + F5*G[3]) - F0*det) + F10*(F12*G[4] + F4*G[5] + F5*G[6]) + F11*(F12*G[10] + F4*G[6] + F5*G[8]));
      
      
      // Number of operations for primary indices: 6
      for (unsigned int j = 0; j < 3; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc14[j]] += FE1_C0[ip][j]*I[0];
      } // end loop over 'j'
      
      // Number of operations for primary indices: 40
      for (unsigned int j = 0; j < 5; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc10[j]] += FE0_D10[ip][j]*I[1];
        // Number of operations to compute entry: 2
        A[nzc12[j]] += FE0_D01[ip][j]*I[2];
        // Number of operations to compute entry: 2
        A[nzc13[j]] += FE0_D10[ip][j]*I[3];
        // Number of operations to compute entry: 2
        A[nzc9[j]] += FE0_D01[ip][j]*I[4];
      } // end loop over 'j'
      
      // Number of operations for primary indices: 24
      for (unsigned int j = 0; j < 6; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc11[j]] += FE0[ip][j]*I[5];
        // Number of operations to compute entry: 2
        A[nzc8[j]] += FE0[ip][j]*I[6];
      } // end loop over 'j'
    } // end loop over 'ip'
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_6_otherwise: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_6_otherwise() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_6_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({false, true, false, false, true});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               std::size_t facet,
                               int cell_orientation) const
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = vertex_coordinates[2*v1 + 0] - vertex_coordinates[2*v0 + 0];
    const double dx1 = vertex_coordinates[2*v1 + 1] - vertex_coordinates[2*v0 + 1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    
    const bool direction = dx1*(vertex_coordinates[2*facet] - vertex_coordinates[2*v0]) - dx0*(vertex_coordinates[2*facet + 1] - vertex_coordinates[2*v0 + 1]) < 0;
    // Compute facet normals from the facet scale factor constants
    const double n0 = direction ? dx1 / det : -dx1 / det;
    const double n1 = direction ? -dx0 / det : dx0 / det;
    
    // Facet area
    
    // Compute cell volume
    
    
    // Compute circumradius of triangle in 2D
    
    
    // Array of quadrature weights.
    static const double W3[3] = {0.277777777777778, 0.444444444444444, 0.277777777777778};
    // Quadrature points on the UFC reference element: (0.112701665379258), (0.5), (0.887298334620742)
    
    // Values of basis functions at quadrature points.
    static const double FE0_f0[3][2] = \
    {{0.887298334620742, 0.112701665379258},
    {0.5, 0.5},
    {0.112701665379258, 0.887298334620742}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[2] = {1, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 1};
    
    static const double FE1_f0[3][3] = \
    {{0.687298334620742, -0.0872983346207417, 0.4},
    {0.0, 0.0, 1.0},
    {-0.0872983346207416, 0.687298334620742, 0.4}};
    
    // Array of non-zero columns
    static const unsigned int nzc20[3] = {6, 8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc19[3] = {0, 2, 4};
    
    // Array of non-zero columns
    static const unsigned int nzc5[3] = {0, 1, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc4[3] = {0, 2, 4};
    
    // Array of non-zero columns
    static const unsigned int nzc3[3] = {1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc22[3] = {0, 1, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc23[3] = {6, 7, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc16[3] = {1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc17[3] = {7, 8, 9};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 2.
    double G[2];
    G[0] =  - det*n0;
    G[1] =  - det*n1;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    switch (facet)
    {
    case 0:
      {
        // Total number of operations to compute element tensor (from this point): 84
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 84
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        double F1 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc0[r]];
        } // end loop over 'r'
        
        // Total number of operations to compute function values = 6
        for (unsigned int r = 0; r < 3; r++)
        {
          F1 += FE1_f0[ip][r]*w[4][nzc3[r]];
        } // end loop over 'r'
        
        // Number of operations to compute ip constants: 6
        double I[2];
        // Number of operations: 3
        I[0] = F0*F1*G[0]*W3[ip];
        
        // Number of operations: 3
        I[1] = F0*F1*G[1]*W3[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc16[j]] += FE1_f0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc17[j]] += FE1_f0[ip][j]*I[1];
        } // end loop over 'j'
      } // end loop over 'ip'
        break;
      }
    case 1:
      {
        // Total number of operations to compute element tensor (from this point): 84
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 84
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        double F1 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc1[r]];
        } // end loop over 'r'
        
        // Total number of operations to compute function values = 6
        for (unsigned int r = 0; r < 3; r++)
        {
          F1 += FE1_f0[ip][r]*w[4][nzc4[r]];
        } // end loop over 'r'
        
        // Number of operations to compute ip constants: 6
        double I[2];
        // Number of operations: 3
        I[0] = F0*F1*G[0]*W3[ip];
        
        // Number of operations: 3
        I[1] = F0*F1*G[1]*W3[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc19[j]] += FE1_f0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc20[j]] += FE1_f0[ip][j]*I[1];
        } // end loop over 'j'
      } // end loop over 'ip'
        break;
      }
    case 2:
      {
        // Total number of operations to compute element tensor (from this point): 84
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 84
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        double F1 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc2[r]];
        } // end loop over 'r'
        
        // Total number of operations to compute function values = 6
        for (unsigned int r = 0; r < 3; r++)
        {
          F1 += FE1_f0[ip][r]*w[4][nzc5[r]];
        } // end loop over 'r'
        
        // Number of operations to compute ip constants: 6
        double I[2];
        // Number of operations: 3
        I[0] = F0*F1*G[0]*W3[ip];
        
        // Number of operations: 3
        I[1] = F0*F1*G[1]*W3[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc22[j]] += FE1_f0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc23[j]] += FE1_f0[ip][j]*I[1];
        } // end loop over 'j'
      } // end loop over 'ip'
        break;
      }
    }
    
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_7_otherwise: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_7_otherwise() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_7_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({true, true, false, true});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               int cell_orientation) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      3
    // Number of operations (multiply-add pairs) for geometry tensor:    292
    // Number of operations (multiply-add pairs) for tensor contraction: 194
    // Total number of operations (multiply-add pairs):                  489
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0_0 = det*w[1][0]*w[0][0]*(1.0);
    const double G0_0_1 = det*w[1][0]*w[0][1]*(1.0);
    const double G0_0_2 = det*w[1][0]*w[0][2]*(1.0);
    const double G0_0_3 = det*w[1][0]*w[0][3]*(1.0);
    const double G0_0_4 = det*w[1][0]*w[0][4]*(1.0);
    const double G0_0_5 = det*w[1][0]*w[0][5]*(1.0);
    const double G0_0_6 = det*w[1][0]*w[0][6]*(1.0);
    const double G0_0_7 = det*w[1][0]*w[0][7]*(1.0);
    const double G0_0_8 = det*w[1][0]*w[0][8]*(1.0);
    const double G0_0_9 = det*w[1][0]*w[0][9]*(1.0);
    const double G0_1_0 = det*w[1][1]*w[0][0]*(1.0);
    const double G0_1_1 = det*w[1][1]*w[0][1]*(1.0);
    const double G0_1_2 = det*w[1][1]*w[0][2]*(1.0);
    const double G0_1_3 = det*w[1][1]*w[0][3]*(1.0);
    const double G0_1_4 = det*w[1][1]*w[0][4]*(1.0);
    const double G0_1_5 = det*w[1][1]*w[0][5]*(1.0);
    const double G0_1_6 = det*w[1][1]*w[0][6]*(1.0);
    const double G0_1_7 = det*w[1][1]*w[0][7]*(1.0);
    const double G0_1_8 = det*w[1][1]*w[0][8]*(1.0);
    const double G0_1_9 = det*w[1][1]*w[0][9]*(1.0);
    const double G0_2_0 = det*w[1][2]*w[0][0]*(1.0);
    const double G0_2_1 = det*w[1][2]*w[0][1]*(1.0);
    const double G0_2_2 = det*w[1][2]*w[0][2]*(1.0);
    const double G0_2_3 = det*w[1][2]*w[0][3]*(1.0);
    const double G0_2_4 = det*w[1][2]*w[0][4]*(1.0);
    const double G0_2_5 = det*w[1][2]*w[0][5]*(1.0);
    const double G0_2_6 = det*w[1][2]*w[0][6]*(1.0);
    const double G0_2_7 = det*w[1][2]*w[0][7]*(1.0);
    const double G0_2_8 = det*w[1][2]*w[0][8]*(1.0);
    const double G0_2_9 = det*w[1][2]*w[0][9]*(1.0);
    const double G0_3_0 = det*w[1][3]*w[0][0]*(1.0);
    const double G0_3_1 = det*w[1][3]*w[0][1]*(1.0);
    const double G0_3_2 = det*w[1][3]*w[0][2]*(1.0);
    const double G0_3_3 = det*w[1][3]*w[0][3]*(1.0);
    const double G0_3_4 = det*w[1][3]*w[0][4]*(1.0);
    const double G0_3_5 = det*w[1][3]*w[0][5]*(1.0);
    const double G0_3_6 = det*w[1][3]*w[0][6]*(1.0);
    const double G0_3_7 = det*w[1][3]*w[0][7]*(1.0);
    const double G0_3_8 = det*w[1][3]*w[0][8]*(1.0);
    const double G0_3_9 = det*w[1][3]*w[0][9]*(1.0);
    const double G0_4_0 = det*w[1][4]*w[0][0]*(1.0);
    const double G0_4_1 = det*w[1][4]*w[0][1]*(1.0);
    const double G0_4_2 = det*w[1][4]*w[0][2]*(1.0);
    const double G0_4_3 = det*w[1][4]*w[0][3]*(1.0);
    const double G0_4_4 = det*w[1][4]*w[0][4]*(1.0);
    const double G0_4_5 = det*w[1][4]*w[0][5]*(1.0);
    const double G0_4_6 = det*w[1][4]*w[0][6]*(1.0);
    const double G0_4_7 = det*w[1][4]*w[0][7]*(1.0);
    const double G0_4_8 = det*w[1][4]*w[0][8]*(1.0);
    const double G0_4_9 = det*w[1][4]*w[0][9]*(1.0);
    const double G0_5_0 = det*w[1][5]*w[0][0]*(1.0);
    const double G0_5_1 = det*w[1][5]*w[0][1]*(1.0);
    const double G0_5_2 = det*w[1][5]*w[0][2]*(1.0);
    const double G0_5_3 = det*w[1][5]*w[0][3]*(1.0);
    const double G0_5_4 = det*w[1][5]*w[0][4]*(1.0);
    const double G0_5_5 = det*w[1][5]*w[0][5]*(1.0);
    const double G0_5_6 = det*w[1][5]*w[0][6]*(1.0);
    const double G0_5_7 = det*w[1][5]*w[0][7]*(1.0);
    const double G0_5_8 = det*w[1][5]*w[0][8]*(1.0);
    const double G0_5_9 = det*w[1][5]*w[0][9]*(1.0);
    const double G0_6_10 = det*w[1][6]*w[0][10]*(1.0);
    const double G0_6_11 = det*w[1][6]*w[0][11]*(1.0);
    const double G0_6_12 = det*w[1][6]*w[0][12]*(1.0);
    const double G0_6_13 = det*w[1][6]*w[0][13]*(1.0);
    const double G0_6_14 = det*w[1][6]*w[0][14]*(1.0);
    const double G0_6_15 = det*w[1][6]*w[0][15]*(1.0);
    const double G0_6_16 = det*w[1][6]*w[0][16]*(1.0);
    const double G0_6_17 = det*w[1][6]*w[0][17]*(1.0);
    const double G0_6_18 = det*w[1][6]*w[0][18]*(1.0);
    const double G0_6_19 = det*w[1][6]*w[0][19]*(1.0);
    const double G0_7_10 = det*w[1][7]*w[0][10]*(1.0);
    const double G0_7_11 = det*w[1][7]*w[0][11]*(1.0);
    const double G0_7_12 = det*w[1][7]*w[0][12]*(1.0);
    const double G0_7_13 = det*w[1][7]*w[0][13]*(1.0);
    const double G0_7_14 = det*w[1][7]*w[0][14]*(1.0);
    const double G0_7_15 = det*w[1][7]*w[0][15]*(1.0);
    const double G0_7_16 = det*w[1][7]*w[0][16]*(1.0);
    const double G0_7_17 = det*w[1][7]*w[0][17]*(1.0);
    const double G0_7_18 = det*w[1][7]*w[0][18]*(1.0);
    const double G0_7_19 = det*w[1][7]*w[0][19]*(1.0);
    const double G0_8_10 = det*w[1][8]*w[0][10]*(1.0);
    const double G0_8_11 = det*w[1][8]*w[0][11]*(1.0);
    const double G0_8_12 = det*w[1][8]*w[0][12]*(1.0);
    const double G0_8_13 = det*w[1][8]*w[0][13]*(1.0);
    const double G0_8_14 = det*w[1][8]*w[0][14]*(1.0);
    const double G0_8_15 = det*w[1][8]*w[0][15]*(1.0);
    const double G0_8_16 = det*w[1][8]*w[0][16]*(1.0);
    const double G0_8_17 = det*w[1][8]*w[0][17]*(1.0);
    const double G0_8_18 = det*w[1][8]*w[0][18]*(1.0);
    const double G0_8_19 = det*w[1][8]*w[0][19]*(1.0);
    const double G0_9_10 = det*w[1][9]*w[0][10]*(1.0);
    const double G0_9_11 = det*w[1][9]*w[0][11]*(1.0);
    const double G0_9_12 = det*w[1][9]*w[0][12]*(1.0);
    const double G0_9_13 = det*w[1][9]*w[0][13]*(1.0);
    const double G0_9_14 = det*w[1][9]*w[0][14]*(1.0);
    const double G0_9_15 = det*w[1][9]*w[0][15]*(1.0);
    const double G0_9_16 = det*w[1][9]*w[0][16]*(1.0);
    const double G0_9_17 = det*w[1][9]*w[0][17]*(1.0);
    const double G0_9_18 = det*w[1][9]*w[0][18]*(1.0);
    const double G0_9_19 = det*w[1][9]*w[0][19]*(1.0);
    const double G0_10_10 = det*w[1][10]*w[0][10]*(1.0);
    const double G0_10_11 = det*w[1][10]*w[0][11]*(1.0);
    const double G0_10_12 = det*w[1][10]*w[0][12]*(1.0);
    const double G0_10_13 = det*w[1][10]*w[0][13]*(1.0);
    const double G0_10_14 = det*w[1][10]*w[0][14]*(1.0);
    const double G0_10_15 = det*w[1][10]*w[0][15]*(1.0);
    const double G0_10_16 = det*w[1][10]*w[0][16]*(1.0);
    const double G0_10_17 = det*w[1][10]*w[0][17]*(1.0);
    const double G0_10_18 = det*w[1][10]*w[0][18]*(1.0);
    const double G0_10_19 = det*w[1][10]*w[0][19]*(1.0);
    const double G0_11_10 = det*w[1][11]*w[0][10]*(1.0);
    const double G0_11_11 = det*w[1][11]*w[0][11]*(1.0);
    const double G0_11_12 = det*w[1][11]*w[0][12]*(1.0);
    const double G0_11_13 = det*w[1][11]*w[0][13]*(1.0);
    const double G0_11_14 = det*w[1][11]*w[0][14]*(1.0);
    const double G0_11_15 = det*w[1][11]*w[0][15]*(1.0);
    const double G0_11_16 = det*w[1][11]*w[0][16]*(1.0);
    const double G0_11_17 = det*w[1][11]*w[0][17]*(1.0);
    const double G0_11_18 = det*w[1][11]*w[0][18]*(1.0);
    const double G0_11_19 = det*w[1][11]*w[0][19]*(1.0);
    const double G0_12_20 = det*w[1][12]*w[0][20]*(1.0);
    const double G0_12_21 = det*w[1][12]*w[0][21]*(1.0);
    const double G0_12_22 = det*w[1][12]*w[0][22]*(1.0);
    const double G0_12_23 = det*w[1][12]*w[0][23]*(1.0);
    const double G0_12_24 = det*w[1][12]*w[0][24]*(1.0);
    const double G0_12_25 = det*w[1][12]*w[0][25]*(1.0);
    const double G0_13_20 = det*w[1][13]*w[0][20]*(1.0);
    const double G0_13_21 = det*w[1][13]*w[0][21]*(1.0);
    const double G0_13_22 = det*w[1][13]*w[0][22]*(1.0);
    const double G0_13_23 = det*w[1][13]*w[0][23]*(1.0);
    const double G0_13_24 = det*w[1][13]*w[0][24]*(1.0);
    const double G0_13_25 = det*w[1][13]*w[0][25]*(1.0);
    const double G0_14_20 = det*w[1][14]*w[0][20]*(1.0);
    const double G0_14_21 = det*w[1][14]*w[0][21]*(1.0);
    const double G0_14_22 = det*w[1][14]*w[0][22]*(1.0);
    const double G0_14_23 = det*w[1][14]*w[0][23]*(1.0);
    const double G0_14_24 = det*w[1][14]*w[0][24]*(1.0);
    const double G0_14_25 = det*w[1][14]*w[0][25]*(1.0);
    const double G1_0_0 = det*w[1][0]*w[3][0]*(1.0);
    const double G1_0_1 = det*w[1][0]*w[3][1]*(1.0);
    const double G1_0_2 = det*w[1][0]*w[3][2]*(1.0);
    const double G1_0_3 = det*w[1][0]*w[3][3]*(1.0);
    const double G1_1_0 = det*w[1][1]*w[3][0]*(1.0);
    const double G1_1_1 = det*w[1][1]*w[3][1]*(1.0);
    const double G1_1_2 = det*w[1][1]*w[3][2]*(1.0);
    const double G1_1_4 = det*w[1][1]*w[3][4]*(1.0);
    const double G1_2_0 = det*w[1][2]*w[3][0]*(1.0);
    const double G1_2_1 = det*w[1][2]*w[3][1]*(1.0);
    const double G1_2_2 = det*w[1][2]*w[3][2]*(1.0);
    const double G1_2_5 = det*w[1][2]*w[3][5]*(1.0);
    const double G1_3_0 = det*w[1][3]*w[3][0]*(1.0);
    const double G1_3_3 = det*w[1][3]*w[3][3]*(1.0);
    const double G1_3_4 = det*w[1][3]*w[3][4]*(1.0);
    const double G1_3_5 = det*w[1][3]*w[3][5]*(1.0);
    const double G1_4_1 = det*w[1][4]*w[3][1]*(1.0);
    const double G1_4_3 = det*w[1][4]*w[3][3]*(1.0);
    const double G1_4_4 = det*w[1][4]*w[3][4]*(1.0);
    const double G1_4_5 = det*w[1][4]*w[3][5]*(1.0);
    const double G1_5_2 = det*w[1][5]*w[3][2]*(1.0);
    const double G1_5_3 = det*w[1][5]*w[3][3]*(1.0);
    const double G1_5_4 = det*w[1][5]*w[3][4]*(1.0);
    const double G1_5_5 = det*w[1][5]*w[3][5]*(1.0);
    const double G1_6_6 = det*w[1][6]*w[3][6]*(1.0);
    const double G1_6_7 = det*w[1][6]*w[3][7]*(1.0);
    const double G1_6_8 = det*w[1][6]*w[3][8]*(1.0);
    const double G1_6_9 = det*w[1][6]*w[3][9]*(1.0);
    const double G1_7_6 = det*w[1][7]*w[3][6]*(1.0);
    const double G1_7_7 = det*w[1][7]*w[3][7]*(1.0);
    const double G1_7_8 = det*w[1][7]*w[3][8]*(1.0);
    const double G1_7_10 = det*w[1][7]*w[3][10]*(1.0);
    const double G1_8_6 = det*w[1][8]*w[3][6]*(1.0);
    const double G1_8_7 = det*w[1][8]*w[3][7]*(1.0);
    const double G1_8_8 = det*w[1][8]*w[3][8]*(1.0);
    const double G1_8_11 = det*w[1][8]*w[3][11]*(1.0);
    const double G1_9_6 = det*w[1][9]*w[3][6]*(1.0);
    const double G1_9_9 = det*w[1][9]*w[3][9]*(1.0);
    const double G1_9_10 = det*w[1][9]*w[3][10]*(1.0);
    const double G1_9_11 = det*w[1][9]*w[3][11]*(1.0);
    const double G1_10_7 = det*w[1][10]*w[3][7]*(1.0);
    const double G1_10_9 = det*w[1][10]*w[3][9]*(1.0);
    const double G1_10_10 = det*w[1][10]*w[3][10]*(1.0);
    const double G1_10_11 = det*w[1][10]*w[3][11]*(1.0);
    const double G1_11_8 = det*w[1][11]*w[3][8]*(1.0);
    const double G1_11_9 = det*w[1][11]*w[3][9]*(1.0);
    const double G1_11_10 = det*w[1][11]*w[3][10]*(1.0);
    const double G1_11_11 = det*w[1][11]*w[3][11]*(1.0);
    const double G1_12_12 = det*w[1][12]*w[3][12]*(1.0);
    const double G1_12_13 = det*w[1][12]*w[3][13]*(1.0);
    const double G1_12_14 = det*w[1][12]*w[3][14]*(1.0);
    const double G1_13_12 = det*w[1][13]*w[3][12]*(1.0);
    const double G1_13_13 = det*w[1][13]*w[3][13]*(1.0);
    const double G1_13_14 = det*w[1][13]*w[3][14]*(1.0);
    const double G1_14_12 = det*w[1][14]*w[3][12]*(1.0);
    const double G1_14_13 = det*w[1][14]*w[3][13]*(1.0);
    const double G1_14_14 = det*w[1][14]*w[3][14]*(1.0);
    
    // Compute element tensor
    A[0] = 0.00595238095238095*G0_0_0 + 0.000595238095238095*G0_0_1 + 0.000595238095238098*G0_0_2 - 0.00357142857142857*G0_0_3 - 0.00357142857142857*G0_0_4 + 0.0160714285714286*G0_0_5 - 0.0107142857142857*G0_0_6 + 0.0160714285714286*G0_0_7 - 0.0107142857142857*G0_0_8 - 0.0107142857142857*G0_0_9 + 0.000595238095238095*G0_1_0 + 0.00595238095238094*G0_1_1 + 0.000595238095238096*G0_1_2 + 0.0160714285714286*G0_1_3 - 0.0107142857142857*G0_1_4 - 0.00357142857142856*G0_1_5 - 0.00357142857142858*G0_1_6 - 0.0107142857142857*G0_1_7 + 0.0160714285714286*G0_1_8 - 0.0107142857142857*G0_1_9 + 0.000595238095238098*G0_2_0 + 0.000595238095238097*G0_2_1 + 0.00595238095238094*G0_2_2 - 0.0107142857142857*G0_2_3 + 0.0160714285714286*G0_2_4 - 0.0107142857142857*G0_2_5 + 0.0160714285714286*G0_2_6 - 0.00357142857142857*G0_2_7 - 0.00357142857142857*G0_2_8 - 0.0107142857142857*G0_2_9 + 0.00476190476190475*G0_3_0 + 0.00238095238095238*G0_3_1 + 0.00238095238095237*G0_3_2 + 0.0285714285714286*G0_3_3 + 0.0285714285714285*G0_3_4 - 0.00714285714285712*G0_3_5 + 0.0142857142857143*G0_3_6 - 0.00714285714285714*G0_3_7 + 0.0142857142857143*G0_3_8 + 0.0857142857142857*G0_3_9 + 0.00238095238095237*G0_4_0 + 0.00476190476190477*G0_4_1 + 0.00238095238095237*G0_4_2 - 0.00714285714285712*G0_4_3 + 0.0142857142857143*G0_4_4 + 0.0285714285714286*G0_4_5 + 0.0285714285714286*G0_4_6 + 0.0142857142857143*G0_4_7 - 0.00714285714285712*G0_4_8 + 0.0857142857142857*G0_4_9 + 0.00238095238095237*G0_5_0 + 0.00238095238095238*G0_5_1 + 0.00476190476190475*G0_5_2 + 0.0142857142857143*G0_5_3 - 0.00714285714285714*G0_5_4 + 0.0142857142857143*G0_5_5 - 0.00714285714285714*G0_5_6 + 0.0285714285714286*G0_5_7 + 0.0285714285714286*G0_5_8 + 0.0857142857142857*G0_5_9 + 0.00595238095238095*G0_6_10 + 0.000595238095238095*G0_6_11 + 0.000595238095238098*G0_6_12 - 0.00357142857142857*G0_6_13 - 0.00357142857142857*G0_6_14 + 0.0160714285714286*G0_6_15 - 0.0107142857142857*G0_6_16 + 0.0160714285714286*G0_6_17 - 0.0107142857142857*G0_6_18 - 0.0107142857142857*G0_6_19 + 0.000595238095238095*G0_7_10 + 0.00595238095238094*G0_7_11 + 0.000595238095238096*G0_7_12 + 0.0160714285714286*G0_7_13 - 0.0107142857142857*G0_7_14 - 0.00357142857142856*G0_7_15 - 0.00357142857142858*G0_7_16 - 0.0107142857142857*G0_7_17 + 0.0160714285714286*G0_7_18 - 0.0107142857142857*G0_7_19 + 0.000595238095238098*G0_8_10 + 0.000595238095238097*G0_8_11 + 0.00595238095238094*G0_8_12 - 0.0107142857142857*G0_8_13 + 0.0160714285714286*G0_8_14 - 0.0107142857142857*G0_8_15 + 0.0160714285714286*G0_8_16 - 0.00357142857142857*G0_8_17 - 0.00357142857142857*G0_8_18 - 0.0107142857142857*G0_8_19 + 0.00476190476190475*G0_9_10 + 0.00238095238095238*G0_9_11 + 0.00238095238095237*G0_9_12 + 0.0285714285714286*G0_9_13 + 0.0285714285714285*G0_9_14 - 0.00714285714285712*G0_9_15 + 0.0142857142857143*G0_9_16 - 0.00714285714285714*G0_9_17 + 0.0142857142857143*G0_9_18 + 0.0857142857142857*G0_9_19 + 0.00238095238095237*G0_10_10 + 0.00476190476190477*G0_10_11 + 0.00238095238095237*G0_10_12 - 0.00714285714285712*G0_10_13 + 0.0142857142857143*G0_10_14 + 0.0285714285714286*G0_10_15 + 0.0285714285714286*G0_10_16 + 0.0142857142857143*G0_10_17 - 0.00714285714285712*G0_10_18 + 0.0857142857142857*G0_10_19 + 0.00238095238095237*G0_11_10 + 0.00238095238095238*G0_11_11 + 0.00476190476190475*G0_11_12 + 0.0142857142857143*G0_11_13 - 0.00714285714285714*G0_11_14 + 0.0142857142857143*G0_11_15 - 0.00714285714285714*G0_11_16 + 0.0285714285714286*G0_11_17 + 0.0285714285714286*G0_11_18 + 0.0857142857142857*G0_11_19 + 0.0166666666666667*G0_12_20 - 0.00833333333333333*G0_12_21 - 0.00833333333333332*G0_12_22 + 0.0333333333333333*G0_12_23 + 0.0666666666666667*G0_12_24 + 0.0666666666666667*G0_12_25 - 0.00833333333333333*G0_13_20 + 0.0166666666666666*G0_13_21 - 0.00833333333333333*G0_13_22 + 0.0666666666666666*G0_13_23 + 0.0333333333333333*G0_13_24 + 0.0666666666666667*G0_13_25 - 0.00833333333333332*G0_14_20 - 0.00833333333333333*G0_14_21 + 0.0166666666666667*G0_14_22 + 0.0666666666666666*G0_14_23 + 0.0666666666666667*G0_14_24 + 0.0333333333333333*G0_14_25 - 0.0166666666666667*G1_0_0 + 0.00277777777777778*G1_0_1 + 0.00277777777777778*G1_0_2 + 0.0111111111111111*G1_0_3 + 0.00277777777777778*G1_1_0 - 0.0166666666666666*G1_1_1 + 0.00277777777777777*G1_1_2 + 0.0111111111111111*G1_1_4 + 0.00277777777777778*G1_2_0 + 0.00277777777777778*G1_2_1 - 0.0166666666666666*G1_2_2 + 0.0111111111111111*G1_2_5 + 0.0111111111111111*G1_3_0 - 0.0888888888888888*G1_3_3 - 0.0444444444444444*G1_3_4 - 0.0444444444444444*G1_3_5 + 0.0111111111111111*G1_4_1 - 0.0444444444444444*G1_4_3 - 0.0888888888888889*G1_4_4 - 0.0444444444444444*G1_4_5 + 0.0111111111111111*G1_5_2 - 0.0444444444444444*G1_5_3 - 0.0444444444444444*G1_5_4 - 0.0888888888888889*G1_5_5 - 0.0166666666666667*G1_6_6 + 0.00277777777777778*G1_6_7 + 0.00277777777777778*G1_6_8 + 0.0111111111111111*G1_6_9 + 0.00277777777777778*G1_7_6 - 0.0166666666666666*G1_7_7 + 0.00277777777777777*G1_7_8 + 0.0111111111111111*G1_7_10 + 0.00277777777777778*G1_8_6 + 0.00277777777777778*G1_8_7 - 0.0166666666666666*G1_8_8 + 0.0111111111111111*G1_8_11 + 0.0111111111111111*G1_9_6 - 0.0888888888888888*G1_9_9 - 0.0444444444444444*G1_9_10 - 0.0444444444444444*G1_9_11 + 0.0111111111111111*G1_10_7 - 0.0444444444444444*G1_10_9 - 0.0888888888888889*G1_10_10 - 0.0444444444444444*G1_10_11 + 0.0111111111111111*G1_11_8 - 0.0444444444444444*G1_11_9 - 0.0444444444444444*G1_11_10 - 0.0888888888888889*G1_11_11 - 0.0833333333333334*G1_12_12 - 0.0416666666666667*G1_12_13 - 0.0416666666666667*G1_12_14 - 0.0416666666666667*G1_13_12 - 0.0833333333333333*G1_13_13 - 0.0416666666666667*G1_13_14 - 0.0416666666666667*G1_14_12 - 0.0416666666666667*G1_14_13 - 0.0833333333333333*G1_14_14;
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_7_otherwise: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_7_otherwise() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_7_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({true, false, true, true});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               std::size_t facet,
                               int cell_orientation) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      10
    // Number of operations (multiply-add pairs) for geometry tensor:    180
    // Number of operations (multiply-add pairs) for tensor contraction: 136
    // Total number of operations (multiply-add pairs):                  326
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = vertex_coordinates[2*v1 + 0] - vertex_coordinates[2*v0 + 0];
    const double dx1 = vertex_coordinates[2*v1 + 1] - vertex_coordinates[2*v0 + 1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    
    // Compute geometry tensor
    const double G0_0_0 = det*w[2][0]*w[0][0]*(1.0);
    const double G0_0_5 = det*w[2][0]*w[0][5]*(1.0);
    const double G0_0_6 = det*w[2][0]*w[0][6]*(1.0);
    const double G0_0_7 = det*w[2][0]*w[0][7]*(1.0);
    const double G0_0_8 = det*w[2][0]*w[0][8]*(1.0);
    const double G0_1_1 = det*w[2][1]*w[0][1]*(1.0);
    const double G0_1_3 = det*w[2][1]*w[0][3]*(1.0);
    const double G0_1_4 = det*w[2][1]*w[0][4]*(1.0);
    const double G0_1_7 = det*w[2][1]*w[0][7]*(1.0);
    const double G0_1_8 = det*w[2][1]*w[0][8]*(1.0);
    const double G0_2_2 = det*w[2][2]*w[0][2]*(1.0);
    const double G0_2_3 = det*w[2][2]*w[0][3]*(1.0);
    const double G0_2_4 = det*w[2][2]*w[0][4]*(1.0);
    const double G0_2_5 = det*w[2][2]*w[0][5]*(1.0);
    const double G0_2_6 = det*w[2][2]*w[0][6]*(1.0);
    const double G0_3_1 = det*w[2][3]*w[0][1]*(1.0);
    const double G0_3_2 = det*w[2][3]*w[0][2]*(1.0);
    const double G0_3_3 = det*w[2][3]*w[0][3]*(1.0);
    const double G0_3_4 = det*w[2][3]*w[0][4]*(1.0);
    const double G0_4_0 = det*w[2][4]*w[0][0]*(1.0);
    const double G0_4_2 = det*w[2][4]*w[0][2]*(1.0);
    const double G0_4_5 = det*w[2][4]*w[0][5]*(1.0);
    const double G0_4_6 = det*w[2][4]*w[0][6]*(1.0);
    const double G0_5_0 = det*w[2][5]*w[0][0]*(1.0);
    const double G0_5_1 = det*w[2][5]*w[0][1]*(1.0);
    const double G0_5_7 = det*w[2][5]*w[0][7]*(1.0);
    const double G0_5_8 = det*w[2][5]*w[0][8]*(1.0);
    const double G0_6_10 = det*w[2][6]*w[0][10]*(1.0);
    const double G0_6_15 = det*w[2][6]*w[0][15]*(1.0);
    const double G0_6_16 = det*w[2][6]*w[0][16]*(1.0);
    const double G0_6_17 = det*w[2][6]*w[0][17]*(1.0);
    const double G0_6_18 = det*w[2][6]*w[0][18]*(1.0);
    const double G0_7_11 = det*w[2][7]*w[0][11]*(1.0);
    const double G0_7_13 = det*w[2][7]*w[0][13]*(1.0);
    const double G0_7_14 = det*w[2][7]*w[0][14]*(1.0);
    const double G0_7_17 = det*w[2][7]*w[0][17]*(1.0);
    const double G0_7_18 = det*w[2][7]*w[0][18]*(1.0);
    const double G0_8_12 = det*w[2][8]*w[0][12]*(1.0);
    const double G0_8_13 = det*w[2][8]*w[0][13]*(1.0);
    const double G0_8_14 = det*w[2][8]*w[0][14]*(1.0);
    const double G0_8_15 = det*w[2][8]*w[0][15]*(1.0);
    const double G0_8_16 = det*w[2][8]*w[0][16]*(1.0);
    const double G0_9_11 = det*w[2][9]*w[0][11]*(1.0);
    const double G0_9_12 = det*w[2][9]*w[0][12]*(1.0);
    const double G0_9_13 = det*w[2][9]*w[0][13]*(1.0);
    const double G0_9_14 = det*w[2][9]*w[0][14]*(1.0);
    const double G0_10_10 = det*w[2][10]*w[0][10]*(1.0);
    const double G0_10_12 = det*w[2][10]*w[0][12]*(1.0);
    const double G0_10_15 = det*w[2][10]*w[0][15]*(1.0);
    const double G0_10_16 = det*w[2][10]*w[0][16]*(1.0);
    const double G0_11_10 = det*w[2][11]*w[0][10]*(1.0);
    const double G0_11_11 = det*w[2][11]*w[0][11]*(1.0);
    const double G0_11_17 = det*w[2][11]*w[0][17]*(1.0);
    const double G0_11_18 = det*w[2][11]*w[0][18]*(1.0);
    const double G0_12_20 = det*w[2][12]*w[0][20]*(1.0);
    const double G0_12_24 = det*w[2][12]*w[0][24]*(1.0);
    const double G0_12_25 = det*w[2][12]*w[0][25]*(1.0);
    const double G0_13_21 = det*w[2][13]*w[0][21]*(1.0);
    const double G0_13_23 = det*w[2][13]*w[0][23]*(1.0);
    const double G0_13_25 = det*w[2][13]*w[0][25]*(1.0);
    const double G0_14_22 = det*w[2][14]*w[0][22]*(1.0);
    const double G0_14_23 = det*w[2][14]*w[0][23]*(1.0);
    const double G0_14_24 = det*w[2][14]*w[0][24]*(1.0);
    const double G1_0_0 = det*w[2][0]*w[3][0]*(1.0);
    const double G1_0_1 = det*w[2][0]*w[3][1]*(1.0);
    const double G1_0_2 = det*w[2][0]*w[3][2]*(1.0);
    const double G1_0_4 = det*w[2][0]*w[3][4]*(1.0);
    const double G1_0_5 = det*w[2][0]*w[3][5]*(1.0);
    const double G1_1_0 = det*w[2][1]*w[3][0]*(1.0);
    const double G1_1_1 = det*w[2][1]*w[3][1]*(1.0);
    const double G1_1_2 = det*w[2][1]*w[3][2]*(1.0);
    const double G1_1_3 = det*w[2][1]*w[3][3]*(1.0);
    const double G1_1_5 = det*w[2][1]*w[3][5]*(1.0);
    const double G1_2_0 = det*w[2][2]*w[3][0]*(1.0);
    const double G1_2_1 = det*w[2][2]*w[3][1]*(1.0);
    const double G1_2_2 = det*w[2][2]*w[3][2]*(1.0);
    const double G1_2_3 = det*w[2][2]*w[3][3]*(1.0);
    const double G1_2_4 = det*w[2][2]*w[3][4]*(1.0);
    const double G1_3_1 = det*w[2][3]*w[3][1]*(1.0);
    const double G1_3_2 = det*w[2][3]*w[3][2]*(1.0);
    const double G1_3_3 = det*w[2][3]*w[3][3]*(1.0);
    const double G1_4_0 = det*w[2][4]*w[3][0]*(1.0);
    const double G1_4_2 = det*w[2][4]*w[3][2]*(1.0);
    const double G1_4_4 = det*w[2][4]*w[3][4]*(1.0);
    const double G1_5_0 = det*w[2][5]*w[3][0]*(1.0);
    const double G1_5_1 = det*w[2][5]*w[3][1]*(1.0);
    const double G1_5_5 = det*w[2][5]*w[3][5]*(1.0);
    const double G1_6_6 = det*w[2][6]*w[3][6]*(1.0);
    const double G1_6_7 = det*w[2][6]*w[3][7]*(1.0);
    const double G1_6_8 = det*w[2][6]*w[3][8]*(1.0);
    const double G1_6_10 = det*w[2][6]*w[3][10]*(1.0);
    const double G1_6_11 = det*w[2][6]*w[3][11]*(1.0);
    const double G1_7_6 = det*w[2][7]*w[3][6]*(1.0);
    const double G1_7_7 = det*w[2][7]*w[3][7]*(1.0);
    const double G1_7_8 = det*w[2][7]*w[3][8]*(1.0);
    const double G1_7_9 = det*w[2][7]*w[3][9]*(1.0);
    const double G1_7_11 = det*w[2][7]*w[3][11]*(1.0);
    const double G1_8_6 = det*w[2][8]*w[3][6]*(1.0);
    const double G1_8_7 = det*w[2][8]*w[3][7]*(1.0);
    const double G1_8_8 = det*w[2][8]*w[3][8]*(1.0);
    const double G1_8_9 = det*w[2][8]*w[3][9]*(1.0);
    const double G1_8_10 = det*w[2][8]*w[3][10]*(1.0);
    const double G1_9_7 = det*w[2][9]*w[3][7]*(1.0);
    const double G1_9_8 = det*w[2][9]*w[3][8]*(1.0);
    const double G1_9_9 = det*w[2][9]*w[3][9]*(1.0);
    const double G1_10_6 = det*w[2][10]*w[3][6]*(1.0);
    const double G1_10_8 = det*w[2][10]*w[3][8]*(1.0);
    const double G1_10_10 = det*w[2][10]*w[3][10]*(1.0);
    const double G1_11_6 = det*w[2][11]*w[3][6]*(1.0);
    const double G1_11_7 = det*w[2][11]*w[3][7]*(1.0);
    const double G1_11_11 = det*w[2][11]*w[3][11]*(1.0);
    const double G1_12_12 = det*w[2][12]*w[3][12]*(1.0);
    const double G1_12_13 = det*w[2][12]*w[3][13]*(1.0);
    const double G1_12_14 = det*w[2][12]*w[3][14]*(1.0);
    const double G1_13_12 = det*w[2][13]*w[3][12]*(1.0);
    const double G1_13_13 = det*w[2][13]*w[3][13]*(1.0);
    const double G1_13_14 = det*w[2][13]*w[3][14]*(1.0);
    const double G1_14_12 = det*w[2][14]*w[3][12]*(1.0);
    const double G1_14_13 = det*w[2][14]*w[3][13]*(1.0);
    const double G1_14_14 = det*w[2][14]*w[3][14]*(1.0);
    
    // Compute element tensor
    switch (facet)
    {
    case 0:
      {
        A[0] = 0.0916666666666666*G0_1_1 + 0.15*G0_1_3 - 0.075*G0_1_4 + 0.0916666666666666*G0_2_2 - 0.0749999999999999*G0_2_3 + 0.15*G0_2_4 + 0.0333333333333333*G0_3_1 + 0.0333333333333333*G0_3_2 + 0.3*G0_3_3 + 0.3*G0_3_4 + 0.0916666666666666*G0_7_11 + 0.15*G0_7_13 - 0.075*G0_7_14 + 0.0916666666666666*G0_8_12 - 0.0749999999999999*G0_8_13 + 0.15*G0_8_14 + 0.0333333333333333*G0_9_11 + 0.0333333333333333*G0_9_12 + 0.3*G0_9_13 + 0.3*G0_9_14 + 0.166666666666667*G0_13_21 + 0.333333333333333*G0_13_23 + 0.166666666666667*G0_14_22 + 0.333333333333333*G0_14_23 - 0.133333333333333*G1_1_1 + 0.0333333333333333*G1_1_2 - 0.0666666666666666*G1_1_3 + 0.0333333333333333*G1_2_1 - 0.133333333333333*G1_2_2 - 0.0666666666666666*G1_2_3 - 0.0666666666666666*G1_3_1 - 0.0666666666666666*G1_3_2 - 0.533333333333333*G1_3_3 - 0.133333333333333*G1_7_7 + 0.0333333333333333*G1_7_8 - 0.0666666666666666*G1_7_9 + 0.0333333333333333*G1_8_7 - 0.133333333333333*G1_8_8 - 0.0666666666666666*G1_8_9 - 0.0666666666666666*G1_9_7 - 0.0666666666666666*G1_9_8 - 0.533333333333333*G1_9_9 - 0.333333333333333*G1_13_13 - 0.166666666666667*G1_13_14 - 0.166666666666667*G1_14_13 - 0.333333333333333*G1_14_14;
        break;
      }
    case 1:
      {
        A[0] = 0.0916666666666666*G0_0_0 + 0.15*G0_0_5 - 0.0749999999999999*G0_0_6 + 0.0916666666666666*G0_2_2 - 0.0749999999999999*G0_2_5 + 0.15*G0_2_6 + 0.0333333333333333*G0_4_0 + 0.0333333333333333*G0_4_2 + 0.3*G0_4_5 + 0.3*G0_4_6 + 0.0916666666666666*G0_6_10 + 0.15*G0_6_15 - 0.0749999999999999*G0_6_16 + 0.0916666666666666*G0_8_12 - 0.0749999999999999*G0_8_15 + 0.15*G0_8_16 + 0.0333333333333333*G0_10_10 + 0.0333333333333333*G0_10_12 + 0.3*G0_10_15 + 0.3*G0_10_16 + 0.166666666666667*G0_12_20 + 0.333333333333333*G0_12_24 + 0.166666666666667*G0_14_22 + 0.333333333333333*G0_14_24 - 0.133333333333333*G1_0_0 + 0.0333333333333333*G1_0_2 - 0.0666666666666666*G1_0_4 + 0.0333333333333333*G1_2_0 - 0.133333333333333*G1_2_2 - 0.0666666666666666*G1_2_4 - 0.0666666666666666*G1_4_0 - 0.0666666666666666*G1_4_2 - 0.533333333333333*G1_4_4 - 0.133333333333333*G1_6_6 + 0.0333333333333333*G1_6_8 - 0.0666666666666666*G1_6_10 + 0.0333333333333333*G1_8_6 - 0.133333333333333*G1_8_8 - 0.0666666666666666*G1_8_10 - 0.0666666666666666*G1_10_6 - 0.0666666666666666*G1_10_8 - 0.533333333333333*G1_10_10 - 0.333333333333333*G1_12_12 - 0.166666666666667*G1_12_14 - 0.166666666666667*G1_14_12 - 0.333333333333333*G1_14_14;
        break;
      }
    case 2:
      {
        A[0] = 0.0916666666666666*G0_0_0 + 0.15*G0_0_7 - 0.0749999999999999*G0_0_8 + 0.0916666666666666*G0_1_1 - 0.075*G0_1_7 + 0.15*G0_1_8 + 0.0333333333333332*G0_5_0 + 0.0333333333333333*G0_5_1 + 0.3*G0_5_7 + 0.3*G0_5_8 + 0.0916666666666666*G0_6_10 + 0.15*G0_6_17 - 0.0749999999999999*G0_6_18 + 0.0916666666666666*G0_7_11 - 0.075*G0_7_17 + 0.15*G0_7_18 + 0.0333333333333332*G0_11_10 + 0.0333333333333333*G0_11_11 + 0.3*G0_11_17 + 0.3*G0_11_18 + 0.166666666666667*G0_12_20 + 0.333333333333333*G0_12_25 + 0.166666666666667*G0_13_21 + 0.333333333333333*G0_13_25 - 0.133333333333333*G1_0_0 + 0.0333333333333333*G1_0_1 - 0.0666666666666666*G1_0_5 + 0.0333333333333333*G1_1_0 - 0.133333333333333*G1_1_1 - 0.0666666666666666*G1_1_5 - 0.0666666666666666*G1_5_0 - 0.0666666666666666*G1_5_1 - 0.533333333333333*G1_5_5 - 0.133333333333333*G1_6_6 + 0.0333333333333333*G1_6_7 - 0.0666666666666666*G1_6_11 + 0.0333333333333333*G1_7_6 - 0.133333333333333*G1_7_7 - 0.0666666666666666*G1_7_11 - 0.0666666666666666*G1_11_6 - 0.0666666666666666*G1_11_7 - 0.533333333333333*G1_11_11 - 0.333333333333333*G1_12_12 - 0.166666666666667*G1_12_13 - 0.166666666666667*G1_13_12 - 0.333333333333333*G1_13_13;
        break;
      }
    }
    
  }

};

/// This class defines the interface for the tabulation of the
/// interior facet tensor corresponding to the local contribution to
/// a form from the integral over an interior facet.

class adaptivenavierstokes_interior_facet_integral_7_otherwise: public ufc::interior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_interior_facet_integral_7_otherwise() : ufc::interior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_interior_facet_integral_7_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({true, false, true, true});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local interior facet
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates_0,
                               const double*  vertex_coordinates_1,
                               std::size_t facet_0,
                               std::size_t facet_1,
                               int cell_orientation_0,
                               int cell_orientation_1) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      12
    // Number of operations (multiply-add pairs) for geometry tensor:    720
    // Number of operations (multiply-add pairs) for tensor contraction: 1647
    // Total number of operations (multiply-add pairs):                  2379
    
    // Compute Jacobian
    double J_0[4];
    compute_jacobian_triangle_2d(J_0, vertex_coordinates_0);
    
    // Compute Jacobian inverse and determinant
    double K_0[4];
    double detJ_0;
    compute_jacobian_inverse_triangle_2d(K_0, detJ_0, J_0);
    
    // Compute Jacobian
    double J_1[4];
    compute_jacobian_triangle_2d(J_1, vertex_coordinates_1);
    
    // Compute Jacobian inverse and determinant
    double K_1[4];
    double detJ_1;
    compute_jacobian_inverse_triangle_2d(K_1, detJ_1, J_1);
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet_0][0];
    const unsigned int v1 = edge_vertices[facet_0][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = vertex_coordinates_0[2*v1 + 0] - vertex_coordinates_0[2*v0 + 0];
    const double dx1 = vertex_coordinates_0[2*v1 + 1] - vertex_coordinates_0[2*v0 + 1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    
    
    // Compute geometry tensor
    const double G0_15_15 = det*w[2][15]*w[3][15]*(1.0);
    const double G0_15_16 = det*w[2][15]*w[3][16]*(1.0);
    const double G0_15_17 = det*w[2][15]*w[3][17]*(1.0);
    const double G0_15_19 = det*w[2][15]*w[3][19]*(1.0);
    const double G0_15_20 = det*w[2][15]*w[3][20]*(1.0);
    const double G0_16_15 = det*w[2][16]*w[3][15]*(1.0);
    const double G0_16_16 = det*w[2][16]*w[3][16]*(1.0);
    const double G0_16_17 = det*w[2][16]*w[3][17]*(1.0);
    const double G0_16_18 = det*w[2][16]*w[3][18]*(1.0);
    const double G0_16_20 = det*w[2][16]*w[3][20]*(1.0);
    const double G0_17_15 = det*w[2][17]*w[3][15]*(1.0);
    const double G0_17_16 = det*w[2][17]*w[3][16]*(1.0);
    const double G0_17_17 = det*w[2][17]*w[3][17]*(1.0);
    const double G0_17_18 = det*w[2][17]*w[3][18]*(1.0);
    const double G0_17_19 = det*w[2][17]*w[3][19]*(1.0);
    const double G0_18_16 = det*w[2][18]*w[3][16]*(1.0);
    const double G0_18_17 = det*w[2][18]*w[3][17]*(1.0);
    const double G0_18_18 = det*w[2][18]*w[3][18]*(1.0);
    const double G0_19_15 = det*w[2][19]*w[3][15]*(1.0);
    const double G0_19_17 = det*w[2][19]*w[3][17]*(1.0);
    const double G0_19_19 = det*w[2][19]*w[3][19]*(1.0);
    const double G0_20_15 = det*w[2][20]*w[3][15]*(1.0);
    const double G0_20_16 = det*w[2][20]*w[3][16]*(1.0);
    const double G0_20_20 = det*w[2][20]*w[3][20]*(1.0);
    const double G0_21_21 = det*w[2][21]*w[3][21]*(1.0);
    const double G0_21_22 = det*w[2][21]*w[3][22]*(1.0);
    const double G0_21_23 = det*w[2][21]*w[3][23]*(1.0);
    const double G0_21_25 = det*w[2][21]*w[3][25]*(1.0);
    const double G0_21_26 = det*w[2][21]*w[3][26]*(1.0);
    const double G0_22_21 = det*w[2][22]*w[3][21]*(1.0);
    const double G0_22_22 = det*w[2][22]*w[3][22]*(1.0);
    const double G0_22_23 = det*w[2][22]*w[3][23]*(1.0);
    const double G0_22_24 = det*w[2][22]*w[3][24]*(1.0);
    const double G0_22_26 = det*w[2][22]*w[3][26]*(1.0);
    const double G0_23_21 = det*w[2][23]*w[3][21]*(1.0);
    const double G0_23_22 = det*w[2][23]*w[3][22]*(1.0);
    const double G0_23_23 = det*w[2][23]*w[3][23]*(1.0);
    const double G0_23_24 = det*w[2][23]*w[3][24]*(1.0);
    const double G0_23_25 = det*w[2][23]*w[3][25]*(1.0);
    const double G0_24_22 = det*w[2][24]*w[3][22]*(1.0);
    const double G0_24_23 = det*w[2][24]*w[3][23]*(1.0);
    const double G0_24_24 = det*w[2][24]*w[3][24]*(1.0);
    const double G0_25_21 = det*w[2][25]*w[3][21]*(1.0);
    const double G0_25_23 = det*w[2][25]*w[3][23]*(1.0);
    const double G0_25_25 = det*w[2][25]*w[3][25]*(1.0);
    const double G0_26_21 = det*w[2][26]*w[3][21]*(1.0);
    const double G0_26_22 = det*w[2][26]*w[3][22]*(1.0);
    const double G0_26_26 = det*w[2][26]*w[3][26]*(1.0);
    const double G0_27_27 = det*w[2][27]*w[3][27]*(1.0);
    const double G0_27_28 = det*w[2][27]*w[3][28]*(1.0);
    const double G0_27_29 = det*w[2][27]*w[3][29]*(1.0);
    const double G0_28_27 = det*w[2][28]*w[3][27]*(1.0);
    const double G0_28_28 = det*w[2][28]*w[3][28]*(1.0);
    const double G0_28_29 = det*w[2][28]*w[3][29]*(1.0);
    const double G0_29_27 = det*w[2][29]*w[3][27]*(1.0);
    const double G0_29_28 = det*w[2][29]*w[3][28]*(1.0);
    const double G0_29_29 = det*w[2][29]*w[3][29]*(1.0);
    const double G1_15_26 = det*w[2][15]*w[0][26]*(1.0);
    const double G1_15_31 = det*w[2][15]*w[0][31]*(1.0);
    const double G1_15_32 = det*w[2][15]*w[0][32]*(1.0);
    const double G1_15_33 = det*w[2][15]*w[0][33]*(1.0);
    const double G1_15_34 = det*w[2][15]*w[0][34]*(1.0);
    const double G1_16_27 = det*w[2][16]*w[0][27]*(1.0);
    const double G1_16_29 = det*w[2][16]*w[0][29]*(1.0);
    const double G1_16_30 = det*w[2][16]*w[0][30]*(1.0);
    const double G1_16_33 = det*w[2][16]*w[0][33]*(1.0);
    const double G1_16_34 = det*w[2][16]*w[0][34]*(1.0);
    const double G1_17_28 = det*w[2][17]*w[0][28]*(1.0);
    const double G1_17_29 = det*w[2][17]*w[0][29]*(1.0);
    const double G1_17_30 = det*w[2][17]*w[0][30]*(1.0);
    const double G1_17_31 = det*w[2][17]*w[0][31]*(1.0);
    const double G1_17_32 = det*w[2][17]*w[0][32]*(1.0);
    const double G1_18_27 = det*w[2][18]*w[0][27]*(1.0);
    const double G1_18_28 = det*w[2][18]*w[0][28]*(1.0);
    const double G1_18_29 = det*w[2][18]*w[0][29]*(1.0);
    const double G1_18_30 = det*w[2][18]*w[0][30]*(1.0);
    const double G1_19_26 = det*w[2][19]*w[0][26]*(1.0);
    const double G1_19_28 = det*w[2][19]*w[0][28]*(1.0);
    const double G1_19_31 = det*w[2][19]*w[0][31]*(1.0);
    const double G1_19_32 = det*w[2][19]*w[0][32]*(1.0);
    const double G1_20_26 = det*w[2][20]*w[0][26]*(1.0);
    const double G1_20_27 = det*w[2][20]*w[0][27]*(1.0);
    const double G1_20_33 = det*w[2][20]*w[0][33]*(1.0);
    const double G1_20_34 = det*w[2][20]*w[0][34]*(1.0);
    const double G1_21_36 = det*w[2][21]*w[0][36]*(1.0);
    const double G1_21_41 = det*w[2][21]*w[0][41]*(1.0);
    const double G1_21_42 = det*w[2][21]*w[0][42]*(1.0);
    const double G1_21_43 = det*w[2][21]*w[0][43]*(1.0);
    const double G1_21_44 = det*w[2][21]*w[0][44]*(1.0);
    const double G1_22_37 = det*w[2][22]*w[0][37]*(1.0);
    const double G1_22_39 = det*w[2][22]*w[0][39]*(1.0);
    const double G1_22_40 = det*w[2][22]*w[0][40]*(1.0);
    const double G1_22_43 = det*w[2][22]*w[0][43]*(1.0);
    const double G1_22_44 = det*w[2][22]*w[0][44]*(1.0);
    const double G1_23_38 = det*w[2][23]*w[0][38]*(1.0);
    const double G1_23_39 = det*w[2][23]*w[0][39]*(1.0);
    const double G1_23_40 = det*w[2][23]*w[0][40]*(1.0);
    const double G1_23_41 = det*w[2][23]*w[0][41]*(1.0);
    const double G1_23_42 = det*w[2][23]*w[0][42]*(1.0);
    const double G1_24_37 = det*w[2][24]*w[0][37]*(1.0);
    const double G1_24_38 = det*w[2][24]*w[0][38]*(1.0);
    const double G1_24_39 = det*w[2][24]*w[0][39]*(1.0);
    const double G1_24_40 = det*w[2][24]*w[0][40]*(1.0);
    const double G1_25_36 = det*w[2][25]*w[0][36]*(1.0);
    const double G1_25_38 = det*w[2][25]*w[0][38]*(1.0);
    const double G1_25_41 = det*w[2][25]*w[0][41]*(1.0);
    const double G1_25_42 = det*w[2][25]*w[0][42]*(1.0);
    const double G1_26_36 = det*w[2][26]*w[0][36]*(1.0);
    const double G1_26_37 = det*w[2][26]*w[0][37]*(1.0);
    const double G1_26_43 = det*w[2][26]*w[0][43]*(1.0);
    const double G1_26_44 = det*w[2][26]*w[0][44]*(1.0);
    const double G1_27_46 = det*w[2][27]*w[0][46]*(1.0);
    const double G1_27_50 = det*w[2][27]*w[0][50]*(1.0);
    const double G1_27_51 = det*w[2][27]*w[0][51]*(1.0);
    const double G1_28_47 = det*w[2][28]*w[0][47]*(1.0);
    const double G1_28_49 = det*w[2][28]*w[0][49]*(1.0);
    const double G1_28_51 = det*w[2][28]*w[0][51]*(1.0);
    const double G1_29_48 = det*w[2][29]*w[0][48]*(1.0);
    const double G1_29_49 = det*w[2][29]*w[0][49]*(1.0);
    const double G1_29_50 = det*w[2][29]*w[0][50]*(1.0);
    const double G2_0_0 = det*w[2][0]*w[3][0]*(1.0);
    const double G2_0_1 = det*w[2][0]*w[3][1]*(1.0);
    const double G2_0_2 = det*w[2][0]*w[3][2]*(1.0);
    const double G2_0_4 = det*w[2][0]*w[3][4]*(1.0);
    const double G2_0_5 = det*w[2][0]*w[3][5]*(1.0);
    const double G2_1_0 = det*w[2][1]*w[3][0]*(1.0);
    const double G2_1_1 = det*w[2][1]*w[3][1]*(1.0);
    const double G2_1_2 = det*w[2][1]*w[3][2]*(1.0);
    const double G2_1_3 = det*w[2][1]*w[3][3]*(1.0);
    const double G2_1_5 = det*w[2][1]*w[3][5]*(1.0);
    const double G2_2_0 = det*w[2][2]*w[3][0]*(1.0);
    const double G2_2_1 = det*w[2][2]*w[3][1]*(1.0);
    const double G2_2_2 = det*w[2][2]*w[3][2]*(1.0);
    const double G2_2_3 = det*w[2][2]*w[3][3]*(1.0);
    const double G2_2_4 = det*w[2][2]*w[3][4]*(1.0);
    const double G2_3_1 = det*w[2][3]*w[3][1]*(1.0);
    const double G2_3_2 = det*w[2][3]*w[3][2]*(1.0);
    const double G2_3_3 = det*w[2][3]*w[3][3]*(1.0);
    const double G2_4_0 = det*w[2][4]*w[3][0]*(1.0);
    const double G2_4_2 = det*w[2][4]*w[3][2]*(1.0);
    const double G2_4_4 = det*w[2][4]*w[3][4]*(1.0);
    const double G2_5_0 = det*w[2][5]*w[3][0]*(1.0);
    const double G2_5_1 = det*w[2][5]*w[3][1]*(1.0);
    const double G2_5_5 = det*w[2][5]*w[3][5]*(1.0);
    const double G2_6_6 = det*w[2][6]*w[3][6]*(1.0);
    const double G2_6_7 = det*w[2][6]*w[3][7]*(1.0);
    const double G2_6_8 = det*w[2][6]*w[3][8]*(1.0);
    const double G2_6_10 = det*w[2][6]*w[3][10]*(1.0);
    const double G2_6_11 = det*w[2][6]*w[3][11]*(1.0);
    const double G2_7_6 = det*w[2][7]*w[3][6]*(1.0);
    const double G2_7_7 = det*w[2][7]*w[3][7]*(1.0);
    const double G2_7_8 = det*w[2][7]*w[3][8]*(1.0);
    const double G2_7_9 = det*w[2][7]*w[3][9]*(1.0);
    const double G2_7_11 = det*w[2][7]*w[3][11]*(1.0);
    const double G2_8_6 = det*w[2][8]*w[3][6]*(1.0);
    const double G2_8_7 = det*w[2][8]*w[3][7]*(1.0);
    const double G2_8_8 = det*w[2][8]*w[3][8]*(1.0);
    const double G2_8_9 = det*w[2][8]*w[3][9]*(1.0);
    const double G2_8_10 = det*w[2][8]*w[3][10]*(1.0);
    const double G2_9_7 = det*w[2][9]*w[3][7]*(1.0);
    const double G2_9_8 = det*w[2][9]*w[3][8]*(1.0);
    const double G2_9_9 = det*w[2][9]*w[3][9]*(1.0);
    const double G2_10_6 = det*w[2][10]*w[3][6]*(1.0);
    const double G2_10_8 = det*w[2][10]*w[3][8]*(1.0);
    const double G2_10_10 = det*w[2][10]*w[3][10]*(1.0);
    const double G2_11_6 = det*w[2][11]*w[3][6]*(1.0);
    const double G2_11_7 = det*w[2][11]*w[3][7]*(1.0);
    const double G2_11_11 = det*w[2][11]*w[3][11]*(1.0);
    const double G2_12_12 = det*w[2][12]*w[3][12]*(1.0);
    const double G2_12_13 = det*w[2][12]*w[3][13]*(1.0);
    const double G2_12_14 = det*w[2][12]*w[3][14]*(1.0);
    const double G2_13_12 = det*w[2][13]*w[3][12]*(1.0);
    const double G2_13_13 = det*w[2][13]*w[3][13]*(1.0);
    const double G2_13_14 = det*w[2][13]*w[3][14]*(1.0);
    const double G2_14_12 = det*w[2][14]*w[3][12]*(1.0);
    const double G2_14_13 = det*w[2][14]*w[3][13]*(1.0);
    const double G2_14_14 = det*w[2][14]*w[3][14]*(1.0);
    const double G3_0_0 = det*w[2][0]*w[0][0]*(1.0);
    const double G3_0_5 = det*w[2][0]*w[0][5]*(1.0);
    const double G3_0_6 = det*w[2][0]*w[0][6]*(1.0);
    const double G3_0_7 = det*w[2][0]*w[0][7]*(1.0);
    const double G3_0_8 = det*w[2][0]*w[0][8]*(1.0);
    const double G3_1_1 = det*w[2][1]*w[0][1]*(1.0);
    const double G3_1_3 = det*w[2][1]*w[0][3]*(1.0);
    const double G3_1_4 = det*w[2][1]*w[0][4]*(1.0);
    const double G3_1_7 = det*w[2][1]*w[0][7]*(1.0);
    const double G3_1_8 = det*w[2][1]*w[0][8]*(1.0);
    const double G3_2_2 = det*w[2][2]*w[0][2]*(1.0);
    const double G3_2_3 = det*w[2][2]*w[0][3]*(1.0);
    const double G3_2_4 = det*w[2][2]*w[0][4]*(1.0);
    const double G3_2_5 = det*w[2][2]*w[0][5]*(1.0);
    const double G3_2_6 = det*w[2][2]*w[0][6]*(1.0);
    const double G3_3_1 = det*w[2][3]*w[0][1]*(1.0);
    const double G3_3_2 = det*w[2][3]*w[0][2]*(1.0);
    const double G3_3_3 = det*w[2][3]*w[0][3]*(1.0);
    const double G3_3_4 = det*w[2][3]*w[0][4]*(1.0);
    const double G3_4_0 = det*w[2][4]*w[0][0]*(1.0);
    const double G3_4_2 = det*w[2][4]*w[0][2]*(1.0);
    const double G3_4_5 = det*w[2][4]*w[0][5]*(1.0);
    const double G3_4_6 = det*w[2][4]*w[0][6]*(1.0);
    const double G3_5_0 = det*w[2][5]*w[0][0]*(1.0);
    const double G3_5_1 = det*w[2][5]*w[0][1]*(1.0);
    const double G3_5_7 = det*w[2][5]*w[0][7]*(1.0);
    const double G3_5_8 = det*w[2][5]*w[0][8]*(1.0);
    const double G3_6_10 = det*w[2][6]*w[0][10]*(1.0);
    const double G3_6_15 = det*w[2][6]*w[0][15]*(1.0);
    const double G3_6_16 = det*w[2][6]*w[0][16]*(1.0);
    const double G3_6_17 = det*w[2][6]*w[0][17]*(1.0);
    const double G3_6_18 = det*w[2][6]*w[0][18]*(1.0);
    const double G3_7_11 = det*w[2][7]*w[0][11]*(1.0);
    const double G3_7_13 = det*w[2][7]*w[0][13]*(1.0);
    const double G3_7_14 = det*w[2][7]*w[0][14]*(1.0);
    const double G3_7_17 = det*w[2][7]*w[0][17]*(1.0);
    const double G3_7_18 = det*w[2][7]*w[0][18]*(1.0);
    const double G3_8_12 = det*w[2][8]*w[0][12]*(1.0);
    const double G3_8_13 = det*w[2][8]*w[0][13]*(1.0);
    const double G3_8_14 = det*w[2][8]*w[0][14]*(1.0);
    const double G3_8_15 = det*w[2][8]*w[0][15]*(1.0);
    const double G3_8_16 = det*w[2][8]*w[0][16]*(1.0);
    const double G3_9_11 = det*w[2][9]*w[0][11]*(1.0);
    const double G3_9_12 = det*w[2][9]*w[0][12]*(1.0);
    const double G3_9_13 = det*w[2][9]*w[0][13]*(1.0);
    const double G3_9_14 = det*w[2][9]*w[0][14]*(1.0);
    const double G3_10_10 = det*w[2][10]*w[0][10]*(1.0);
    const double G3_10_12 = det*w[2][10]*w[0][12]*(1.0);
    const double G3_10_15 = det*w[2][10]*w[0][15]*(1.0);
    const double G3_10_16 = det*w[2][10]*w[0][16]*(1.0);
    const double G3_11_10 = det*w[2][11]*w[0][10]*(1.0);
    const double G3_11_11 = det*w[2][11]*w[0][11]*(1.0);
    const double G3_11_17 = det*w[2][11]*w[0][17]*(1.0);
    const double G3_11_18 = det*w[2][11]*w[0][18]*(1.0);
    const double G3_12_20 = det*w[2][12]*w[0][20]*(1.0);
    const double G3_12_24 = det*w[2][12]*w[0][24]*(1.0);
    const double G3_12_25 = det*w[2][12]*w[0][25]*(1.0);
    const double G3_13_21 = det*w[2][13]*w[0][21]*(1.0);
    const double G3_13_23 = det*w[2][13]*w[0][23]*(1.0);
    const double G3_13_25 = det*w[2][13]*w[0][25]*(1.0);
    const double G3_14_22 = det*w[2][14]*w[0][22]*(1.0);
    const double G3_14_23 = det*w[2][14]*w[0][23]*(1.0);
    const double G3_14_24 = det*w[2][14]*w[0][24]*(1.0);
    const double G4_15_15 = det*w[2][15]*w[3][15]*(1.0);
    const double G4_15_16 = det*w[2][15]*w[3][16]*(1.0);
    const double G4_15_17 = det*w[2][15]*w[3][17]*(1.0);
    const double G4_15_19 = det*w[2][15]*w[3][19]*(1.0);
    const double G4_15_20 = det*w[2][15]*w[3][20]*(1.0);
    const double G4_16_15 = det*w[2][16]*w[3][15]*(1.0);
    const double G4_16_16 = det*w[2][16]*w[3][16]*(1.0);
    const double G4_16_17 = det*w[2][16]*w[3][17]*(1.0);
    const double G4_16_18 = det*w[2][16]*w[3][18]*(1.0);
    const double G4_16_20 = det*w[2][16]*w[3][20]*(1.0);
    const double G4_17_15 = det*w[2][17]*w[3][15]*(1.0);
    const double G4_17_16 = det*w[2][17]*w[3][16]*(1.0);
    const double G4_17_17 = det*w[2][17]*w[3][17]*(1.0);
    const double G4_17_18 = det*w[2][17]*w[3][18]*(1.0);
    const double G4_17_19 = det*w[2][17]*w[3][19]*(1.0);
    const double G4_18_16 = det*w[2][18]*w[3][16]*(1.0);
    const double G4_18_17 = det*w[2][18]*w[3][17]*(1.0);
    const double G4_18_18 = det*w[2][18]*w[3][18]*(1.0);
    const double G4_19_15 = det*w[2][19]*w[3][15]*(1.0);
    const double G4_19_17 = det*w[2][19]*w[3][17]*(1.0);
    const double G4_19_19 = det*w[2][19]*w[3][19]*(1.0);
    const double G4_20_15 = det*w[2][20]*w[3][15]*(1.0);
    const double G4_20_16 = det*w[2][20]*w[3][16]*(1.0);
    const double G4_20_20 = det*w[2][20]*w[3][20]*(1.0);
    const double G4_21_21 = det*w[2][21]*w[3][21]*(1.0);
    const double G4_21_22 = det*w[2][21]*w[3][22]*(1.0);
    const double G4_21_23 = det*w[2][21]*w[3][23]*(1.0);
    const double G4_21_25 = det*w[2][21]*w[3][25]*(1.0);
    const double G4_21_26 = det*w[2][21]*w[3][26]*(1.0);
    const double G4_22_21 = det*w[2][22]*w[3][21]*(1.0);
    const double G4_22_22 = det*w[2][22]*w[3][22]*(1.0);
    const double G4_22_23 = det*w[2][22]*w[3][23]*(1.0);
    const double G4_22_24 = det*w[2][22]*w[3][24]*(1.0);
    const double G4_22_26 = det*w[2][22]*w[3][26]*(1.0);
    const double G4_23_21 = det*w[2][23]*w[3][21]*(1.0);
    const double G4_23_22 = det*w[2][23]*w[3][22]*(1.0);
    const double G4_23_23 = det*w[2][23]*w[3][23]*(1.0);
    const double G4_23_24 = det*w[2][23]*w[3][24]*(1.0);
    const double G4_23_25 = det*w[2][23]*w[3][25]*(1.0);
    const double G4_24_22 = det*w[2][24]*w[3][22]*(1.0);
    const double G4_24_23 = det*w[2][24]*w[3][23]*(1.0);
    const double G4_24_24 = det*w[2][24]*w[3][24]*(1.0);
    const double G4_25_21 = det*w[2][25]*w[3][21]*(1.0);
    const double G4_25_23 = det*w[2][25]*w[3][23]*(1.0);
    const double G4_25_25 = det*w[2][25]*w[3][25]*(1.0);
    const double G4_26_21 = det*w[2][26]*w[3][21]*(1.0);
    const double G4_26_22 = det*w[2][26]*w[3][22]*(1.0);
    const double G4_26_26 = det*w[2][26]*w[3][26]*(1.0);
    const double G4_27_27 = det*w[2][27]*w[3][27]*(1.0);
    const double G4_27_28 = det*w[2][27]*w[3][28]*(1.0);
    const double G4_27_29 = det*w[2][27]*w[3][29]*(1.0);
    const double G4_28_27 = det*w[2][28]*w[3][27]*(1.0);
    const double G4_28_28 = det*w[2][28]*w[3][28]*(1.0);
    const double G4_28_29 = det*w[2][28]*w[3][29]*(1.0);
    const double G4_29_27 = det*w[2][29]*w[3][27]*(1.0);
    const double G4_29_28 = det*w[2][29]*w[3][28]*(1.0);
    const double G4_29_29 = det*w[2][29]*w[3][29]*(1.0);
    const double G5_15_26 = det*w[2][15]*w[0][26]*(1.0);
    const double G5_15_31 = det*w[2][15]*w[0][31]*(1.0);
    const double G5_15_32 = det*w[2][15]*w[0][32]*(1.0);
    const double G5_15_33 = det*w[2][15]*w[0][33]*(1.0);
    const double G5_15_34 = det*w[2][15]*w[0][34]*(1.0);
    const double G5_16_27 = det*w[2][16]*w[0][27]*(1.0);
    const double G5_16_29 = det*w[2][16]*w[0][29]*(1.0);
    const double G5_16_30 = det*w[2][16]*w[0][30]*(1.0);
    const double G5_16_33 = det*w[2][16]*w[0][33]*(1.0);
    const double G5_16_34 = det*w[2][16]*w[0][34]*(1.0);
    const double G5_17_28 = det*w[2][17]*w[0][28]*(1.0);
    const double G5_17_29 = det*w[2][17]*w[0][29]*(1.0);
    const double G5_17_30 = det*w[2][17]*w[0][30]*(1.0);
    const double G5_17_31 = det*w[2][17]*w[0][31]*(1.0);
    const double G5_17_32 = det*w[2][17]*w[0][32]*(1.0);
    const double G5_18_27 = det*w[2][18]*w[0][27]*(1.0);
    const double G5_18_28 = det*w[2][18]*w[0][28]*(1.0);
    const double G5_18_29 = det*w[2][18]*w[0][29]*(1.0);
    const double G5_18_30 = det*w[2][18]*w[0][30]*(1.0);
    const double G5_19_26 = det*w[2][19]*w[0][26]*(1.0);
    const double G5_19_28 = det*w[2][19]*w[0][28]*(1.0);
    const double G5_19_31 = det*w[2][19]*w[0][31]*(1.0);
    const double G5_19_32 = det*w[2][19]*w[0][32]*(1.0);
    const double G5_20_26 = det*w[2][20]*w[0][26]*(1.0);
    const double G5_20_27 = det*w[2][20]*w[0][27]*(1.0);
    const double G5_20_33 = det*w[2][20]*w[0][33]*(1.0);
    const double G5_20_34 = det*w[2][20]*w[0][34]*(1.0);
    const double G5_21_36 = det*w[2][21]*w[0][36]*(1.0);
    const double G5_21_41 = det*w[2][21]*w[0][41]*(1.0);
    const double G5_21_42 = det*w[2][21]*w[0][42]*(1.0);
    const double G5_21_43 = det*w[2][21]*w[0][43]*(1.0);
    const double G5_21_44 = det*w[2][21]*w[0][44]*(1.0);
    const double G5_22_37 = det*w[2][22]*w[0][37]*(1.0);
    const double G5_22_39 = det*w[2][22]*w[0][39]*(1.0);
    const double G5_22_40 = det*w[2][22]*w[0][40]*(1.0);
    const double G5_22_43 = det*w[2][22]*w[0][43]*(1.0);
    const double G5_22_44 = det*w[2][22]*w[0][44]*(1.0);
    const double G5_23_38 = det*w[2][23]*w[0][38]*(1.0);
    const double G5_23_39 = det*w[2][23]*w[0][39]*(1.0);
    const double G5_23_40 = det*w[2][23]*w[0][40]*(1.0);
    const double G5_23_41 = det*w[2][23]*w[0][41]*(1.0);
    const double G5_23_42 = det*w[2][23]*w[0][42]*(1.0);
    const double G5_24_37 = det*w[2][24]*w[0][37]*(1.0);
    const double G5_24_38 = det*w[2][24]*w[0][38]*(1.0);
    const double G5_24_39 = det*w[2][24]*w[0][39]*(1.0);
    const double G5_24_40 = det*w[2][24]*w[0][40]*(1.0);
    const double G5_25_36 = det*w[2][25]*w[0][36]*(1.0);
    const double G5_25_38 = det*w[2][25]*w[0][38]*(1.0);
    const double G5_25_41 = det*w[2][25]*w[0][41]*(1.0);
    const double G5_25_42 = det*w[2][25]*w[0][42]*(1.0);
    const double G5_26_36 = det*w[2][26]*w[0][36]*(1.0);
    const double G5_26_37 = det*w[2][26]*w[0][37]*(1.0);
    const double G5_26_43 = det*w[2][26]*w[0][43]*(1.0);
    const double G5_26_44 = det*w[2][26]*w[0][44]*(1.0);
    const double G5_27_46 = det*w[2][27]*w[0][46]*(1.0);
    const double G5_27_50 = det*w[2][27]*w[0][50]*(1.0);
    const double G5_27_51 = det*w[2][27]*w[0][51]*(1.0);
    const double G5_28_47 = det*w[2][28]*w[0][47]*(1.0);
    const double G5_28_49 = det*w[2][28]*w[0][49]*(1.0);
    const double G5_28_51 = det*w[2][28]*w[0][51]*(1.0);
    const double G5_29_48 = det*w[2][29]*w[0][48]*(1.0);
    const double G5_29_49 = det*w[2][29]*w[0][49]*(1.0);
    const double G5_29_50 = det*w[2][29]*w[0][50]*(1.0);
    const double G6_0_0 = det*w[2][0]*w[3][0]*(1.0);
    const double G6_0_1 = det*w[2][0]*w[3][1]*(1.0);
    const double G6_0_2 = det*w[2][0]*w[3][2]*(1.0);
    const double G6_0_4 = det*w[2][0]*w[3][4]*(1.0);
    const double G6_0_5 = det*w[2][0]*w[3][5]*(1.0);
    const double G6_1_0 = det*w[2][1]*w[3][0]*(1.0);
    const double G6_1_1 = det*w[2][1]*w[3][1]*(1.0);
    const double G6_1_2 = det*w[2][1]*w[3][2]*(1.0);
    const double G6_1_3 = det*w[2][1]*w[3][3]*(1.0);
    const double G6_1_5 = det*w[2][1]*w[3][5]*(1.0);
    const double G6_2_0 = det*w[2][2]*w[3][0]*(1.0);
    const double G6_2_1 = det*w[2][2]*w[3][1]*(1.0);
    const double G6_2_2 = det*w[2][2]*w[3][2]*(1.0);
    const double G6_2_3 = det*w[2][2]*w[3][3]*(1.0);
    const double G6_2_4 = det*w[2][2]*w[3][4]*(1.0);
    const double G6_3_1 = det*w[2][3]*w[3][1]*(1.0);
    const double G6_3_2 = det*w[2][3]*w[3][2]*(1.0);
    const double G6_3_3 = det*w[2][3]*w[3][3]*(1.0);
    const double G6_4_0 = det*w[2][4]*w[3][0]*(1.0);
    const double G6_4_2 = det*w[2][4]*w[3][2]*(1.0);
    const double G6_4_4 = det*w[2][4]*w[3][4]*(1.0);
    const double G6_5_0 = det*w[2][5]*w[3][0]*(1.0);
    const double G6_5_1 = det*w[2][5]*w[3][1]*(1.0);
    const double G6_5_5 = det*w[2][5]*w[3][5]*(1.0);
    const double G6_6_6 = det*w[2][6]*w[3][6]*(1.0);
    const double G6_6_7 = det*w[2][6]*w[3][7]*(1.0);
    const double G6_6_8 = det*w[2][6]*w[3][8]*(1.0);
    const double G6_6_10 = det*w[2][6]*w[3][10]*(1.0);
    const double G6_6_11 = det*w[2][6]*w[3][11]*(1.0);
    const double G6_7_6 = det*w[2][7]*w[3][6]*(1.0);
    const double G6_7_7 = det*w[2][7]*w[3][7]*(1.0);
    const double G6_7_8 = det*w[2][7]*w[3][8]*(1.0);
    const double G6_7_9 = det*w[2][7]*w[3][9]*(1.0);
    const double G6_7_11 = det*w[2][7]*w[3][11]*(1.0);
    const double G6_8_6 = det*w[2][8]*w[3][6]*(1.0);
    const double G6_8_7 = det*w[2][8]*w[3][7]*(1.0);
    const double G6_8_8 = det*w[2][8]*w[3][8]*(1.0);
    const double G6_8_9 = det*w[2][8]*w[3][9]*(1.0);
    const double G6_8_10 = det*w[2][8]*w[3][10]*(1.0);
    const double G6_9_7 = det*w[2][9]*w[3][7]*(1.0);
    const double G6_9_8 = det*w[2][9]*w[3][8]*(1.0);
    const double G6_9_9 = det*w[2][9]*w[3][9]*(1.0);
    const double G6_10_6 = det*w[2][10]*w[3][6]*(1.0);
    const double G6_10_8 = det*w[2][10]*w[3][8]*(1.0);
    const double G6_10_10 = det*w[2][10]*w[3][10]*(1.0);
    const double G6_11_6 = det*w[2][11]*w[3][6]*(1.0);
    const double G6_11_7 = det*w[2][11]*w[3][7]*(1.0);
    const double G6_11_11 = det*w[2][11]*w[3][11]*(1.0);
    const double G6_12_12 = det*w[2][12]*w[3][12]*(1.0);
    const double G6_12_13 = det*w[2][12]*w[3][13]*(1.0);
    const double G6_12_14 = det*w[2][12]*w[3][14]*(1.0);
    const double G6_13_12 = det*w[2][13]*w[3][12]*(1.0);
    const double G6_13_13 = det*w[2][13]*w[3][13]*(1.0);
    const double G6_13_14 = det*w[2][13]*w[3][14]*(1.0);
    const double G6_14_12 = det*w[2][14]*w[3][12]*(1.0);
    const double G6_14_13 = det*w[2][14]*w[3][13]*(1.0);
    const double G6_14_14 = det*w[2][14]*w[3][14]*(1.0);
    const double G7_0_0 = det*w[2][0]*w[0][0]*(1.0);
    const double G7_0_5 = det*w[2][0]*w[0][5]*(1.0);
    const double G7_0_6 = det*w[2][0]*w[0][6]*(1.0);
    const double G7_0_7 = det*w[2][0]*w[0][7]*(1.0);
    const double G7_0_8 = det*w[2][0]*w[0][8]*(1.0);
    const double G7_1_1 = det*w[2][1]*w[0][1]*(1.0);
    const double G7_1_3 = det*w[2][1]*w[0][3]*(1.0);
    const double G7_1_4 = det*w[2][1]*w[0][4]*(1.0);
    const double G7_1_7 = det*w[2][1]*w[0][7]*(1.0);
    const double G7_1_8 = det*w[2][1]*w[0][8]*(1.0);
    const double G7_2_2 = det*w[2][2]*w[0][2]*(1.0);
    const double G7_2_3 = det*w[2][2]*w[0][3]*(1.0);
    const double G7_2_4 = det*w[2][2]*w[0][4]*(1.0);
    const double G7_2_5 = det*w[2][2]*w[0][5]*(1.0);
    const double G7_2_6 = det*w[2][2]*w[0][6]*(1.0);
    const double G7_3_1 = det*w[2][3]*w[0][1]*(1.0);
    const double G7_3_2 = det*w[2][3]*w[0][2]*(1.0);
    const double G7_3_3 = det*w[2][3]*w[0][3]*(1.0);
    const double G7_3_4 = det*w[2][3]*w[0][4]*(1.0);
    const double G7_4_0 = det*w[2][4]*w[0][0]*(1.0);
    const double G7_4_2 = det*w[2][4]*w[0][2]*(1.0);
    const double G7_4_5 = det*w[2][4]*w[0][5]*(1.0);
    const double G7_4_6 = det*w[2][4]*w[0][6]*(1.0);
    const double G7_5_0 = det*w[2][5]*w[0][0]*(1.0);
    const double G7_5_1 = det*w[2][5]*w[0][1]*(1.0);
    const double G7_5_7 = det*w[2][5]*w[0][7]*(1.0);
    const double G7_5_8 = det*w[2][5]*w[0][8]*(1.0);
    const double G7_6_10 = det*w[2][6]*w[0][10]*(1.0);
    const double G7_6_15 = det*w[2][6]*w[0][15]*(1.0);
    const double G7_6_16 = det*w[2][6]*w[0][16]*(1.0);
    const double G7_6_17 = det*w[2][6]*w[0][17]*(1.0);
    const double G7_6_18 = det*w[2][6]*w[0][18]*(1.0);
    const double G7_7_11 = det*w[2][7]*w[0][11]*(1.0);
    const double G7_7_13 = det*w[2][7]*w[0][13]*(1.0);
    const double G7_7_14 = det*w[2][7]*w[0][14]*(1.0);
    const double G7_7_17 = det*w[2][7]*w[0][17]*(1.0);
    const double G7_7_18 = det*w[2][7]*w[0][18]*(1.0);
    const double G7_8_12 = det*w[2][8]*w[0][12]*(1.0);
    const double G7_8_13 = det*w[2][8]*w[0][13]*(1.0);
    const double G7_8_14 = det*w[2][8]*w[0][14]*(1.0);
    const double G7_8_15 = det*w[2][8]*w[0][15]*(1.0);
    const double G7_8_16 = det*w[2][8]*w[0][16]*(1.0);
    const double G7_9_11 = det*w[2][9]*w[0][11]*(1.0);
    const double G7_9_12 = det*w[2][9]*w[0][12]*(1.0);
    const double G7_9_13 = det*w[2][9]*w[0][13]*(1.0);
    const double G7_9_14 = det*w[2][9]*w[0][14]*(1.0);
    const double G7_10_10 = det*w[2][10]*w[0][10]*(1.0);
    const double G7_10_12 = det*w[2][10]*w[0][12]*(1.0);
    const double G7_10_15 = det*w[2][10]*w[0][15]*(1.0);
    const double G7_10_16 = det*w[2][10]*w[0][16]*(1.0);
    const double G7_11_10 = det*w[2][11]*w[0][10]*(1.0);
    const double G7_11_11 = det*w[2][11]*w[0][11]*(1.0);
    const double G7_11_17 = det*w[2][11]*w[0][17]*(1.0);
    const double G7_11_18 = det*w[2][11]*w[0][18]*(1.0);
    const double G7_12_20 = det*w[2][12]*w[0][20]*(1.0);
    const double G7_12_24 = det*w[2][12]*w[0][24]*(1.0);
    const double G7_12_25 = det*w[2][12]*w[0][25]*(1.0);
    const double G7_13_21 = det*w[2][13]*w[0][21]*(1.0);
    const double G7_13_23 = det*w[2][13]*w[0][23]*(1.0);
    const double G7_13_25 = det*w[2][13]*w[0][25]*(1.0);
    const double G7_14_22 = det*w[2][14]*w[0][22]*(1.0);
    const double G7_14_23 = det*w[2][14]*w[0][23]*(1.0);
    const double G7_14_24 = det*w[2][14]*w[0][24]*(1.0);
    
    // Compute element tensor
    switch (facet_0)
    {
    case 0:
      {
        switch (facet_1)
      {
      case 0:
        {
          A[0] = -0.0666666666666667*G4_16_16 + 0.0166666666666666*G4_16_17 - 0.0333333333333333*G4_16_18 + 0.0166666666666666*G4_17_16 - 0.0666666666666667*G4_17_17 - 0.0333333333333333*G4_17_18 - 0.0333333333333333*G4_18_16 - 0.0333333333333333*G4_18_17 - 0.266666666666666*G4_18_18 - 0.0666666666666667*G4_22_22 + 0.0166666666666666*G4_22_23 - 0.0333333333333333*G4_22_24 + 0.0166666666666666*G4_23_22 - 0.0666666666666667*G4_23_23 - 0.0333333333333333*G4_23_24 - 0.0333333333333333*G4_24_22 - 0.0333333333333333*G4_24_23 - 0.266666666666666*G4_24_24 - 0.166666666666667*G4_28_28 - 0.0833333333333333*G4_28_29 - 0.0833333333333333*G4_29_28 - 0.166666666666667*G4_29_29 + 0.0458333333333333*G5_16_27 + 0.075*G5_16_29 - 0.0375*G5_16_30 + 0.0458333333333333*G5_17_28 - 0.0375*G5_17_29 + 0.075*G5_17_30 + 0.0166666666666666*G5_18_27 + 0.0166666666666666*G5_18_28 + 0.15*G5_18_29 + 0.15*G5_18_30 + 0.0458333333333333*G5_22_37 + 0.075*G5_22_39 - 0.0375*G5_22_40 + 0.0458333333333333*G5_23_38 - 0.0375*G5_23_39 + 0.075*G5_23_40 + 0.0166666666666666*G5_24_37 + 0.0166666666666666*G5_24_38 + 0.15*G5_24_39 + 0.15*G5_24_40 + 0.0833333333333333*G5_28_47 + 0.166666666666667*G5_28_49 + 0.0833333333333333*G5_29_48 + 0.166666666666667*G5_29_49 - 0.0666666666666667*G6_1_1 + 0.0166666666666666*G6_1_2 - 0.0333333333333333*G6_1_3 + 0.0166666666666666*G6_2_1 - 0.0666666666666667*G6_2_2 - 0.0333333333333333*G6_2_3 - 0.0333333333333333*G6_3_1 - 0.0333333333333333*G6_3_2 - 0.266666666666666*G6_3_3 - 0.0666666666666667*G6_7_7 + 0.0166666666666666*G6_7_8 - 0.0333333333333333*G6_7_9 + 0.0166666666666666*G6_8_7 - 0.0666666666666667*G6_8_8 - 0.0333333333333333*G6_8_9 - 0.0333333333333333*G6_9_7 - 0.0333333333333333*G6_9_8 - 0.266666666666666*G6_9_9 - 0.166666666666667*G6_13_13 - 0.0833333333333333*G6_13_14 - 0.0833333333333333*G6_14_13 - 0.166666666666667*G6_14_14 + 0.0458333333333333*G7_1_1 + 0.075*G7_1_3 - 0.0375*G7_1_4 + 0.0458333333333333*G7_2_2 - 0.0375*G7_2_3 + 0.075*G7_2_4 + 0.0166666666666666*G7_3_1 + 0.0166666666666666*G7_3_2 + 0.15*G7_3_3 + 0.15*G7_3_4 + 0.0458333333333333*G7_7_11 + 0.075*G7_7_13 - 0.0375*G7_7_14 + 0.0458333333333333*G7_8_12 - 0.0375*G7_8_13 + 0.075*G7_8_14 + 0.0166666666666666*G7_9_11 + 0.0166666666666666*G7_9_12 + 0.15*G7_9_13 + 0.15*G7_9_14 + 0.0833333333333333*G7_13_21 + 0.166666666666667*G7_13_23 + 0.0833333333333333*G7_14_22 + 0.166666666666667*G7_14_23;
        A[1] = -0.0666666666666667*G0_16_16 + 0.0166666666666666*G0_16_17 - 0.0333333333333333*G0_16_18 + 0.0166666666666666*G0_17_16 - 0.0666666666666667*G0_17_17 - 0.0333333333333333*G0_17_18 - 0.0333333333333333*G0_18_16 - 0.0333333333333333*G0_18_17 - 0.266666666666666*G0_18_18 - 0.0666666666666667*G0_22_22 + 0.0166666666666666*G0_22_23 - 0.0333333333333333*G0_22_24 + 0.0166666666666666*G0_23_22 - 0.0666666666666667*G0_23_23 - 0.0333333333333333*G0_23_24 - 0.0333333333333333*G0_24_22 - 0.0333333333333333*G0_24_23 - 0.266666666666666*G0_24_24 - 0.166666666666667*G0_28_28 - 0.0833333333333333*G0_28_29 - 0.0833333333333333*G0_29_28 - 0.166666666666667*G0_29_29 + 0.0458333333333333*G1_16_27 + 0.075*G1_16_29 - 0.0375*G1_16_30 + 0.0458333333333333*G1_17_28 - 0.0375*G1_17_29 + 0.075*G1_17_30 + 0.0166666666666666*G1_18_27 + 0.0166666666666666*G1_18_28 + 0.15*G1_18_29 + 0.15*G1_18_30 + 0.0458333333333333*G1_22_37 + 0.075*G1_22_39 - 0.0375*G1_22_40 + 0.0458333333333333*G1_23_38 - 0.0375*G1_23_39 + 0.075*G1_23_40 + 0.0166666666666666*G1_24_37 + 0.0166666666666666*G1_24_38 + 0.15*G1_24_39 + 0.15*G1_24_40 + 0.0833333333333333*G1_28_47 + 0.166666666666667*G1_28_49 + 0.0833333333333333*G1_29_48 + 0.166666666666667*G1_29_49 - 0.0666666666666667*G2_1_1 + 0.0166666666666666*G2_1_2 - 0.0333333333333333*G2_1_3 + 0.0166666666666666*G2_2_1 - 0.0666666666666667*G2_2_2 - 0.0333333333333333*G2_2_3 - 0.0333333333333333*G2_3_1 - 0.0333333333333333*G2_3_2 - 0.266666666666666*G2_3_3 - 0.0666666666666667*G2_7_7 + 0.0166666666666666*G2_7_8 - 0.0333333333333333*G2_7_9 + 0.0166666666666666*G2_8_7 - 0.0666666666666667*G2_8_8 - 0.0333333333333333*G2_8_9 - 0.0333333333333333*G2_9_7 - 0.0333333333333333*G2_9_8 - 0.266666666666666*G2_9_9 - 0.166666666666667*G2_13_13 - 0.0833333333333333*G2_13_14 - 0.0833333333333333*G2_14_13 - 0.166666666666667*G2_14_14 + 0.0458333333333333*G3_1_1 + 0.075*G3_1_3 - 0.0375*G3_1_4 + 0.0458333333333333*G3_2_2 - 0.0375*G3_2_3 + 0.075*G3_2_4 + 0.0166666666666666*G3_3_1 + 0.0166666666666666*G3_3_2 + 0.15*G3_3_3 + 0.15*G3_3_4 + 0.0458333333333333*G3_7_11 + 0.075*G3_7_13 - 0.0375*G3_7_14 + 0.0458333333333333*G3_8_12 - 0.0375*G3_8_13 + 0.075*G3_8_14 + 0.0166666666666666*G3_9_11 + 0.0166666666666666*G3_9_12 + 0.15*G3_9_13 + 0.15*G3_9_14 + 0.0833333333333333*G3_13_21 + 0.166666666666667*G3_13_23 + 0.0833333333333333*G3_14_22 + 0.166666666666667*G3_14_23;
          break;
        }
      case 1:
        {
          A[0] = -0.0666666666666666*G4_15_15 + 0.0166666666666666*G4_15_17 - 0.0333333333333333*G4_15_19 + 0.0166666666666666*G4_17_15 - 0.0666666666666667*G4_17_17 - 0.0333333333333333*G4_17_19 - 0.0333333333333333*G4_19_15 - 0.0333333333333333*G4_19_17 - 0.266666666666666*G4_19_19 - 0.0666666666666666*G4_21_21 + 0.0166666666666666*G4_21_23 - 0.0333333333333333*G4_21_25 + 0.0166666666666666*G4_23_21 - 0.0666666666666667*G4_23_23 - 0.0333333333333333*G4_23_25 - 0.0333333333333333*G4_25_21 - 0.0333333333333333*G4_25_23 - 0.266666666666666*G4_25_25 - 0.166666666666667*G4_27_27 - 0.0833333333333333*G4_27_29 - 0.0833333333333333*G4_29_27 - 0.166666666666667*G4_29_29 + 0.0458333333333333*G5_15_26 + 0.075*G5_15_31 - 0.0375*G5_15_32 + 0.0458333333333333*G5_17_28 - 0.0375*G5_17_31 + 0.075*G5_17_32 + 0.0166666666666666*G5_19_26 + 0.0166666666666666*G5_19_28 + 0.15*G5_19_31 + 0.15*G5_19_32 + 0.0458333333333333*G5_21_36 + 0.075*G5_21_41 - 0.0375*G5_21_42 + 0.0458333333333333*G5_23_38 - 0.0375*G5_23_41 + 0.075*G5_23_42 + 0.0166666666666666*G5_25_36 + 0.0166666666666666*G5_25_38 + 0.15*G5_25_41 + 0.15*G5_25_42 + 0.0833333333333333*G5_27_46 + 0.166666666666667*G5_27_50 + 0.0833333333333333*G5_29_48 + 0.166666666666667*G5_29_50 - 0.0666666666666667*G6_1_1 + 0.0166666666666666*G6_1_2 - 0.0333333333333333*G6_1_3 + 0.0166666666666666*G6_2_1 - 0.0666666666666667*G6_2_2 - 0.0333333333333333*G6_2_3 - 0.0333333333333333*G6_3_1 - 0.0333333333333333*G6_3_2 - 0.266666666666666*G6_3_3 - 0.0666666666666667*G6_7_7 + 0.0166666666666666*G6_7_8 - 0.0333333333333333*G6_7_9 + 0.0166666666666666*G6_8_7 - 0.0666666666666667*G6_8_8 - 0.0333333333333333*G6_8_9 - 0.0333333333333333*G6_9_7 - 0.0333333333333333*G6_9_8 - 0.266666666666666*G6_9_9 - 0.166666666666667*G6_13_13 - 0.0833333333333333*G6_13_14 - 0.0833333333333333*G6_14_13 - 0.166666666666667*G6_14_14 + 0.0458333333333333*G7_1_1 + 0.075*G7_1_3 - 0.0375*G7_1_4 + 0.0458333333333333*G7_2_2 - 0.0375*G7_2_3 + 0.075*G7_2_4 + 0.0166666666666666*G7_3_1 + 0.0166666666666666*G7_3_2 + 0.15*G7_3_3 + 0.15*G7_3_4 + 0.0458333333333333*G7_7_11 + 0.075*G7_7_13 - 0.0375*G7_7_14 + 0.0458333333333333*G7_8_12 - 0.0375*G7_8_13 + 0.075*G7_8_14 + 0.0166666666666666*G7_9_11 + 0.0166666666666666*G7_9_12 + 0.15*G7_9_13 + 0.15*G7_9_14 + 0.0833333333333333*G7_13_21 + 0.166666666666667*G7_13_23 + 0.0833333333333333*G7_14_22 + 0.166666666666667*G7_14_23;
        A[1] = -0.0666666666666666*G0_15_15 + 0.0166666666666666*G0_15_17 - 0.0333333333333333*G0_15_19 + 0.0166666666666666*G0_17_15 - 0.0666666666666667*G0_17_17 - 0.0333333333333333*G0_17_19 - 0.0333333333333333*G0_19_15 - 0.0333333333333333*G0_19_17 - 0.266666666666666*G0_19_19 - 0.0666666666666666*G0_21_21 + 0.0166666666666666*G0_21_23 - 0.0333333333333333*G0_21_25 + 0.0166666666666666*G0_23_21 - 0.0666666666666667*G0_23_23 - 0.0333333333333333*G0_23_25 - 0.0333333333333333*G0_25_21 - 0.0333333333333333*G0_25_23 - 0.266666666666666*G0_25_25 - 0.166666666666667*G0_27_27 - 0.0833333333333333*G0_27_29 - 0.0833333333333333*G0_29_27 - 0.166666666666667*G0_29_29 + 0.0458333333333333*G1_15_26 + 0.075*G1_15_31 - 0.0375*G1_15_32 + 0.0458333333333333*G1_17_28 - 0.0375*G1_17_31 + 0.075*G1_17_32 + 0.0166666666666666*G1_19_26 + 0.0166666666666666*G1_19_28 + 0.15*G1_19_31 + 0.15*G1_19_32 + 0.0458333333333333*G1_21_36 + 0.075*G1_21_41 - 0.0375*G1_21_42 + 0.0458333333333333*G1_23_38 - 0.0375*G1_23_41 + 0.075*G1_23_42 + 0.0166666666666666*G1_25_36 + 0.0166666666666666*G1_25_38 + 0.15*G1_25_41 + 0.15*G1_25_42 + 0.0833333333333333*G1_27_46 + 0.166666666666667*G1_27_50 + 0.0833333333333333*G1_29_48 + 0.166666666666667*G1_29_50 - 0.0666666666666667*G2_1_1 + 0.0166666666666666*G2_1_2 - 0.0333333333333333*G2_1_3 + 0.0166666666666666*G2_2_1 - 0.0666666666666667*G2_2_2 - 0.0333333333333333*G2_2_3 - 0.0333333333333333*G2_3_1 - 0.0333333333333333*G2_3_2 - 0.266666666666666*G2_3_3 - 0.0666666666666667*G2_7_7 + 0.0166666666666666*G2_7_8 - 0.0333333333333333*G2_7_9 + 0.0166666666666666*G2_8_7 - 0.0666666666666667*G2_8_8 - 0.0333333333333333*G2_8_9 - 0.0333333333333333*G2_9_7 - 0.0333333333333333*G2_9_8 - 0.266666666666666*G2_9_9 - 0.166666666666667*G2_13_13 - 0.0833333333333333*G2_13_14 - 0.0833333333333333*G2_14_13 - 0.166666666666667*G2_14_14 + 0.0458333333333333*G3_1_1 + 0.075*G3_1_3 - 0.0375*G3_1_4 + 0.0458333333333333*G3_2_2 - 0.0375*G3_2_3 + 0.075*G3_2_4 + 0.0166666666666666*G3_3_1 + 0.0166666666666666*G3_3_2 + 0.15*G3_3_3 + 0.15*G3_3_4 + 0.0458333333333333*G3_7_11 + 0.075*G3_7_13 - 0.0375*G3_7_14 + 0.0458333333333333*G3_8_12 - 0.0375*G3_8_13 + 0.075*G3_8_14 + 0.0166666666666666*G3_9_11 + 0.0166666666666666*G3_9_12 + 0.15*G3_9_13 + 0.15*G3_9_14 + 0.0833333333333333*G3_13_21 + 0.166666666666667*G3_13_23 + 0.0833333333333333*G3_14_22 + 0.166666666666667*G3_14_23;
          break;
        }
      case 2:
        {
          A[0] = -0.0666666666666666*G4_15_15 + 0.0166666666666666*G4_15_16 - 0.0333333333333333*G4_15_20 + 0.0166666666666666*G4_16_15 - 0.0666666666666666*G4_16_16 - 0.0333333333333333*G4_16_20 - 0.0333333333333333*G4_20_15 - 0.0333333333333333*G4_20_16 - 0.266666666666667*G4_20_20 - 0.0666666666666666*G4_21_21 + 0.0166666666666666*G4_21_22 - 0.0333333333333333*G4_21_26 + 0.0166666666666666*G4_22_21 - 0.0666666666666666*G4_22_22 - 0.0333333333333333*G4_22_26 - 0.0333333333333333*G4_26_21 - 0.0333333333333333*G4_26_22 - 0.266666666666667*G4_26_26 - 0.166666666666667*G4_27_27 - 0.0833333333333333*G4_27_28 - 0.0833333333333333*G4_28_27 - 0.166666666666667*G4_28_28 + 0.0458333333333333*G5_15_26 + 0.0749999999999999*G5_15_33 - 0.0375*G5_15_34 + 0.0458333333333333*G5_16_27 - 0.0375*G5_16_33 + 0.075*G5_16_34 + 0.0166666666666666*G5_20_26 + 0.0166666666666666*G5_20_27 + 0.15*G5_20_33 + 0.15*G5_20_34 + 0.0458333333333333*G5_21_36 + 0.0749999999999999*G5_21_43 - 0.0375*G5_21_44 + 0.0458333333333333*G5_22_37 - 0.0375*G5_22_43 + 0.075*G5_22_44 + 0.0166666666666666*G5_26_36 + 0.0166666666666666*G5_26_37 + 0.15*G5_26_43 + 0.15*G5_26_44 + 0.0833333333333333*G5_27_46 + 0.166666666666667*G5_27_51 + 0.0833333333333333*G5_28_47 + 0.166666666666667*G5_28_51 - 0.0666666666666667*G6_1_1 + 0.0166666666666666*G6_1_2 - 0.0333333333333333*G6_1_3 + 0.0166666666666666*G6_2_1 - 0.0666666666666667*G6_2_2 - 0.0333333333333333*G6_2_3 - 0.0333333333333333*G6_3_1 - 0.0333333333333333*G6_3_2 - 0.266666666666666*G6_3_3 - 0.0666666666666667*G6_7_7 + 0.0166666666666666*G6_7_8 - 0.0333333333333333*G6_7_9 + 0.0166666666666666*G6_8_7 - 0.0666666666666667*G6_8_8 - 0.0333333333333333*G6_8_9 - 0.0333333333333333*G6_9_7 - 0.0333333333333333*G6_9_8 - 0.266666666666666*G6_9_9 - 0.166666666666667*G6_13_13 - 0.0833333333333333*G6_13_14 - 0.0833333333333333*G6_14_13 - 0.166666666666667*G6_14_14 + 0.0458333333333333*G7_1_1 + 0.075*G7_1_3 - 0.0375*G7_1_4 + 0.0458333333333333*G7_2_2 - 0.0375*G7_2_3 + 0.075*G7_2_4 + 0.0166666666666666*G7_3_1 + 0.0166666666666666*G7_3_2 + 0.15*G7_3_3 + 0.15*G7_3_4 + 0.0458333333333333*G7_7_11 + 0.075*G7_7_13 - 0.0375*G7_7_14 + 0.0458333333333333*G7_8_12 - 0.0375*G7_8_13 + 0.075*G7_8_14 + 0.0166666666666666*G7_9_11 + 0.0166666666666666*G7_9_12 + 0.15*G7_9_13 + 0.15*G7_9_14 + 0.0833333333333333*G7_13_21 + 0.166666666666667*G7_13_23 + 0.0833333333333333*G7_14_22 + 0.166666666666667*G7_14_23;
        A[1] = -0.0666666666666666*G0_15_15 + 0.0166666666666666*G0_15_16 - 0.0333333333333333*G0_15_20 + 0.0166666666666666*G0_16_15 - 0.0666666666666666*G0_16_16 - 0.0333333333333333*G0_16_20 - 0.0333333333333333*G0_20_15 - 0.0333333333333333*G0_20_16 - 0.266666666666667*G0_20_20 - 0.0666666666666666*G0_21_21 + 0.0166666666666666*G0_21_22 - 0.0333333333333333*G0_21_26 + 0.0166666666666666*G0_22_21 - 0.0666666666666666*G0_22_22 - 0.0333333333333333*G0_22_26 - 0.0333333333333333*G0_26_21 - 0.0333333333333333*G0_26_22 - 0.266666666666667*G0_26_26 - 0.166666666666667*G0_27_27 - 0.0833333333333333*G0_27_28 - 0.0833333333333333*G0_28_27 - 0.166666666666667*G0_28_28 + 0.0458333333333333*G1_15_26 + 0.0749999999999999*G1_15_33 - 0.0375*G1_15_34 + 0.0458333333333333*G1_16_27 - 0.0375*G1_16_33 + 0.075*G1_16_34 + 0.0166666666666666*G1_20_26 + 0.0166666666666666*G1_20_27 + 0.15*G1_20_33 + 0.15*G1_20_34 + 0.0458333333333333*G1_21_36 + 0.0749999999999999*G1_21_43 - 0.0375*G1_21_44 + 0.0458333333333333*G1_22_37 - 0.0375*G1_22_43 + 0.075*G1_22_44 + 0.0166666666666666*G1_26_36 + 0.0166666666666666*G1_26_37 + 0.15*G1_26_43 + 0.15*G1_26_44 + 0.0833333333333333*G1_27_46 + 0.166666666666667*G1_27_51 + 0.0833333333333333*G1_28_47 + 0.166666666666667*G1_28_51 - 0.0666666666666667*G2_1_1 + 0.0166666666666666*G2_1_2 - 0.0333333333333333*G2_1_3 + 0.0166666666666666*G2_2_1 - 0.0666666666666667*G2_2_2 - 0.0333333333333333*G2_2_3 - 0.0333333333333333*G2_3_1 - 0.0333333333333333*G2_3_2 - 0.266666666666666*G2_3_3 - 0.0666666666666667*G2_7_7 + 0.0166666666666666*G2_7_8 - 0.0333333333333333*G2_7_9 + 0.0166666666666666*G2_8_7 - 0.0666666666666667*G2_8_8 - 0.0333333333333333*G2_8_9 - 0.0333333333333333*G2_9_7 - 0.0333333333333333*G2_9_8 - 0.266666666666666*G2_9_9 - 0.166666666666667*G2_13_13 - 0.0833333333333333*G2_13_14 - 0.0833333333333333*G2_14_13 - 0.166666666666667*G2_14_14 + 0.0458333333333333*G3_1_1 + 0.075*G3_1_3 - 0.0375*G3_1_4 + 0.0458333333333333*G3_2_2 - 0.0375*G3_2_3 + 0.075*G3_2_4 + 0.0166666666666666*G3_3_1 + 0.0166666666666666*G3_3_2 + 0.15*G3_3_3 + 0.15*G3_3_4 + 0.0458333333333333*G3_7_11 + 0.075*G3_7_13 - 0.0375*G3_7_14 + 0.0458333333333333*G3_8_12 - 0.0375*G3_8_13 + 0.075*G3_8_14 + 0.0166666666666666*G3_9_11 + 0.0166666666666666*G3_9_12 + 0.15*G3_9_13 + 0.15*G3_9_14 + 0.0833333333333333*G3_13_21 + 0.166666666666667*G3_13_23 + 0.0833333333333333*G3_14_22 + 0.166666666666667*G3_14_23;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        switch (facet_1)
      {
      case 0:
        {
          A[0] = -0.0666666666666667*G4_16_16 + 0.0166666666666666*G4_16_17 - 0.0333333333333333*G4_16_18 + 0.0166666666666666*G4_17_16 - 0.0666666666666667*G4_17_17 - 0.0333333333333333*G4_17_18 - 0.0333333333333333*G4_18_16 - 0.0333333333333333*G4_18_17 - 0.266666666666666*G4_18_18 - 0.0666666666666667*G4_22_22 + 0.0166666666666666*G4_22_23 - 0.0333333333333333*G4_22_24 + 0.0166666666666666*G4_23_22 - 0.0666666666666667*G4_23_23 - 0.0333333333333333*G4_23_24 - 0.0333333333333333*G4_24_22 - 0.0333333333333333*G4_24_23 - 0.266666666666666*G4_24_24 - 0.166666666666667*G4_28_28 - 0.0833333333333333*G4_28_29 - 0.0833333333333333*G4_29_28 - 0.166666666666667*G4_29_29 + 0.0458333333333333*G5_16_27 + 0.075*G5_16_29 - 0.0375*G5_16_30 + 0.0458333333333333*G5_17_28 - 0.0375*G5_17_29 + 0.075*G5_17_30 + 0.0166666666666666*G5_18_27 + 0.0166666666666666*G5_18_28 + 0.15*G5_18_29 + 0.15*G5_18_30 + 0.0458333333333333*G5_22_37 + 0.075*G5_22_39 - 0.0375*G5_22_40 + 0.0458333333333333*G5_23_38 - 0.0375*G5_23_39 + 0.075*G5_23_40 + 0.0166666666666666*G5_24_37 + 0.0166666666666666*G5_24_38 + 0.15*G5_24_39 + 0.15*G5_24_40 + 0.0833333333333333*G5_28_47 + 0.166666666666667*G5_28_49 + 0.0833333333333333*G5_29_48 + 0.166666666666667*G5_29_49 - 0.0666666666666666*G6_0_0 + 0.0166666666666666*G6_0_2 - 0.0333333333333333*G6_0_4 + 0.0166666666666666*G6_2_0 - 0.0666666666666667*G6_2_2 - 0.0333333333333333*G6_2_4 - 0.0333333333333333*G6_4_0 - 0.0333333333333333*G6_4_2 - 0.266666666666666*G6_4_4 - 0.0666666666666666*G6_6_6 + 0.0166666666666666*G6_6_8 - 0.0333333333333333*G6_6_10 + 0.0166666666666666*G6_8_6 - 0.0666666666666667*G6_8_8 - 0.0333333333333333*G6_8_10 - 0.0333333333333333*G6_10_6 - 0.0333333333333333*G6_10_8 - 0.266666666666666*G6_10_10 - 0.166666666666667*G6_12_12 - 0.0833333333333333*G6_12_14 - 0.0833333333333333*G6_14_12 - 0.166666666666667*G6_14_14 + 0.0458333333333333*G7_0_0 + 0.075*G7_0_5 - 0.0375*G7_0_6 + 0.0458333333333333*G7_2_2 - 0.0375*G7_2_5 + 0.075*G7_2_6 + 0.0166666666666666*G7_4_0 + 0.0166666666666666*G7_4_2 + 0.15*G7_4_5 + 0.15*G7_4_6 + 0.0458333333333333*G7_6_10 + 0.075*G7_6_15 - 0.0375*G7_6_16 + 0.0458333333333333*G7_8_12 - 0.0375*G7_8_15 + 0.075*G7_8_16 + 0.0166666666666666*G7_10_10 + 0.0166666666666666*G7_10_12 + 0.15*G7_10_15 + 0.15*G7_10_16 + 0.0833333333333333*G7_12_20 + 0.166666666666667*G7_12_24 + 0.0833333333333333*G7_14_22 + 0.166666666666667*G7_14_24;
        A[1] = -0.0666666666666667*G0_16_16 + 0.0166666666666666*G0_16_17 - 0.0333333333333333*G0_16_18 + 0.0166666666666666*G0_17_16 - 0.0666666666666667*G0_17_17 - 0.0333333333333333*G0_17_18 - 0.0333333333333333*G0_18_16 - 0.0333333333333333*G0_18_17 - 0.266666666666666*G0_18_18 - 0.0666666666666667*G0_22_22 + 0.0166666666666666*G0_22_23 - 0.0333333333333333*G0_22_24 + 0.0166666666666666*G0_23_22 - 0.0666666666666667*G0_23_23 - 0.0333333333333333*G0_23_24 - 0.0333333333333333*G0_24_22 - 0.0333333333333333*G0_24_23 - 0.266666666666666*G0_24_24 - 0.166666666666667*G0_28_28 - 0.0833333333333333*G0_28_29 - 0.0833333333333333*G0_29_28 - 0.166666666666667*G0_29_29 + 0.0458333333333333*G1_16_27 + 0.075*G1_16_29 - 0.0375*G1_16_30 + 0.0458333333333333*G1_17_28 - 0.0375*G1_17_29 + 0.075*G1_17_30 + 0.0166666666666666*G1_18_27 + 0.0166666666666666*G1_18_28 + 0.15*G1_18_29 + 0.15*G1_18_30 + 0.0458333333333333*G1_22_37 + 0.075*G1_22_39 - 0.0375*G1_22_40 + 0.0458333333333333*G1_23_38 - 0.0375*G1_23_39 + 0.075*G1_23_40 + 0.0166666666666666*G1_24_37 + 0.0166666666666666*G1_24_38 + 0.15*G1_24_39 + 0.15*G1_24_40 + 0.0833333333333333*G1_28_47 + 0.166666666666667*G1_28_49 + 0.0833333333333333*G1_29_48 + 0.166666666666667*G1_29_49 - 0.0666666666666666*G2_0_0 + 0.0166666666666666*G2_0_2 - 0.0333333333333333*G2_0_4 + 0.0166666666666666*G2_2_0 - 0.0666666666666667*G2_2_2 - 0.0333333333333333*G2_2_4 - 0.0333333333333333*G2_4_0 - 0.0333333333333333*G2_4_2 - 0.266666666666666*G2_4_4 - 0.0666666666666666*G2_6_6 + 0.0166666666666666*G2_6_8 - 0.0333333333333333*G2_6_10 + 0.0166666666666666*G2_8_6 - 0.0666666666666667*G2_8_8 - 0.0333333333333333*G2_8_10 - 0.0333333333333333*G2_10_6 - 0.0333333333333333*G2_10_8 - 0.266666666666666*G2_10_10 - 0.166666666666667*G2_12_12 - 0.0833333333333333*G2_12_14 - 0.0833333333333333*G2_14_12 - 0.166666666666667*G2_14_14 + 0.0458333333333333*G3_0_0 + 0.075*G3_0_5 - 0.0375*G3_0_6 + 0.0458333333333333*G3_2_2 - 0.0375*G3_2_5 + 0.075*G3_2_6 + 0.0166666666666666*G3_4_0 + 0.0166666666666666*G3_4_2 + 0.15*G3_4_5 + 0.15*G3_4_6 + 0.0458333333333333*G3_6_10 + 0.075*G3_6_15 - 0.0375*G3_6_16 + 0.0458333333333333*G3_8_12 - 0.0375*G3_8_15 + 0.075*G3_8_16 + 0.0166666666666666*G3_10_10 + 0.0166666666666666*G3_10_12 + 0.15*G3_10_15 + 0.15*G3_10_16 + 0.0833333333333333*G3_12_20 + 0.166666666666667*G3_12_24 + 0.0833333333333333*G3_14_22 + 0.166666666666667*G3_14_24;
          break;
        }
      case 1:
        {
          A[0] = -0.0666666666666666*G4_15_15 + 0.0166666666666666*G4_15_17 - 0.0333333333333333*G4_15_19 + 0.0166666666666666*G4_17_15 - 0.0666666666666667*G4_17_17 - 0.0333333333333333*G4_17_19 - 0.0333333333333333*G4_19_15 - 0.0333333333333333*G4_19_17 - 0.266666666666666*G4_19_19 - 0.0666666666666666*G4_21_21 + 0.0166666666666666*G4_21_23 - 0.0333333333333333*G4_21_25 + 0.0166666666666666*G4_23_21 - 0.0666666666666667*G4_23_23 - 0.0333333333333333*G4_23_25 - 0.0333333333333333*G4_25_21 - 0.0333333333333333*G4_25_23 - 0.266666666666666*G4_25_25 - 0.166666666666667*G4_27_27 - 0.0833333333333333*G4_27_29 - 0.0833333333333333*G4_29_27 - 0.166666666666667*G4_29_29 + 0.0458333333333333*G5_15_26 + 0.075*G5_15_31 - 0.0375*G5_15_32 + 0.0458333333333333*G5_17_28 - 0.0375*G5_17_31 + 0.075*G5_17_32 + 0.0166666666666666*G5_19_26 + 0.0166666666666666*G5_19_28 + 0.15*G5_19_31 + 0.15*G5_19_32 + 0.0458333333333333*G5_21_36 + 0.075*G5_21_41 - 0.0375*G5_21_42 + 0.0458333333333333*G5_23_38 - 0.0375*G5_23_41 + 0.075*G5_23_42 + 0.0166666666666666*G5_25_36 + 0.0166666666666666*G5_25_38 + 0.15*G5_25_41 + 0.15*G5_25_42 + 0.0833333333333333*G5_27_46 + 0.166666666666667*G5_27_50 + 0.0833333333333333*G5_29_48 + 0.166666666666667*G5_29_50 - 0.0666666666666666*G6_0_0 + 0.0166666666666666*G6_0_2 - 0.0333333333333333*G6_0_4 + 0.0166666666666666*G6_2_0 - 0.0666666666666667*G6_2_2 - 0.0333333333333333*G6_2_4 - 0.0333333333333333*G6_4_0 - 0.0333333333333333*G6_4_2 - 0.266666666666666*G6_4_4 - 0.0666666666666666*G6_6_6 + 0.0166666666666666*G6_6_8 - 0.0333333333333333*G6_6_10 + 0.0166666666666666*G6_8_6 - 0.0666666666666667*G6_8_8 - 0.0333333333333333*G6_8_10 - 0.0333333333333333*G6_10_6 - 0.0333333333333333*G6_10_8 - 0.266666666666666*G6_10_10 - 0.166666666666667*G6_12_12 - 0.0833333333333333*G6_12_14 - 0.0833333333333333*G6_14_12 - 0.166666666666667*G6_14_14 + 0.0458333333333333*G7_0_0 + 0.075*G7_0_5 - 0.0375*G7_0_6 + 0.0458333333333333*G7_2_2 - 0.0375*G7_2_5 + 0.075*G7_2_6 + 0.0166666666666666*G7_4_0 + 0.0166666666666666*G7_4_2 + 0.15*G7_4_5 + 0.15*G7_4_6 + 0.0458333333333333*G7_6_10 + 0.075*G7_6_15 - 0.0375*G7_6_16 + 0.0458333333333333*G7_8_12 - 0.0375*G7_8_15 + 0.075*G7_8_16 + 0.0166666666666666*G7_10_10 + 0.0166666666666666*G7_10_12 + 0.15*G7_10_15 + 0.15*G7_10_16 + 0.0833333333333333*G7_12_20 + 0.166666666666667*G7_12_24 + 0.0833333333333333*G7_14_22 + 0.166666666666667*G7_14_24;
        A[1] = -0.0666666666666666*G0_15_15 + 0.0166666666666666*G0_15_17 - 0.0333333333333333*G0_15_19 + 0.0166666666666666*G0_17_15 - 0.0666666666666667*G0_17_17 - 0.0333333333333333*G0_17_19 - 0.0333333333333333*G0_19_15 - 0.0333333333333333*G0_19_17 - 0.266666666666666*G0_19_19 - 0.0666666666666666*G0_21_21 + 0.0166666666666666*G0_21_23 - 0.0333333333333333*G0_21_25 + 0.0166666666666666*G0_23_21 - 0.0666666666666667*G0_23_23 - 0.0333333333333333*G0_23_25 - 0.0333333333333333*G0_25_21 - 0.0333333333333333*G0_25_23 - 0.266666666666666*G0_25_25 - 0.166666666666667*G0_27_27 - 0.0833333333333333*G0_27_29 - 0.0833333333333333*G0_29_27 - 0.166666666666667*G0_29_29 + 0.0458333333333333*G1_15_26 + 0.075*G1_15_31 - 0.0375*G1_15_32 + 0.0458333333333333*G1_17_28 - 0.0375*G1_17_31 + 0.075*G1_17_32 + 0.0166666666666666*G1_19_26 + 0.0166666666666666*G1_19_28 + 0.15*G1_19_31 + 0.15*G1_19_32 + 0.0458333333333333*G1_21_36 + 0.075*G1_21_41 - 0.0375*G1_21_42 + 0.0458333333333333*G1_23_38 - 0.0375*G1_23_41 + 0.075*G1_23_42 + 0.0166666666666666*G1_25_36 + 0.0166666666666666*G1_25_38 + 0.15*G1_25_41 + 0.15*G1_25_42 + 0.0833333333333333*G1_27_46 + 0.166666666666667*G1_27_50 + 0.0833333333333333*G1_29_48 + 0.166666666666667*G1_29_50 - 0.0666666666666666*G2_0_0 + 0.0166666666666666*G2_0_2 - 0.0333333333333333*G2_0_4 + 0.0166666666666666*G2_2_0 - 0.0666666666666667*G2_2_2 - 0.0333333333333333*G2_2_4 - 0.0333333333333333*G2_4_0 - 0.0333333333333333*G2_4_2 - 0.266666666666666*G2_4_4 - 0.0666666666666666*G2_6_6 + 0.0166666666666666*G2_6_8 - 0.0333333333333333*G2_6_10 + 0.0166666666666666*G2_8_6 - 0.0666666666666667*G2_8_8 - 0.0333333333333333*G2_8_10 - 0.0333333333333333*G2_10_6 - 0.0333333333333333*G2_10_8 - 0.266666666666666*G2_10_10 - 0.166666666666667*G2_12_12 - 0.0833333333333333*G2_12_14 - 0.0833333333333333*G2_14_12 - 0.166666666666667*G2_14_14 + 0.0458333333333333*G3_0_0 + 0.075*G3_0_5 - 0.0375*G3_0_6 + 0.0458333333333333*G3_2_2 - 0.0375*G3_2_5 + 0.075*G3_2_6 + 0.0166666666666666*G3_4_0 + 0.0166666666666666*G3_4_2 + 0.15*G3_4_5 + 0.15*G3_4_6 + 0.0458333333333333*G3_6_10 + 0.075*G3_6_15 - 0.0375*G3_6_16 + 0.0458333333333333*G3_8_12 - 0.0375*G3_8_15 + 0.075*G3_8_16 + 0.0166666666666666*G3_10_10 + 0.0166666666666666*G3_10_12 + 0.15*G3_10_15 + 0.15*G3_10_16 + 0.0833333333333333*G3_12_20 + 0.166666666666667*G3_12_24 + 0.0833333333333333*G3_14_22 + 0.166666666666667*G3_14_24;
          break;
        }
      case 2:
        {
          A[0] = -0.0666666666666666*G4_15_15 + 0.0166666666666666*G4_15_16 - 0.0333333333333333*G4_15_20 + 0.0166666666666666*G4_16_15 - 0.0666666666666666*G4_16_16 - 0.0333333333333333*G4_16_20 - 0.0333333333333333*G4_20_15 - 0.0333333333333333*G4_20_16 - 0.266666666666667*G4_20_20 - 0.0666666666666666*G4_21_21 + 0.0166666666666666*G4_21_22 - 0.0333333333333333*G4_21_26 + 0.0166666666666666*G4_22_21 - 0.0666666666666666*G4_22_22 - 0.0333333333333333*G4_22_26 - 0.0333333333333333*G4_26_21 - 0.0333333333333333*G4_26_22 - 0.266666666666667*G4_26_26 - 0.166666666666667*G4_27_27 - 0.0833333333333333*G4_27_28 - 0.0833333333333333*G4_28_27 - 0.166666666666667*G4_28_28 + 0.0458333333333333*G5_15_26 + 0.0749999999999999*G5_15_33 - 0.0375*G5_15_34 + 0.0458333333333333*G5_16_27 - 0.0375*G5_16_33 + 0.075*G5_16_34 + 0.0166666666666666*G5_20_26 + 0.0166666666666666*G5_20_27 + 0.15*G5_20_33 + 0.15*G5_20_34 + 0.0458333333333333*G5_21_36 + 0.0749999999999999*G5_21_43 - 0.0375*G5_21_44 + 0.0458333333333333*G5_22_37 - 0.0375*G5_22_43 + 0.075*G5_22_44 + 0.0166666666666666*G5_26_36 + 0.0166666666666666*G5_26_37 + 0.15*G5_26_43 + 0.15*G5_26_44 + 0.0833333333333333*G5_27_46 + 0.166666666666667*G5_27_51 + 0.0833333333333333*G5_28_47 + 0.166666666666667*G5_28_51 - 0.0666666666666666*G6_0_0 + 0.0166666666666666*G6_0_2 - 0.0333333333333333*G6_0_4 + 0.0166666666666666*G6_2_0 - 0.0666666666666667*G6_2_2 - 0.0333333333333333*G6_2_4 - 0.0333333333333333*G6_4_0 - 0.0333333333333333*G6_4_2 - 0.266666666666666*G6_4_4 - 0.0666666666666666*G6_6_6 + 0.0166666666666666*G6_6_8 - 0.0333333333333333*G6_6_10 + 0.0166666666666666*G6_8_6 - 0.0666666666666667*G6_8_8 - 0.0333333333333333*G6_8_10 - 0.0333333333333333*G6_10_6 - 0.0333333333333333*G6_10_8 - 0.266666666666666*G6_10_10 - 0.166666666666667*G6_12_12 - 0.0833333333333333*G6_12_14 - 0.0833333333333333*G6_14_12 - 0.166666666666667*G6_14_14 + 0.0458333333333333*G7_0_0 + 0.075*G7_0_5 - 0.0375*G7_0_6 + 0.0458333333333333*G7_2_2 - 0.0375*G7_2_5 + 0.075*G7_2_6 + 0.0166666666666666*G7_4_0 + 0.0166666666666666*G7_4_2 + 0.15*G7_4_5 + 0.15*G7_4_6 + 0.0458333333333333*G7_6_10 + 0.075*G7_6_15 - 0.0375*G7_6_16 + 0.0458333333333333*G7_8_12 - 0.0375*G7_8_15 + 0.075*G7_8_16 + 0.0166666666666666*G7_10_10 + 0.0166666666666666*G7_10_12 + 0.15*G7_10_15 + 0.15*G7_10_16 + 0.0833333333333333*G7_12_20 + 0.166666666666667*G7_12_24 + 0.0833333333333333*G7_14_22 + 0.166666666666667*G7_14_24;
        A[1] = -0.0666666666666666*G0_15_15 + 0.0166666666666666*G0_15_16 - 0.0333333333333333*G0_15_20 + 0.0166666666666666*G0_16_15 - 0.0666666666666666*G0_16_16 - 0.0333333333333333*G0_16_20 - 0.0333333333333333*G0_20_15 - 0.0333333333333333*G0_20_16 - 0.266666666666667*G0_20_20 - 0.0666666666666666*G0_21_21 + 0.0166666666666666*G0_21_22 - 0.0333333333333333*G0_21_26 + 0.0166666666666666*G0_22_21 - 0.0666666666666666*G0_22_22 - 0.0333333333333333*G0_22_26 - 0.0333333333333333*G0_26_21 - 0.0333333333333333*G0_26_22 - 0.266666666666667*G0_26_26 - 0.166666666666667*G0_27_27 - 0.0833333333333333*G0_27_28 - 0.0833333333333333*G0_28_27 - 0.166666666666667*G0_28_28 + 0.0458333333333333*G1_15_26 + 0.0749999999999999*G1_15_33 - 0.0375*G1_15_34 + 0.0458333333333333*G1_16_27 - 0.0375*G1_16_33 + 0.075*G1_16_34 + 0.0166666666666666*G1_20_26 + 0.0166666666666666*G1_20_27 + 0.15*G1_20_33 + 0.15*G1_20_34 + 0.0458333333333333*G1_21_36 + 0.0749999999999999*G1_21_43 - 0.0375*G1_21_44 + 0.0458333333333333*G1_22_37 - 0.0375*G1_22_43 + 0.075*G1_22_44 + 0.0166666666666666*G1_26_36 + 0.0166666666666666*G1_26_37 + 0.15*G1_26_43 + 0.15*G1_26_44 + 0.0833333333333333*G1_27_46 + 0.166666666666667*G1_27_51 + 0.0833333333333333*G1_28_47 + 0.166666666666667*G1_28_51 - 0.0666666666666666*G2_0_0 + 0.0166666666666666*G2_0_2 - 0.0333333333333333*G2_0_4 + 0.0166666666666666*G2_2_0 - 0.0666666666666667*G2_2_2 - 0.0333333333333333*G2_2_4 - 0.0333333333333333*G2_4_0 - 0.0333333333333333*G2_4_2 - 0.266666666666666*G2_4_4 - 0.0666666666666666*G2_6_6 + 0.0166666666666666*G2_6_8 - 0.0333333333333333*G2_6_10 + 0.0166666666666666*G2_8_6 - 0.0666666666666667*G2_8_8 - 0.0333333333333333*G2_8_10 - 0.0333333333333333*G2_10_6 - 0.0333333333333333*G2_10_8 - 0.266666666666666*G2_10_10 - 0.166666666666667*G2_12_12 - 0.0833333333333333*G2_12_14 - 0.0833333333333333*G2_14_12 - 0.166666666666667*G2_14_14 + 0.0458333333333333*G3_0_0 + 0.075*G3_0_5 - 0.0375*G3_0_6 + 0.0458333333333333*G3_2_2 - 0.0375*G3_2_5 + 0.075*G3_2_6 + 0.0166666666666666*G3_4_0 + 0.0166666666666666*G3_4_2 + 0.15*G3_4_5 + 0.15*G3_4_6 + 0.0458333333333333*G3_6_10 + 0.075*G3_6_15 - 0.0375*G3_6_16 + 0.0458333333333333*G3_8_12 - 0.0375*G3_8_15 + 0.075*G3_8_16 + 0.0166666666666666*G3_10_10 + 0.0166666666666666*G3_10_12 + 0.15*G3_10_15 + 0.15*G3_10_16 + 0.0833333333333333*G3_12_20 + 0.166666666666667*G3_12_24 + 0.0833333333333333*G3_14_22 + 0.166666666666667*G3_14_24;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        switch (facet_1)
      {
      case 0:
        {
          A[0] = -0.0666666666666667*G4_16_16 + 0.0166666666666666*G4_16_17 - 0.0333333333333333*G4_16_18 + 0.0166666666666666*G4_17_16 - 0.0666666666666667*G4_17_17 - 0.0333333333333333*G4_17_18 - 0.0333333333333333*G4_18_16 - 0.0333333333333333*G4_18_17 - 0.266666666666666*G4_18_18 - 0.0666666666666667*G4_22_22 + 0.0166666666666666*G4_22_23 - 0.0333333333333333*G4_22_24 + 0.0166666666666666*G4_23_22 - 0.0666666666666667*G4_23_23 - 0.0333333333333333*G4_23_24 - 0.0333333333333333*G4_24_22 - 0.0333333333333333*G4_24_23 - 0.266666666666666*G4_24_24 - 0.166666666666667*G4_28_28 - 0.0833333333333333*G4_28_29 - 0.0833333333333333*G4_29_28 - 0.166666666666667*G4_29_29 + 0.0458333333333333*G5_16_27 + 0.075*G5_16_29 - 0.0375*G5_16_30 + 0.0458333333333333*G5_17_28 - 0.0375*G5_17_29 + 0.075*G5_17_30 + 0.0166666666666666*G5_18_27 + 0.0166666666666666*G5_18_28 + 0.15*G5_18_29 + 0.15*G5_18_30 + 0.0458333333333333*G5_22_37 + 0.075*G5_22_39 - 0.0375*G5_22_40 + 0.0458333333333333*G5_23_38 - 0.0375*G5_23_39 + 0.075*G5_23_40 + 0.0166666666666666*G5_24_37 + 0.0166666666666666*G5_24_38 + 0.15*G5_24_39 + 0.15*G5_24_40 + 0.0833333333333333*G5_28_47 + 0.166666666666667*G5_28_49 + 0.0833333333333333*G5_29_48 + 0.166666666666667*G5_29_49 - 0.0666666666666666*G6_0_0 + 0.0166666666666666*G6_0_1 - 0.0333333333333333*G6_0_5 + 0.0166666666666666*G6_1_0 - 0.0666666666666666*G6_1_1 - 0.0333333333333333*G6_1_5 - 0.0333333333333333*G6_5_0 - 0.0333333333333333*G6_5_1 - 0.266666666666667*G6_5_5 - 0.0666666666666666*G6_6_6 + 0.0166666666666666*G6_6_7 - 0.0333333333333333*G6_6_11 + 0.0166666666666666*G6_7_6 - 0.0666666666666666*G6_7_7 - 0.0333333333333333*G6_7_11 - 0.0333333333333333*G6_11_6 - 0.0333333333333333*G6_11_7 - 0.266666666666667*G6_11_11 - 0.166666666666667*G6_12_12 - 0.0833333333333333*G6_12_13 - 0.0833333333333333*G6_13_12 - 0.166666666666667*G6_13_13 + 0.0458333333333333*G7_0_0 + 0.0749999999999999*G7_0_7 - 0.0375*G7_0_8 + 0.0458333333333333*G7_1_1 - 0.0375*G7_1_7 + 0.075*G7_1_8 + 0.0166666666666666*G7_5_0 + 0.0166666666666666*G7_5_1 + 0.15*G7_5_7 + 0.15*G7_5_8 + 0.0458333333333333*G7_6_10 + 0.0749999999999999*G7_6_17 - 0.0375*G7_6_18 + 0.0458333333333333*G7_7_11 - 0.0375*G7_7_17 + 0.075*G7_7_18 + 0.0166666666666666*G7_11_10 + 0.0166666666666666*G7_11_11 + 0.15*G7_11_17 + 0.15*G7_11_18 + 0.0833333333333333*G7_12_20 + 0.166666666666667*G7_12_25 + 0.0833333333333333*G7_13_21 + 0.166666666666667*G7_13_25;
        A[1] = -0.0666666666666667*G0_16_16 + 0.0166666666666666*G0_16_17 - 0.0333333333333333*G0_16_18 + 0.0166666666666666*G0_17_16 - 0.0666666666666667*G0_17_17 - 0.0333333333333333*G0_17_18 - 0.0333333333333333*G0_18_16 - 0.0333333333333333*G0_18_17 - 0.266666666666666*G0_18_18 - 0.0666666666666667*G0_22_22 + 0.0166666666666666*G0_22_23 - 0.0333333333333333*G0_22_24 + 0.0166666666666666*G0_23_22 - 0.0666666666666667*G0_23_23 - 0.0333333333333333*G0_23_24 - 0.0333333333333333*G0_24_22 - 0.0333333333333333*G0_24_23 - 0.266666666666666*G0_24_24 - 0.166666666666667*G0_28_28 - 0.0833333333333333*G0_28_29 - 0.0833333333333333*G0_29_28 - 0.166666666666667*G0_29_29 + 0.0458333333333333*G1_16_27 + 0.075*G1_16_29 - 0.0375*G1_16_30 + 0.0458333333333333*G1_17_28 - 0.0375*G1_17_29 + 0.075*G1_17_30 + 0.0166666666666666*G1_18_27 + 0.0166666666666666*G1_18_28 + 0.15*G1_18_29 + 0.15*G1_18_30 + 0.0458333333333333*G1_22_37 + 0.075*G1_22_39 - 0.0375*G1_22_40 + 0.0458333333333333*G1_23_38 - 0.0375*G1_23_39 + 0.075*G1_23_40 + 0.0166666666666666*G1_24_37 + 0.0166666666666666*G1_24_38 + 0.15*G1_24_39 + 0.15*G1_24_40 + 0.0833333333333333*G1_28_47 + 0.166666666666667*G1_28_49 + 0.0833333333333333*G1_29_48 + 0.166666666666667*G1_29_49 - 0.0666666666666666*G2_0_0 + 0.0166666666666666*G2_0_1 - 0.0333333333333333*G2_0_5 + 0.0166666666666666*G2_1_0 - 0.0666666666666666*G2_1_1 - 0.0333333333333333*G2_1_5 - 0.0333333333333333*G2_5_0 - 0.0333333333333333*G2_5_1 - 0.266666666666667*G2_5_5 - 0.0666666666666666*G2_6_6 + 0.0166666666666666*G2_6_7 - 0.0333333333333333*G2_6_11 + 0.0166666666666666*G2_7_6 - 0.0666666666666666*G2_7_7 - 0.0333333333333333*G2_7_11 - 0.0333333333333333*G2_11_6 - 0.0333333333333333*G2_11_7 - 0.266666666666667*G2_11_11 - 0.166666666666667*G2_12_12 - 0.0833333333333333*G2_12_13 - 0.0833333333333333*G2_13_12 - 0.166666666666667*G2_13_13 + 0.0458333333333333*G3_0_0 + 0.0749999999999999*G3_0_7 - 0.0375*G3_0_8 + 0.0458333333333333*G3_1_1 - 0.0375*G3_1_7 + 0.075*G3_1_8 + 0.0166666666666666*G3_5_0 + 0.0166666666666666*G3_5_1 + 0.15*G3_5_7 + 0.15*G3_5_8 + 0.0458333333333333*G3_6_10 + 0.0749999999999999*G3_6_17 - 0.0375*G3_6_18 + 0.0458333333333333*G3_7_11 - 0.0375*G3_7_17 + 0.075*G3_7_18 + 0.0166666666666666*G3_11_10 + 0.0166666666666666*G3_11_11 + 0.15*G3_11_17 + 0.15*G3_11_18 + 0.0833333333333333*G3_12_20 + 0.166666666666667*G3_12_25 + 0.0833333333333333*G3_13_21 + 0.166666666666667*G3_13_25;
          break;
        }
      case 1:
        {
          A[0] = -0.0666666666666666*G4_15_15 + 0.0166666666666666*G4_15_17 - 0.0333333333333333*G4_15_19 + 0.0166666666666666*G4_17_15 - 0.0666666666666667*G4_17_17 - 0.0333333333333333*G4_17_19 - 0.0333333333333333*G4_19_15 - 0.0333333333333333*G4_19_17 - 0.266666666666666*G4_19_19 - 0.0666666666666666*G4_21_21 + 0.0166666666666666*G4_21_23 - 0.0333333333333333*G4_21_25 + 0.0166666666666666*G4_23_21 - 0.0666666666666667*G4_23_23 - 0.0333333333333333*G4_23_25 - 0.0333333333333333*G4_25_21 - 0.0333333333333333*G4_25_23 - 0.266666666666666*G4_25_25 - 0.166666666666667*G4_27_27 - 0.0833333333333333*G4_27_29 - 0.0833333333333333*G4_29_27 - 0.166666666666667*G4_29_29 + 0.0458333333333333*G5_15_26 + 0.075*G5_15_31 - 0.0375*G5_15_32 + 0.0458333333333333*G5_17_28 - 0.0375*G5_17_31 + 0.075*G5_17_32 + 0.0166666666666666*G5_19_26 + 0.0166666666666666*G5_19_28 + 0.15*G5_19_31 + 0.15*G5_19_32 + 0.0458333333333333*G5_21_36 + 0.075*G5_21_41 - 0.0375*G5_21_42 + 0.0458333333333333*G5_23_38 - 0.0375*G5_23_41 + 0.075*G5_23_42 + 0.0166666666666666*G5_25_36 + 0.0166666666666666*G5_25_38 + 0.15*G5_25_41 + 0.15*G5_25_42 + 0.0833333333333333*G5_27_46 + 0.166666666666667*G5_27_50 + 0.0833333333333333*G5_29_48 + 0.166666666666667*G5_29_50 - 0.0666666666666666*G6_0_0 + 0.0166666666666666*G6_0_1 - 0.0333333333333333*G6_0_5 + 0.0166666666666666*G6_1_0 - 0.0666666666666666*G6_1_1 - 0.0333333333333333*G6_1_5 - 0.0333333333333333*G6_5_0 - 0.0333333333333333*G6_5_1 - 0.266666666666667*G6_5_5 - 0.0666666666666666*G6_6_6 + 0.0166666666666666*G6_6_7 - 0.0333333333333333*G6_6_11 + 0.0166666666666666*G6_7_6 - 0.0666666666666666*G6_7_7 - 0.0333333333333333*G6_7_11 - 0.0333333333333333*G6_11_6 - 0.0333333333333333*G6_11_7 - 0.266666666666667*G6_11_11 - 0.166666666666667*G6_12_12 - 0.0833333333333333*G6_12_13 - 0.0833333333333333*G6_13_12 - 0.166666666666667*G6_13_13 + 0.0458333333333333*G7_0_0 + 0.0749999999999999*G7_0_7 - 0.0375*G7_0_8 + 0.0458333333333333*G7_1_1 - 0.0375*G7_1_7 + 0.075*G7_1_8 + 0.0166666666666666*G7_5_0 + 0.0166666666666666*G7_5_1 + 0.15*G7_5_7 + 0.15*G7_5_8 + 0.0458333333333333*G7_6_10 + 0.0749999999999999*G7_6_17 - 0.0375*G7_6_18 + 0.0458333333333333*G7_7_11 - 0.0375*G7_7_17 + 0.075*G7_7_18 + 0.0166666666666666*G7_11_10 + 0.0166666666666666*G7_11_11 + 0.15*G7_11_17 + 0.15*G7_11_18 + 0.0833333333333333*G7_12_20 + 0.166666666666667*G7_12_25 + 0.0833333333333333*G7_13_21 + 0.166666666666667*G7_13_25;
        A[1] = -0.0666666666666666*G0_15_15 + 0.0166666666666666*G0_15_17 - 0.0333333333333333*G0_15_19 + 0.0166666666666666*G0_17_15 - 0.0666666666666667*G0_17_17 - 0.0333333333333333*G0_17_19 - 0.0333333333333333*G0_19_15 - 0.0333333333333333*G0_19_17 - 0.266666666666666*G0_19_19 - 0.0666666666666666*G0_21_21 + 0.0166666666666666*G0_21_23 - 0.0333333333333333*G0_21_25 + 0.0166666666666666*G0_23_21 - 0.0666666666666667*G0_23_23 - 0.0333333333333333*G0_23_25 - 0.0333333333333333*G0_25_21 - 0.0333333333333333*G0_25_23 - 0.266666666666666*G0_25_25 - 0.166666666666667*G0_27_27 - 0.0833333333333333*G0_27_29 - 0.0833333333333333*G0_29_27 - 0.166666666666667*G0_29_29 + 0.0458333333333333*G1_15_26 + 0.075*G1_15_31 - 0.0375*G1_15_32 + 0.0458333333333333*G1_17_28 - 0.0375*G1_17_31 + 0.075*G1_17_32 + 0.0166666666666666*G1_19_26 + 0.0166666666666666*G1_19_28 + 0.15*G1_19_31 + 0.15*G1_19_32 + 0.0458333333333333*G1_21_36 + 0.075*G1_21_41 - 0.0375*G1_21_42 + 0.0458333333333333*G1_23_38 - 0.0375*G1_23_41 + 0.075*G1_23_42 + 0.0166666666666666*G1_25_36 + 0.0166666666666666*G1_25_38 + 0.15*G1_25_41 + 0.15*G1_25_42 + 0.0833333333333333*G1_27_46 + 0.166666666666667*G1_27_50 + 0.0833333333333333*G1_29_48 + 0.166666666666667*G1_29_50 - 0.0666666666666666*G2_0_0 + 0.0166666666666666*G2_0_1 - 0.0333333333333333*G2_0_5 + 0.0166666666666666*G2_1_0 - 0.0666666666666666*G2_1_1 - 0.0333333333333333*G2_1_5 - 0.0333333333333333*G2_5_0 - 0.0333333333333333*G2_5_1 - 0.266666666666667*G2_5_5 - 0.0666666666666666*G2_6_6 + 0.0166666666666666*G2_6_7 - 0.0333333333333333*G2_6_11 + 0.0166666666666666*G2_7_6 - 0.0666666666666666*G2_7_7 - 0.0333333333333333*G2_7_11 - 0.0333333333333333*G2_11_6 - 0.0333333333333333*G2_11_7 - 0.266666666666667*G2_11_11 - 0.166666666666667*G2_12_12 - 0.0833333333333333*G2_12_13 - 0.0833333333333333*G2_13_12 - 0.166666666666667*G2_13_13 + 0.0458333333333333*G3_0_0 + 0.0749999999999999*G3_0_7 - 0.0375*G3_0_8 + 0.0458333333333333*G3_1_1 - 0.0375*G3_1_7 + 0.075*G3_1_8 + 0.0166666666666666*G3_5_0 + 0.0166666666666666*G3_5_1 + 0.15*G3_5_7 + 0.15*G3_5_8 + 0.0458333333333333*G3_6_10 + 0.0749999999999999*G3_6_17 - 0.0375*G3_6_18 + 0.0458333333333333*G3_7_11 - 0.0375*G3_7_17 + 0.075*G3_7_18 + 0.0166666666666666*G3_11_10 + 0.0166666666666666*G3_11_11 + 0.15*G3_11_17 + 0.15*G3_11_18 + 0.0833333333333333*G3_12_20 + 0.166666666666667*G3_12_25 + 0.0833333333333333*G3_13_21 + 0.166666666666667*G3_13_25;
          break;
        }
      case 2:
        {
          A[0] = -0.0666666666666666*G4_15_15 + 0.0166666666666666*G4_15_16 - 0.0333333333333333*G4_15_20 + 0.0166666666666666*G4_16_15 - 0.0666666666666666*G4_16_16 - 0.0333333333333333*G4_16_20 - 0.0333333333333333*G4_20_15 - 0.0333333333333333*G4_20_16 - 0.266666666666667*G4_20_20 - 0.0666666666666666*G4_21_21 + 0.0166666666666666*G4_21_22 - 0.0333333333333333*G4_21_26 + 0.0166666666666666*G4_22_21 - 0.0666666666666666*G4_22_22 - 0.0333333333333333*G4_22_26 - 0.0333333333333333*G4_26_21 - 0.0333333333333333*G4_26_22 - 0.266666666666667*G4_26_26 - 0.166666666666667*G4_27_27 - 0.0833333333333333*G4_27_28 - 0.0833333333333333*G4_28_27 - 0.166666666666667*G4_28_28 + 0.0458333333333333*G5_15_26 + 0.0749999999999999*G5_15_33 - 0.0375*G5_15_34 + 0.0458333333333333*G5_16_27 - 0.0375*G5_16_33 + 0.075*G5_16_34 + 0.0166666666666666*G5_20_26 + 0.0166666666666666*G5_20_27 + 0.15*G5_20_33 + 0.15*G5_20_34 + 0.0458333333333333*G5_21_36 + 0.0749999999999999*G5_21_43 - 0.0375*G5_21_44 + 0.0458333333333333*G5_22_37 - 0.0375*G5_22_43 + 0.075*G5_22_44 + 0.0166666666666666*G5_26_36 + 0.0166666666666666*G5_26_37 + 0.15*G5_26_43 + 0.15*G5_26_44 + 0.0833333333333333*G5_27_46 + 0.166666666666667*G5_27_51 + 0.0833333333333333*G5_28_47 + 0.166666666666667*G5_28_51 - 0.0666666666666666*G6_0_0 + 0.0166666666666666*G6_0_1 - 0.0333333333333333*G6_0_5 + 0.0166666666666666*G6_1_0 - 0.0666666666666666*G6_1_1 - 0.0333333333333333*G6_1_5 - 0.0333333333333333*G6_5_0 - 0.0333333333333333*G6_5_1 - 0.266666666666667*G6_5_5 - 0.0666666666666666*G6_6_6 + 0.0166666666666666*G6_6_7 - 0.0333333333333333*G6_6_11 + 0.0166666666666666*G6_7_6 - 0.0666666666666666*G6_7_7 - 0.0333333333333333*G6_7_11 - 0.0333333333333333*G6_11_6 - 0.0333333333333333*G6_11_7 - 0.266666666666667*G6_11_11 - 0.166666666666667*G6_12_12 - 0.0833333333333333*G6_12_13 - 0.0833333333333333*G6_13_12 - 0.166666666666667*G6_13_13 + 0.0458333333333333*G7_0_0 + 0.0749999999999999*G7_0_7 - 0.0375*G7_0_8 + 0.0458333333333333*G7_1_1 - 0.0375*G7_1_7 + 0.075*G7_1_8 + 0.0166666666666666*G7_5_0 + 0.0166666666666666*G7_5_1 + 0.15*G7_5_7 + 0.15*G7_5_8 + 0.0458333333333333*G7_6_10 + 0.0749999999999999*G7_6_17 - 0.0375*G7_6_18 + 0.0458333333333333*G7_7_11 - 0.0375*G7_7_17 + 0.075*G7_7_18 + 0.0166666666666666*G7_11_10 + 0.0166666666666666*G7_11_11 + 0.15*G7_11_17 + 0.15*G7_11_18 + 0.0833333333333333*G7_12_20 + 0.166666666666667*G7_12_25 + 0.0833333333333333*G7_13_21 + 0.166666666666667*G7_13_25;
        A[1] = -0.0666666666666666*G0_15_15 + 0.0166666666666666*G0_15_16 - 0.0333333333333333*G0_15_20 + 0.0166666666666666*G0_16_15 - 0.0666666666666666*G0_16_16 - 0.0333333333333333*G0_16_20 - 0.0333333333333333*G0_20_15 - 0.0333333333333333*G0_20_16 - 0.266666666666667*G0_20_20 - 0.0666666666666666*G0_21_21 + 0.0166666666666666*G0_21_22 - 0.0333333333333333*G0_21_26 + 0.0166666666666666*G0_22_21 - 0.0666666666666666*G0_22_22 - 0.0333333333333333*G0_22_26 - 0.0333333333333333*G0_26_21 - 0.0333333333333333*G0_26_22 - 0.266666666666667*G0_26_26 - 0.166666666666667*G0_27_27 - 0.0833333333333333*G0_27_28 - 0.0833333333333333*G0_28_27 - 0.166666666666667*G0_28_28 + 0.0458333333333333*G1_15_26 + 0.0749999999999999*G1_15_33 - 0.0375*G1_15_34 + 0.0458333333333333*G1_16_27 - 0.0375*G1_16_33 + 0.075*G1_16_34 + 0.0166666666666666*G1_20_26 + 0.0166666666666666*G1_20_27 + 0.15*G1_20_33 + 0.15*G1_20_34 + 0.0458333333333333*G1_21_36 + 0.0749999999999999*G1_21_43 - 0.0375*G1_21_44 + 0.0458333333333333*G1_22_37 - 0.0375*G1_22_43 + 0.075*G1_22_44 + 0.0166666666666666*G1_26_36 + 0.0166666666666666*G1_26_37 + 0.15*G1_26_43 + 0.15*G1_26_44 + 0.0833333333333333*G1_27_46 + 0.166666666666667*G1_27_51 + 0.0833333333333333*G1_28_47 + 0.166666666666667*G1_28_51 - 0.0666666666666666*G2_0_0 + 0.0166666666666666*G2_0_1 - 0.0333333333333333*G2_0_5 + 0.0166666666666666*G2_1_0 - 0.0666666666666666*G2_1_1 - 0.0333333333333333*G2_1_5 - 0.0333333333333333*G2_5_0 - 0.0333333333333333*G2_5_1 - 0.266666666666667*G2_5_5 - 0.0666666666666666*G2_6_6 + 0.0166666666666666*G2_6_7 - 0.0333333333333333*G2_6_11 + 0.0166666666666666*G2_7_6 - 0.0666666666666666*G2_7_7 - 0.0333333333333333*G2_7_11 - 0.0333333333333333*G2_11_6 - 0.0333333333333333*G2_11_7 - 0.266666666666667*G2_11_11 - 0.166666666666667*G2_12_12 - 0.0833333333333333*G2_12_13 - 0.0833333333333333*G2_13_12 - 0.166666666666667*G2_13_13 + 0.0458333333333333*G3_0_0 + 0.0749999999999999*G3_0_7 - 0.0375*G3_0_8 + 0.0458333333333333*G3_1_1 - 0.0375*G3_1_7 + 0.075*G3_1_8 + 0.0166666666666666*G3_5_0 + 0.0166666666666666*G3_5_1 + 0.15*G3_5_7 + 0.15*G3_5_8 + 0.0458333333333333*G3_6_10 + 0.0749999999999999*G3_6_17 - 0.0375*G3_6_18 + 0.0458333333333333*G3_7_11 - 0.0375*G3_7_17 + 0.075*G3_7_18 + 0.0166666666666666*G3_11_10 + 0.0166666666666666*G3_11_11 + 0.15*G3_11_17 + 0.15*G3_11_18 + 0.0833333333333333*G3_12_20 + 0.166666666666667*G3_12_25 + 0.0833333333333333*G3_13_21 + 0.166666666666667*G3_13_25;
          break;
        }
      }
      
        break;
      }
    }
    
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_8_otherwise: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_8_otherwise() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_8_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({true, true});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               int cell_orientation) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      3
    // Number of operations (multiply-add pairs) for geometry tensor:    172
    // Number of operations (multiply-add pairs) for tensor contraction: 2992
    // Total number of operations (multiply-add pairs):                  3167
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0_0 = det*w[0][0]*K[0]*(1.0);
    const double G0_0_1 = det*w[0][0]*K[2]*(1.0);
    const double G0_1_0 = det*w[0][1]*K[0]*(1.0);
    const double G0_2_1 = det*w[0][2]*K[2]*(1.0);
    const double G0_3_0 = det*w[0][3]*K[0]*(1.0);
    const double G0_3_1 = det*w[0][3]*K[2]*(1.0);
    const double G0_4_0 = det*w[0][4]*K[0]*(1.0);
    const double G0_4_1 = det*w[0][4]*K[2]*(1.0);
    const double G0_5_0 = det*w[0][5]*K[0]*(1.0);
    const double G0_5_1 = det*w[0][5]*K[2]*(1.0);
    const double G1_0_0 = det*w[0][0]*K[0]*(1.0);
    const double G1_0_1 = det*w[0][0]*K[2]*(1.0);
    const double G1_1_0 = det*w[0][1]*K[0]*(1.0);
    const double G1_1_1 = det*w[0][1]*K[2]*(1.0);
    const double G1_2_0 = det*w[0][2]*K[0]*(1.0);
    const double G1_2_1 = det*w[0][2]*K[2]*(1.0);
    const double G1_3_0 = det*w[0][3]*K[0]*(1.0);
    const double G1_3_1 = det*w[0][3]*K[2]*(1.0);
    const double G1_4_0 = det*w[0][4]*K[0]*(1.0);
    const double G1_4_1 = det*w[0][4]*K[2]*(1.0);
    const double G1_5_0 = det*w[0][5]*K[0]*(1.0);
    const double G1_5_1 = det*w[0][5]*K[2]*(1.0);
    const double G2_0_0 = det*w[0][0]*K[1]*(1.0);
    const double G2_0_1 = det*w[0][0]*K[3]*(1.0);
    const double G2_1_0 = det*w[0][1]*K[1]*(1.0);
    const double G2_2_1 = det*w[0][2]*K[3]*(1.0);
    const double G2_3_0 = det*w[0][3]*K[1]*(1.0);
    const double G2_3_1 = det*w[0][3]*K[3]*(1.0);
    const double G2_4_0 = det*w[0][4]*K[1]*(1.0);
    const double G2_4_1 = det*w[0][4]*K[3]*(1.0);
    const double G2_5_0 = det*w[0][5]*K[1]*(1.0);
    const double G2_5_1 = det*w[0][5]*K[3]*(1.0);
    const double G3_6_0 = det*w[0][6]*K[1]*(1.0);
    const double G3_6_1 = det*w[0][6]*K[3]*(1.0);
    const double G3_7_0 = det*w[0][7]*K[1]*(1.0);
    const double G3_7_1 = det*w[0][7]*K[3]*(1.0);
    const double G3_8_0 = det*w[0][8]*K[1]*(1.0);
    const double G3_8_1 = det*w[0][8]*K[3]*(1.0);
    const double G3_9_0 = det*w[0][9]*K[1]*(1.0);
    const double G3_9_1 = det*w[0][9]*K[3]*(1.0);
    const double G3_10_0 = det*w[0][10]*K[1]*(1.0);
    const double G3_10_1 = det*w[0][10]*K[3]*(1.0);
    const double G3_11_0 = det*w[0][11]*K[1]*(1.0);
    const double G3_11_1 = det*w[0][11]*K[3]*(1.0);
    const double G4_6_0 = det*w[0][6]*K[0]*(1.0);
    const double G4_6_1 = det*w[0][6]*K[2]*(1.0);
    const double G4_7_0 = det*w[0][7]*K[0]*(1.0);
    const double G4_8_1 = det*w[0][8]*K[2]*(1.0);
    const double G4_9_0 = det*w[0][9]*K[0]*(1.0);
    const double G4_9_1 = det*w[0][9]*K[2]*(1.0);
    const double G4_10_0 = det*w[0][10]*K[0]*(1.0);
    const double G4_10_1 = det*w[0][10]*K[2]*(1.0);
    const double G4_11_0 = det*w[0][11]*K[0]*(1.0);
    const double G4_11_1 = det*w[0][11]*K[2]*(1.0);
    const double G5_0_0 = det*w[0][0]*K[0]*(1.0);
    const double G5_0_1 = det*w[0][0]*K[2]*(1.0);
    const double G5_1_0 = det*w[0][1]*K[0]*(1.0);
    const double G5_1_1 = det*w[0][1]*K[2]*(1.0);
    const double G5_2_0 = det*w[0][2]*K[0]*(1.0);
    const double G5_2_1 = det*w[0][2]*K[2]*(1.0);
    const double G5_3_0 = det*w[0][3]*K[0]*(1.0);
    const double G5_3_1 = det*w[0][3]*K[2]*(1.0);
    const double G5_4_0 = det*w[0][4]*K[0]*(1.0);
    const double G5_4_1 = det*w[0][4]*K[2]*(1.0);
    const double G5_5_0 = det*w[0][5]*K[0]*(1.0);
    const double G5_5_1 = det*w[0][5]*K[2]*(1.0);
    const double G6_6_0 = det*w[0][6]*K[1]*(1.0);
    const double G6_6_1 = det*w[0][6]*K[3]*(1.0);
    const double G6_7_0 = det*w[0][7]*K[1]*(1.0);
    const double G6_8_1 = det*w[0][8]*K[3]*(1.0);
    const double G6_9_0 = det*w[0][9]*K[1]*(1.0);
    const double G6_9_1 = det*w[0][9]*K[3]*(1.0);
    const double G6_10_0 = det*w[0][10]*K[1]*(1.0);
    const double G6_10_1 = det*w[0][10]*K[3]*(1.0);
    const double G6_11_0 = det*w[0][11]*K[1]*(1.0);
    const double G6_11_1 = det*w[0][11]*K[3]*(1.0);
    const double G7_6_0 = det*w[0][6]*K[1]*(1.0);
    const double G7_6_1 = det*w[0][6]*K[3]*(1.0);
    const double G7_7_0 = det*w[0][7]*K[1]*(1.0);
    const double G7_7_1 = det*w[0][7]*K[3]*(1.0);
    const double G7_8_0 = det*w[0][8]*K[1]*(1.0);
    const double G7_8_1 = det*w[0][8]*K[3]*(1.0);
    const double G7_9_0 = det*w[0][9]*K[1]*(1.0);
    const double G7_9_1 = det*w[0][9]*K[3]*(1.0);
    const double G7_10_0 = det*w[0][10]*K[1]*(1.0);
    const double G7_10_1 = det*w[0][10]*K[3]*(1.0);
    const double G7_11_0 = det*w[0][11]*K[1]*(1.0);
    const double G7_11_1 = det*w[0][11]*K[3]*(1.0);
    const double G8_0 = det*K[0]*(1.0);
    const double G8_1 = det*K[2]*(1.0);
    const double G9_0 = det*K[1]*(1.0);
    const double G9_1 = det*K[3]*(1.0);
    const double G10_0_0_0 = det*w[1][0]*K[0]*K[0]*(1.0);
    const double G10_0_0_1 = det*w[1][0]*K[0]*K[2]*(1.0);
    const double G10_0_1_0 = det*w[1][0]*K[2]*K[0]*(1.0);
    const double G10_0_1_1 = det*w[1][0]*K[2]*K[2]*(1.0);
    const double G11_0_0_0 = det*w[1][0]*K[0]*K[0]*(1.0);
    const double G11_0_0_1 = det*w[1][0]*K[0]*K[2]*(1.0);
    const double G11_0_1_0 = det*w[1][0]*K[2]*K[0]*(1.0);
    const double G11_0_1_1 = det*w[1][0]*K[2]*K[2]*(1.0);
    const double G12_0_0_0 = det*w[1][0]*K[1]*K[1]*(1.0);
    const double G12_0_0_1 = det*w[1][0]*K[1]*K[3]*(1.0);
    const double G12_0_1_0 = det*w[1][0]*K[3]*K[1]*(1.0);
    const double G12_0_1_1 = det*w[1][0]*K[3]*K[3]*(1.0);
    const double G13_0_0_0 = det*w[1][0]*K[1]*K[1]*(1.0);
    const double G13_0_0_1 = det*w[1][0]*K[1]*K[3]*(1.0);
    const double G13_0_1_0 = det*w[1][0]*K[3]*K[1]*(1.0);
    const double G13_0_1_1 = det*w[1][0]*K[3]*K[3]*(1.0);
    const double G14_0 = det*K[0]*(1.0);
    const double G14_1 = det*K[2]*(1.0);
    const double G15_0 = det*K[1]*(1.0);
    const double G15_1 = det*K[3]*(1.0);
    
    // Compute element tensor
    A[0] = -0.030952380952381*G0_0_0 - 0.030952380952381*G0_0_1 - 0.00714285714285715*G0_1_0 - 0.00714285714285715*G0_2_1 + 0.00952380952380951*G0_3_0 + 0.00952380952380951*G0_3_1 - 0.00952380952380951*G0_4_0 + 0.0380952380952381*G0_4_1 + 0.0380952380952381*G0_5_0 - 0.00952380952380952*G0_5_1 - 0.030952380952381*G1_0_0 - 0.030952380952381*G1_0_1 + 0.00357142857142857*G1_1_0 + 0.00357142857142857*G1_1_1 + 0.00357142857142857*G1_2_0 + 0.00357142857142857*G1_2_1 - 0.00476190476190477*G1_3_0 - 0.00476190476190477*G1_3_1 - 0.0190476190476191*G1_4_0 - 0.0190476190476191*G1_4_1 - 0.0190476190476191*G1_5_0 - 0.0190476190476191*G1_5_1 - 0.030952380952381*G3_6_0 - 0.030952380952381*G3_6_1 + 0.00357142857142857*G3_7_0 + 0.00357142857142857*G3_7_1 + 0.00357142857142857*G3_8_0 + 0.00357142857142857*G3_8_1 - 0.00476190476190477*G3_9_0 - 0.00476190476190477*G3_9_1 - 0.0190476190476191*G3_10_0 - 0.0190476190476191*G3_10_1 - 0.0190476190476191*G3_11_0 - 0.0190476190476191*G3_11_1 + 0.5*G10_0_0_0 + 0.5*G10_0_0_1 + 0.5*G10_0_1_0 + 0.5*G10_0_1_1 + 0.5*G12_0_0_0 + 0.5*G12_0_0_1 + 0.5*G12_0_1_0 + 0.5*G12_0_1_1;
    A[1] = 0.00357142857142857*G0_0_0 + 0.00357142857142857*G0_0_1 - 0.00357142857142857*G0_1_0 + 0.00436507936507936*G0_2_1 + 0.00158730158730159*G0_3_0 - 0.00634920634920634*G0_3_1 - 0.00158730158730159*G0_4_0 - 0.00793650793650793*G0_4_1 + 0.00634920634920635*G0_5_1 - 0.00714285714285715*G1_0_0 - 0.00357142857142857*G1_1_0 + 0.00436507936507936*G1_2_0 - 0.00793650793650793*G1_3_0 - 0.00634920634920636*G1_4_0 - 0.0126984126984127*G1_5_0 - 0.00714285714285715*G3_6_0 - 0.00357142857142857*G3_7_0 + 0.00436507936507936*G3_8_0 - 0.00793650793650793*G3_9_0 - 0.00634920634920636*G3_10_0 - 0.0126984126984127*G3_11_0 + 0.166666666666667*G10_0_0_0 + 0.166666666666667*G10_0_1_0 + 0.166666666666667*G12_0_0_0 + 0.166666666666667*G12_0_1_0;
    A[2] = 0.00357142857142857*G0_0_0 + 0.00357142857142857*G0_0_1 + 0.00436507936507936*G0_1_0 - 0.00357142857142857*G0_2_1 - 0.00634920634920634*G0_3_0 + 0.00158730158730159*G0_3_1 + 0.00634920634920634*G0_4_0 - 0.00793650793650793*G0_5_0 - 0.00158730158730159*G0_5_1 - 0.00714285714285715*G1_0_1 + 0.00436507936507936*G1_1_1 - 0.00357142857142857*G1_2_1 - 0.00793650793650793*G1_3_1 - 0.0126984126984127*G1_4_1 - 0.00634920634920635*G1_5_1 - 0.00714285714285715*G3_6_1 + 0.00436507936507936*G3_7_1 - 0.00357142857142857*G3_8_1 - 0.00793650793650793*G3_9_1 - 0.0126984126984127*G3_10_1 - 0.00634920634920635*G3_11_1 + 0.166666666666667*G10_0_0_1 + 0.166666666666667*G10_0_1_1 + 0.166666666666667*G12_0_0_1 + 0.166666666666667*G12_0_1_1;
    A[3] = -0.00476190476190477*G0_0_0 - 0.00476190476190477*G0_0_1 - 0.00793650793650793*G0_1_0 - 0.00793650793650793*G0_2_1 - 0.019047619047619*G0_3_0 - 0.019047619047619*G0_3_1 + 0.019047619047619*G0_4_0 + 0.0126984126984127*G0_4_1 + 0.0126984126984127*G0_5_0 + 0.019047619047619*G0_5_1 + 0.00952380952380951*G1_0_0 + 0.00952380952380951*G1_0_1 + 0.00158730158730159*G1_1_0 - 0.00634920634920634*G1_1_1 - 0.00634920634920634*G1_2_0 + 0.00158730158730159*G1_2_1 - 0.019047619047619*G1_3_0 - 0.019047619047619*G1_3_1 - 0.0126984126984127*G1_4_0 - 0.00634920634920634*G1_4_1 - 0.00634920634920635*G1_5_0 - 0.0126984126984127*G1_5_1 + 0.00952380952380951*G3_6_0 + 0.00952380952380951*G3_6_1 + 0.00158730158730159*G3_7_0 - 0.00634920634920634*G3_7_1 - 0.00634920634920634*G3_8_0 + 0.00158730158730159*G3_8_1 - 0.019047619047619*G3_9_0 - 0.019047619047619*G3_9_1 - 0.0126984126984127*G3_10_0 - 0.00634920634920634*G3_10_1 - 0.00634920634920635*G3_11_0 - 0.0126984126984127*G3_11_1;
    A[4] = -0.0190476190476191*G0_0_0 - 0.0190476190476191*G0_0_1 - 0.00634920634920636*G0_1_0 - 0.0126984126984127*G0_2_1 - 0.0126984126984127*G0_3_0 - 0.00634920634920634*G0_3_1 + 0.0126984126984127*G0_4_0 + 0.0317460317460318*G0_4_1 + 0.0253968253968254*G0_5_0 + 0.00634920634920634*G0_5_1 - 0.00952380952380951*G1_0_0 + 0.0380952380952381*G1_0_1 - 0.00158730158730159*G1_1_0 - 0.00793650793650793*G1_1_1 + 0.00634920634920634*G1_2_0 + 0.019047619047619*G1_3_0 + 0.0126984126984127*G1_3_1 + 0.0126984126984127*G1_4_0 + 0.0317460317460318*G1_4_1 + 0.00634920634920635*G1_5_0 + 0.0253968253968254*G1_5_1 - 0.00952380952380951*G3_6_0 + 0.0380952380952381*G3_6_1 - 0.00158730158730159*G3_7_0 - 0.00793650793650793*G3_7_1 + 0.00634920634920634*G3_8_0 + 0.019047619047619*G3_9_0 + 0.0126984126984127*G3_9_1 + 0.0126984126984127*G3_10_0 + 0.0317460317460318*G3_10_1 + 0.00634920634920635*G3_11_0 + 0.0253968253968254*G3_11_1 - 0.666666666666667*G10_0_0_1 - 0.666666666666666*G10_0_1_1 - 0.666666666666667*G12_0_0_1 - 0.666666666666666*G12_0_1_1;
    A[5] = -0.0190476190476191*G0_0_0 - 0.0190476190476191*G0_0_1 - 0.0126984126984127*G0_1_0 - 0.00634920634920635*G0_2_1 - 0.00634920634920635*G0_3_0 - 0.0126984126984127*G0_3_1 + 0.00634920634920635*G0_4_0 + 0.0253968253968254*G0_4_1 + 0.0317460317460318*G0_5_0 + 0.0126984126984127*G0_5_1 + 0.0380952380952381*G1_0_0 - 0.00952380952380952*G1_0_1 + 0.00634920634920635*G1_1_1 - 0.00793650793650793*G1_2_0 - 0.00158730158730159*G1_2_1 + 0.0126984126984127*G1_3_0 + 0.019047619047619*G1_3_1 + 0.0253968253968254*G1_4_0 + 0.00634920634920634*G1_4_1 + 0.0317460317460318*G1_5_0 + 0.0126984126984127*G1_5_1 + 0.0380952380952381*G3_6_0 - 0.00952380952380952*G3_6_1 + 0.00634920634920635*G3_7_1 - 0.00793650793650793*G3_8_0 - 0.00158730158730159*G3_8_1 + 0.0126984126984127*G3_9_0 + 0.019047619047619*G3_9_1 + 0.0253968253968254*G3_10_0 + 0.00634920634920634*G3_10_1 + 0.0317460317460318*G3_11_0 + 0.0126984126984127*G3_11_1 - 0.666666666666667*G10_0_0_0 - 0.666666666666667*G10_0_1_0 - 0.666666666666667*G12_0_0_0 - 0.666666666666667*G12_0_1_0;
    A[6] = -0.030952380952381*G2_0_0 - 0.030952380952381*G2_0_1 - 0.00714285714285715*G2_1_0 - 0.00714285714285715*G2_2_1 + 0.00952380952380951*G2_3_0 + 0.00952380952380951*G2_3_1 - 0.00952380952380951*G2_4_0 + 0.0380952380952381*G2_4_1 + 0.0380952380952381*G2_5_0 - 0.00952380952380952*G2_5_1;
    A[7] = 0.00357142857142857*G2_0_0 + 0.00357142857142857*G2_0_1 - 0.00357142857142857*G2_1_0 + 0.00436507936507936*G2_2_1 + 0.00158730158730159*G2_3_0 - 0.00634920634920634*G2_3_1 - 0.00158730158730159*G2_4_0 - 0.00793650793650793*G2_4_1 + 0.00634920634920635*G2_5_1;
    A[8] = 0.00357142857142857*G2_0_0 + 0.00357142857142857*G2_0_1 + 0.00436507936507936*G2_1_0 - 0.00357142857142857*G2_2_1 - 0.00634920634920634*G2_3_0 + 0.00158730158730159*G2_3_1 + 0.00634920634920634*G2_4_0 - 0.00793650793650793*G2_5_0 - 0.00158730158730159*G2_5_1;
    A[9] = -0.00476190476190477*G2_0_0 - 0.00476190476190477*G2_0_1 - 0.00793650793650793*G2_1_0 - 0.00793650793650793*G2_2_1 - 0.019047619047619*G2_3_0 - 0.019047619047619*G2_3_1 + 0.019047619047619*G2_4_0 + 0.0126984126984127*G2_4_1 + 0.0126984126984127*G2_5_0 + 0.019047619047619*G2_5_1;
    A[10] = -0.0190476190476191*G2_0_0 - 0.0190476190476191*G2_0_1 - 0.00634920634920636*G2_1_0 - 0.0126984126984127*G2_2_1 - 0.0126984126984127*G2_3_0 - 0.00634920634920634*G2_3_1 + 0.0126984126984127*G2_4_0 + 0.0317460317460318*G2_4_1 + 0.0253968253968254*G2_5_0 + 0.00634920634920634*G2_5_1;
    A[11] = -0.0190476190476191*G2_0_0 - 0.0190476190476191*G2_0_1 - 0.0126984126984127*G2_1_0 - 0.00634920634920635*G2_2_1 - 0.00634920634920635*G2_3_0 - 0.0126984126984127*G2_3_1 + 0.00634920634920635*G2_4_0 + 0.0253968253968254*G2_4_1 + 0.0317460317460318*G2_5_0 + 0.0126984126984127*G2_5_1;
    A[12] = 0.166666666666667*G14_0 + 0.166666666666667*G14_1;
    A[13] = 0.0;
    A[14] = 0.0;
    A[15] = 0.00357142857142857*G0_0_0 + 0.00357142857142857*G0_0_1 - 0.00357142857142857*G0_1_0 + 0.00436507936507936*G0_2_1 + 0.00158730158730159*G0_3_0 - 0.00634920634920634*G0_3_1 - 0.00158730158730159*G0_4_0 - 0.00793650793650793*G0_4_1 + 0.00634920634920635*G0_5_1 + 0.00357142857142857*G1_0_0 + 0.00357142857142857*G1_0_1 + 0.00714285714285713*G1_1_0 + 0.00714285714285714*G1_1_1 - 0.00436507936507936*G1_2_0 - 0.00436507936507936*G1_2_1 + 0.00634920634920634*G1_3_0 + 0.00634920634920634*G1_3_1 + 0.00793650793650793*G1_4_0 + 0.00793650793650793*G1_4_1 + 0.0126984126984127*G1_5_0 + 0.0126984126984127*G1_5_1 + 0.00357142857142857*G3_6_0 + 0.00357142857142857*G3_6_1 + 0.00714285714285713*G3_7_0 + 0.00714285714285714*G3_7_1 - 0.00436507936507936*G3_8_0 - 0.00436507936507936*G3_8_1 + 0.00634920634920634*G3_9_0 + 0.00634920634920634*G3_9_1 + 0.00793650793650793*G3_10_0 + 0.00793650793650793*G3_10_1 + 0.0126984126984127*G3_11_0 + 0.0126984126984127*G3_11_1 + 0.166666666666667*G10_0_0_0 + 0.166666666666667*G10_0_0_1 + 0.166666666666667*G12_0_0_0 + 0.166666666666667*G12_0_0_1;
    A[16] = 0.00714285714285713*G0_0_0 + 0.00714285714285714*G0_0_1 + 0.0309523809523809*G0_1_0 - 0.00714285714285713*G0_2_1 + 0.0095238095238095*G0_3_0 + 0.0476190476190476*G0_3_1 - 0.0095238095238095*G0_4_0 - 0.0380952380952381*G0_5_0 - 0.0476190476190476*G0_5_1 - 0.00357142857142857*G1_0_0 + 0.0309523809523809*G1_1_0 - 0.00357142857142856*G1_2_0 + 0.019047619047619*G1_3_0 + 0.00476190476190476*G1_4_0 + 0.019047619047619*G1_5_0 - 0.00357142857142857*G3_6_0 + 0.0309523809523809*G3_7_0 - 0.00357142857142856*G3_8_0 + 0.019047619047619*G3_9_0 + 0.00476190476190476*G3_10_0 + 0.019047619047619*G3_11_0 + 0.5*G10_0_0_0 + 0.5*G12_0_0_0;
    A[17] = -0.00436507936507936*G0_0_0 - 0.00436507936507936*G0_0_1 - 0.00357142857142856*G0_1_0 - 0.00357142857142857*G0_2_1 - 0.00634920634920633*G0_3_0 - 0.00634920634920634*G0_3_1 + 0.00634920634920633*G0_4_0 + 0.00793650793650792*G0_4_1 + 0.00793650793650793*G0_5_0 + 0.00634920634920634*G0_5_1 + 0.00436507936507936*G1_0_1 - 0.00714285714285713*G1_1_1 - 0.00357142857142857*G1_2_1 - 0.0126984126984127*G1_3_1 - 0.00793650793650794*G1_4_1 - 0.00634920634920636*G1_5_1 + 0.00436507936507936*G3_6_1 - 0.00714285714285713*G3_7_1 - 0.00357142857142857*G3_8_1 - 0.0126984126984127*G3_9_1 - 0.00793650793650794*G3_10_1 - 0.00634920634920636*G3_11_1 - 0.166666666666667*G10_0_0_1 - 0.166666666666667*G12_0_0_1;
    A[18] = 0.00634920634920634*G0_0_0 + 0.00634920634920634*G0_0_1 + 0.019047619047619*G0_1_0 - 0.0126984126984127*G0_2_1 - 0.0126984126984127*G0_3_0 + 0.019047619047619*G0_3_1 + 0.0126984126984127*G0_4_0 + 0.00634920634920636*G0_4_1 - 0.0253968253968254*G0_5_0 - 0.019047619047619*G0_5_1 + 0.00158730158730159*G1_0_0 - 0.00634920634920634*G1_0_1 + 0.0095238095238095*G1_1_0 + 0.0476190476190476*G1_1_1 - 0.00634920634920633*G1_2_0 - 0.00634920634920634*G1_2_1 - 0.0126984126984127*G1_3_0 + 0.019047619047619*G1_3_1 - 0.019047619047619*G1_4_0 - 0.00634920634920634*G1_4_1 - 0.00634920634920635*G1_5_0 + 0.019047619047619*G1_5_1 + 0.00158730158730159*G3_6_0 - 0.00634920634920634*G3_6_1 + 0.0095238095238095*G3_7_0 + 0.0476190476190476*G3_7_1 - 0.00634920634920633*G3_8_0 - 0.00634920634920634*G3_8_1 - 0.0126984126984127*G3_9_0 + 0.019047619047619*G3_9_1 - 0.019047619047619*G3_10_0 - 0.00634920634920634*G3_10_1 - 0.00634920634920635*G3_11_0 + 0.019047619047619*G3_11_1 + 0.666666666666666*G10_0_0_1 + 0.666666666666666*G12_0_0_1;
    A[19] = 0.00793650793650793*G0_0_0 + 0.00793650793650793*G0_0_1 + 0.00476190476190476*G0_1_0 - 0.00793650793650794*G0_2_1 - 0.019047619047619*G0_3_0 - 0.00634920634920634*G0_3_1 + 0.019047619047619*G0_4_0 - 0.0126984126984127*G0_5_0 + 0.00634920634920634*G0_5_1 - 0.00158730158730159*G1_0_0 - 0.00793650793650793*G1_0_1 - 0.0095238095238095*G1_1_0 + 0.00634920634920633*G1_2_0 + 0.00793650793650792*G1_2_1 + 0.0126984126984127*G1_3_0 + 0.00634920634920636*G1_3_1 + 0.019047619047619*G1_4_0 + 0.00634920634920635*G1_5_0 - 0.00634920634920633*G1_5_1 - 0.00158730158730159*G3_6_0 - 0.00793650793650793*G3_6_1 - 0.0095238095238095*G3_7_0 + 0.00634920634920633*G3_8_0 + 0.00793650793650792*G3_8_1 + 0.0126984126984127*G3_9_0 + 0.00634920634920636*G3_9_1 + 0.019047619047619*G3_10_0 + 0.00634920634920635*G3_11_0 - 0.00634920634920633*G3_11_1;
    A[20] = 0.0126984126984127*G0_0_0 + 0.0126984126984127*G0_0_1 + 0.019047619047619*G0_1_0 - 0.00634920634920636*G0_2_1 - 0.00634920634920635*G0_3_0 + 0.019047619047619*G0_3_1 + 0.00634920634920635*G0_4_0 - 0.00634920634920633*G0_4_1 - 0.0317460317460317*G0_5_0 - 0.0190476190476191*G0_5_1 + 0.00634920634920635*G1_0_1 - 0.0380952380952381*G1_1_0 - 0.0476190476190476*G1_1_1 + 0.00793650793650793*G1_2_0 + 0.00634920634920634*G1_2_1 - 0.0253968253968254*G1_3_0 - 0.019047619047619*G1_3_1 - 0.0126984126984127*G1_4_0 + 0.00634920634920634*G1_4_1 - 0.0317460317460317*G1_5_0 - 0.0190476190476191*G1_5_1 + 0.00634920634920635*G3_6_1 - 0.0380952380952381*G3_7_0 - 0.0476190476190476*G3_7_1 + 0.00793650793650793*G3_8_0 + 0.00634920634920634*G3_8_1 - 0.0253968253968254*G3_9_0 - 0.019047619047619*G3_9_1 - 0.0126984126984127*G3_10_0 + 0.00634920634920634*G3_10_1 - 0.0317460317460317*G3_11_0 - 0.0190476190476191*G3_11_1 - 0.666666666666667*G10_0_0_0 - 0.666666666666666*G10_0_0_1 - 0.666666666666667*G12_0_0_0 - 0.666666666666666*G12_0_0_1;
    A[21] = 0.00357142857142857*G2_0_0 + 0.00357142857142857*G2_0_1 - 0.00357142857142857*G2_1_0 + 0.00436507936507936*G2_2_1 + 0.00158730158730159*G2_3_0 - 0.00634920634920634*G2_3_1 - 0.00158730158730159*G2_4_0 - 0.00793650793650793*G2_4_1 + 0.00634920634920635*G2_5_1;
    A[22] = 0.00714285714285713*G2_0_0 + 0.00714285714285714*G2_0_1 + 0.0309523809523809*G2_1_0 - 0.00714285714285713*G2_2_1 + 0.0095238095238095*G2_3_0 + 0.0476190476190476*G2_3_1 - 0.0095238095238095*G2_4_0 - 0.0380952380952381*G2_5_0 - 0.0476190476190476*G2_5_1;
    A[23] = -0.00436507936507936*G2_0_0 - 0.00436507936507936*G2_0_1 - 0.00357142857142856*G2_1_0 - 0.00357142857142857*G2_2_1 - 0.00634920634920633*G2_3_0 - 0.00634920634920634*G2_3_1 + 0.00634920634920633*G2_4_0 + 0.00793650793650792*G2_4_1 + 0.00793650793650793*G2_5_0 + 0.00634920634920634*G2_5_1;
    A[24] = 0.00634920634920634*G2_0_0 + 0.00634920634920634*G2_0_1 + 0.019047619047619*G2_1_0 - 0.0126984126984127*G2_2_1 - 0.0126984126984127*G2_3_0 + 0.019047619047619*G2_3_1 + 0.0126984126984127*G2_4_0 + 0.00634920634920636*G2_4_1 - 0.0253968253968254*G2_5_0 - 0.019047619047619*G2_5_1;
    A[25] = 0.00793650793650793*G2_0_0 + 0.00793650793650793*G2_0_1 + 0.00476190476190476*G2_1_0 - 0.00793650793650794*G2_2_1 - 0.019047619047619*G2_3_0 - 0.00634920634920634*G2_3_1 + 0.019047619047619*G2_4_0 - 0.0126984126984127*G2_5_0 + 0.00634920634920634*G2_5_1;
    A[26] = 0.0126984126984127*G2_0_0 + 0.0126984126984127*G2_0_1 + 0.019047619047619*G2_1_0 - 0.00634920634920636*G2_2_1 - 0.00634920634920635*G2_3_0 + 0.019047619047619*G2_3_1 + 0.00634920634920635*G2_4_0 - 0.00634920634920633*G2_4_1 - 0.0317460317460317*G2_5_0 - 0.0190476190476191*G2_5_1;
    A[27] = 0.0;
    A[28] = -0.166666666666667*G14_0;
    A[29] = 0.0;
    A[30] = 0.00357142857142857*G0_0_0 + 0.00357142857142857*G0_0_1 + 0.00436507936507936*G0_1_0 - 0.00357142857142857*G0_2_1 - 0.00634920634920634*G0_3_0 + 0.00158730158730159*G0_3_1 + 0.00634920634920634*G0_4_0 - 0.00793650793650793*G0_5_0 - 0.00158730158730159*G0_5_1 + 0.00357142857142857*G1_0_0 + 0.00357142857142857*G1_0_1 - 0.00436507936507936*G1_1_0 - 0.00436507936507936*G1_1_1 + 0.00714285714285714*G1_2_0 + 0.00714285714285713*G1_2_1 + 0.00634920634920635*G1_3_0 + 0.00634920634920634*G1_3_1 + 0.0126984126984127*G1_4_0 + 0.0126984126984127*G1_4_1 + 0.00793650793650793*G1_5_0 + 0.00793650793650793*G1_5_1 + 0.00357142857142857*G3_6_0 + 0.00357142857142857*G3_6_1 - 0.00436507936507936*G3_7_0 - 0.00436507936507936*G3_7_1 + 0.00714285714285714*G3_8_0 + 0.00714285714285713*G3_8_1 + 0.00634920634920635*G3_9_0 + 0.00634920634920634*G3_9_1 + 0.0126984126984127*G3_10_0 + 0.0126984126984127*G3_10_1 + 0.00793650793650793*G3_11_0 + 0.00793650793650793*G3_11_1 + 0.166666666666667*G10_0_1_0 + 0.166666666666667*G10_0_1_1 + 0.166666666666667*G12_0_1_0 + 0.166666666666667*G12_0_1_1;
    A[31] = -0.00436507936507936*G0_0_0 - 0.00436507936507936*G0_0_1 - 0.00357142857142857*G0_1_0 - 0.00357142857142857*G0_2_1 - 0.00634920634920634*G0_3_0 - 0.00634920634920634*G0_3_1 + 0.00634920634920634*G0_4_0 + 0.00793650793650792*G0_4_1 + 0.00793650793650793*G0_5_0 + 0.00634920634920634*G0_5_1 + 0.00436507936507936*G1_0_0 - 0.00357142857142857*G1_1_0 - 0.00714285714285714*G1_2_0 - 0.0126984126984127*G1_3_0 - 0.00634920634920635*G1_4_0 - 0.00793650793650793*G1_5_0 + 0.00436507936507936*G3_6_0 - 0.00357142857142857*G3_7_0 - 0.00714285714285714*G3_8_0 - 0.0126984126984127*G3_9_0 - 0.00634920634920635*G3_10_0 - 0.00793650793650793*G3_11_0 - 0.166666666666667*G10_0_1_0 - 0.166666666666667*G12_0_1_0;
    A[32] = 0.00714285714285714*G0_0_0 + 0.00714285714285713*G0_0_1 - 0.00714285714285714*G0_1_0 + 0.0309523809523809*G0_2_1 + 0.0476190476190475*G0_3_0 + 0.0095238095238095*G0_3_1 - 0.0476190476190475*G0_4_0 - 0.038095238095238*G0_4_1 - 0.00952380952380951*G0_5_1 - 0.00357142857142857*G1_0_1 - 0.00357142857142857*G1_1_1 + 0.0309523809523809*G1_2_1 + 0.019047619047619*G1_3_1 + 0.019047619047619*G1_4_1 + 0.00476190476190476*G1_5_1 - 0.00357142857142857*G3_6_1 - 0.00357142857142857*G3_7_1 + 0.0309523809523809*G3_8_1 + 0.019047619047619*G3_9_1 + 0.019047619047619*G3_10_1 + 0.00476190476190476*G3_11_1 + 0.5*G10_0_1_1 + 0.5*G12_0_1_1;
    A[33] = 0.00634920634920635*G0_0_0 + 0.00634920634920634*G0_0_1 - 0.0126984126984127*G0_1_0 + 0.019047619047619*G0_2_1 + 0.019047619047619*G0_3_0 - 0.0126984126984127*G0_3_1 - 0.019047619047619*G0_4_0 - 0.0253968253968254*G0_4_1 + 0.00634920634920634*G0_5_0 + 0.0126984126984127*G0_5_1 - 0.00634920634920634*G1_0_0 + 0.00158730158730159*G1_0_1 - 0.00634920634920634*G1_1_0 - 0.00634920634920634*G1_1_1 + 0.0476190476190475*G1_2_0 + 0.0095238095238095*G1_2_1 + 0.019047619047619*G1_3_0 - 0.0126984126984127*G1_3_1 + 0.019047619047619*G1_4_0 - 0.00634920634920634*G1_4_1 - 0.00634920634920633*G1_5_0 - 0.019047619047619*G1_5_1 - 0.00634920634920634*G3_6_0 + 0.00158730158730159*G3_6_1 - 0.00634920634920634*G3_7_0 - 0.00634920634920634*G3_7_1 + 0.0476190476190475*G3_8_0 + 0.0095238095238095*G3_8_1 + 0.019047619047619*G3_9_0 - 0.0126984126984127*G3_9_1 + 0.019047619047619*G3_10_0 - 0.00634920634920634*G3_10_1 - 0.00634920634920633*G3_11_0 - 0.019047619047619*G3_11_1 + 0.666666666666666*G10_0_1_0 + 0.666666666666666*G12_0_1_0;
    A[34] = 0.0126984126984127*G0_0_0 + 0.0126984126984127*G0_0_1 - 0.00634920634920635*G0_1_0 + 0.019047619047619*G0_2_1 + 0.019047619047619*G0_3_0 - 0.00634920634920634*G0_3_1 - 0.019047619047619*G0_4_0 - 0.0317460317460317*G0_4_1 - 0.00634920634920635*G0_5_0 + 0.00634920634920634*G0_5_1 + 0.00634920634920634*G1_0_0 + 0.00634920634920634*G1_1_0 + 0.00793650793650792*G1_1_1 - 0.0476190476190475*G1_2_0 - 0.038095238095238*G1_2_1 - 0.019047619047619*G1_3_0 - 0.0253968253968254*G1_3_1 - 0.019047619047619*G1_4_0 - 0.0317460317460317*G1_4_1 + 0.00634920634920633*G1_5_0 - 0.0126984126984127*G1_5_1 + 0.00634920634920634*G3_6_0 + 0.00634920634920634*G3_7_0 + 0.00793650793650792*G3_7_1 - 0.0476190476190475*G3_8_0 - 0.038095238095238*G3_8_1 - 0.019047619047619*G3_9_0 - 0.0253968253968254*G3_9_1 - 0.019047619047619*G3_10_0 - 0.0317460317460317*G3_10_1 + 0.00634920634920633*G3_11_0 - 0.0126984126984127*G3_11_1 - 0.666666666666666*G10_0_1_0 - 0.666666666666666*G10_0_1_1 - 0.666666666666666*G12_0_1_0 - 0.666666666666666*G12_0_1_1;
    A[35] = 0.00793650793650793*G0_0_0 + 0.00793650793650793*G0_0_1 - 0.00793650793650793*G0_1_0 + 0.00476190476190476*G0_2_1 - 0.00634920634920633*G0_3_0 - 0.019047619047619*G0_3_1 + 0.00634920634920633*G0_4_0 - 0.0126984126984127*G0_4_1 + 0.019047619047619*G0_5_1 - 0.00793650793650793*G1_0_0 - 0.00158730158730159*G1_0_1 + 0.00793650793650793*G1_1_0 + 0.00634920634920634*G1_1_1 - 0.00952380952380951*G1_2_1 + 0.00634920634920634*G1_3_0 + 0.0126984126984127*G1_3_1 - 0.00634920634920635*G1_4_0 + 0.00634920634920634*G1_4_1 + 0.019047619047619*G1_5_1 - 0.00793650793650793*G3_6_0 - 0.00158730158730159*G3_6_1 + 0.00793650793650793*G3_7_0 + 0.00634920634920634*G3_7_1 - 0.00952380952380951*G3_8_1 + 0.00634920634920634*G3_9_0 + 0.0126984126984127*G3_9_1 - 0.00634920634920635*G3_10_0 + 0.00634920634920634*G3_10_1 + 0.019047619047619*G3_11_1;
    A[36] = 0.00357142857142857*G2_0_0 + 0.00357142857142857*G2_0_1 + 0.00436507936507936*G2_1_0 - 0.00357142857142857*G2_2_1 - 0.00634920634920634*G2_3_0 + 0.00158730158730159*G2_3_1 + 0.00634920634920634*G2_4_0 - 0.00793650793650793*G2_5_0 - 0.00158730158730159*G2_5_1;
    A[37] = -0.00436507936507936*G2_0_0 - 0.00436507936507936*G2_0_1 - 0.00357142857142857*G2_1_0 - 0.00357142857142857*G2_2_1 - 0.00634920634920634*G2_3_0 - 0.00634920634920634*G2_3_1 + 0.00634920634920634*G2_4_0 + 0.00793650793650792*G2_4_1 + 0.00793650793650793*G2_5_0 + 0.00634920634920634*G2_5_1;
    A[38] = 0.00714285714285714*G2_0_0 + 0.00714285714285713*G2_0_1 - 0.00714285714285714*G2_1_0 + 0.0309523809523809*G2_2_1 + 0.0476190476190475*G2_3_0 + 0.0095238095238095*G2_3_1 - 0.0476190476190475*G2_4_0 - 0.038095238095238*G2_4_1 - 0.00952380952380951*G2_5_1;
    A[39] = 0.00634920634920635*G2_0_0 + 0.00634920634920634*G2_0_1 - 0.0126984126984127*G2_1_0 + 0.019047619047619*G2_2_1 + 0.019047619047619*G2_3_0 - 0.0126984126984127*G2_3_1 - 0.019047619047619*G2_4_0 - 0.0253968253968254*G2_4_1 + 0.00634920634920634*G2_5_0 + 0.0126984126984127*G2_5_1;
    A[40] = 0.0126984126984127*G2_0_0 + 0.0126984126984127*G2_0_1 - 0.00634920634920635*G2_1_0 + 0.019047619047619*G2_2_1 + 0.019047619047619*G2_3_0 - 0.00634920634920634*G2_3_1 - 0.019047619047619*G2_4_0 - 0.0317460317460317*G2_4_1 - 0.00634920634920635*G2_5_0 + 0.00634920634920634*G2_5_1;
    A[41] = 0.00793650793650793*G2_0_0 + 0.00793650793650793*G2_0_1 - 0.00793650793650793*G2_1_0 + 0.00476190476190476*G2_2_1 - 0.00634920634920633*G2_3_0 - 0.019047619047619*G2_3_1 + 0.00634920634920633*G2_4_0 - 0.0126984126984127*G2_4_1 + 0.019047619047619*G2_5_1;
    A[42] = 0.0;
    A[43] = 0.0;
    A[44] = -0.166666666666667*G14_1;
    A[45] = -0.00476190476190476*G0_0_0 - 0.00476190476190477*G0_0_1 - 0.00793650793650793*G0_1_0 - 0.00793650793650793*G0_2_1 - 0.019047619047619*G0_3_0 - 0.019047619047619*G0_3_1 + 0.019047619047619*G0_4_0 + 0.0126984126984127*G0_4_1 + 0.0126984126984127*G0_5_0 + 0.019047619047619*G0_5_1 - 0.00476190476190476*G1_0_0 - 0.00476190476190477*G1_0_1 + 0.00634920634920634*G1_1_0 + 0.00634920634920634*G1_1_1 + 0.00634920634920635*G1_2_0 + 0.00634920634920634*G1_2_1 + 0.0380952380952381*G1_3_0 + 0.0380952380952381*G1_3_1 - 0.00634920634920633*G1_4_0 - 0.00634920634920632*G1_4_1 - 0.00634920634920633*G1_5_0 - 0.00634920634920632*G1_5_1 - 0.00476190476190476*G3_6_0 - 0.00476190476190477*G3_6_1 + 0.00634920634920634*G3_7_0 + 0.00634920634920634*G3_7_1 + 0.00634920634920635*G3_8_0 + 0.00634920634920634*G3_8_1 + 0.0380952380952381*G3_9_0 + 0.0380952380952381*G3_9_1 - 0.00634920634920633*G3_10_0 - 0.00634920634920632*G3_10_1 - 0.00634920634920633*G3_11_0 - 0.00634920634920632*G3_11_1;
    A[46] = 0.00634920634920634*G0_0_0 + 0.00634920634920634*G0_0_1 + 0.019047619047619*G0_1_0 - 0.0126984126984127*G0_2_1 - 0.0126984126984127*G0_3_0 + 0.019047619047619*G0_3_1 + 0.0126984126984127*G0_4_0 + 0.00634920634920636*G0_4_1 - 0.0253968253968254*G0_5_0 - 0.019047619047619*G0_5_1 - 0.00793650793650793*G1_0_0 + 0.019047619047619*G1_1_0 - 0.0126984126984127*G1_2_0 + 0.0634920634920634*G1_3_0 + 0.00634920634920634*G1_4_0 + 0.0317460317460317*G1_5_0 - 0.00793650793650793*G3_6_0 + 0.019047619047619*G3_7_0 - 0.0126984126984127*G3_8_0 + 0.0634920634920634*G3_9_0 + 0.00634920634920634*G3_10_0 + 0.0317460317460317*G3_11_0 + 0.666666666666666*G10_0_1_0 + 0.666666666666666*G12_0_1_0;
    A[47] = 0.00634920634920635*G0_0_0 + 0.00634920634920634*G0_0_1 - 0.0126984126984127*G0_1_0 + 0.019047619047619*G0_2_1 + 0.019047619047619*G0_3_0 - 0.0126984126984127*G0_3_1 - 0.019047619047619*G0_4_0 - 0.0253968253968254*G0_4_1 + 0.00634920634920634*G0_5_0 + 0.0126984126984127*G0_5_1 - 0.00793650793650793*G1_0_1 - 0.0126984126984127*G1_1_1 + 0.019047619047619*G1_2_1 + 0.0634920634920634*G1_3_1 + 0.0317460317460317*G1_4_1 + 0.00634920634920636*G1_5_1 - 0.00793650793650793*G3_6_1 - 0.0126984126984127*G3_7_1 + 0.019047619047619*G3_8_1 + 0.0634920634920634*G3_9_1 + 0.0317460317460317*G3_10_1 + 0.00634920634920636*G3_11_1 + 0.666666666666666*G10_0_0_1 + 0.666666666666666*G12_0_0_1;
    A[48] = 0.0380952380952381*G0_0_0 + 0.0380952380952381*G0_0_1 + 0.0634920634920634*G0_1_0 + 0.0634920634920634*G0_2_1 + 0.152380952380952*G0_3_0 + 0.152380952380952*G0_3_1 - 0.152380952380952*G0_4_0 - 0.101587301587301*G0_4_1 - 0.101587301587302*G0_5_0 - 0.152380952380952*G0_5_1 - 0.019047619047619*G1_0_0 - 0.019047619047619*G1_0_1 - 0.0126984126984127*G1_1_0 + 0.019047619047619*G1_1_1 + 0.019047619047619*G1_2_0 - 0.0126984126984127*G1_2_1 + 0.152380952380952*G1_3_0 + 0.152380952380952*G1_3_1 + 0.0761904761904761*G1_4_0 + 0.0507936507936507*G1_4_1 + 0.0507936507936508*G1_5_0 + 0.0761904761904761*G1_5_1 - 0.019047619047619*G3_6_0 - 0.019047619047619*G3_6_1 - 0.0126984126984127*G3_7_0 + 0.019047619047619*G3_7_1 + 0.019047619047619*G3_8_0 - 0.0126984126984127*G3_8_1 + 0.152380952380952*G3_9_0 + 0.152380952380952*G3_9_1 + 0.0761904761904761*G3_10_0 + 0.0507936507936507*G3_10_1 + 0.0507936507936508*G3_11_0 + 0.0761904761904761*G3_11_1 + 1.33333333333333*G10_0_0_0 + 0.666666666666665*G10_0_0_1 + 0.666666666666665*G10_0_1_0 + 1.33333333333333*G10_0_1_1 + 1.33333333333333*G12_0_0_0 + 0.666666666666665*G12_0_0_1 + 0.666666666666665*G12_0_1_0 + 1.33333333333333*G12_0_1_1;
    A[49] = -0.00634920634920633*G0_0_0 - 0.00634920634920632*G0_0_1 + 0.00634920634920634*G0_1_0 + 0.0317460317460317*G0_2_1 + 0.0761904761904761*G0_3_0 + 0.0507936507936507*G0_3_1 - 0.0761904761904761*G0_4_0 - 0.0253968253968254*G0_4_1 - 0.0507936507936508*G0_5_1 + 0.019047619047619*G1_0_0 + 0.0126984126984127*G1_0_1 + 0.0126984126984127*G1_1_0 + 0.00634920634920636*G1_1_1 - 0.019047619047619*G1_2_0 - 0.0253968253968254*G1_2_1 - 0.152380952380952*G1_3_0 - 0.101587301587301*G1_3_1 - 0.0761904761904761*G1_4_0 - 0.0253968253968254*G1_4_1 - 0.0507936507936508*G1_5_0 + 0.019047619047619*G3_6_0 + 0.0126984126984127*G3_6_1 + 0.0126984126984127*G3_7_0 + 0.00634920634920636*G3_7_1 - 0.019047619047619*G3_8_0 - 0.0253968253968254*G3_8_1 - 0.152380952380952*G3_9_0 - 0.101587301587301*G3_9_1 - 0.0761904761904761*G3_10_0 - 0.0253968253968254*G3_10_1 - 0.0507936507936508*G3_11_0 - 1.33333333333333*G10_0_0_0 - 0.666666666666666*G10_0_0_1 - 0.666666666666665*G10_0_1_0 - 1.33333333333333*G12_0_0_0 - 0.666666666666666*G12_0_0_1 - 0.666666666666665*G12_0_1_0;
    A[50] = -0.00634920634920633*G0_0_0 - 0.00634920634920632*G0_0_1 + 0.0317460317460317*G0_1_0 + 0.00634920634920636*G0_2_1 + 0.0507936507936508*G0_3_0 + 0.0761904761904761*G0_3_1 - 0.0507936507936508*G0_4_0 - 0.0253968253968254*G0_5_0 - 0.0761904761904762*G0_5_1 + 0.0126984126984127*G1_0_0 + 0.019047619047619*G1_0_1 - 0.0253968253968254*G1_1_0 - 0.019047619047619*G1_1_1 + 0.00634920634920634*G1_2_0 + 0.0126984126984127*G1_2_1 - 0.101587301587302*G1_3_0 - 0.152380952380952*G1_3_1 - 0.0507936507936508*G1_4_1 - 0.0253968253968254*G1_5_0 - 0.0761904761904762*G1_5_1 + 0.0126984126984127*G3_6_0 + 0.019047619047619*G3_6_1 - 0.0253968253968254*G3_7_0 - 0.019047619047619*G3_7_1 + 0.00634920634920634*G3_8_0 + 0.0126984126984127*G3_8_1 - 0.101587301587302*G3_9_0 - 0.152380952380952*G3_9_1 - 0.0507936507936508*G3_10_1 - 0.0253968253968254*G3_11_0 - 0.0761904761904762*G3_11_1 - 0.666666666666665*G10_0_0_1 - 0.666666666666667*G10_0_1_0 - 1.33333333333333*G10_0_1_1 - 0.666666666666665*G12_0_0_1 - 0.666666666666667*G12_0_1_0 - 1.33333333333333*G12_0_1_1;
    A[51] = -0.00476190476190476*G2_0_0 - 0.00476190476190477*G2_0_1 - 0.00793650793650793*G2_1_0 - 0.00793650793650793*G2_2_1 - 0.019047619047619*G2_3_0 - 0.019047619047619*G2_3_1 + 0.019047619047619*G2_4_0 + 0.0126984126984127*G2_4_1 + 0.0126984126984127*G2_5_0 + 0.019047619047619*G2_5_1;
    A[52] = 0.00634920634920634*G2_0_0 + 0.00634920634920634*G2_0_1 + 0.019047619047619*G2_1_0 - 0.0126984126984127*G2_2_1 - 0.0126984126984127*G2_3_0 + 0.019047619047619*G2_3_1 + 0.0126984126984127*G2_4_0 + 0.00634920634920636*G2_4_1 - 0.0253968253968254*G2_5_0 - 0.019047619047619*G2_5_1;
    A[53] = 0.00634920634920635*G2_0_0 + 0.00634920634920634*G2_0_1 - 0.0126984126984127*G2_1_0 + 0.019047619047619*G2_2_1 + 0.019047619047619*G2_3_0 - 0.0126984126984127*G2_3_1 - 0.019047619047619*G2_4_0 - 0.0253968253968254*G2_4_1 + 0.00634920634920634*G2_5_0 + 0.0126984126984127*G2_5_1;
    A[54] = 0.0380952380952381*G2_0_0 + 0.0380952380952381*G2_0_1 + 0.0634920634920634*G2_1_0 + 0.0634920634920634*G2_2_1 + 0.152380952380952*G2_3_0 + 0.152380952380952*G2_3_1 - 0.152380952380952*G2_4_0 - 0.101587301587301*G2_4_1 - 0.101587301587302*G2_5_0 - 0.152380952380952*G2_5_1;
    A[55] = -0.00634920634920633*G2_0_0 - 0.00634920634920632*G2_0_1 + 0.00634920634920634*G2_1_0 + 0.0317460317460317*G2_2_1 + 0.0761904761904761*G2_3_0 + 0.0507936507936507*G2_3_1 - 0.0761904761904761*G2_4_0 - 0.0253968253968254*G2_4_1 - 0.0507936507936508*G2_5_1;
    A[56] = -0.00634920634920633*G2_0_0 - 0.00634920634920632*G2_0_1 + 0.0317460317460317*G2_1_0 + 0.00634920634920636*G2_2_1 + 0.0507936507936508*G2_3_0 + 0.0761904761904761*G2_3_1 - 0.0507936507936508*G2_4_0 - 0.0253968253968254*G2_5_0 - 0.0761904761904762*G2_5_1;
    A[57] = -0.166666666666667*G14_0 - 0.166666666666667*G14_1;
    A[58] = -0.166666666666667*G14_0 - 0.333333333333333*G14_1;
    A[59] = -0.333333333333333*G14_0 - 0.166666666666666*G14_1;
    A[60] = -0.0190476190476191*G0_0_0 - 0.0190476190476191*G0_0_1 - 0.00634920634920636*G0_1_0 - 0.0126984126984127*G0_2_1 - 0.0126984126984127*G0_3_0 - 0.00634920634920634*G0_3_1 + 0.0126984126984127*G0_4_0 + 0.0317460317460318*G0_4_1 + 0.0253968253968254*G0_5_0 + 0.00634920634920634*G0_5_1 - 0.0190476190476191*G1_0_0 - 0.0190476190476191*G1_0_1 + 0.00793650793650793*G1_1_0 + 0.00793650793650793*G1_1_1 + 0.0126984126984127*G1_2_0 + 0.0126984126984127*G1_2_1 - 0.00634920634920633*G1_3_0 - 0.00634920634920632*G1_3_1 - 0.0634920634920635*G1_4_0 - 0.0634920634920635*G1_4_1 - 0.0317460317460317*G1_5_0 - 0.0317460317460317*G1_5_1 - 0.0190476190476191*G3_6_0 - 0.0190476190476191*G3_6_1 + 0.00793650793650793*G3_7_0 + 0.00793650793650793*G3_7_1 + 0.0126984126984127*G3_8_0 + 0.0126984126984127*G3_8_1 - 0.00634920634920633*G3_9_0 - 0.00634920634920632*G3_9_1 - 0.0634920634920635*G3_10_0 - 0.0634920634920635*G3_10_1 - 0.0317460317460317*G3_11_0 - 0.0317460317460317*G3_11_1 - 0.666666666666667*G10_0_1_0 - 0.666666666666666*G10_0_1_1 - 0.666666666666667*G12_0_1_0 - 0.666666666666666*G12_0_1_1;
    A[61] = 0.00793650793650793*G0_0_0 + 0.00793650793650793*G0_0_1 + 0.00476190476190476*G0_1_0 - 0.00793650793650794*G0_2_1 - 0.019047619047619*G0_3_0 - 0.00634920634920634*G0_3_1 + 0.019047619047619*G0_4_0 - 0.0126984126984127*G0_5_0 + 0.00634920634920634*G0_5_1 - 0.00634920634920636*G1_0_0 + 0.00476190476190476*G1_1_0 - 0.00634920634920635*G1_2_0 + 0.00634920634920634*G1_3_0 - 0.0380952380952381*G1_4_0 + 0.00634920634920634*G1_5_0 - 0.00634920634920636*G3_6_0 + 0.00476190476190476*G3_7_0 - 0.00634920634920635*G3_8_0 + 0.00634920634920634*G3_9_0 - 0.0380952380952381*G3_10_0 + 0.00634920634920634*G3_11_0;
    A[62] = 0.0126984126984127*G0_0_0 + 0.0126984126984127*G0_0_1 - 0.00634920634920635*G0_1_0 + 0.019047619047619*G0_2_1 + 0.019047619047619*G0_3_0 - 0.00634920634920634*G0_3_1 - 0.019047619047619*G0_4_0 - 0.0317460317460317*G0_4_1 - 0.00634920634920635*G0_5_0 + 0.00634920634920634*G0_5_1 - 0.0126984126984127*G1_0_1 - 0.00793650793650794*G1_1_1 + 0.019047619047619*G1_2_1 + 0.0317460317460317*G1_3_1 + 0.0634920634920635*G1_4_1 + 0.00634920634920636*G1_5_1 - 0.0126984126984127*G3_6_1 - 0.00793650793650794*G3_7_1 + 0.019047619047619*G3_8_1 + 0.0317460317460317*G3_9_1 + 0.0634920634920635*G3_10_1 + 0.00634920634920636*G3_11_1 - 0.666666666666666*G10_0_0_1 - 0.666666666666666*G10_0_1_1 - 0.666666666666666*G12_0_0_1 - 0.666666666666666*G12_0_1_1;
    A[63] = -0.00634920634920633*G0_0_0 - 0.00634920634920632*G0_0_1 + 0.00634920634920634*G0_1_0 + 0.0317460317460317*G0_2_1 + 0.0761904761904761*G0_3_0 + 0.0507936507936507*G0_3_1 - 0.0761904761904761*G0_4_0 - 0.0253968253968254*G0_4_1 - 0.0507936507936508*G0_5_1 - 0.0126984126984127*G1_0_0 - 0.00634920634920634*G1_0_1 - 0.019047619047619*G1_1_0 - 0.00634920634920634*G1_1_1 + 0.019047619047619*G1_2_0 - 0.00634920634920634*G1_2_1 + 0.0761904761904761*G1_3_0 + 0.0507936507936507*G1_3_1 + 0.152380952380952*G1_4_0 + 0.0507936507936507*G1_4_1 + 0.0507936507936508*G1_5_0 + 0.0507936507936507*G1_5_1 - 0.0126984126984127*G3_6_0 - 0.00634920634920634*G3_6_1 - 0.019047619047619*G3_7_0 - 0.00634920634920634*G3_7_1 + 0.019047619047619*G3_8_0 - 0.00634920634920634*G3_8_1 + 0.0761904761904761*G3_9_0 + 0.0507936507936507*G3_9_1 + 0.152380952380952*G3_10_0 + 0.0507936507936507*G3_10_1 + 0.0507936507936508*G3_11_0 + 0.0507936507936507*G3_11_1 - 1.33333333333333*G10_0_0_0 - 0.666666666666665*G10_0_0_1 - 0.666666666666666*G10_0_1_0 - 1.33333333333333*G12_0_0_0 - 0.666666666666665*G12_0_0_1 - 0.666666666666666*G12_0_1_0;
    A[64] = -0.0634920634920635*G0_0_0 - 0.0634920634920635*G0_0_1 - 0.0380952380952381*G0_1_0 + 0.0634920634920635*G0_2_1 + 0.152380952380952*G0_3_0 + 0.0507936507936507*G0_3_1 - 0.152380952380952*G0_4_0 + 0.101587301587302*G0_5_0 - 0.0507936507936507*G0_5_1 + 0.0126984126984127*G1_0_0 + 0.0317460317460318*G1_0_1 + 0.019047619047619*G1_1_0 - 0.019047619047619*G1_2_0 - 0.0317460317460317*G1_2_1 - 0.0761904761904761*G1_3_0 - 0.0253968253968254*G1_3_1 - 0.152380952380952*G1_4_0 - 0.0507936507936508*G1_5_0 + 0.0253968253968254*G1_5_1 + 0.0126984126984127*G3_6_0 + 0.0317460317460318*G3_6_1 + 0.019047619047619*G3_7_0 - 0.019047619047619*G3_8_0 - 0.0317460317460317*G3_8_1 - 0.0761904761904761*G3_9_0 - 0.0253968253968254*G3_9_1 - 0.152380952380952*G3_10_0 - 0.0507936507936508*G3_11_0 + 0.0253968253968254*G3_11_1 + 1.33333333333333*G10_0_0_0 + 0.666666666666666*G10_0_0_1 + 0.666666666666666*G10_0_1_0 + 1.33333333333333*G10_0_1_1 + 1.33333333333333*G12_0_0_0 + 0.666666666666666*G12_0_0_1 + 0.666666666666666*G12_0_1_0 + 1.33333333333333*G12_0_1_1;
    A[65] = -0.0317460317460317*G0_0_0 - 0.0317460317460317*G0_0_1 + 0.00634920634920634*G0_1_0 + 0.00634920634920636*G0_2_1 + 0.0507936507936508*G0_3_0 + 0.0507936507936507*G0_3_1 - 0.0507936507936508*G0_4_0 + 0.0253968253968254*G0_4_1 + 0.0253968253968254*G0_5_0 - 0.0507936507936508*G0_5_1 + 0.0253968253968254*G1_0_0 + 0.00634920634920634*G1_0_1 - 0.0126984126984127*G1_1_0 + 0.00634920634920634*G1_1_1 - 0.00634920634920635*G1_2_0 + 0.00634920634920634*G1_2_1 - 0.0507936507936508*G1_3_1 + 0.101587301587302*G1_4_0 - 0.0507936507936507*G1_4_1 + 0.0253968253968254*G1_5_0 - 0.0507936507936508*G1_5_1 + 0.0253968253968254*G3_6_0 + 0.00634920634920634*G3_6_1 - 0.0126984126984127*G3_7_0 + 0.00634920634920634*G3_7_1 - 0.00634920634920635*G3_8_0 + 0.00634920634920634*G3_8_1 - 0.0507936507936508*G3_9_1 + 0.101587301587302*G3_10_0 - 0.0507936507936507*G3_10_1 + 0.0253968253968254*G3_11_0 - 0.0507936507936508*G3_11_1 + 0.666666666666665*G10_0_0_1 + 0.666666666666667*G10_0_1_0 + 0.666666666666665*G12_0_0_1 + 0.666666666666667*G12_0_1_0;
    A[66] = -0.0190476190476191*G2_0_0 - 0.0190476190476191*G2_0_1 - 0.00634920634920636*G2_1_0 - 0.0126984126984127*G2_2_1 - 0.0126984126984127*G2_3_0 - 0.00634920634920634*G2_3_1 + 0.0126984126984127*G2_4_0 + 0.0317460317460318*G2_4_1 + 0.0253968253968254*G2_5_0 + 0.00634920634920634*G2_5_1;
    A[67] = 0.00793650793650793*G2_0_0 + 0.00793650793650793*G2_0_1 + 0.00476190476190476*G2_1_0 - 0.00793650793650794*G2_2_1 - 0.019047619047619*G2_3_0 - 0.00634920634920634*G2_3_1 + 0.019047619047619*G2_4_0 - 0.0126984126984127*G2_5_0 + 0.00634920634920634*G2_5_1;
    A[68] = 0.0126984126984127*G2_0_0 + 0.0126984126984127*G2_0_1 - 0.00634920634920635*G2_1_0 + 0.019047619047619*G2_2_1 + 0.019047619047619*G2_3_0 - 0.00634920634920634*G2_3_1 - 0.019047619047619*G2_4_0 - 0.0317460317460317*G2_4_1 - 0.00634920634920635*G2_5_0 + 0.00634920634920634*G2_5_1;
    A[69] = -0.00634920634920633*G2_0_0 - 0.00634920634920632*G2_0_1 + 0.00634920634920634*G2_1_0 + 0.0317460317460317*G2_2_1 + 0.0761904761904761*G2_3_0 + 0.0507936507936507*G2_3_1 - 0.0761904761904761*G2_4_0 - 0.0253968253968254*G2_4_1 - 0.0507936507936508*G2_5_1;
    A[70] = -0.0634920634920635*G2_0_0 - 0.0634920634920635*G2_0_1 - 0.0380952380952381*G2_1_0 + 0.0634920634920635*G2_2_1 + 0.152380952380952*G2_3_0 + 0.0507936507936507*G2_3_1 - 0.152380952380952*G2_4_0 + 0.101587301587302*G2_5_0 - 0.0507936507936507*G2_5_1;
    A[71] = -0.0317460317460317*G2_0_0 - 0.0317460317460317*G2_0_1 + 0.00634920634920634*G2_1_0 + 0.00634920634920636*G2_2_1 + 0.0507936507936508*G2_3_0 + 0.0507936507936507*G2_3_1 - 0.0507936507936508*G2_4_0 + 0.0253968253968254*G2_4_1 + 0.0253968253968254*G2_5_0 - 0.0507936507936508*G2_5_1;
    A[72] = 0.166666666666667*G14_0 - 0.166666666666667*G14_1;
    A[73] = 0.166666666666667*G14_0;
    A[74] = 0.333333333333333*G14_0 + 0.166666666666667*G14_1;
    A[75] = -0.0190476190476191*G0_0_0 - 0.0190476190476191*G0_0_1 - 0.0126984126984127*G0_1_0 - 0.00634920634920635*G0_2_1 - 0.00634920634920635*G0_3_0 - 0.0126984126984127*G0_3_1 + 0.00634920634920635*G0_4_0 + 0.0253968253968254*G0_4_1 + 0.0317460317460318*G0_5_0 + 0.0126984126984127*G0_5_1 - 0.0190476190476191*G1_0_0 - 0.0190476190476191*G1_0_1 + 0.0126984126984127*G1_1_0 + 0.0126984126984127*G1_1_1 + 0.00793650793650793*G1_2_0 + 0.00793650793650793*G1_2_1 - 0.00634920634920633*G1_3_0 - 0.00634920634920632*G1_3_1 - 0.0317460317460317*G1_4_0 - 0.0317460317460317*G1_4_1 - 0.0634920634920635*G1_5_0 - 0.0634920634920635*G1_5_1 - 0.0190476190476191*G3_6_0 - 0.0190476190476191*G3_6_1 + 0.0126984126984127*G3_7_0 + 0.0126984126984127*G3_7_1 + 0.00793650793650793*G3_8_0 + 0.00793650793650793*G3_8_1 - 0.00634920634920633*G3_9_0 - 0.00634920634920632*G3_9_1 - 0.0317460317460317*G3_10_0 - 0.0317460317460317*G3_10_1 - 0.0634920634920635*G3_11_0 - 0.0634920634920635*G3_11_1 - 0.666666666666667*G10_0_0_0 - 0.666666666666667*G10_0_0_1 - 0.666666666666667*G12_0_0_0 - 0.666666666666667*G12_0_0_1;
    A[76] = 0.0126984126984127*G0_0_0 + 0.0126984126984127*G0_0_1 + 0.019047619047619*G0_1_0 - 0.00634920634920636*G0_2_1 - 0.00634920634920635*G0_3_0 + 0.019047619047619*G0_3_1 + 0.00634920634920635*G0_4_0 - 0.00634920634920633*G0_4_1 - 0.0317460317460317*G0_5_0 - 0.0190476190476191*G0_5_1 - 0.0126984126984127*G1_0_0 + 0.019047619047619*G1_1_0 - 0.00793650793650793*G1_2_0 + 0.0317460317460317*G1_3_0 + 0.00634920634920634*G1_4_0 + 0.0634920634920635*G1_5_0 - 0.0126984126984127*G3_6_0 + 0.019047619047619*G3_7_0 - 0.00793650793650793*G3_8_0 + 0.0317460317460317*G3_9_0 + 0.00634920634920634*G3_10_0 + 0.0634920634920635*G3_11_0 - 0.666666666666667*G10_0_0_0 - 0.666666666666667*G10_0_1_0 - 0.666666666666667*G12_0_0_0 - 0.666666666666667*G12_0_1_0;
    A[77] = 0.00793650793650793*G0_0_0 + 0.00793650793650793*G0_0_1 - 0.00793650793650793*G0_1_0 + 0.00476190476190476*G0_2_1 - 0.00634920634920633*G0_3_0 - 0.019047619047619*G0_3_1 + 0.00634920634920633*G0_4_0 - 0.0126984126984127*G0_4_1 + 0.019047619047619*G0_5_1 - 0.00634920634920635*G1_0_1 - 0.00634920634920636*G1_1_1 + 0.00476190476190476*G1_2_1 + 0.00634920634920636*G1_3_1 + 0.00634920634920636*G1_4_1 - 0.0380952380952381*G1_5_1 - 0.00634920634920635*G3_6_1 - 0.00634920634920636*G3_7_1 + 0.00476190476190476*G3_8_1 + 0.00634920634920636*G3_9_1 + 0.00634920634920636*G3_10_1 - 0.0380952380952381*G3_11_1;
    A[78] = -0.00634920634920633*G0_0_0 - 0.00634920634920632*G0_0_1 + 0.0317460317460317*G0_1_0 + 0.00634920634920636*G0_2_1 + 0.0507936507936508*G0_3_0 + 0.0761904761904761*G0_3_1 - 0.0507936507936508*G0_4_0 - 0.0253968253968254*G0_5_0 - 0.0761904761904762*G0_5_1 - 0.00634920634920635*G1_0_0 - 0.0126984126984127*G1_0_1 - 0.00634920634920635*G1_1_0 + 0.019047619047619*G1_1_1 - 0.00634920634920633*G1_2_0 - 0.019047619047619*G1_2_1 + 0.0507936507936508*G1_3_0 + 0.0761904761904761*G1_3_1 + 0.0507936507936507*G1_4_0 + 0.0507936507936507*G1_4_1 + 0.0507936507936507*G1_5_0 + 0.152380952380952*G1_5_1 - 0.00634920634920635*G3_6_0 - 0.0126984126984127*G3_6_1 - 0.00634920634920635*G3_7_0 + 0.019047619047619*G3_7_1 - 0.00634920634920633*G3_8_0 - 0.019047619047619*G3_8_1 + 0.0507936507936508*G3_9_0 + 0.0761904761904761*G3_9_1 + 0.0507936507936507*G3_10_0 + 0.0507936507936507*G3_10_1 + 0.0507936507936507*G3_11_0 + 0.152380952380952*G3_11_1 - 0.666666666666667*G10_0_0_1 - 0.666666666666666*G10_0_1_0 - 1.33333333333333*G10_0_1_1 - 0.666666666666667*G12_0_0_1 - 0.666666666666666*G12_0_1_0 - 1.33333333333333*G12_0_1_1;
    A[79] = -0.0317460317460317*G0_0_0 - 0.0317460317460317*G0_0_1 + 0.00634920634920634*G0_1_0 + 0.00634920634920636*G0_2_1 + 0.0507936507936507*G0_3_0 + 0.0507936507936507*G0_3_1 - 0.0507936507936507*G0_4_0 + 0.0253968253968254*G0_4_1 + 0.0253968253968254*G0_5_0 - 0.0507936507936508*G0_5_1 + 0.00634920634920635*G1_0_0 + 0.0253968253968254*G1_0_1 + 0.00634920634920635*G1_1_0 - 0.00634920634920633*G1_1_1 + 0.00634920634920633*G1_2_0 - 0.0126984126984127*G1_2_1 - 0.0507936507936508*G1_3_0 - 0.0507936507936507*G1_4_0 + 0.0253968253968254*G1_4_1 - 0.0507936507936507*G1_5_0 + 0.101587301587302*G1_5_1 + 0.00634920634920635*G3_6_0 + 0.0253968253968254*G3_6_1 + 0.00634920634920635*G3_7_0 - 0.00634920634920633*G3_7_1 + 0.00634920634920633*G3_8_0 - 0.0126984126984127*G3_8_1 - 0.0507936507936508*G3_9_0 - 0.0507936507936507*G3_10_0 + 0.0253968253968254*G3_10_1 - 0.0507936507936507*G3_11_0 + 0.101587301587302*G3_11_1 + 0.666666666666667*G10_0_0_1 + 0.666666666666666*G10_0_1_0 + 0.666666666666667*G12_0_0_1 + 0.666666666666666*G12_0_1_0;
    A[80] = -0.0634920634920635*G0_0_0 - 0.0634920634920635*G0_0_1 + 0.0634920634920635*G0_1_0 - 0.0380952380952381*G0_2_1 + 0.0507936507936507*G0_3_0 + 0.152380952380952*G0_3_1 - 0.0507936507936507*G0_4_0 + 0.101587301587302*G0_4_1 - 0.152380952380952*G0_5_1 + 0.0317460317460318*G1_0_0 + 0.0126984126984127*G1_0_1 - 0.0317460317460317*G1_1_0 - 0.0190476190476191*G1_1_1 + 0.019047619047619*G1_2_1 - 0.0253968253968254*G1_3_0 - 0.0761904761904762*G1_3_1 + 0.0253968253968254*G1_4_0 - 0.0507936507936508*G1_4_1 - 0.152380952380952*G1_5_1 + 0.0317460317460318*G3_6_0 + 0.0126984126984127*G3_6_1 - 0.0317460317460317*G3_7_0 - 0.0190476190476191*G3_7_1 + 0.019047619047619*G3_8_1 - 0.0253968253968254*G3_9_0 - 0.0761904761904762*G3_9_1 + 0.0253968253968254*G3_10_0 - 0.0507936507936508*G3_10_1 - 0.152380952380952*G3_11_1 + 1.33333333333333*G10_0_0_0 + 0.666666666666667*G10_0_0_1 + 0.666666666666667*G10_0_1_0 + 1.33333333333333*G10_0_1_1 + 1.33333333333333*G12_0_0_0 + 0.666666666666667*G12_0_0_1 + 0.666666666666667*G12_0_1_0 + 1.33333333333333*G12_0_1_1;
    A[81] = -0.0190476190476191*G2_0_0 - 0.0190476190476191*G2_0_1 - 0.0126984126984127*G2_1_0 - 0.00634920634920635*G2_2_1 - 0.00634920634920635*G2_3_0 - 0.0126984126984127*G2_3_1 + 0.00634920634920635*G2_4_0 + 0.0253968253968254*G2_4_1 + 0.0317460317460318*G2_5_0 + 0.0126984126984127*G2_5_1;
    A[82] = 0.0126984126984127*G2_0_0 + 0.0126984126984127*G2_0_1 + 0.019047619047619*G2_1_0 - 0.00634920634920636*G2_2_1 - 0.00634920634920635*G2_3_0 + 0.019047619047619*G2_3_1 + 0.00634920634920635*G2_4_0 - 0.00634920634920633*G2_4_1 - 0.0317460317460317*G2_5_0 - 0.0190476190476191*G2_5_1;
    A[83] = 0.00793650793650793*G2_0_0 + 0.00793650793650793*G2_0_1 - 0.00793650793650793*G2_1_0 + 0.00476190476190476*G2_2_1 - 0.00634920634920633*G2_3_0 - 0.019047619047619*G2_3_1 + 0.00634920634920633*G2_4_0 - 0.0126984126984127*G2_4_1 + 0.019047619047619*G2_5_1;
    A[84] = -0.00634920634920633*G2_0_0 - 0.00634920634920632*G2_0_1 + 0.0317460317460317*G2_1_0 + 0.00634920634920636*G2_2_1 + 0.0507936507936508*G2_3_0 + 0.0761904761904761*G2_3_1 - 0.0507936507936508*G2_4_0 - 0.0253968253968254*G2_5_0 - 0.0761904761904762*G2_5_1;
    A[85] = -0.0317460317460317*G2_0_0 - 0.0317460317460317*G2_0_1 + 0.00634920634920634*G2_1_0 + 0.00634920634920636*G2_2_1 + 0.0507936507936507*G2_3_0 + 0.0507936507936507*G2_3_1 - 0.0507936507936507*G2_4_0 + 0.0253968253968254*G2_4_1 + 0.0253968253968254*G2_5_0 - 0.0507936507936508*G2_5_1;
    A[86] = -0.0634920634920635*G2_0_0 - 0.0634920634920635*G2_0_1 + 0.0634920634920635*G2_1_0 - 0.0380952380952381*G2_2_1 + 0.0507936507936507*G2_3_0 + 0.152380952380952*G2_3_1 - 0.0507936507936507*G2_4_0 + 0.101587301587302*G2_4_1 - 0.152380952380952*G2_5_1;
    A[87] = -0.166666666666667*G14_0 + 0.166666666666667*G14_1;
    A[88] = 0.166666666666667*G14_0 + 0.333333333333333*G14_1;
    A[89] = 0.166666666666667*G14_1;
    A[90] = -0.030952380952381*G4_6_0 - 0.030952380952381*G4_6_1 - 0.00714285714285715*G4_7_0 - 0.00714285714285715*G4_8_1 + 0.00952380952380951*G4_9_0 + 0.00952380952380951*G4_9_1 - 0.00952380952380951*G4_10_0 + 0.0380952380952381*G4_10_1 + 0.0380952380952381*G4_11_0 - 0.00952380952380952*G4_11_1;
    A[91] = 0.00357142857142857*G4_6_0 + 0.00357142857142857*G4_6_1 - 0.00357142857142857*G4_7_0 + 0.00436507936507936*G4_8_1 + 0.00158730158730159*G4_9_0 - 0.00634920634920634*G4_9_1 - 0.00158730158730159*G4_10_0 - 0.00793650793650793*G4_10_1 + 0.00634920634920635*G4_11_1;
    A[92] = 0.00357142857142857*G4_6_0 + 0.00357142857142857*G4_6_1 + 0.00436507936507936*G4_7_0 - 0.00357142857142857*G4_8_1 - 0.00634920634920634*G4_9_0 + 0.00158730158730159*G4_9_1 + 0.00634920634920634*G4_10_0 - 0.00793650793650793*G4_11_0 - 0.00158730158730159*G4_11_1;
    A[93] = -0.00476190476190477*G4_6_0 - 0.00476190476190477*G4_6_1 - 0.00793650793650793*G4_7_0 - 0.00793650793650793*G4_8_1 - 0.019047619047619*G4_9_0 - 0.019047619047619*G4_9_1 + 0.019047619047619*G4_10_0 + 0.0126984126984127*G4_10_1 + 0.0126984126984127*G4_11_0 + 0.019047619047619*G4_11_1;
    A[94] = -0.0190476190476191*G4_6_0 - 0.0190476190476191*G4_6_1 - 0.00634920634920636*G4_7_0 - 0.0126984126984127*G4_8_1 - 0.0126984126984127*G4_9_0 - 0.00634920634920634*G4_9_1 + 0.0126984126984127*G4_10_0 + 0.0317460317460318*G4_10_1 + 0.0253968253968254*G4_11_0 + 0.00634920634920634*G4_11_1;
    A[95] = -0.0190476190476191*G4_6_0 - 0.0190476190476191*G4_6_1 - 0.0126984126984127*G4_7_0 - 0.00634920634920635*G4_8_1 - 0.00634920634920635*G4_9_0 - 0.0126984126984127*G4_9_1 + 0.00634920634920635*G4_10_0 + 0.0253968253968254*G4_10_1 + 0.0317460317460318*G4_11_0 + 0.0126984126984127*G4_11_1;
    A[96] = -0.030952380952381*G5_0_0 - 0.030952380952381*G5_0_1 + 0.00357142857142857*G5_1_0 + 0.00357142857142857*G5_1_1 + 0.00357142857142857*G5_2_0 + 0.00357142857142857*G5_2_1 - 0.00476190476190477*G5_3_0 - 0.00476190476190477*G5_3_1 - 0.0190476190476191*G5_4_0 - 0.0190476190476191*G5_4_1 - 0.0190476190476191*G5_5_0 - 0.0190476190476191*G5_5_1 - 0.030952380952381*G6_6_0 - 0.030952380952381*G6_6_1 - 0.00714285714285715*G6_7_0 - 0.00714285714285715*G6_8_1 + 0.00952380952380951*G6_9_0 + 0.00952380952380951*G6_9_1 - 0.00952380952380951*G6_10_0 + 0.0380952380952381*G6_10_1 + 0.0380952380952381*G6_11_0 - 0.00952380952380952*G6_11_1 - 0.030952380952381*G7_6_0 - 0.030952380952381*G7_6_1 + 0.00357142857142857*G7_7_0 + 0.00357142857142857*G7_7_1 + 0.00357142857142857*G7_8_0 + 0.00357142857142857*G7_8_1 - 0.00476190476190477*G7_9_0 - 0.00476190476190477*G7_9_1 - 0.0190476190476191*G7_10_0 - 0.0190476190476191*G7_10_1 - 0.0190476190476191*G7_11_0 - 0.0190476190476191*G7_11_1 + 0.5*G11_0_0_0 + 0.5*G11_0_0_1 + 0.5*G11_0_1_0 + 0.5*G11_0_1_1 + 0.5*G13_0_0_0 + 0.5*G13_0_0_1 + 0.5*G13_0_1_0 + 0.5*G13_0_1_1;
    A[97] = -0.00714285714285715*G5_0_0 - 0.00357142857142857*G5_1_0 + 0.00436507936507936*G5_2_0 - 0.00793650793650793*G5_3_0 - 0.00634920634920636*G5_4_0 - 0.0126984126984127*G5_5_0 + 0.00357142857142857*G6_6_0 + 0.00357142857142857*G6_6_1 - 0.00357142857142857*G6_7_0 + 0.00436507936507936*G6_8_1 + 0.00158730158730159*G6_9_0 - 0.00634920634920634*G6_9_1 - 0.00158730158730159*G6_10_0 - 0.00793650793650793*G6_10_1 + 0.00634920634920635*G6_11_1 - 0.00714285714285715*G7_6_0 - 0.00357142857142857*G7_7_0 + 0.00436507936507936*G7_8_0 - 0.00793650793650793*G7_9_0 - 0.00634920634920636*G7_10_0 - 0.0126984126984127*G7_11_0 + 0.166666666666667*G11_0_0_0 + 0.166666666666667*G11_0_1_0 + 0.166666666666667*G13_0_0_0 + 0.166666666666667*G13_0_1_0;
    A[98] = -0.00714285714285715*G5_0_1 + 0.00436507936507936*G5_1_1 - 0.00357142857142857*G5_2_1 - 0.00793650793650793*G5_3_1 - 0.0126984126984127*G5_4_1 - 0.00634920634920635*G5_5_1 + 0.00357142857142857*G6_6_0 + 0.00357142857142857*G6_6_1 + 0.00436507936507936*G6_7_0 - 0.00357142857142857*G6_8_1 - 0.00634920634920634*G6_9_0 + 0.00158730158730159*G6_9_1 + 0.00634920634920634*G6_10_0 - 0.00793650793650793*G6_11_0 - 0.00158730158730159*G6_11_1 - 0.00714285714285715*G7_6_1 + 0.00436507936507936*G7_7_1 - 0.00357142857142857*G7_8_1 - 0.00793650793650793*G7_9_1 - 0.0126984126984127*G7_10_1 - 0.00634920634920635*G7_11_1 + 0.166666666666667*G11_0_0_1 + 0.166666666666667*G11_0_1_1 + 0.166666666666667*G13_0_0_1 + 0.166666666666667*G13_0_1_1;
    A[99] = 0.00952380952380951*G5_0_0 + 0.00952380952380951*G5_0_1 + 0.00158730158730159*G5_1_0 - 0.00634920634920634*G5_1_1 - 0.00634920634920634*G5_2_0 + 0.00158730158730159*G5_2_1 - 0.019047619047619*G5_3_0 - 0.019047619047619*G5_3_1 - 0.0126984126984127*G5_4_0 - 0.00634920634920634*G5_4_1 - 0.00634920634920635*G5_5_0 - 0.0126984126984127*G5_5_1 - 0.00476190476190477*G6_6_0 - 0.00476190476190477*G6_6_1 - 0.00793650793650793*G6_7_0 - 0.00793650793650793*G6_8_1 - 0.019047619047619*G6_9_0 - 0.019047619047619*G6_9_1 + 0.019047619047619*G6_10_0 + 0.0126984126984127*G6_10_1 + 0.0126984126984127*G6_11_0 + 0.019047619047619*G6_11_1 + 0.00952380952380951*G7_6_0 + 0.00952380952380951*G7_6_1 + 0.00158730158730159*G7_7_0 - 0.00634920634920634*G7_7_1 - 0.00634920634920634*G7_8_0 + 0.00158730158730159*G7_8_1 - 0.019047619047619*G7_9_0 - 0.019047619047619*G7_9_1 - 0.0126984126984127*G7_10_0 - 0.00634920634920634*G7_10_1 - 0.00634920634920635*G7_11_0 - 0.0126984126984127*G7_11_1;
    A[100] = -0.00952380952380951*G5_0_0 + 0.0380952380952381*G5_0_1 - 0.00158730158730159*G5_1_0 - 0.00793650793650793*G5_1_1 + 0.00634920634920634*G5_2_0 + 0.019047619047619*G5_3_0 + 0.0126984126984127*G5_3_1 + 0.0126984126984127*G5_4_0 + 0.0317460317460318*G5_4_1 + 0.00634920634920635*G5_5_0 + 0.0253968253968254*G5_5_1 - 0.0190476190476191*G6_6_0 - 0.0190476190476191*G6_6_1 - 0.00634920634920636*G6_7_0 - 0.0126984126984127*G6_8_1 - 0.0126984126984127*G6_9_0 - 0.00634920634920634*G6_9_1 + 0.0126984126984127*G6_10_0 + 0.0317460317460318*G6_10_1 + 0.0253968253968254*G6_11_0 + 0.00634920634920634*G6_11_1 - 0.00952380952380951*G7_6_0 + 0.0380952380952381*G7_6_1 - 0.00158730158730159*G7_7_0 - 0.00793650793650793*G7_7_1 + 0.00634920634920634*G7_8_0 + 0.019047619047619*G7_9_0 + 0.0126984126984127*G7_9_1 + 0.0126984126984127*G7_10_0 + 0.0317460317460318*G7_10_1 + 0.00634920634920635*G7_11_0 + 0.0253968253968254*G7_11_1 - 0.666666666666667*G11_0_0_1 - 0.666666666666666*G11_0_1_1 - 0.666666666666667*G13_0_0_1 - 0.666666666666666*G13_0_1_1;
    A[101] = 0.0380952380952381*G5_0_0 - 0.00952380952380952*G5_0_1 + 0.00634920634920635*G5_1_1 - 0.00793650793650793*G5_2_0 - 0.00158730158730159*G5_2_1 + 0.0126984126984127*G5_3_0 + 0.019047619047619*G5_3_1 + 0.0253968253968254*G5_4_0 + 0.00634920634920634*G5_4_1 + 0.0317460317460318*G5_5_0 + 0.0126984126984127*G5_5_1 - 0.0190476190476191*G6_6_0 - 0.0190476190476191*G6_6_1 - 0.0126984126984127*G6_7_0 - 0.00634920634920635*G6_8_1 - 0.00634920634920635*G6_9_0 - 0.0126984126984127*G6_9_1 + 0.00634920634920635*G6_10_0 + 0.0253968253968254*G6_10_1 + 0.0317460317460318*G6_11_0 + 0.0126984126984127*G6_11_1 + 0.0380952380952381*G7_6_0 - 0.00952380952380952*G7_6_1 + 0.00634920634920635*G7_7_1 - 0.00793650793650793*G7_8_0 - 0.00158730158730159*G7_8_1 + 0.0126984126984127*G7_9_0 + 0.019047619047619*G7_9_1 + 0.0253968253968254*G7_10_0 + 0.00634920634920634*G7_10_1 + 0.0317460317460318*G7_11_0 + 0.0126984126984127*G7_11_1 - 0.666666666666667*G11_0_0_0 - 0.666666666666667*G11_0_1_0 - 0.666666666666667*G13_0_0_0 - 0.666666666666667*G13_0_1_0;
    A[102] = 0.166666666666667*G15_0 + 0.166666666666667*G15_1;
    A[103] = 0.0;
    A[104] = 0.0;
    A[105] = 0.00357142857142857*G4_6_0 + 0.00357142857142857*G4_6_1 - 0.00357142857142857*G4_7_0 + 0.00436507936507936*G4_8_1 + 0.00158730158730159*G4_9_0 - 0.00634920634920634*G4_9_1 - 0.00158730158730159*G4_10_0 - 0.00793650793650793*G4_10_1 + 0.00634920634920635*G4_11_1;
    A[106] = 0.00714285714285713*G4_6_0 + 0.00714285714285714*G4_6_1 + 0.0309523809523809*G4_7_0 - 0.00714285714285713*G4_8_1 + 0.0095238095238095*G4_9_0 + 0.0476190476190476*G4_9_1 - 0.0095238095238095*G4_10_0 - 0.0380952380952381*G4_11_0 - 0.0476190476190476*G4_11_1;
    A[107] = -0.00436507936507936*G4_6_0 - 0.00436507936507936*G4_6_1 - 0.00357142857142856*G4_7_0 - 0.00357142857142857*G4_8_1 - 0.00634920634920633*G4_9_0 - 0.00634920634920634*G4_9_1 + 0.00634920634920633*G4_10_0 + 0.00793650793650792*G4_10_1 + 0.00793650793650793*G4_11_0 + 0.00634920634920634*G4_11_1;
    A[108] = 0.00634920634920634*G4_6_0 + 0.00634920634920634*G4_6_1 + 0.019047619047619*G4_7_0 - 0.0126984126984127*G4_8_1 - 0.0126984126984127*G4_9_0 + 0.019047619047619*G4_9_1 + 0.0126984126984127*G4_10_0 + 0.00634920634920636*G4_10_1 - 0.0253968253968254*G4_11_0 - 0.019047619047619*G4_11_1;
    A[109] = 0.00793650793650793*G4_6_0 + 0.00793650793650793*G4_6_1 + 0.00476190476190476*G4_7_0 - 0.00793650793650794*G4_8_1 - 0.019047619047619*G4_9_0 - 0.00634920634920634*G4_9_1 + 0.019047619047619*G4_10_0 - 0.0126984126984127*G4_11_0 + 0.00634920634920634*G4_11_1;
    A[110] = 0.0126984126984127*G4_6_0 + 0.0126984126984127*G4_6_1 + 0.019047619047619*G4_7_0 - 0.00634920634920636*G4_8_1 - 0.00634920634920635*G4_9_0 + 0.019047619047619*G4_9_1 + 0.00634920634920635*G4_10_0 - 0.00634920634920633*G4_10_1 - 0.0317460317460317*G4_11_0 - 0.0190476190476191*G4_11_1;
    A[111] = 0.00357142857142857*G5_0_0 + 0.00357142857142857*G5_0_1 + 0.00714285714285713*G5_1_0 + 0.00714285714285714*G5_1_1 - 0.00436507936507936*G5_2_0 - 0.00436507936507936*G5_2_1 + 0.00634920634920634*G5_3_0 + 0.00634920634920634*G5_3_1 + 0.00793650793650793*G5_4_0 + 0.00793650793650793*G5_4_1 + 0.0126984126984127*G5_5_0 + 0.0126984126984127*G5_5_1 + 0.00357142857142857*G6_6_0 + 0.00357142857142857*G6_6_1 - 0.00357142857142857*G6_7_0 + 0.00436507936507936*G6_8_1 + 0.00158730158730159*G6_9_0 - 0.00634920634920634*G6_9_1 - 0.00158730158730159*G6_10_0 - 0.00793650793650793*G6_10_1 + 0.00634920634920635*G6_11_1 + 0.00357142857142857*G7_6_0 + 0.00357142857142857*G7_6_1 + 0.00714285714285713*G7_7_0 + 0.00714285714285714*G7_7_1 - 0.00436507936507936*G7_8_0 - 0.00436507936507936*G7_8_1 + 0.00634920634920634*G7_9_0 + 0.00634920634920634*G7_9_1 + 0.00793650793650793*G7_10_0 + 0.00793650793650793*G7_10_1 + 0.0126984126984127*G7_11_0 + 0.0126984126984127*G7_11_1 + 0.166666666666667*G11_0_0_0 + 0.166666666666667*G11_0_0_1 + 0.166666666666667*G13_0_0_0 + 0.166666666666667*G13_0_0_1;
    A[112] = -0.00357142857142857*G5_0_0 + 0.0309523809523809*G5_1_0 - 0.00357142857142856*G5_2_0 + 0.019047619047619*G5_3_0 + 0.00476190476190476*G5_4_0 + 0.019047619047619*G5_5_0 + 0.00714285714285713*G6_6_0 + 0.00714285714285714*G6_6_1 + 0.0309523809523809*G6_7_0 - 0.00714285714285713*G6_8_1 + 0.0095238095238095*G6_9_0 + 0.0476190476190476*G6_9_1 - 0.0095238095238095*G6_10_0 - 0.0380952380952381*G6_11_0 - 0.0476190476190476*G6_11_1 - 0.00357142857142857*G7_6_0 + 0.0309523809523809*G7_7_0 - 0.00357142857142856*G7_8_0 + 0.019047619047619*G7_9_0 + 0.00476190476190476*G7_10_0 + 0.019047619047619*G7_11_0 + 0.5*G11_0_0_0 + 0.5*G13_0_0_0;
    A[113] = 0.00436507936507936*G5_0_1 - 0.00714285714285713*G5_1_1 - 0.00357142857142857*G5_2_1 - 0.0126984126984127*G5_3_1 - 0.00793650793650794*G5_4_1 - 0.00634920634920636*G5_5_1 - 0.00436507936507936*G6_6_0 - 0.00436507936507936*G6_6_1 - 0.00357142857142856*G6_7_0 - 0.00357142857142857*G6_8_1 - 0.00634920634920633*G6_9_0 - 0.00634920634920634*G6_9_1 + 0.00634920634920633*G6_10_0 + 0.00793650793650792*G6_10_1 + 0.00793650793650793*G6_11_0 + 0.00634920634920634*G6_11_1 + 0.00436507936507936*G7_6_1 - 0.00714285714285713*G7_7_1 - 0.00357142857142857*G7_8_1 - 0.0126984126984127*G7_9_1 - 0.00793650793650794*G7_10_1 - 0.00634920634920636*G7_11_1 - 0.166666666666667*G11_0_0_1 - 0.166666666666667*G13_0_0_1;
    A[114] = 0.00158730158730159*G5_0_0 - 0.00634920634920634*G5_0_1 + 0.0095238095238095*G5_1_0 + 0.0476190476190476*G5_1_1 - 0.00634920634920633*G5_2_0 - 0.00634920634920634*G5_2_1 - 0.0126984126984127*G5_3_0 + 0.019047619047619*G5_3_1 - 0.019047619047619*G5_4_0 - 0.00634920634920634*G5_4_1 - 0.00634920634920635*G5_5_0 + 0.019047619047619*G5_5_1 + 0.00634920634920634*G6_6_0 + 0.00634920634920634*G6_6_1 + 0.019047619047619*G6_7_0 - 0.0126984126984127*G6_8_1 - 0.0126984126984127*G6_9_0 + 0.019047619047619*G6_9_1 + 0.0126984126984127*G6_10_0 + 0.00634920634920636*G6_10_1 - 0.0253968253968254*G6_11_0 - 0.019047619047619*G6_11_1 + 0.00158730158730159*G7_6_0 - 0.00634920634920634*G7_6_1 + 0.0095238095238095*G7_7_0 + 0.0476190476190476*G7_7_1 - 0.00634920634920633*G7_8_0 - 0.00634920634920634*G7_8_1 - 0.0126984126984127*G7_9_0 + 0.019047619047619*G7_9_1 - 0.019047619047619*G7_10_0 - 0.00634920634920634*G7_10_1 - 0.00634920634920635*G7_11_0 + 0.019047619047619*G7_11_1 + 0.666666666666666*G11_0_0_1 + 0.666666666666666*G13_0_0_1;
    A[115] = -0.00158730158730159*G5_0_0 - 0.00793650793650793*G5_0_1 - 0.0095238095238095*G5_1_0 + 0.00634920634920633*G5_2_0 + 0.00793650793650792*G5_2_1 + 0.0126984126984127*G5_3_0 + 0.00634920634920636*G5_3_1 + 0.019047619047619*G5_4_0 + 0.00634920634920635*G5_5_0 - 0.00634920634920633*G5_5_1 + 0.00793650793650793*G6_6_0 + 0.00793650793650793*G6_6_1 + 0.00476190476190476*G6_7_0 - 0.00793650793650794*G6_8_1 - 0.019047619047619*G6_9_0 - 0.00634920634920634*G6_9_1 + 0.019047619047619*G6_10_0 - 0.0126984126984127*G6_11_0 + 0.00634920634920634*G6_11_1 - 0.00158730158730159*G7_6_0 - 0.00793650793650793*G7_6_1 - 0.0095238095238095*G7_7_0 + 0.00634920634920633*G7_8_0 + 0.00793650793650792*G7_8_1 + 0.0126984126984127*G7_9_0 + 0.00634920634920636*G7_9_1 + 0.019047619047619*G7_10_0 + 0.00634920634920635*G7_11_0 - 0.00634920634920633*G7_11_1;
    A[116] = 0.00634920634920635*G5_0_1 - 0.0380952380952381*G5_1_0 - 0.0476190476190476*G5_1_1 + 0.00793650793650793*G5_2_0 + 0.00634920634920634*G5_2_1 - 0.0253968253968254*G5_3_0 - 0.019047619047619*G5_3_1 - 0.0126984126984127*G5_4_0 + 0.00634920634920634*G5_4_1 - 0.0317460317460317*G5_5_0 - 0.0190476190476191*G5_5_1 + 0.0126984126984127*G6_6_0 + 0.0126984126984127*G6_6_1 + 0.019047619047619*G6_7_0 - 0.00634920634920636*G6_8_1 - 0.00634920634920635*G6_9_0 + 0.019047619047619*G6_9_1 + 0.00634920634920635*G6_10_0 - 0.00634920634920633*G6_10_1 - 0.0317460317460317*G6_11_0 - 0.0190476190476191*G6_11_1 + 0.00634920634920635*G7_6_1 - 0.0380952380952381*G7_7_0 - 0.0476190476190476*G7_7_1 + 0.00793650793650793*G7_8_0 + 0.00634920634920634*G7_8_1 - 0.0253968253968254*G7_9_0 - 0.019047619047619*G7_9_1 - 0.0126984126984127*G7_10_0 + 0.00634920634920634*G7_10_1 - 0.0317460317460317*G7_11_0 - 0.0190476190476191*G7_11_1 - 0.666666666666667*G11_0_0_0 - 0.666666666666666*G11_0_0_1 - 0.666666666666667*G13_0_0_0 - 0.666666666666666*G13_0_0_1;
    A[117] = 0.0;
    A[118] = -0.166666666666667*G15_0;
    A[119] = 0.0;
    A[120] = 0.00357142857142857*G4_6_0 + 0.00357142857142857*G4_6_1 + 0.00436507936507936*G4_7_0 - 0.00357142857142857*G4_8_1 - 0.00634920634920634*G4_9_0 + 0.00158730158730159*G4_9_1 + 0.00634920634920634*G4_10_0 - 0.00793650793650793*G4_11_0 - 0.00158730158730159*G4_11_1;
    A[121] = -0.00436507936507936*G4_6_0 - 0.00436507936507936*G4_6_1 - 0.00357142857142857*G4_7_0 - 0.00357142857142857*G4_8_1 - 0.00634920634920634*G4_9_0 - 0.00634920634920634*G4_9_1 + 0.00634920634920634*G4_10_0 + 0.00793650793650792*G4_10_1 + 0.00793650793650793*G4_11_0 + 0.00634920634920634*G4_11_1;
    A[122] = 0.00714285714285714*G4_6_0 + 0.00714285714285713*G4_6_1 - 0.00714285714285714*G4_7_0 + 0.0309523809523809*G4_8_1 + 0.0476190476190475*G4_9_0 + 0.0095238095238095*G4_9_1 - 0.0476190476190475*G4_10_0 - 0.038095238095238*G4_10_1 - 0.00952380952380951*G4_11_1;
    A[123] = 0.00634920634920635*G4_6_0 + 0.00634920634920634*G4_6_1 - 0.0126984126984127*G4_7_0 + 0.019047619047619*G4_8_1 + 0.019047619047619*G4_9_0 - 0.0126984126984127*G4_9_1 - 0.019047619047619*G4_10_0 - 0.0253968253968254*G4_10_1 + 0.00634920634920634*G4_11_0 + 0.0126984126984127*G4_11_1;
    A[124] = 0.0126984126984127*G4_6_0 + 0.0126984126984127*G4_6_1 - 0.00634920634920635*G4_7_0 + 0.019047619047619*G4_8_1 + 0.019047619047619*G4_9_0 - 0.00634920634920634*G4_9_1 - 0.019047619047619*G4_10_0 - 0.0317460317460317*G4_10_1 - 0.00634920634920635*G4_11_0 + 0.00634920634920634*G4_11_1;
    A[125] = 0.00793650793650793*G4_6_0 + 0.00793650793650793*G4_6_1 - 0.00793650793650793*G4_7_0 + 0.00476190476190476*G4_8_1 - 0.00634920634920633*G4_9_0 - 0.019047619047619*G4_9_1 + 0.00634920634920633*G4_10_0 - 0.0126984126984127*G4_10_1 + 0.019047619047619*G4_11_1;
    A[126] = 0.00357142857142857*G5_0_0 + 0.00357142857142857*G5_0_1 - 0.00436507936507936*G5_1_0 - 0.00436507936507936*G5_1_1 + 0.00714285714285714*G5_2_0 + 0.00714285714285713*G5_2_1 + 0.00634920634920635*G5_3_0 + 0.00634920634920634*G5_3_1 + 0.0126984126984127*G5_4_0 + 0.0126984126984127*G5_4_1 + 0.00793650793650793*G5_5_0 + 0.00793650793650793*G5_5_1 + 0.00357142857142857*G6_6_0 + 0.00357142857142857*G6_6_1 + 0.00436507936507936*G6_7_0 - 0.00357142857142857*G6_8_1 - 0.00634920634920634*G6_9_0 + 0.00158730158730159*G6_9_1 + 0.00634920634920634*G6_10_0 - 0.00793650793650793*G6_11_0 - 0.00158730158730159*G6_11_1 + 0.00357142857142857*G7_6_0 + 0.00357142857142857*G7_6_1 - 0.00436507936507936*G7_7_0 - 0.00436507936507936*G7_7_1 + 0.00714285714285714*G7_8_0 + 0.00714285714285713*G7_8_1 + 0.00634920634920635*G7_9_0 + 0.00634920634920634*G7_9_1 + 0.0126984126984127*G7_10_0 + 0.0126984126984127*G7_10_1 + 0.00793650793650793*G7_11_0 + 0.00793650793650793*G7_11_1 + 0.166666666666667*G11_0_1_0 + 0.166666666666667*G11_0_1_1 + 0.166666666666667*G13_0_1_0 + 0.166666666666667*G13_0_1_1;
    A[127] = 0.00436507936507936*G5_0_0 - 0.00357142857142857*G5_1_0 - 0.00714285714285714*G5_2_0 - 0.0126984126984127*G5_3_0 - 0.00634920634920635*G5_4_0 - 0.00793650793650793*G5_5_0 - 0.00436507936507936*G6_6_0 - 0.00436507936507936*G6_6_1 - 0.00357142857142857*G6_7_0 - 0.00357142857142857*G6_8_1 - 0.00634920634920634*G6_9_0 - 0.00634920634920634*G6_9_1 + 0.00634920634920634*G6_10_0 + 0.00793650793650792*G6_10_1 + 0.00793650793650793*G6_11_0 + 0.00634920634920634*G6_11_1 + 0.00436507936507936*G7_6_0 - 0.00357142857142857*G7_7_0 - 0.00714285714285714*G7_8_0 - 0.0126984126984127*G7_9_0 - 0.00634920634920635*G7_10_0 - 0.00793650793650793*G7_11_0 - 0.166666666666667*G11_0_1_0 - 0.166666666666667*G13_0_1_0;
    A[128] = -0.00357142857142857*G5_0_1 - 0.00357142857142857*G5_1_1 + 0.0309523809523809*G5_2_1 + 0.019047619047619*G5_3_1 + 0.019047619047619*G5_4_1 + 0.00476190476190476*G5_5_1 + 0.00714285714285714*G6_6_0 + 0.00714285714285713*G6_6_1 - 0.00714285714285714*G6_7_0 + 0.0309523809523809*G6_8_1 + 0.0476190476190475*G6_9_0 + 0.0095238095238095*G6_9_1 - 0.0476190476190475*G6_10_0 - 0.038095238095238*G6_10_1 - 0.00952380952380951*G6_11_1 - 0.00357142857142857*G7_6_1 - 0.00357142857142857*G7_7_1 + 0.0309523809523809*G7_8_1 + 0.019047619047619*G7_9_1 + 0.019047619047619*G7_10_1 + 0.00476190476190476*G7_11_1 + 0.5*G11_0_1_1 + 0.5*G13_0_1_1;
    A[129] = -0.00634920634920634*G5_0_0 + 0.00158730158730159*G5_0_1 - 0.00634920634920634*G5_1_0 - 0.00634920634920634*G5_1_1 + 0.0476190476190475*G5_2_0 + 0.0095238095238095*G5_2_1 + 0.019047619047619*G5_3_0 - 0.0126984126984127*G5_3_1 + 0.019047619047619*G5_4_0 - 0.00634920634920634*G5_4_1 - 0.00634920634920633*G5_5_0 - 0.019047619047619*G5_5_1 + 0.00634920634920635*G6_6_0 + 0.00634920634920634*G6_6_1 - 0.0126984126984127*G6_7_0 + 0.019047619047619*G6_8_1 + 0.019047619047619*G6_9_0 - 0.0126984126984127*G6_9_1 - 0.019047619047619*G6_10_0 - 0.0253968253968254*G6_10_1 + 0.00634920634920634*G6_11_0 + 0.0126984126984127*G6_11_1 - 0.00634920634920634*G7_6_0 + 0.00158730158730159*G7_6_1 - 0.00634920634920634*G7_7_0 - 0.00634920634920634*G7_7_1 + 0.0476190476190475*G7_8_0 + 0.0095238095238095*G7_8_1 + 0.019047619047619*G7_9_0 - 0.0126984126984127*G7_9_1 + 0.019047619047619*G7_10_0 - 0.00634920634920634*G7_10_1 - 0.00634920634920633*G7_11_0 - 0.019047619047619*G7_11_1 + 0.666666666666666*G11_0_1_0 + 0.666666666666666*G13_0_1_0;
    A[130] = 0.00634920634920634*G5_0_0 + 0.00634920634920634*G5_1_0 + 0.00793650793650792*G5_1_1 - 0.0476190476190475*G5_2_0 - 0.038095238095238*G5_2_1 - 0.019047619047619*G5_3_0 - 0.0253968253968254*G5_3_1 - 0.019047619047619*G5_4_0 - 0.0317460317460317*G5_4_1 + 0.00634920634920633*G5_5_0 - 0.0126984126984127*G5_5_1 + 0.0126984126984127*G6_6_0 + 0.0126984126984127*G6_6_1 - 0.00634920634920635*G6_7_0 + 0.019047619047619*G6_8_1 + 0.019047619047619*G6_9_0 - 0.00634920634920634*G6_9_1 - 0.019047619047619*G6_10_0 - 0.0317460317460317*G6_10_1 - 0.00634920634920635*G6_11_0 + 0.00634920634920634*G6_11_1 + 0.00634920634920634*G7_6_0 + 0.00634920634920634*G7_7_0 + 0.00793650793650792*G7_7_1 - 0.0476190476190475*G7_8_0 - 0.038095238095238*G7_8_1 - 0.019047619047619*G7_9_0 - 0.0253968253968254*G7_9_1 - 0.019047619047619*G7_10_0 - 0.0317460317460317*G7_10_1 + 0.00634920634920633*G7_11_0 - 0.0126984126984127*G7_11_1 - 0.666666666666666*G11_0_1_0 - 0.666666666666666*G11_0_1_1 - 0.666666666666666*G13_0_1_0 - 0.666666666666666*G13_0_1_1;
    A[131] = -0.00793650793650793*G5_0_0 - 0.00158730158730159*G5_0_1 + 0.00793650793650793*G5_1_0 + 0.00634920634920634*G5_1_1 - 0.00952380952380951*G5_2_1 + 0.00634920634920634*G5_3_0 + 0.0126984126984127*G5_3_1 - 0.00634920634920635*G5_4_0 + 0.00634920634920634*G5_4_1 + 0.019047619047619*G5_5_1 + 0.00793650793650793*G6_6_0 + 0.00793650793650793*G6_6_1 - 0.00793650793650793*G6_7_0 + 0.00476190476190476*G6_8_1 - 0.00634920634920633*G6_9_0 - 0.019047619047619*G6_9_1 + 0.00634920634920633*G6_10_0 - 0.0126984126984127*G6_10_1 + 0.019047619047619*G6_11_1 - 0.00793650793650793*G7_6_0 - 0.00158730158730159*G7_6_1 + 0.00793650793650793*G7_7_0 + 0.00634920634920634*G7_7_1 - 0.00952380952380951*G7_8_1 + 0.00634920634920634*G7_9_0 + 0.0126984126984127*G7_9_1 - 0.00634920634920635*G7_10_0 + 0.00634920634920634*G7_10_1 + 0.019047619047619*G7_11_1;
    A[132] = 0.0;
    A[133] = 0.0;
    A[134] = -0.166666666666667*G15_1;
    A[135] = -0.00476190476190476*G4_6_0 - 0.00476190476190477*G4_6_1 - 0.00793650793650793*G4_7_0 - 0.00793650793650793*G4_8_1 - 0.019047619047619*G4_9_0 - 0.019047619047619*G4_9_1 + 0.019047619047619*G4_10_0 + 0.0126984126984127*G4_10_1 + 0.0126984126984127*G4_11_0 + 0.019047619047619*G4_11_1;
    A[136] = 0.00634920634920634*G4_6_0 + 0.00634920634920634*G4_6_1 + 0.019047619047619*G4_7_0 - 0.0126984126984127*G4_8_1 - 0.0126984126984127*G4_9_0 + 0.019047619047619*G4_9_1 + 0.0126984126984127*G4_10_0 + 0.00634920634920636*G4_10_1 - 0.0253968253968254*G4_11_0 - 0.019047619047619*G4_11_1;
    A[137] = 0.00634920634920635*G4_6_0 + 0.00634920634920634*G4_6_1 - 0.0126984126984127*G4_7_0 + 0.019047619047619*G4_8_1 + 0.019047619047619*G4_9_0 - 0.0126984126984127*G4_9_1 - 0.019047619047619*G4_10_0 - 0.0253968253968254*G4_10_1 + 0.00634920634920634*G4_11_0 + 0.0126984126984127*G4_11_1;
    A[138] = 0.0380952380952381*G4_6_0 + 0.0380952380952381*G4_6_1 + 0.0634920634920634*G4_7_0 + 0.0634920634920634*G4_8_1 + 0.152380952380952*G4_9_0 + 0.152380952380952*G4_9_1 - 0.152380952380952*G4_10_0 - 0.101587301587301*G4_10_1 - 0.101587301587302*G4_11_0 - 0.152380952380952*G4_11_1;
    A[139] = -0.00634920634920633*G4_6_0 - 0.00634920634920632*G4_6_1 + 0.00634920634920634*G4_7_0 + 0.0317460317460317*G4_8_1 + 0.0761904761904761*G4_9_0 + 0.0507936507936507*G4_9_1 - 0.0761904761904761*G4_10_0 - 0.0253968253968254*G4_10_1 - 0.0507936507936508*G4_11_1;
    A[140] = -0.00634920634920633*G4_6_0 - 0.00634920634920632*G4_6_1 + 0.0317460317460317*G4_7_0 + 0.00634920634920636*G4_8_1 + 0.0507936507936508*G4_9_0 + 0.0761904761904761*G4_9_1 - 0.0507936507936508*G4_10_0 - 0.0253968253968254*G4_11_0 - 0.0761904761904762*G4_11_1;
    A[141] = -0.00476190476190476*G5_0_0 - 0.00476190476190477*G5_0_1 + 0.00634920634920634*G5_1_0 + 0.00634920634920634*G5_1_1 + 0.00634920634920635*G5_2_0 + 0.00634920634920634*G5_2_1 + 0.0380952380952381*G5_3_0 + 0.0380952380952381*G5_3_1 - 0.00634920634920633*G5_4_0 - 0.00634920634920632*G5_4_1 - 0.00634920634920633*G5_5_0 - 0.00634920634920632*G5_5_1 - 0.00476190476190476*G6_6_0 - 0.00476190476190477*G6_6_1 - 0.00793650793650793*G6_7_0 - 0.00793650793650793*G6_8_1 - 0.019047619047619*G6_9_0 - 0.019047619047619*G6_9_1 + 0.019047619047619*G6_10_0 + 0.0126984126984127*G6_10_1 + 0.0126984126984127*G6_11_0 + 0.019047619047619*G6_11_1 - 0.00476190476190476*G7_6_0 - 0.00476190476190477*G7_6_1 + 0.00634920634920634*G7_7_0 + 0.00634920634920634*G7_7_1 + 0.00634920634920635*G7_8_0 + 0.00634920634920634*G7_8_1 + 0.0380952380952381*G7_9_0 + 0.0380952380952381*G7_9_1 - 0.00634920634920633*G7_10_0 - 0.00634920634920632*G7_10_1 - 0.00634920634920633*G7_11_0 - 0.00634920634920632*G7_11_1;
    A[142] = -0.00793650793650793*G5_0_0 + 0.019047619047619*G5_1_0 - 0.0126984126984127*G5_2_0 + 0.0634920634920634*G5_3_0 + 0.00634920634920634*G5_4_0 + 0.0317460317460317*G5_5_0 + 0.00634920634920634*G6_6_0 + 0.00634920634920634*G6_6_1 + 0.019047619047619*G6_7_0 - 0.0126984126984127*G6_8_1 - 0.0126984126984127*G6_9_0 + 0.019047619047619*G6_9_1 + 0.0126984126984127*G6_10_0 + 0.00634920634920636*G6_10_1 - 0.0253968253968254*G6_11_0 - 0.019047619047619*G6_11_1 - 0.00793650793650793*G7_6_0 + 0.019047619047619*G7_7_0 - 0.0126984126984127*G7_8_0 + 0.0634920634920634*G7_9_0 + 0.00634920634920634*G7_10_0 + 0.0317460317460317*G7_11_0 + 0.666666666666666*G11_0_1_0 + 0.666666666666666*G13_0_1_0;
    A[143] = -0.00793650793650793*G5_0_1 - 0.0126984126984127*G5_1_1 + 0.019047619047619*G5_2_1 + 0.0634920634920634*G5_3_1 + 0.0317460317460317*G5_4_1 + 0.00634920634920636*G5_5_1 + 0.00634920634920635*G6_6_0 + 0.00634920634920634*G6_6_1 - 0.0126984126984127*G6_7_0 + 0.019047619047619*G6_8_1 + 0.019047619047619*G6_9_0 - 0.0126984126984127*G6_9_1 - 0.019047619047619*G6_10_0 - 0.0253968253968254*G6_10_1 + 0.00634920634920634*G6_11_0 + 0.0126984126984127*G6_11_1 - 0.00793650793650793*G7_6_1 - 0.0126984126984127*G7_7_1 + 0.019047619047619*G7_8_1 + 0.0634920634920634*G7_9_1 + 0.0317460317460317*G7_10_1 + 0.00634920634920636*G7_11_1 + 0.666666666666666*G11_0_0_1 + 0.666666666666666*G13_0_0_1;
    A[144] = -0.019047619047619*G5_0_0 - 0.019047619047619*G5_0_1 - 0.0126984126984127*G5_1_0 + 0.019047619047619*G5_1_1 + 0.019047619047619*G5_2_0 - 0.0126984126984127*G5_2_1 + 0.152380952380952*G5_3_0 + 0.152380952380952*G5_3_1 + 0.0761904761904761*G5_4_0 + 0.0507936507936507*G5_4_1 + 0.0507936507936508*G5_5_0 + 0.0761904761904761*G5_5_1 + 0.0380952380952381*G6_6_0 + 0.0380952380952381*G6_6_1 + 0.0634920634920634*G6_7_0 + 0.0634920634920634*G6_8_1 + 0.152380952380952*G6_9_0 + 0.152380952380952*G6_9_1 - 0.152380952380952*G6_10_0 - 0.101587301587301*G6_10_1 - 0.101587301587302*G6_11_0 - 0.152380952380952*G6_11_1 - 0.019047619047619*G7_6_0 - 0.019047619047619*G7_6_1 - 0.0126984126984127*G7_7_0 + 0.019047619047619*G7_7_1 + 0.019047619047619*G7_8_0 - 0.0126984126984127*G7_8_1 + 0.152380952380952*G7_9_0 + 0.152380952380952*G7_9_1 + 0.0761904761904761*G7_10_0 + 0.0507936507936507*G7_10_1 + 0.0507936507936508*G7_11_0 + 0.0761904761904761*G7_11_1 + 1.33333333333333*G11_0_0_0 + 0.666666666666665*G11_0_0_1 + 0.666666666666665*G11_0_1_0 + 1.33333333333333*G11_0_1_1 + 1.33333333333333*G13_0_0_0 + 0.666666666666665*G13_0_0_1 + 0.666666666666665*G13_0_1_0 + 1.33333333333333*G13_0_1_1;
    A[145] = 0.019047619047619*G5_0_0 + 0.0126984126984127*G5_0_1 + 0.0126984126984127*G5_1_0 + 0.00634920634920636*G5_1_1 - 0.019047619047619*G5_2_0 - 0.0253968253968254*G5_2_1 - 0.152380952380952*G5_3_0 - 0.101587301587301*G5_3_1 - 0.0761904761904761*G5_4_0 - 0.0253968253968254*G5_4_1 - 0.0507936507936508*G5_5_0 - 0.00634920634920633*G6_6_0 - 0.00634920634920632*G6_6_1 + 0.00634920634920634*G6_7_0 + 0.0317460317460317*G6_8_1 + 0.0761904761904761*G6_9_0 + 0.0507936507936507*G6_9_1 - 0.0761904761904761*G6_10_0 - 0.0253968253968254*G6_10_1 - 0.0507936507936508*G6_11_1 + 0.019047619047619*G7_6_0 + 0.0126984126984127*G7_6_1 + 0.0126984126984127*G7_7_0 + 0.00634920634920636*G7_7_1 - 0.019047619047619*G7_8_0 - 0.0253968253968254*G7_8_1 - 0.152380952380952*G7_9_0 - 0.101587301587301*G7_9_1 - 0.0761904761904761*G7_10_0 - 0.0253968253968254*G7_10_1 - 0.0507936507936508*G7_11_0 - 1.33333333333333*G11_0_0_0 - 0.666666666666666*G11_0_0_1 - 0.666666666666665*G11_0_1_0 - 1.33333333333333*G13_0_0_0 - 0.666666666666666*G13_0_0_1 - 0.666666666666665*G13_0_1_0;
    A[146] = 0.0126984126984127*G5_0_0 + 0.019047619047619*G5_0_1 - 0.0253968253968254*G5_1_0 - 0.019047619047619*G5_1_1 + 0.00634920634920634*G5_2_0 + 0.0126984126984127*G5_2_1 - 0.101587301587302*G5_3_0 - 0.152380952380952*G5_3_1 - 0.0507936507936508*G5_4_1 - 0.0253968253968254*G5_5_0 - 0.0761904761904762*G5_5_1 - 0.00634920634920633*G6_6_0 - 0.00634920634920632*G6_6_1 + 0.0317460317460317*G6_7_0 + 0.00634920634920636*G6_8_1 + 0.0507936507936508*G6_9_0 + 0.0761904761904761*G6_9_1 - 0.0507936507936508*G6_10_0 - 0.0253968253968254*G6_11_0 - 0.0761904761904762*G6_11_1 + 0.0126984126984127*G7_6_0 + 0.019047619047619*G7_6_1 - 0.0253968253968254*G7_7_0 - 0.019047619047619*G7_7_1 + 0.00634920634920634*G7_8_0 + 0.0126984126984127*G7_8_1 - 0.101587301587302*G7_9_0 - 0.152380952380952*G7_9_1 - 0.0507936507936508*G7_10_1 - 0.0253968253968254*G7_11_0 - 0.0761904761904762*G7_11_1 - 0.666666666666665*G11_0_0_1 - 0.666666666666667*G11_0_1_0 - 1.33333333333333*G11_0_1_1 - 0.666666666666665*G13_0_0_1 - 0.666666666666667*G13_0_1_0 - 1.33333333333333*G13_0_1_1;
    A[147] = -0.166666666666667*G15_0 - 0.166666666666667*G15_1;
    A[148] = -0.166666666666667*G15_0 - 0.333333333333333*G15_1;
    A[149] = -0.333333333333333*G15_0 - 0.166666666666666*G15_1;
    A[150] = -0.0190476190476191*G4_6_0 - 0.0190476190476191*G4_6_1 - 0.00634920634920636*G4_7_0 - 0.0126984126984127*G4_8_1 - 0.0126984126984127*G4_9_0 - 0.00634920634920634*G4_9_1 + 0.0126984126984127*G4_10_0 + 0.0317460317460318*G4_10_1 + 0.0253968253968254*G4_11_0 + 0.00634920634920634*G4_11_1;
    A[151] = 0.00793650793650793*G4_6_0 + 0.00793650793650793*G4_6_1 + 0.00476190476190476*G4_7_0 - 0.00793650793650794*G4_8_1 - 0.019047619047619*G4_9_0 - 0.00634920634920634*G4_9_1 + 0.019047619047619*G4_10_0 - 0.0126984126984127*G4_11_0 + 0.00634920634920634*G4_11_1;
    A[152] = 0.0126984126984127*G4_6_0 + 0.0126984126984127*G4_6_1 - 0.00634920634920635*G4_7_0 + 0.019047619047619*G4_8_1 + 0.019047619047619*G4_9_0 - 0.00634920634920634*G4_9_1 - 0.019047619047619*G4_10_0 - 0.0317460317460317*G4_10_1 - 0.00634920634920635*G4_11_0 + 0.00634920634920634*G4_11_1;
    A[153] = -0.00634920634920633*G4_6_0 - 0.00634920634920632*G4_6_1 + 0.00634920634920634*G4_7_0 + 0.0317460317460317*G4_8_1 + 0.0761904761904761*G4_9_0 + 0.0507936507936507*G4_9_1 - 0.0761904761904761*G4_10_0 - 0.0253968253968254*G4_10_1 - 0.0507936507936508*G4_11_1;
    A[154] = -0.0634920634920635*G4_6_0 - 0.0634920634920635*G4_6_1 - 0.0380952380952381*G4_7_0 + 0.0634920634920635*G4_8_1 + 0.152380952380952*G4_9_0 + 0.0507936507936507*G4_9_1 - 0.152380952380952*G4_10_0 + 0.101587301587302*G4_11_0 - 0.0507936507936507*G4_11_1;
    A[155] = -0.0317460317460317*G4_6_0 - 0.0317460317460317*G4_6_1 + 0.00634920634920634*G4_7_0 + 0.00634920634920636*G4_8_1 + 0.0507936507936508*G4_9_0 + 0.0507936507936507*G4_9_1 - 0.0507936507936508*G4_10_0 + 0.0253968253968254*G4_10_1 + 0.0253968253968254*G4_11_0 - 0.0507936507936508*G4_11_1;
    A[156] = -0.0190476190476191*G5_0_0 - 0.0190476190476191*G5_0_1 + 0.00793650793650793*G5_1_0 + 0.00793650793650793*G5_1_1 + 0.0126984126984127*G5_2_0 + 0.0126984126984127*G5_2_1 - 0.00634920634920633*G5_3_0 - 0.00634920634920632*G5_3_1 - 0.0634920634920635*G5_4_0 - 0.0634920634920635*G5_4_1 - 0.0317460317460317*G5_5_0 - 0.0317460317460317*G5_5_1 - 0.0190476190476191*G6_6_0 - 0.0190476190476191*G6_6_1 - 0.00634920634920636*G6_7_0 - 0.0126984126984127*G6_8_1 - 0.0126984126984127*G6_9_0 - 0.00634920634920634*G6_9_1 + 0.0126984126984127*G6_10_0 + 0.0317460317460318*G6_10_1 + 0.0253968253968254*G6_11_0 + 0.00634920634920634*G6_11_1 - 0.0190476190476191*G7_6_0 - 0.0190476190476191*G7_6_1 + 0.00793650793650793*G7_7_0 + 0.00793650793650793*G7_7_1 + 0.0126984126984127*G7_8_0 + 0.0126984126984127*G7_8_1 - 0.00634920634920633*G7_9_0 - 0.00634920634920632*G7_9_1 - 0.0634920634920635*G7_10_0 - 0.0634920634920635*G7_10_1 - 0.0317460317460317*G7_11_0 - 0.0317460317460317*G7_11_1 - 0.666666666666667*G11_0_1_0 - 0.666666666666666*G11_0_1_1 - 0.666666666666667*G13_0_1_0 - 0.666666666666666*G13_0_1_1;
    A[157] = -0.00634920634920636*G5_0_0 + 0.00476190476190476*G5_1_0 - 0.00634920634920635*G5_2_0 + 0.00634920634920634*G5_3_0 - 0.0380952380952381*G5_4_0 + 0.00634920634920634*G5_5_0 + 0.00793650793650793*G6_6_0 + 0.00793650793650793*G6_6_1 + 0.00476190476190476*G6_7_0 - 0.00793650793650794*G6_8_1 - 0.019047619047619*G6_9_0 - 0.00634920634920634*G6_9_1 + 0.019047619047619*G6_10_0 - 0.0126984126984127*G6_11_0 + 0.00634920634920634*G6_11_1 - 0.00634920634920636*G7_6_0 + 0.00476190476190476*G7_7_0 - 0.00634920634920635*G7_8_0 + 0.00634920634920634*G7_9_0 - 0.0380952380952381*G7_10_0 + 0.00634920634920634*G7_11_0;
    A[158] = -0.0126984126984127*G5_0_1 - 0.00793650793650794*G5_1_1 + 0.019047619047619*G5_2_1 + 0.0317460317460317*G5_3_1 + 0.0634920634920635*G5_4_1 + 0.00634920634920636*G5_5_1 + 0.0126984126984127*G6_6_0 + 0.0126984126984127*G6_6_1 - 0.00634920634920635*G6_7_0 + 0.019047619047619*G6_8_1 + 0.019047619047619*G6_9_0 - 0.00634920634920634*G6_9_1 - 0.019047619047619*G6_10_0 - 0.0317460317460317*G6_10_1 - 0.00634920634920635*G6_11_0 + 0.00634920634920634*G6_11_1 - 0.0126984126984127*G7_6_1 - 0.00793650793650794*G7_7_1 + 0.019047619047619*G7_8_1 + 0.0317460317460317*G7_9_1 + 0.0634920634920635*G7_10_1 + 0.00634920634920636*G7_11_1 - 0.666666666666666*G11_0_0_1 - 0.666666666666666*G11_0_1_1 - 0.666666666666666*G13_0_0_1 - 0.666666666666666*G13_0_1_1;
    A[159] = -0.0126984126984127*G5_0_0 - 0.00634920634920634*G5_0_1 - 0.019047619047619*G5_1_0 - 0.00634920634920634*G5_1_1 + 0.019047619047619*G5_2_0 - 0.00634920634920634*G5_2_1 + 0.0761904761904761*G5_3_0 + 0.0507936507936507*G5_3_1 + 0.152380952380952*G5_4_0 + 0.0507936507936507*G5_4_1 + 0.0507936507936508*G5_5_0 + 0.0507936507936507*G5_5_1 - 0.00634920634920633*G6_6_0 - 0.00634920634920632*G6_6_1 + 0.00634920634920634*G6_7_0 + 0.0317460317460317*G6_8_1 + 0.0761904761904761*G6_9_0 + 0.0507936507936507*G6_9_1 - 0.0761904761904761*G6_10_0 - 0.0253968253968254*G6_10_1 - 0.0507936507936508*G6_11_1 - 0.0126984126984127*G7_6_0 - 0.00634920634920634*G7_6_1 - 0.019047619047619*G7_7_0 - 0.00634920634920634*G7_7_1 + 0.019047619047619*G7_8_0 - 0.00634920634920634*G7_8_1 + 0.0761904761904761*G7_9_0 + 0.0507936507936507*G7_9_1 + 0.152380952380952*G7_10_0 + 0.0507936507936507*G7_10_1 + 0.0507936507936508*G7_11_0 + 0.0507936507936507*G7_11_1 - 1.33333333333333*G11_0_0_0 - 0.666666666666665*G11_0_0_1 - 0.666666666666666*G11_0_1_0 - 1.33333333333333*G13_0_0_0 - 0.666666666666665*G13_0_0_1 - 0.666666666666666*G13_0_1_0;
    A[160] = 0.0126984126984127*G5_0_0 + 0.0317460317460318*G5_0_1 + 0.019047619047619*G5_1_0 - 0.019047619047619*G5_2_0 - 0.0317460317460317*G5_2_1 - 0.0761904761904761*G5_3_0 - 0.0253968253968254*G5_3_1 - 0.152380952380952*G5_4_0 - 0.0507936507936508*G5_5_0 + 0.0253968253968254*G5_5_1 - 0.0634920634920635*G6_6_0 - 0.0634920634920635*G6_6_1 - 0.0380952380952381*G6_7_0 + 0.0634920634920635*G6_8_1 + 0.152380952380952*G6_9_0 + 0.0507936507936507*G6_9_1 - 0.152380952380952*G6_10_0 + 0.101587301587302*G6_11_0 - 0.0507936507936507*G6_11_1 + 0.0126984126984127*G7_6_0 + 0.0317460317460318*G7_6_1 + 0.019047619047619*G7_7_0 - 0.019047619047619*G7_8_0 - 0.0317460317460317*G7_8_1 - 0.0761904761904761*G7_9_0 - 0.0253968253968254*G7_9_1 - 0.152380952380952*G7_10_0 - 0.0507936507936508*G7_11_0 + 0.0253968253968254*G7_11_1 + 1.33333333333333*G11_0_0_0 + 0.666666666666666*G11_0_0_1 + 0.666666666666666*G11_0_1_0 + 1.33333333333333*G11_0_1_1 + 1.33333333333333*G13_0_0_0 + 0.666666666666666*G13_0_0_1 + 0.666666666666666*G13_0_1_0 + 1.33333333333333*G13_0_1_1;
    A[161] = 0.0253968253968254*G5_0_0 + 0.00634920634920634*G5_0_1 - 0.0126984126984127*G5_1_0 + 0.00634920634920634*G5_1_1 - 0.00634920634920635*G5_2_0 + 0.00634920634920634*G5_2_1 - 0.0507936507936508*G5_3_1 + 0.101587301587302*G5_4_0 - 0.0507936507936507*G5_4_1 + 0.0253968253968254*G5_5_0 - 0.0507936507936508*G5_5_1 - 0.0317460317460317*G6_6_0 - 0.0317460317460317*G6_6_1 + 0.00634920634920634*G6_7_0 + 0.00634920634920636*G6_8_1 + 0.0507936507936508*G6_9_0 + 0.0507936507936507*G6_9_1 - 0.0507936507936508*G6_10_0 + 0.0253968253968254*G6_10_1 + 0.0253968253968254*G6_11_0 - 0.0507936507936508*G6_11_1 + 0.0253968253968254*G7_6_0 + 0.00634920634920634*G7_6_1 - 0.0126984126984127*G7_7_0 + 0.00634920634920634*G7_7_1 - 0.00634920634920635*G7_8_0 + 0.00634920634920634*G7_8_1 - 0.0507936507936508*G7_9_1 + 0.101587301587302*G7_10_0 - 0.0507936507936507*G7_10_1 + 0.0253968253968254*G7_11_0 - 0.0507936507936508*G7_11_1 + 0.666666666666665*G11_0_0_1 + 0.666666666666667*G11_0_1_0 + 0.666666666666665*G13_0_0_1 + 0.666666666666667*G13_0_1_0;
    A[162] = 0.166666666666667*G15_0 - 0.166666666666667*G15_1;
    A[163] = 0.166666666666667*G15_0;
    A[164] = 0.333333333333333*G15_0 + 0.166666666666667*G15_1;
    A[165] = -0.0190476190476191*G4_6_0 - 0.0190476190476191*G4_6_1 - 0.0126984126984127*G4_7_0 - 0.00634920634920635*G4_8_1 - 0.00634920634920635*G4_9_0 - 0.0126984126984127*G4_9_1 + 0.00634920634920635*G4_10_0 + 0.0253968253968254*G4_10_1 + 0.0317460317460318*G4_11_0 + 0.0126984126984127*G4_11_1;
    A[166] = 0.0126984126984127*G4_6_0 + 0.0126984126984127*G4_6_1 + 0.019047619047619*G4_7_0 - 0.00634920634920636*G4_8_1 - 0.00634920634920635*G4_9_0 + 0.019047619047619*G4_9_1 + 0.00634920634920635*G4_10_0 - 0.00634920634920633*G4_10_1 - 0.0317460317460317*G4_11_0 - 0.0190476190476191*G4_11_1;
    A[167] = 0.00793650793650793*G4_6_0 + 0.00793650793650793*G4_6_1 - 0.00793650793650793*G4_7_0 + 0.00476190476190476*G4_8_1 - 0.00634920634920633*G4_9_0 - 0.019047619047619*G4_9_1 + 0.00634920634920633*G4_10_0 - 0.0126984126984127*G4_10_1 + 0.019047619047619*G4_11_1;
    A[168] = -0.00634920634920633*G4_6_0 - 0.00634920634920632*G4_6_1 + 0.0317460317460317*G4_7_0 + 0.00634920634920636*G4_8_1 + 0.0507936507936508*G4_9_0 + 0.0761904761904761*G4_9_1 - 0.0507936507936508*G4_10_0 - 0.0253968253968254*G4_11_0 - 0.0761904761904762*G4_11_1;
    A[169] = -0.0317460317460317*G4_6_0 - 0.0317460317460317*G4_6_1 + 0.00634920634920634*G4_7_0 + 0.00634920634920636*G4_8_1 + 0.0507936507936507*G4_9_0 + 0.0507936507936507*G4_9_1 - 0.0507936507936507*G4_10_0 + 0.0253968253968254*G4_10_1 + 0.0253968253968254*G4_11_0 - 0.0507936507936508*G4_11_1;
    A[170] = -0.0634920634920635*G4_6_0 - 0.0634920634920635*G4_6_1 + 0.0634920634920635*G4_7_0 - 0.0380952380952381*G4_8_1 + 0.0507936507936507*G4_9_0 + 0.152380952380952*G4_9_1 - 0.0507936507936507*G4_10_0 + 0.101587301587302*G4_10_1 - 0.152380952380952*G4_11_1;
    A[171] = -0.0190476190476191*G5_0_0 - 0.0190476190476191*G5_0_1 + 0.0126984126984127*G5_1_0 + 0.0126984126984127*G5_1_1 + 0.00793650793650793*G5_2_0 + 0.00793650793650793*G5_2_1 - 0.00634920634920633*G5_3_0 - 0.00634920634920632*G5_3_1 - 0.0317460317460317*G5_4_0 - 0.0317460317460317*G5_4_1 - 0.0634920634920635*G5_5_0 - 0.0634920634920635*G5_5_1 - 0.0190476190476191*G6_6_0 - 0.0190476190476191*G6_6_1 - 0.0126984126984127*G6_7_0 - 0.00634920634920635*G6_8_1 - 0.00634920634920635*G6_9_0 - 0.0126984126984127*G6_9_1 + 0.00634920634920635*G6_10_0 + 0.0253968253968254*G6_10_1 + 0.0317460317460318*G6_11_0 + 0.0126984126984127*G6_11_1 - 0.0190476190476191*G7_6_0 - 0.0190476190476191*G7_6_1 + 0.0126984126984127*G7_7_0 + 0.0126984126984127*G7_7_1 + 0.00793650793650793*G7_8_0 + 0.00793650793650793*G7_8_1 - 0.00634920634920633*G7_9_0 - 0.00634920634920632*G7_9_1 - 0.0317460317460317*G7_10_0 - 0.0317460317460317*G7_10_1 - 0.0634920634920635*G7_11_0 - 0.0634920634920635*G7_11_1 - 0.666666666666667*G11_0_0_0 - 0.666666666666667*G11_0_0_1 - 0.666666666666667*G13_0_0_0 - 0.666666666666667*G13_0_0_1;
    A[172] = -0.0126984126984127*G5_0_0 + 0.019047619047619*G5_1_0 - 0.00793650793650793*G5_2_0 + 0.0317460317460317*G5_3_0 + 0.00634920634920634*G5_4_0 + 0.0634920634920635*G5_5_0 + 0.0126984126984127*G6_6_0 + 0.0126984126984127*G6_6_1 + 0.019047619047619*G6_7_0 - 0.00634920634920636*G6_8_1 - 0.00634920634920635*G6_9_0 + 0.019047619047619*G6_9_1 + 0.00634920634920635*G6_10_0 - 0.00634920634920633*G6_10_1 - 0.0317460317460317*G6_11_0 - 0.0190476190476191*G6_11_1 - 0.0126984126984127*G7_6_0 + 0.019047619047619*G7_7_0 - 0.00793650793650793*G7_8_0 + 0.0317460317460317*G7_9_0 + 0.00634920634920634*G7_10_0 + 0.0634920634920635*G7_11_0 - 0.666666666666667*G11_0_0_0 - 0.666666666666667*G11_0_1_0 - 0.666666666666667*G13_0_0_0 - 0.666666666666667*G13_0_1_0;
    A[173] = -0.00634920634920635*G5_0_1 - 0.00634920634920636*G5_1_1 + 0.00476190476190476*G5_2_1 + 0.00634920634920636*G5_3_1 + 0.00634920634920636*G5_4_1 - 0.0380952380952381*G5_5_1 + 0.00793650793650793*G6_6_0 + 0.00793650793650793*G6_6_1 - 0.00793650793650793*G6_7_0 + 0.00476190476190476*G6_8_1 - 0.00634920634920633*G6_9_0 - 0.019047619047619*G6_9_1 + 0.00634920634920633*G6_10_0 - 0.0126984126984127*G6_10_1 + 0.019047619047619*G6_11_1 - 0.00634920634920635*G7_6_1 - 0.00634920634920636*G7_7_1 + 0.00476190476190476*G7_8_1 + 0.00634920634920636*G7_9_1 + 0.00634920634920636*G7_10_1 - 0.0380952380952381*G7_11_1;
    A[174] = -0.00634920634920635*G5_0_0 - 0.0126984126984127*G5_0_1 - 0.00634920634920635*G5_1_0 + 0.019047619047619*G5_1_1 - 0.00634920634920633*G5_2_0 - 0.019047619047619*G5_2_1 + 0.0507936507936508*G5_3_0 + 0.0761904761904761*G5_3_1 + 0.0507936507936507*G5_4_0 + 0.0507936507936507*G5_4_1 + 0.0507936507936507*G5_5_0 + 0.152380952380952*G5_5_1 - 0.00634920634920633*G6_6_0 - 0.00634920634920632*G6_6_1 + 0.0317460317460317*G6_7_0 + 0.00634920634920636*G6_8_1 + 0.0507936507936508*G6_9_0 + 0.0761904761904761*G6_9_1 - 0.0507936507936508*G6_10_0 - 0.0253968253968254*G6_11_0 - 0.0761904761904762*G6_11_1 - 0.00634920634920635*G7_6_0 - 0.0126984126984127*G7_6_1 - 0.00634920634920635*G7_7_0 + 0.019047619047619*G7_7_1 - 0.00634920634920633*G7_8_0 - 0.019047619047619*G7_8_1 + 0.0507936507936508*G7_9_0 + 0.0761904761904761*G7_9_1 + 0.0507936507936507*G7_10_0 + 0.0507936507936507*G7_10_1 + 0.0507936507936507*G7_11_0 + 0.152380952380952*G7_11_1 - 0.666666666666667*G11_0_0_1 - 0.666666666666666*G11_0_1_0 - 1.33333333333333*G11_0_1_1 - 0.666666666666667*G13_0_0_1 - 0.666666666666666*G13_0_1_0 - 1.33333333333333*G13_0_1_1;
    A[175] = 0.00634920634920635*G5_0_0 + 0.0253968253968254*G5_0_1 + 0.00634920634920635*G5_1_0 - 0.00634920634920633*G5_1_1 + 0.00634920634920633*G5_2_0 - 0.0126984126984127*G5_2_1 - 0.0507936507936508*G5_3_0 - 0.0507936507936507*G5_4_0 + 0.0253968253968254*G5_4_1 - 0.0507936507936507*G5_5_0 + 0.101587301587302*G5_5_1 - 0.0317460317460317*G6_6_0 - 0.0317460317460317*G6_6_1 + 0.00634920634920634*G6_7_0 + 0.00634920634920636*G6_8_1 + 0.0507936507936507*G6_9_0 + 0.0507936507936507*G6_9_1 - 0.0507936507936507*G6_10_0 + 0.0253968253968254*G6_10_1 + 0.0253968253968254*G6_11_0 - 0.0507936507936508*G6_11_1 + 0.00634920634920635*G7_6_0 + 0.0253968253968254*G7_6_1 + 0.00634920634920635*G7_7_0 - 0.00634920634920633*G7_7_1 + 0.00634920634920633*G7_8_0 - 0.0126984126984127*G7_8_1 - 0.0507936507936508*G7_9_0 - 0.0507936507936507*G7_10_0 + 0.0253968253968254*G7_10_1 - 0.0507936507936507*G7_11_0 + 0.101587301587302*G7_11_1 + 0.666666666666667*G11_0_0_1 + 0.666666666666666*G11_0_1_0 + 0.666666666666667*G13_0_0_1 + 0.666666666666666*G13_0_1_0;
    A[176] = 0.0317460317460318*G5_0_0 + 0.0126984126984127*G5_0_1 - 0.0317460317460317*G5_1_0 - 0.0190476190476191*G5_1_1 + 0.019047619047619*G5_2_1 - 0.0253968253968254*G5_3_0 - 0.0761904761904762*G5_3_1 + 0.0253968253968254*G5_4_0 - 0.0507936507936508*G5_4_1 - 0.152380952380952*G5_5_1 - 0.0634920634920635*G6_6_0 - 0.0634920634920635*G6_6_1 + 0.0634920634920635*G6_7_0 - 0.0380952380952381*G6_8_1 + 0.0507936507936507*G6_9_0 + 0.152380952380952*G6_9_1 - 0.0507936507936507*G6_10_0 + 0.101587301587302*G6_10_1 - 0.152380952380952*G6_11_1 + 0.0317460317460318*G7_6_0 + 0.0126984126984127*G7_6_1 - 0.0317460317460317*G7_7_0 - 0.0190476190476191*G7_7_1 + 0.019047619047619*G7_8_1 - 0.0253968253968254*G7_9_0 - 0.0761904761904762*G7_9_1 + 0.0253968253968254*G7_10_0 - 0.0507936507936508*G7_10_1 - 0.152380952380952*G7_11_1 + 1.33333333333333*G11_0_0_0 + 0.666666666666667*G11_0_0_1 + 0.666666666666667*G11_0_1_0 + 1.33333333333333*G11_0_1_1 + 1.33333333333333*G13_0_0_0 + 0.666666666666667*G13_0_0_1 + 0.666666666666667*G13_0_1_0 + 1.33333333333333*G13_0_1_1;
    A[177] = -0.166666666666667*G15_0 + 0.166666666666667*G15_1;
    A[178] = 0.166666666666667*G15_0 + 0.333333333333333*G15_1;
    A[179] = 0.166666666666667*G15_1;
    A[180] = -0.166666666666667*G8_0 - 0.166666666666667*G8_1;
    A[181] = 0.0;
    A[182] = 0.0;
    A[183] = 0.166666666666667*G8_0 + 0.166666666666667*G8_1;
    A[184] = -0.166666666666667*G8_0 + 0.166666666666667*G8_1;
    A[185] = 0.166666666666667*G8_0 - 0.166666666666667*G8_1;
    A[186] = -0.166666666666667*G9_0 - 0.166666666666667*G9_1;
    A[187] = 0.0;
    A[188] = 0.0;
    A[189] = 0.166666666666667*G9_0 + 0.166666666666667*G9_1;
    A[190] = -0.166666666666667*G9_0 + 0.166666666666667*G9_1;
    A[191] = 0.166666666666667*G9_0 - 0.166666666666667*G9_1;
    A[192] = 0.0;
    A[193] = 0.0;
    A[194] = 0.0;
    A[195] = 0.0;
    A[196] = 0.166666666666667*G8_0;
    A[197] = 0.0;
    A[198] = 0.166666666666667*G8_0 + 0.333333333333333*G8_1;
    A[199] = -0.166666666666667*G8_0;
    A[200] = -0.166666666666667*G8_0 - 0.333333333333333*G8_1;
    A[201] = 0.0;
    A[202] = 0.166666666666667*G9_0;
    A[203] = 0.0;
    A[204] = 0.166666666666667*G9_0 + 0.333333333333333*G9_1;
    A[205] = -0.166666666666667*G9_0;
    A[206] = -0.166666666666667*G9_0 - 0.333333333333333*G9_1;
    A[207] = 0.0;
    A[208] = 0.0;
    A[209] = 0.0;
    A[210] = 0.0;
    A[211] = 0.0;
    A[212] = 0.166666666666667*G8_1;
    A[213] = 0.333333333333333*G8_0 + 0.166666666666666*G8_1;
    A[214] = -0.333333333333333*G8_0 - 0.166666666666667*G8_1;
    A[215] = -0.166666666666667*G8_1;
    A[216] = 0.0;
    A[217] = 0.0;
    A[218] = 0.166666666666667*G9_1;
    A[219] = 0.333333333333333*G9_0 + 0.166666666666666*G9_1;
    A[220] = -0.333333333333333*G9_0 - 0.166666666666667*G9_1;
    A[221] = -0.166666666666667*G9_1;
    A[222] = 0.0;
    A[223] = 0.0;
    A[224] = 0.0;
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_9_otherwise: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_9_otherwise() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_9_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({true, false, true});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               int cell_orientation) const
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute cell volume
    
    
    // Compute circumradius of triangle in 2D
    
    
    // Array of quadrature weights.
    static const double W7[7] = {0.1125, 0.0629695902724136, 0.0629695902724136, 0.0629695902724136, 0.0661970763942531, 0.0661970763942531, 0.0661970763942531};
    // Quadrature points on the UFC reference element: (0.333333333333333, 0.333333333333333), (0.797426985353087, 0.101286507323456), (0.101286507323456, 0.797426985353087), (0.101286507323456, 0.101286507323456), (0.0597158717897698, 0.470142064105115), (0.470142064105115, 0.0597158717897698), (0.470142064105115, 0.470142064105115)
    
    // Values of basis functions at quadrature points.
    static const double FE0_C0[7][3] = \
    {{0.333333333333333, 0.333333333333333, 0.333333333333333},
    {0.101286507323456, 0.797426985353087, 0.101286507323456},
    {0.101286507323457, 0.101286507323456, 0.797426985353087},
    {0.797426985353087, 0.101286507323456, 0.101286507323456},
    {0.470142064105115, 0.0597158717897698, 0.470142064105115},
    {0.470142064105115, 0.470142064105115, 0.0597158717897697},
    {0.0597158717897699, 0.470142064105115, 0.470142064105115}};
    
    // Array of non-zero columns
    static const unsigned int nzc12[3] = {12, 13, 14};
    
    static const double FE1_C0[7][6] = \
    {{-0.111111111111111, -0.111111111111111, -0.111111111111111, 0.444444444444444, 0.444444444444444, 0.444444444444444},
    {-0.0807685941918872, 0.474352608585538, -0.0807685941918871, 0.323074376767549, 0.0410358262631383, 0.323074376767549},
    {-0.0807685941918872, -0.0807685941918872, 0.474352608585538, 0.323074376767549, 0.323074376767549, 0.0410358262631383},
    {0.474352608585539, -0.0807685941918871, -0.0807685941918871, 0.0410358262631383, 0.323074376767549, 0.323074376767549},
    {-0.0280749432230786, -0.0525839011025453, -0.0280749432230788, 0.112299772892315, 0.884134241764073, 0.112299772892315},
    {-0.0280749432230787, -0.0280749432230788, -0.0525839011025453, 0.112299772892315, 0.112299772892315, 0.884134241764073},
    {-0.0525839011025454, -0.0280749432230789, -0.0280749432230788, 0.884134241764072, 0.112299772892315, 0.112299772892315}};
    
    // Array of non-zero columns
    static const unsigned int nzc6[6] = {0, 1, 2, 3, 4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc9[6] = {6, 7, 8, 9, 10, 11};
    
    static const double FE1_C0_D01[7][5] = \
    {{-0.333333333333333, 0.333333333333333, 1.33333333333333, 0.0, -1.33333333333333},
    {0.594853970706175, -0.594853970706175, 3.18970794141235, 0.0, -3.18970794141235},
    {0.594853970706174, 2.18970794141235, 0.405146029293824, -2.78456191211852, -0.405146029293825},
    {-2.18970794141235, -0.594853970706175, 0.405146029293824, 2.78456191211852, -0.405146029293825},
    {-0.880568256420461, 0.88056825642046, 0.238863487159078, 0.0, -0.238863487159078},
    {-0.88056825642046, -0.76113651284092, 1.88056825642046, 1.64170476926138, -1.88056825642046},
    {0.761136512840921, 0.88056825642046, 1.88056825642046, -1.64170476926138, -1.88056825642046}};
    
    // Array of non-zero columns
    static const unsigned int nzc10[5] = {6, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc7[5] = {0, 2, 3, 4, 5};
    
    static const double FE1_C0_D10[7][5] = \
    {{-0.333333333333333, 0.333333333333333, 1.33333333333333, -1.33333333333333, 0.0},
    {0.594853970706174, 2.18970794141235, 0.405146029293824, -0.405146029293824, -2.78456191211852},
    {0.594853970706175, -0.594853970706175, 3.18970794141235, -3.18970794141235, 0.0},
    {-2.18970794141235, -0.594853970706175, 0.405146029293824, -0.405146029293824, 2.78456191211852},
    {-0.880568256420461, -0.761136512840922, 1.88056825642046, -1.88056825642046, 1.64170476926138},
    {-0.88056825642046, 0.880568256420461, 0.238863487159078, -0.238863487159078, 0.0},
    {0.761136512840921, 0.88056825642046, 1.88056825642046, -1.88056825642046, -1.64170476926138}};
    
    // Array of non-zero columns
    static const unsigned int nzc11[5] = {6, 7, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc8[5] = {0, 1, 3, 4, 5};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 23.
    double G[11];
    G[0] = K[0]*det;
    G[1] = K[2]*det;
    G[2] = K[1]*det;
    G[3] = K[3]*det;
    G[4] = det*w[2][0]*(K[0]*K[2] + K[1]*K[3]);
    G[5] = det*w[2][0]*(K[2]*K[2] + K[3]*K[3]);
    G[6] =  - K[3]*det;
    G[7] = det*w[2][0]*(K[0]*K[0] + K[1]*K[1]);
    G[8] =  - K[1]*det;
    G[9] =  - K[2]*det;
    G[10] =  - K[0]*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 1344
    for (unsigned int ip = 0; ip < 7; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      
      // Total number of operations to compute function values = 6
      for (unsigned int r = 0; r < 3; r++)
      {
        F6 += FE0_C0[ip][r]*w[0][nzc12[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 40
      for (unsigned int r = 0; r < 5; r++)
      {
        F0 += FE1_C0_D10[ip][r]*w[0][nzc8[r]];
        F1 += FE1_C0_D01[ip][r]*w[0][nzc7[r]];
        F4 += FE1_C0_D10[ip][r]*w[0][nzc11[r]];
        F5 += FE1_C0_D01[ip][r]*w[0][nzc10[r]];
      } // end loop over 'r'
      
      // Total number of operations to compute function values = 24
      for (unsigned int r = 0; r < 6; r++)
      {
        F2 += FE1_C0[ip][r]*w[0][nzc6[r]];
        F3 += FE1_C0[ip][r]*w[0][nzc9[r]];
      } // end loop over 'r'
      
      // Number of operations to compute ip constants: 52
      double I[7];
      // Number of operations: 8
      I[0] = W7[ip]*(F0*G[0] + F1*G[1] + F4*G[2] + F5*G[3]);
      
      // Number of operations: 6
      I[1] = W7[ip]*(F4*G[4] + F5*G[5] + F6*G[6]);
      
      // Number of operations: 6
      I[2] = W7[ip]*(F4*G[7] + F5*G[4] + F6*G[8]);
      
      // Number of operations: 6
      I[3] = W7[ip]*(F0*G[4] + F1*G[5] + F6*G[9]);
      
      // Number of operations: 6
      I[4] = W7[ip]*(F0*G[7] + F1*G[4] + F6*G[10]);
      
      // Number of operations: 10
      I[5] = W7[ip]*(F2*(F0*G[0] + F1*G[1]) + F3*(F0*G[2] + F1*G[3]));
      
      // Number of operations: 10
      I[6] = W7[ip]*(F4*(F2*G[0] + F3*G[2]) + F5*(F2*G[1] + F3*G[3]));
      
      
      // Number of operations for primary indices: 6
      for (unsigned int j = 0; j < 3; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc12[j]] += FE0_C0[ip][j]*I[0];
      } // end loop over 'j'
      
      // Number of operations for primary indices: 40
      for (unsigned int j = 0; j < 5; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc10[j]] += FE1_C0_D01[ip][j]*I[1];
        // Number of operations to compute entry: 2
        A[nzc11[j]] += FE1_C0_D10[ip][j]*I[2];
        // Number of operations to compute entry: 2
        A[nzc7[j]] += FE1_C0_D01[ip][j]*I[3];
        // Number of operations to compute entry: 2
        A[nzc8[j]] += FE1_C0_D10[ip][j]*I[4];
      } // end loop over 'j'
      
      // Number of operations for primary indices: 24
      for (unsigned int j = 0; j < 6; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc6[j]] += FE1_C0[ip][j]*I[5];
        // Number of operations to compute entry: 2
        A[nzc9[j]] += FE1_C0[ip][j]*I[6];
      } // end loop over 'j'
    } // end loop over 'ip'
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_9_otherwise: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_9_otherwise() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_9_otherwise()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({false, true, false});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               std::size_t facet,
                               int cell_orientation) const
  {
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = vertex_coordinates[2*v1 + 0] - vertex_coordinates[2*v0 + 0];
    const double dx1 = vertex_coordinates[2*v1 + 1] - vertex_coordinates[2*v0 + 1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    
    const bool direction = dx1*(vertex_coordinates[2*facet] - vertex_coordinates[2*v0]) - dx0*(vertex_coordinates[2*facet + 1] - vertex_coordinates[2*v0 + 1]) < 0;
    // Compute facet normals from the facet scale factor constants
    const double n0 = direction ? dx1 / det : -dx1 / det;
    const double n1 = direction ? -dx0 / det : dx0 / det;
    
    // Facet area
    
    // Compute cell volume
    
    
    // Compute circumradius of triangle in 2D
    
    
    // Array of quadrature weights.
    static const double W2[2] = {0.5, 0.5};
    // Quadrature points on the UFC reference element: (0.211324865405187), (0.788675134594813)
    
    // Values of basis functions at quadrature points.
    static const double FE0_f0[2][2] = \
    {{0.788675134594813, 0.211324865405187},
    {0.211324865405187, 0.788675134594813}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[2] = {1, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 2};
    
    static const double FE2_f0_C0[2][3] = \
    {{0.455341801261479, -0.122008467928146, 0.666666666666667},
    {-0.122008467928146, 0.45534180126148, 0.666666666666667}};
    
    // Array of non-zero columns
    static const unsigned int nzc14[3] = {7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc13[3] = {1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc20[3] = {6, 7, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc19[3] = {0, 1, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc16[3] = {0, 2, 4};
    
    // Array of non-zero columns
    static const unsigned int nzc17[3] = {6, 8, 10};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.0;
    } // end loop over 'r'
    // Number of operations to compute geometry constants: 2.
    double G[2];
    G[0] = det*n0;
    G[1] = det*n1;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    switch (facet)
    {
    case 0:
      {
        // Total number of operations to compute element tensor (from this point): 40
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 40
      for (unsigned int ip = 0; ip < 2; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc0[r]];
        } // end loop over 'r'
        
        // Number of operations to compute ip constants: 4
        double I[2];
        // Number of operations: 2
        I[0] = F0*G[0]*W2[ip];
        
        // Number of operations: 2
        I[1] = F0*G[1]*W2[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc13[j]] += FE2_f0_C0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc14[j]] += FE2_f0_C0[ip][j]*I[1];
        } // end loop over 'j'
      } // end loop over 'ip'
        break;
      }
    case 1:
      {
        // Total number of operations to compute element tensor (from this point): 40
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 40
      for (unsigned int ip = 0; ip < 2; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc1[r]];
        } // end loop over 'r'
        
        // Number of operations to compute ip constants: 4
        double I[2];
        // Number of operations: 2
        I[0] = F0*G[0]*W2[ip];
        
        // Number of operations: 2
        I[1] = F0*G[1]*W2[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc16[j]] += FE2_f0_C0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc17[j]] += FE2_f0_C0[ip][j]*I[1];
        } // end loop over 'j'
      } // end loop over 'ip'
        break;
      }
    case 2:
      {
        // Total number of operations to compute element tensor (from this point): 40
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 40
      for (unsigned int ip = 0; ip < 2; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc2[r]];
        } // end loop over 'r'
        
        // Number of operations to compute ip constants: 4
        double I[2];
        // Number of operations: 2
        I[0] = F0*G[0]*W2[ip];
        
        // Number of operations: 2
        I[1] = F0*G[1]*W2[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc19[j]] += FE2_f0_C0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc20[j]] += FE2_f0_C0[ip][j]*I[1];
        } // end loop over 'j'
      } // end loop over 'ip'
        break;
      }
    }
    
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_10_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_10_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_10_0()
  {
    // Do nothing
  }

  /// Tabulate which form coefficients are used by this integral
  virtual const std::vector<bool> & enabled_coefficients() const
  {
    static const std::vector<bool> enabled({true});
    return enabled;
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double*  A,
                               const double * const *  w,
                               const double*  vertex_coordinates,
                               std::size_t facet,
                               int cell_orientation) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      10
    // Number of operations (multiply-add pairs) for geometry tensor:    6
    // Number of operations (multiply-add pairs) for tensor contraction: 7
    // Total number of operations (multiply-add pairs):                  23
    
    // Compute Jacobian
    double J[4];
    compute_jacobian_triangle_2d(J, vertex_coordinates);
    
    // Compute Jacobian inverse and determinant
    double K[4];
    double detJ;
    compute_jacobian_inverse_triangle_2d(K, detJ, J);
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = vertex_coordinates[2*v1 + 0] - vertex_coordinates[2*v0 + 0];
    const double dx1 = vertex_coordinates[2*v1 + 1] - vertex_coordinates[2*v0 + 1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    
    // Compute geometry tensor
    const double G0_0 = det*w[0][0]*(1.0);
    const double G0_1 = det*w[0][1]*(1.0);
    const double G0_2 = det*w[0][2]*(1.0);
    const double G0_3 = det*w[0][3]*(1.0);
    const double G0_4 = det*w[0][4]*(1.0);
    const double G0_5 = det*w[0][5]*(1.0);
    
    // Compute element tensor
    switch (facet)
    {
    case 0:
      {
        A[0] = 0.166666666666666*G0_1 + 0.166666666666667*G0_2 + 0.666666666666666*G0_3;
        break;
      }
    case 1:
      {
        A[0] = 0.166666666666667*G0_0 + 0.166666666666667*G0_2 + 0.666666666666666*G0_4;
        break;
      }
    case 2:
      {
        A[0] = 0.166666666666667*G0_0 + 0.166666666666667*G0_1 + 0.666666666666666*G0_5;
        break;
      }
    }
    
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_0: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_0() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_0()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "9f5ea297aed9baffd42b79c1d8849fe669858c13bb7688bb64ab5d6276df3d376d21a30e549f6e3ff1dcee3e057a8a9f4a400e31b3b2349de314701d8bd487a2";
  }

  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const
  {
    return 2;
  }

  /// Return the number of cell domains
  virtual std::size_t num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual std::size_t num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual std::size_t num_interior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of point domains
  virtual std::size_t num_point_domains() const
  {
    return 0;
  }

  /// Return the number of custom domains
  virtual std::size_t num_custom_domains() const
  {
    return 0;
  }

  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const
  {
    return true;
  }

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any point integrals
  virtual bool has_point_integrals() const
  {
    return false;
  }

  /// Return whether the form has any custom integrals
  virtual bool has_custom_integrals() const
  {
    return false;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_10();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_10();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new point integral on sub domain i
  virtual ufc::point_integral* create_point_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new custom integral on sub domain i
  virtual ufc::custom_integral* create_custom_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const
  {
    return new adaptivenavierstokes_cell_integral_0_otherwise();
  }

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const
  {
    return 0;
  }

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const
  {
    return 0;
  }

  /// Create a new point integral on everywhere else
  virtual ufc::point_integral* create_default_point_integral() const
  {
    return 0;
  }

  /// Create a new custom integral on everywhere else
  virtual ufc::custom_integral* create_default_custom_integral() const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_1: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_1() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_1()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "1431fcd6d97da8fa48e6d1b82b62bffd65cb3efb7c993210e1961321fdbaec3f19d6505e6aa532ef963cb1f61cb7f9c7af8be5ed0b38250407f04d21b637b244";
  }

  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const
  {
    return 0;
  }

  /// Return the number of cell domains
  virtual std::size_t num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual std::size_t num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual std::size_t num_interior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of point domains
  virtual std::size_t num_point_domains() const
  {
    return 0;
  }

  /// Return the number of custom domains
  virtual std::size_t num_custom_domains() const
  {
    return 0;
  }

  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const
  {
    return false;
  }

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const
  {
    return true;
  }

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any point integrals
  virtual bool has_point_integrals() const
  {
    return false;
  }

  /// Return whether the form has any custom integrals
  virtual bool has_custom_integrals() const
  {
    return false;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_1_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new point integral on sub domain i
  virtual ufc::point_integral* create_point_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new custom integral on sub domain i
  virtual ufc::custom_integral* create_custom_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const
  {
    return 0;
  }

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const
  {
    return 0;
  }

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const
  {
    return 0;
  }

  /// Create a new point integral on everywhere else
  virtual ufc::point_integral* create_default_point_integral() const
  {
    return 0;
  }

  /// Create a new custom integral on everywhere else
  virtual ufc::custom_integral* create_default_custom_integral() const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_2: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_2() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_2()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "b85c0cd3595332dedb933bc3a10d8c51f24c9a502be803da9b661b53ce182b4ed337835a855cdd96a4c198bb1871343c720d6f8762f9835e26419ccbb66040f0";
  }

  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const
  {
    return 0;
  }

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const
  {
    return 4;
  }

  /// Return the number of cell domains
  virtual std::size_t num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual std::size_t num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual std::size_t num_interior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of point domains
  virtual std::size_t num_point_domains() const
  {
    return 0;
  }

  /// Return the number of custom domains
  virtual std::size_t num_custom_domains() const
  {
    return 0;
  }

  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const
  {
    return true;
  }

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const
  {
    return true;
  }

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any point integrals
  virtual bool has_point_integrals() const
  {
    return false;
  }

  /// Return whether the form has any custom integrals
  virtual bool has_custom_integrals() const
  {
    return false;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_10();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_9();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_10();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_9();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new point integral on sub domain i
  virtual ufc::point_integral* create_point_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new custom integral on sub domain i
  virtual ufc::custom_integral* create_custom_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const
  {
    return new adaptivenavierstokes_cell_integral_2_otherwise();
  }

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const
  {
    return new adaptivenavierstokes_exterior_facet_integral_2_otherwise();
  }

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const
  {
    return 0;
  }

  /// Create a new point integral on everywhere else
  virtual ufc::point_integral* create_default_point_integral() const
  {
    return 0;
  }

  /// Create a new custom integral on everywhere else
  virtual ufc::custom_integral* create_default_custom_integral() const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_3: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_3() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_3()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "aac28481fc513a486483e1edec2768df3b10e571489785af2eb4374b51fc4dd911c25295b817561847127611069424e841d8eaaa499c7cd70bac4e4df7f9af61";
  }

  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const
  {
    return 1;
  }

  /// Return the number of cell domains
  virtual std::size_t num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual std::size_t num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual std::size_t num_interior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of point domains
  virtual std::size_t num_point_domains() const
  {
    return 0;
  }

  /// Return the number of custom domains
  virtual std::size_t num_custom_domains() const
  {
    return 0;
  }

  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const
  {
    return true;
  }

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any point integrals
  virtual bool has_point_integrals() const
  {
    return false;
  }

  /// Return whether the form has any custom integrals
  virtual bool has_custom_integrals() const
  {
    return false;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_1();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_1();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new point integral on sub domain i
  virtual ufc::point_integral* create_point_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new custom integral on sub domain i
  virtual ufc::custom_integral* create_custom_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const
  {
    return new adaptivenavierstokes_cell_integral_3_otherwise();
  }

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const
  {
    return 0;
  }

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const
  {
    return 0;
  }

  /// Create a new point integral on everywhere else
  virtual ufc::point_integral* create_default_point_integral() const
  {
    return 0;
  }

  /// Create a new custom integral on everywhere else
  virtual ufc::custom_integral* create_default_custom_integral() const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_4: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_4() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_4()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "09b5760361d6e81604b048c19450be4febce6f205189587e6c46d0d41a48d12a76843dcd24bdd24515046fb2ae0f14c19ce79b774a20fac561c46c387ff1097c";
  }

  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const
  {
    return 4;
  }

  /// Return the number of cell domains
  virtual std::size_t num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual std::size_t num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual std::size_t num_interior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of point domains
  virtual std::size_t num_point_domains() const
  {
    return 0;
  }

  /// Return the number of custom domains
  virtual std::size_t num_custom_domains() const
  {
    return 0;
  }

  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const
  {
    return true;
  }

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const
  {
    return true;
  }

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any point integrals
  virtual bool has_point_integrals() const
  {
    return false;
  }

  /// Return whether the form has any custom integrals
  virtual bool has_custom_integrals() const
  {
    return false;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_10();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_finite_element_1();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_10();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_dofmap_1();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new point integral on sub domain i
  virtual ufc::point_integral* create_point_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new custom integral on sub domain i
  virtual ufc::custom_integral* create_custom_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const
  {
    return new adaptivenavierstokes_cell_integral_4_otherwise();
  }

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const
  {
    return new adaptivenavierstokes_exterior_facet_integral_4_otherwise();
  }

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const
  {
    return 0;
  }

  /// Create a new point integral on everywhere else
  virtual ufc::point_integral* create_default_point_integral() const
  {
    return 0;
  }

  /// Create a new custom integral on everywhere else
  virtual ufc::custom_integral* create_default_custom_integral() const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_5: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_5() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_5()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "0b649f0c08ed5629a1c24b96fd215ca1af83c2d38e52ae56808fc93671084c436235faa70e9f043f6e8bdff81d1227434c5508d6b8d8ab2f9553bdd946d4e1e9";
  }

  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const
  {
    return 1;
  }

  /// Return the number of cell domains
  virtual std::size_t num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual std::size_t num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual std::size_t num_interior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of point domains
  virtual std::size_t num_point_domains() const
  {
    return 0;
  }

  /// Return the number of custom domains
  virtual std::size_t num_custom_domains() const
  {
    return 0;
  }

  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const
  {
    return false;
  }

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const
  {
    return true;
  }

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const
  {
    return true;
  }

  /// Return whether the form has any point integrals
  virtual bool has_point_integrals() const
  {
    return false;
  }

  /// Return whether the form has any custom integrals
  virtual bool has_custom_integrals() const
  {
    return false;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new point integral on sub domain i
  virtual ufc::point_integral* create_point_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new custom integral on sub domain i
  virtual ufc::custom_integral* create_custom_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const
  {
    return 0;
  }

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const
  {
    return new adaptivenavierstokes_exterior_facet_integral_5_otherwise();
  }

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const
  {
    return new adaptivenavierstokes_interior_facet_integral_5_otherwise();
  }

  /// Create a new point integral on everywhere else
  virtual ufc::point_integral* create_default_point_integral() const
  {
    return 0;
  }

  /// Create a new custom integral on everywhere else
  virtual ufc::custom_integral* create_default_custom_integral() const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_6: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_6() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_6()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "6ab8db5005c4db9d874fc1203ac685516beab14929e0f5712afea0bcb8077e4f8d897bb973d3171bca0f367e9da6c7c42f272efe952184a8b3172867e858dc7e";
  }

  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const
  {
    return 5;
  }

  /// Return the number of cell domains
  virtual std::size_t num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual std::size_t num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual std::size_t num_interior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of point domains
  virtual std::size_t num_point_domains() const
  {
    return 0;
  }

  /// Return the number of custom domains
  virtual std::size_t num_custom_domains() const
  {
    return 0;
  }

  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const
  {
    return true;
  }

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const
  {
    return true;
  }

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any point integrals
  virtual bool has_point_integrals() const
  {
    return false;
  }

  /// Return whether the form has any custom integrals
  virtual bool has_custom_integrals() const
  {
    return false;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_10();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 5:
      {
        return new adaptivenavierstokes_finite_element_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_10();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 5:
      {
        return new adaptivenavierstokes_dofmap_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new point integral on sub domain i
  virtual ufc::point_integral* create_point_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new custom integral on sub domain i
  virtual ufc::custom_integral* create_custom_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const
  {
    return new adaptivenavierstokes_cell_integral_6_otherwise();
  }

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const
  {
    return new adaptivenavierstokes_exterior_facet_integral_6_otherwise();
  }

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const
  {
    return 0;
  }

  /// Create a new point integral on everywhere else
  virtual ufc::point_integral* create_default_point_integral() const
  {
    return 0;
  }

  /// Create a new custom integral on everywhere else
  virtual ufc::custom_integral* create_default_custom_integral() const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_7: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_7() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_7()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "a974673ba1ca23c88472c67f03256f0d7477aa2f57e702b5712aa38763c91a1be9515bda1a7b5e16c7d67ffdbc9c9b097965a8038b1702965e1600dca61101e7";
  }

  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const
  {
    return 4;
  }

  /// Return the number of cell domains
  virtual std::size_t num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual std::size_t num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual std::size_t num_interior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of point domains
  virtual std::size_t num_point_domains() const
  {
    return 0;
  }

  /// Return the number of custom domains
  virtual std::size_t num_custom_domains() const
  {
    return 0;
  }

  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const
  {
    return true;
  }

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const
  {
    return true;
  }

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const
  {
    return true;
  }

  /// Return whether the form has any point integrals
  virtual bool has_point_integrals() const
  {
    return false;
  }

  /// Return whether the form has any custom integrals
  virtual bool has_custom_integrals() const
  {
    return false;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_0();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_9();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_0();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_9();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new point integral on sub domain i
  virtual ufc::point_integral* create_point_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new custom integral on sub domain i
  virtual ufc::custom_integral* create_custom_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const
  {
    return new adaptivenavierstokes_cell_integral_7_otherwise();
  }

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const
  {
    return new adaptivenavierstokes_exterior_facet_integral_7_otherwise();
  }

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const
  {
    return new adaptivenavierstokes_interior_facet_integral_7_otherwise();
  }

  /// Create a new point integral on everywhere else
  virtual ufc::point_integral* create_default_point_integral() const
  {
    return 0;
  }

  /// Create a new custom integral on everywhere else
  virtual ufc::custom_integral* create_default_custom_integral() const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_8: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_8() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_8()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "0c555154fd68b8d2e96486b0f764aa1fcaa806229d0c798f5e08c4e4ea228bec7df9ce43a1791cbb91bed4d2a35111efb5f41aaabaadfe13dad7d3235e84c6ae";
  }

  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const
  {
    return 2;
  }

  /// Return the number of cell domains
  virtual std::size_t num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual std::size_t num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual std::size_t num_interior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of point domains
  virtual std::size_t num_point_domains() const
  {
    return 0;
  }

  /// Return the number of custom domains
  virtual std::size_t num_custom_domains() const
  {
    return 0;
  }

  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const
  {
    return true;
  }

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any point integrals
  virtual bool has_point_integrals() const
  {
    return false;
  }

  /// Return whether the form has any custom integrals
  virtual bool has_custom_integrals() const
  {
    return false;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_10();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_10();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new point integral on sub domain i
  virtual ufc::point_integral* create_point_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new custom integral on sub domain i
  virtual ufc::custom_integral* create_custom_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const
  {
    return new adaptivenavierstokes_cell_integral_8_otherwise();
  }

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const
  {
    return 0;
  }

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const
  {
    return 0;
  }

  /// Create a new point integral on everywhere else
  virtual ufc::point_integral* create_default_point_integral() const
  {
    return 0;
  }

  /// Create a new custom integral on everywhere else
  virtual ufc::custom_integral* create_default_custom_integral() const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_9: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_9() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_9()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "9690b1279fec0dfc8ec9a692f1510d4d88e76f1720371bf85f5d40068a0e5abd114b963a02c853170f51c468677b8452c8849a7a9bb4ac431a9f99a95d92d23d";
  }

  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const
  {
    return 3;
  }

  /// Return the number of cell domains
  virtual std::size_t num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual std::size_t num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual std::size_t num_interior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of point domains
  virtual std::size_t num_point_domains() const
  {
    return 0;
  }

  /// Return the number of custom domains
  virtual std::size_t num_custom_domains() const
  {
    return 0;
  }

  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const
  {
    return true;
  }

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const
  {
    return true;
  }

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any point integrals
  virtual bool has_point_integrals() const
  {
    return false;
  }

  /// Return whether the form has any custom integrals
  virtual bool has_custom_integrals() const
  {
    return false;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_10();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_10();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new point integral on sub domain i
  virtual ufc::point_integral* create_point_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new custom integral on sub domain i
  virtual ufc::custom_integral* create_custom_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const
  {
    return new adaptivenavierstokes_cell_integral_9_otherwise();
  }

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const
  {
    return new adaptivenavierstokes_exterior_facet_integral_9_otherwise();
  }

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const
  {
    return 0;
  }

  /// Create a new point integral on everywhere else
  virtual ufc::point_integral* create_default_point_integral() const
  {
    return 0;
  }

  /// Create a new custom integral on everywhere else
  virtual ufc::custom_integral* create_default_custom_integral() const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_10: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_10() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_10()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "ebf3d448ab8d2ad0c6b1c385a6ff187b82e7c45945fc89e730de8d133f937712c1a67202099b516a4903be27b033cd8bfa7a33704352979527f378d5840d96eb";
  }

  /// Return the rank of the global tensor (r)
  virtual std::size_t rank() const
  {
    return 0;
  }

  /// Return the number of coefficients (n)
  virtual std::size_t num_coefficients() const
  {
    return 1;
  }

  /// Return the number of cell domains
  virtual std::size_t num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual std::size_t num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual std::size_t num_interior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of point domains
  virtual std::size_t num_point_domains() const
  {
    return 0;
  }

  /// Return the number of custom domains
  virtual std::size_t num_custom_domains() const
  {
    return 0;
  }

  /// Return whether the form has any cell integrals
  virtual bool has_cell_integrals() const
  {
    return false;
  }

  /// Return whether the form has any exterior facet integrals
  virtual bool has_exterior_facet_integrals() const
  {
    return true;
  }

  /// Return whether the form has any interior facet integrals
  virtual bool has_interior_facet_integrals() const
  {
    return false;
  }

  /// Return whether the form has any point integrals
  virtual bool has_point_integrals() const
  {
    return false;
  }

  /// Return whether the form has any custom integrals
  virtual bool has_custom_integrals() const
  {
    return false;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_10_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new point integral on sub domain i
  virtual ufc::point_integral* create_point_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new custom integral on sub domain i
  virtual ufc::custom_integral* create_custom_integral(std::size_t i) const
  {
    return 0;
  }

  /// Create a new cell integral on everywhere else
  virtual ufc::cell_integral* create_default_cell_integral() const
  {
    return 0;
  }

  /// Create a new exterior facet integral on everywhere else
  virtual ufc::exterior_facet_integral* create_default_exterior_facet_integral() const
  {
    return 0;
  }

  /// Create a new interior facet integral on everywhere else
  virtual ufc::interior_facet_integral* create_default_interior_facet_integral() const
  {
    return 0;
  }

  /// Create a new point integral on everywhere else
  virtual ufc::point_integral* create_default_point_integral() const
  {
    return 0;
  }

  /// Create a new custom integral on everywhere else
  virtual ufc::custom_integral* create_default_custom_integral() const
  {
    return 0;
  }

};

// DOLFIN wrappers

// Standard library includes
#include <string>

// DOLFIN includes
#include <dolfin/common/NoDeleter.h>
#include <dolfin/mesh/Restriction.h>
#include <dolfin/fem/FiniteElement.h>
#include <dolfin/fem/DofMap.h>
#include <dolfin/fem/Form.h>
#include <dolfin/function/FunctionSpace.h>
#include <dolfin/function/GenericFunction.h>
#include <dolfin/function/CoefficientAssigner.h>
#include <dolfin/adaptivity/ErrorControl.h>
#include <dolfin/adaptivity/GoalFunctional.h>

namespace AdaptiveNavierStokes
{

class CoefficientSpace___cell_bubble: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace___cell_bubble(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_1()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_1()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace___cell_bubble(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_1()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_1()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace___cell_bubble(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_1()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_1()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace___cell_bubble(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_1()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_1()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  CoefficientSpace___cell_bubble(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_1()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_1()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  CoefficientSpace___cell_bubble(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_1()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_1()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~CoefficientSpace___cell_bubble()
  {
  }

};

class CoefficientSpace___cell_cone: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace___cell_cone(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_2()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace___cell_cone(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_2()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace___cell_cone(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_2()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace___cell_cone(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_2()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  CoefficientSpace___cell_cone(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_2()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  CoefficientSpace___cell_cone(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_2()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_2()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~CoefficientSpace___cell_cone()
  {
  }

};

class CoefficientSpace___cell_residual: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace___cell_residual(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace___cell_residual(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace___cell_residual(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace___cell_residual(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  CoefficientSpace___cell_residual(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  CoefficientSpace___cell_residual(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~CoefficientSpace___cell_residual()
  {
  }

};

class CoefficientSpace___discrete_dual_solution: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace___discrete_dual_solution(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace___discrete_dual_solution(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace___discrete_dual_solution(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace___discrete_dual_solution(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  CoefficientSpace___discrete_dual_solution(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  CoefficientSpace___discrete_dual_solution(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~CoefficientSpace___discrete_dual_solution()
  {
  }

};

class CoefficientSpace___facet_residual: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace___facet_residual(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace___facet_residual(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace___facet_residual(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace___facet_residual(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  CoefficientSpace___facet_residual(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  CoefficientSpace___facet_residual(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~CoefficientSpace___facet_residual()
  {
  }

};

class CoefficientSpace___improved_dual: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace___improved_dual(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace___improved_dual(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace___improved_dual(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace___improved_dual(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  CoefficientSpace___improved_dual(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  CoefficientSpace___improved_dual(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~CoefficientSpace___improved_dual()
  {
  }

};

class CoefficientSpace_nu: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_nu(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_10()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_10()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_nu(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_10()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_10()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_nu(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_10()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_10()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_nu(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_10()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_10()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  CoefficientSpace_nu(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_10()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_10()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  CoefficientSpace_nu(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_10()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_10()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~CoefficientSpace_nu()
  {
  }

};

class CoefficientSpace_p0: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_p0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_p0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_p0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_p0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  CoefficientSpace_p0(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  CoefficientSpace_p0(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~CoefficientSpace_p0()
  {
  }

};

class CoefficientSpace_w: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_w(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_w(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  CoefficientSpace_w(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  CoefficientSpace_w(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  CoefficientSpace_w(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  CoefficientSpace_w(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~CoefficientSpace_w()
  {
  }

};

class Form_0_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_0_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_0_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_0_FunctionSpace_0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_0_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  Form_0_FunctionSpace_0(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  Form_0_FunctionSpace_0(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~Form_0_FunctionSpace_0()
  {
  }

};

class Form_0_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_0_FunctionSpace_1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_0_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_0_FunctionSpace_1(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_0_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  Form_0_FunctionSpace_1(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  Form_0_FunctionSpace_1(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~Form_0_FunctionSpace_1()
  {
  }

};

typedef CoefficientSpace_w Form_0_FunctionSpace_2;

typedef CoefficientSpace_nu Form_0_FunctionSpace_3;

class Form_0: public dolfin::Form
{
public:

  // Constructor
  Form_0(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Constructor
  Form_0(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->w = w;
    this->nu = nu;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Constructor
  Form_0(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, std::shared_ptr<const dolfin::GenericFunction> w, std::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->w = *w;
    this->nu = *nu;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Constructor
  Form_0(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Constructor
  Form_0(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->w = w;
    this->nu = nu;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Constructor
  Form_0(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> w, std::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->w = *w;
    this->nu = *nu;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Destructor
  ~Form_0()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "nu")
      return 1;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "nu";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_0_FunctionSpace_0 TestSpace;
  typedef Form_0_FunctionSpace_1 TrialSpace;
  typedef Form_0_FunctionSpace_2 CoefficientSpace_w;
  typedef Form_0_FunctionSpace_3 CoefficientSpace_nu;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner nu;
};

class Form_1_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_1_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_1_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_1_FunctionSpace_0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_1_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  Form_1_FunctionSpace_0(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  Form_1_FunctionSpace_0(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~Form_1_FunctionSpace_0()
  {
  }

};

class Form_1: public dolfin::Form
{
public:

  // Constructor
  Form_1(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_1());
  }

  // Constructor
  Form_1(std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 0)
  {
    _function_spaces[0] = V0;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_1());
  }

  // Destructor
  ~Form_1()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "There are no coefficients");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "There are no coefficients");
    return "unnamed";
  }

  // Typedefs
  typedef Form_1_FunctionSpace_0 TestSpace;

  // Coefficients
};

typedef CoefficientSpace_w Form_2_FunctionSpace_0;

typedef CoefficientSpace_p0 Form_2_FunctionSpace_1;

typedef CoefficientSpace_nu Form_2_FunctionSpace_2;

typedef CoefficientSpace___improved_dual Form_2_FunctionSpace_3;

class Form_2: public dolfin::Form
{
public:

  // Constructor
  Form_2(const dolfin::Mesh& mesh):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Constructor
  Form_2(const dolfin::Mesh& mesh, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __improved_dual):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__improved_dual = __improved_dual;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Constructor
  Form_2(const dolfin::Mesh& mesh, std::shared_ptr<const dolfin::GenericFunction> w, std::shared_ptr<const dolfin::GenericFunction> p0, std::shared_ptr<const dolfin::GenericFunction> nu, std::shared_ptr<const dolfin::GenericFunction> __improved_dual):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__improved_dual = *__improved_dual;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Constructor
  Form_2(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = mesh;
    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Constructor
  Form_2(std::shared_ptr<const dolfin::Mesh> mesh, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __improved_dual):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = mesh;
    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__improved_dual = __improved_dual;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Constructor
  Form_2(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::GenericFunction> w, std::shared_ptr<const dolfin::GenericFunction> p0, std::shared_ptr<const dolfin::GenericFunction> nu, std::shared_ptr<const dolfin::GenericFunction> __improved_dual):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = mesh;
    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__improved_dual = *__improved_dual;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Destructor
  ~Form_2()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "p0")
      return 1;
    else if (name == "nu")
      return 2;
    else if (name == "__improved_dual")
      return 3;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "p0";
    case 2:
      return "nu";
    case 3:
      return "__improved_dual";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_2_FunctionSpace_0 CoefficientSpace_w;
  typedef Form_2_FunctionSpace_1 CoefficientSpace_p0;
  typedef Form_2_FunctionSpace_2 CoefficientSpace_nu;
  typedef Form_2_FunctionSpace_3 CoefficientSpace___improved_dual;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner p0;
  dolfin::CoefficientAssigner nu;
  dolfin::CoefficientAssigner __improved_dual;
};

class Form_3_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_3_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_3_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_3_FunctionSpace_0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_3_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  Form_3_FunctionSpace_0(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  Form_3_FunctionSpace_0(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~Form_3_FunctionSpace_0()
  {
  }

};

class Form_3_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_3_FunctionSpace_1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_3_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_3_FunctionSpace_1(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_3_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  Form_3_FunctionSpace_1(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  Form_3_FunctionSpace_1(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~Form_3_FunctionSpace_1()
  {
  }

};

typedef CoefficientSpace___cell_bubble Form_3_FunctionSpace_2;

class Form_3: public dolfin::Form
{
public:

  // Constructor
  Form_3(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Constructor
  Form_3(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& __cell_bubble):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->__cell_bubble = __cell_bubble;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Constructor
  Form_3(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, std::shared_ptr<const dolfin::GenericFunction> __cell_bubble):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->__cell_bubble = *__cell_bubble;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Constructor
  Form_3(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Constructor
  Form_3(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& __cell_bubble):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->__cell_bubble = __cell_bubble;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Constructor
  Form_3(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> __cell_bubble):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->__cell_bubble = *__cell_bubble;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Destructor
  ~Form_3()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "__cell_bubble")
      return 0;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "__cell_bubble";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_3_FunctionSpace_0 TestSpace;
  typedef Form_3_FunctionSpace_1 TrialSpace;
  typedef Form_3_FunctionSpace_2 CoefficientSpace___cell_bubble;

  // Coefficients
  dolfin::CoefficientAssigner __cell_bubble;
};

class Form_4_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_4_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_4_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_4_FunctionSpace_0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_4_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  Form_4_FunctionSpace_0(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  Form_4_FunctionSpace_0(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~Form_4_FunctionSpace_0()
  {
  }

};

typedef CoefficientSpace_w Form_4_FunctionSpace_1;

typedef CoefficientSpace_p0 Form_4_FunctionSpace_2;

typedef CoefficientSpace_nu Form_4_FunctionSpace_3;

typedef CoefficientSpace___cell_bubble Form_4_FunctionSpace_4;

class Form_4: public dolfin::Form
{
public:

  // Constructor
  Form_4(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Constructor
  Form_4(const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __cell_bubble):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__cell_bubble = __cell_bubble;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Constructor
  Form_4(const dolfin::FunctionSpace& V0, std::shared_ptr<const dolfin::GenericFunction> w, std::shared_ptr<const dolfin::GenericFunction> p0, std::shared_ptr<const dolfin::GenericFunction> nu, std::shared_ptr<const dolfin::GenericFunction> __cell_bubble):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__cell_bubble = *__cell_bubble;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Constructor
  Form_4(std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = V0;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Constructor
  Form_4(std::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __cell_bubble):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = V0;

    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__cell_bubble = __cell_bubble;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Constructor
  Form_4(std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> w, std::shared_ptr<const dolfin::GenericFunction> p0, std::shared_ptr<const dolfin::GenericFunction> nu, std::shared_ptr<const dolfin::GenericFunction> __cell_bubble):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = V0;

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__cell_bubble = *__cell_bubble;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Destructor
  ~Form_4()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "p0")
      return 1;
    else if (name == "nu")
      return 2;
    else if (name == "__cell_bubble")
      return 3;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "p0";
    case 2:
      return "nu";
    case 3:
      return "__cell_bubble";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_4_FunctionSpace_0 TestSpace;
  typedef Form_4_FunctionSpace_1 CoefficientSpace_w;
  typedef Form_4_FunctionSpace_2 CoefficientSpace_p0;
  typedef Form_4_FunctionSpace_3 CoefficientSpace_nu;
  typedef Form_4_FunctionSpace_4 CoefficientSpace___cell_bubble;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner p0;
  dolfin::CoefficientAssigner nu;
  dolfin::CoefficientAssigner __cell_bubble;
};

class Form_5_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_5_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_5_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_5_FunctionSpace_0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_5_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  Form_5_FunctionSpace_0(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  Form_5_FunctionSpace_0(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~Form_5_FunctionSpace_0()
  {
  }

};

class Form_5_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_5_FunctionSpace_1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_5_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_5_FunctionSpace_1(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_5_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  Form_5_FunctionSpace_1(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  Form_5_FunctionSpace_1(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~Form_5_FunctionSpace_1()
  {
  }

};

typedef CoefficientSpace___cell_cone Form_5_FunctionSpace_2;

class Form_5: public dolfin::Form
{
public:

  // Constructor
  Form_5(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Constructor
  Form_5(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& __cell_cone):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->__cell_cone = __cell_cone;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Constructor
  Form_5(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, std::shared_ptr<const dolfin::GenericFunction> __cell_cone):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->__cell_cone = *__cell_cone;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Constructor
  Form_5(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Constructor
  Form_5(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& __cell_cone):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->__cell_cone = __cell_cone;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Constructor
  Form_5(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> __cell_cone):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->__cell_cone = *__cell_cone;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Destructor
  ~Form_5()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "__cell_cone")
      return 0;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "__cell_cone";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_5_FunctionSpace_0 TestSpace;
  typedef Form_5_FunctionSpace_1 TrialSpace;
  typedef Form_5_FunctionSpace_2 CoefficientSpace___cell_cone;

  // Coefficients
  dolfin::CoefficientAssigner __cell_cone;
};

class Form_6_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_6_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_6_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_6_FunctionSpace_0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_6_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  Form_6_FunctionSpace_0(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  Form_6_FunctionSpace_0(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~Form_6_FunctionSpace_0()
  {
  }

};

typedef CoefficientSpace_w Form_6_FunctionSpace_1;

typedef CoefficientSpace_p0 Form_6_FunctionSpace_2;

typedef CoefficientSpace_nu Form_6_FunctionSpace_3;

typedef CoefficientSpace___cell_residual Form_6_FunctionSpace_4;

typedef CoefficientSpace___cell_cone Form_6_FunctionSpace_5;

class Form_6: public dolfin::Form
{
public:

  // Constructor
  Form_6(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Constructor
  Form_6(const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __cell_residual, const dolfin::GenericFunction& __cell_cone):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__cell_residual = __cell_residual;
    this->__cell_cone = __cell_cone;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Constructor
  Form_6(const dolfin::FunctionSpace& V0, std::shared_ptr<const dolfin::GenericFunction> w, std::shared_ptr<const dolfin::GenericFunction> p0, std::shared_ptr<const dolfin::GenericFunction> nu, std::shared_ptr<const dolfin::GenericFunction> __cell_residual, std::shared_ptr<const dolfin::GenericFunction> __cell_cone):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__cell_residual = *__cell_residual;
    this->__cell_cone = *__cell_cone;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Constructor
  Form_6(std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = V0;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Constructor
  Form_6(std::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __cell_residual, const dolfin::GenericFunction& __cell_cone):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = V0;

    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__cell_residual = __cell_residual;
    this->__cell_cone = __cell_cone;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Constructor
  Form_6(std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> w, std::shared_ptr<const dolfin::GenericFunction> p0, std::shared_ptr<const dolfin::GenericFunction> nu, std::shared_ptr<const dolfin::GenericFunction> __cell_residual, std::shared_ptr<const dolfin::GenericFunction> __cell_cone):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = V0;

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__cell_residual = *__cell_residual;
    this->__cell_cone = *__cell_cone;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Destructor
  ~Form_6()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "p0")
      return 1;
    else if (name == "nu")
      return 2;
    else if (name == "__cell_residual")
      return 3;
    else if (name == "__cell_cone")
      return 4;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "p0";
    case 2:
      return "nu";
    case 3:
      return "__cell_residual";
    case 4:
      return "__cell_cone";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_6_FunctionSpace_0 TestSpace;
  typedef Form_6_FunctionSpace_1 CoefficientSpace_w;
  typedef Form_6_FunctionSpace_2 CoefficientSpace_p0;
  typedef Form_6_FunctionSpace_3 CoefficientSpace_nu;
  typedef Form_6_FunctionSpace_4 CoefficientSpace___cell_residual;
  typedef Form_6_FunctionSpace_5 CoefficientSpace___cell_cone;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner p0;
  dolfin::CoefficientAssigner nu;
  dolfin::CoefficientAssigner __cell_residual;
  dolfin::CoefficientAssigner __cell_cone;
};

class Form_7_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_7_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_0()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_7_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_0()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_7_FunctionSpace_0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_0()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_7_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_0()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  Form_7_FunctionSpace_0(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_0()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  Form_7_FunctionSpace_0(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_0()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_0()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~Form_7_FunctionSpace_0()
  {
  }

};

typedef CoefficientSpace___improved_dual Form_7_FunctionSpace_1;

typedef CoefficientSpace___cell_residual Form_7_FunctionSpace_2;

typedef CoefficientSpace___facet_residual Form_7_FunctionSpace_3;

typedef CoefficientSpace___discrete_dual_solution Form_7_FunctionSpace_4;

class Form_7: public dolfin::Form
{
public:

  // Constructor
  Form_7(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Constructor
  Form_7(const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& __improved_dual, const dolfin::GenericFunction& __cell_residual, const dolfin::GenericFunction& __facet_residual, const dolfin::GenericFunction& __discrete_dual_solution):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->__improved_dual = __improved_dual;
    this->__cell_residual = __cell_residual;
    this->__facet_residual = __facet_residual;
    this->__discrete_dual_solution = __discrete_dual_solution;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Constructor
  Form_7(const dolfin::FunctionSpace& V0, std::shared_ptr<const dolfin::GenericFunction> __improved_dual, std::shared_ptr<const dolfin::GenericFunction> __cell_residual, std::shared_ptr<const dolfin::GenericFunction> __facet_residual, std::shared_ptr<const dolfin::GenericFunction> __discrete_dual_solution):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->__improved_dual = *__improved_dual;
    this->__cell_residual = *__cell_residual;
    this->__facet_residual = *__facet_residual;
    this->__discrete_dual_solution = *__discrete_dual_solution;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Constructor
  Form_7(std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = V0;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Constructor
  Form_7(std::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& __improved_dual, const dolfin::GenericFunction& __cell_residual, const dolfin::GenericFunction& __facet_residual, const dolfin::GenericFunction& __discrete_dual_solution):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = V0;

    this->__improved_dual = __improved_dual;
    this->__cell_residual = __cell_residual;
    this->__facet_residual = __facet_residual;
    this->__discrete_dual_solution = __discrete_dual_solution;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Constructor
  Form_7(std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> __improved_dual, std::shared_ptr<const dolfin::GenericFunction> __cell_residual, std::shared_ptr<const dolfin::GenericFunction> __facet_residual, std::shared_ptr<const dolfin::GenericFunction> __discrete_dual_solution):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = V0;

    this->__improved_dual = *__improved_dual;
    this->__cell_residual = *__cell_residual;
    this->__facet_residual = *__facet_residual;
    this->__discrete_dual_solution = *__discrete_dual_solution;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Destructor
  ~Form_7()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "__improved_dual")
      return 0;
    else if (name == "__cell_residual")
      return 1;
    else if (name == "__facet_residual")
      return 2;
    else if (name == "__discrete_dual_solution")
      return 3;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "__improved_dual";
    case 1:
      return "__cell_residual";
    case 2:
      return "__facet_residual";
    case 3:
      return "__discrete_dual_solution";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_7_FunctionSpace_0 TestSpace;
  typedef Form_7_FunctionSpace_1 CoefficientSpace___improved_dual;
  typedef Form_7_FunctionSpace_2 CoefficientSpace___cell_residual;
  typedef Form_7_FunctionSpace_3 CoefficientSpace___facet_residual;
  typedef Form_7_FunctionSpace_4 CoefficientSpace___discrete_dual_solution;

  // Coefficients
  dolfin::CoefficientAssigner __improved_dual;
  dolfin::CoefficientAssigner __cell_residual;
  dolfin::CoefficientAssigner __facet_residual;
  dolfin::CoefficientAssigner __discrete_dual_solution;
};

class Form_lhs_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_lhs_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_lhs_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_lhs_FunctionSpace_0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_lhs_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  Form_lhs_FunctionSpace_0(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  Form_lhs_FunctionSpace_0(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~Form_lhs_FunctionSpace_0()
  {
  }

};

class Form_lhs_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_lhs_FunctionSpace_1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_lhs_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_lhs_FunctionSpace_1(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_lhs_FunctionSpace_1(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  Form_lhs_FunctionSpace_1(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  Form_lhs_FunctionSpace_1(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~Form_lhs_FunctionSpace_1()
  {
  }

};

typedef CoefficientSpace_w Form_lhs_FunctionSpace_2;

typedef CoefficientSpace_nu Form_lhs_FunctionSpace_3;

class Form_lhs: public dolfin::Form
{
public:

  // Constructor
  Form_lhs(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Constructor
  Form_lhs(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->w = w;
    this->nu = nu;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Constructor
  Form_lhs(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, std::shared_ptr<const dolfin::GenericFunction> w, std::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->w = *w;
    this->nu = *nu;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Constructor
  Form_lhs(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Constructor
  Form_lhs(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->w = w;
    this->nu = nu;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Constructor
  Form_lhs(std::shared_ptr<const dolfin::FunctionSpace> V1, std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> w, std::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->w = *w;
    this->nu = *nu;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Destructor
  ~Form_lhs()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "nu")
      return 1;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "nu";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_lhs_FunctionSpace_0 TestSpace;
  typedef Form_lhs_FunctionSpace_1 TrialSpace;
  typedef Form_lhs_FunctionSpace_2 CoefficientSpace_w;
  typedef Form_lhs_FunctionSpace_3 CoefficientSpace_nu;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner nu;
};

class Form_rhs_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  //--- Constructors for standard function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_rhs_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_rhs_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
    // Do nothing
  }

  //--- Constructors for constrained function space, 2 different versions ---

  // Create standard function space (reference version)
  Form_rhs_FunctionSpace_0(const dolfin::Mesh& mesh, const dolfin::SubDomain& constrained_domain):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh,
                              dolfin::reference_to_no_delete_pointer(constrained_domain))))
  {
    // Do nothing
  }

  // Create standard function space (shared pointer version)
  Form_rhs_FunctionSpace_0(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::SubDomain> constrained_domain):
    dolfin::FunctionSpace(mesh,
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh, constrained_domain)))
  {
    // Do nothing
  }

  //--- Constructors for restricted function space, 2 different versions ---

  // Create restricted function space (reference version)
  Form_rhs_FunctionSpace_0(const dolfin::Restriction& restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction.mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()),
                                                                                     reference_to_no_delete_pointer(restriction))))
  {
    // Do nothing
  }

  // Create restricted function space (shared pointer version)
  Form_rhs_FunctionSpace_0(std::shared_ptr<const dolfin::Restriction> restriction):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(restriction->mesh()),
                          std::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(std::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          std::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(std::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()),
                                                                                     restriction)))
  {
    // Do nothing
  }

  // Copy constructor
  ~Form_rhs_FunctionSpace_0()
  {
  }

};

typedef CoefficientSpace_w Form_rhs_FunctionSpace_1;

typedef CoefficientSpace_p0 Form_rhs_FunctionSpace_2;

typedef CoefficientSpace_nu Form_rhs_FunctionSpace_3;

class Form_rhs: public dolfin::Form
{
public:

  // Constructor
  Form_rhs(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Constructor
  Form_rhs(const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = w;
    this->p0 = p0;
    this->nu = nu;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Constructor
  Form_rhs(const dolfin::FunctionSpace& V0, std::shared_ptr<const dolfin::GenericFunction> w, std::shared_ptr<const dolfin::GenericFunction> p0, std::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Constructor
  Form_rhs(std::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = V0;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Constructor
  Form_rhs(std::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = V0;

    this->w = w;
    this->p0 = p0;
    this->nu = nu;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Constructor
  Form_rhs(std::shared_ptr<const dolfin::FunctionSpace> V0, std::shared_ptr<const dolfin::GenericFunction> w, std::shared_ptr<const dolfin::GenericFunction> p0, std::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = V0;

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Destructor
  ~Form_rhs()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "p0")
      return 1;
    else if (name == "nu")
      return 2;

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "p0";
    case 2:
      return "nu";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_rhs_FunctionSpace_0 TestSpace;
  typedef Form_rhs_FunctionSpace_1 CoefficientSpace_w;
  typedef Form_rhs_FunctionSpace_2 CoefficientSpace_p0;
  typedef Form_rhs_FunctionSpace_3 CoefficientSpace_nu;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner p0;
  dolfin::CoefficientAssigner nu;
};

typedef CoefficientSpace_w Form_goal_FunctionSpace_0;

class Form_goal: public dolfin::GoalFunctional
{
public:

  // Constructor
  Form_goal(const dolfin::Mesh& mesh):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Constructor
  Form_goal(const dolfin::Mesh& mesh, const dolfin::GenericFunction& w):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    this->w = w;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Constructor
  Form_goal(const dolfin::Mesh& mesh, std::shared_ptr<const dolfin::GenericFunction> w):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    this->w = *w;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Constructor
  Form_goal(std::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = mesh;
    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Constructor
  Form_goal(std::shared_ptr<const dolfin::Mesh> mesh, const dolfin::GenericFunction& w):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = mesh;
    this->w = w;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Constructor
  Form_goal(std::shared_ptr<const dolfin::Mesh> mesh, std::shared_ptr<const dolfin::GenericFunction> w):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = mesh;
    this->w = *w;

    _ufc_form = std::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Destructor
  ~Form_goal()
  {}

  /// Return the number of the coefficient with this name
  virtual std::size_t coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;

    dolfin::dolfin_error("generated code for class GoalFunctional",
                         "access coefficient data",
                         "Invalid coefficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(std::size_t i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    }

    dolfin::dolfin_error("generated code for class GoalFunctional",
                         "access coefficient data",
                         "Invalid coefficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_goal_FunctionSpace_0 CoefficientSpace_w;

  // Coefficients
  dolfin::CoefficientAssigner w;

  /// Initialize all error control forms, attach coefficients and
  /// (re-)set error control
  virtual void update_ec(const dolfin::Form& a, const dolfin::Form& L)
  {
    // This stuff is created here and shipped elsewhere
    std::shared_ptr<dolfin::Form> a_star;           // Dual lhs
    std::shared_ptr<dolfin::Form> L_star;           // Dual rhs
    std::shared_ptr<dolfin::FunctionSpace> V_Ez_h;  // Extrapolation space
    std::shared_ptr<dolfin::Function> Ez_h;         // Extrapolated dual
    std::shared_ptr<dolfin::Form> residual;         // Residual (as functional)
    std::shared_ptr<dolfin::FunctionSpace> V_R_T;   // Trial space for cell residual
    std::shared_ptr<dolfin::Form> a_R_T;            // Cell residual lhs
    std::shared_ptr<dolfin::Form> L_R_T;            // Cell residual rhs
    std::shared_ptr<dolfin::FunctionSpace> V_b_T;   // Function space for cell bubble
    std::shared_ptr<dolfin::Function> b_T;          // Cell bubble
    std::shared_ptr<dolfin::FunctionSpace> V_R_dT;  // Trial space for facet residual
    std::shared_ptr<dolfin::Form> a_R_dT;           // Facet residual lhs
    std::shared_ptr<dolfin::Form> L_R_dT;           // Facet residual rhs
    std::shared_ptr<dolfin::FunctionSpace> V_b_e;   // Function space for cell cone
    std::shared_ptr<dolfin::Function> b_e;          // Cell cone
    std::shared_ptr<dolfin::FunctionSpace> V_eta_T; // Function space for indicators
    std::shared_ptr<dolfin::Form> eta_T;            // Indicator form

    // Some handy views
    const dolfin::FunctionSpace& Vhat(*(a.function_space(0))); // Primal test
    const dolfin::FunctionSpace& V(*(a.function_space(1)));    // Primal trial
    assert(V.mesh());
    const dolfin::Mesh& mesh(*V.mesh());
    std::string name;

    // Initialize dual forms
    a_star.reset(new Form_0(V, Vhat));
    L_star.reset(new Form_1(V));

    
    // Attach coefficients from a to a_star
    for (std::size_t i = 0; i < a.num_coefficients(); i++)
    {
      name = a.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed).
      if (name == "__discrete_primal_solution")
        continue;

      // Test whether a_star has coefficient named 'name'
      try {
        a_star->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to a_star";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      a_star->set_coefficient(name, a.coefficient(i));
    }
    
    // Attach subdomains from a to a_star
    a_star->dx = a.cell_domains();
    a_star->ds = a.exterior_facet_domains();
    a_star->dS = a.interior_facet_domains();

    
    // Attach coefficients from (*this) to L_star
    for (std::size_t i = 0; i < (*this).num_coefficients(); i++)
    {
      name = (*this).coefficient_name(i);
      // Don't attach discrete primal solution here (not computed).
      if (name == "__discrete_primal_solution")
        continue;

      // Test whether L_star has coefficient named 'name'
      try {
        L_star->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to L_star";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      L_star->set_coefficient(name, (*this).coefficient(i));
    }
    
    // Attach subdomains from (*this) to L_star
    L_star->dx = (*this).cell_domains();
    L_star->ds = (*this).exterior_facet_domains();
    L_star->dS = (*this).interior_facet_domains();


    // Initialize residual
    residual.reset(new Form_2(mesh));
    
    // Attach coefficients from a to residual
    for (std::size_t i = 0; i < a.num_coefficients(); i++)
    {
      name = a.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed).
      if (name == "__discrete_primal_solution")
        continue;

      // Test whether residual has coefficient named 'name'
      try {
        residual->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to residual";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      residual->set_coefficient(name, a.coefficient(i));
    }
    

    // Attach coefficients from L to residual
    for (std::size_t i = 0; i < L.num_coefficients(); i++)
    {
      name = L.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed).
      if (name == "__discrete_primal_solution")
        continue;

      // Test whether residual has coefficient named 'name'
      try {
        residual->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to residual";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      residual->set_coefficient(name, L.coefficient(i));
    }
    
    // Attach subdomains from L to residual
    residual->dx = L.cell_domains();
    residual->ds = L.exterior_facet_domains();
    residual->dS = L.interior_facet_domains();


    // Initialize extrapolation space and (fake) extrapolation
    V_Ez_h.reset(new CoefficientSpace___improved_dual(mesh));
    Ez_h.reset(new dolfin::Function(V_Ez_h));
    residual->set_coefficient("__improved_dual", Ez_h);

    // Create bilinear and linear form for computing cell residual R_T
    V_R_T.reset(new Form_4::TestSpace(mesh));
    a_R_T.reset(new Form_3(V_R_T, V_R_T));
    L_R_T.reset(new Form_4(V_R_T));

    // Initialize bubble and attach to a_R_T and L_R_T
    V_b_T.reset(new CoefficientSpace___cell_bubble(mesh));
    b_T.reset(new dolfin::Function(V_b_T));
    *b_T->vector() = 1.0;
    
    // Attach coefficients from a to L_R_T
    for (std::size_t i = 0; i < a.num_coefficients(); i++)
    {
      name = a.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed).
      if (name == "__discrete_primal_solution")
        continue;

      // Test whether L_R_T has coefficient named 'name'
      try {
        L_R_T->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to L_R_T";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      L_R_T->set_coefficient(name, a.coefficient(i));
    }
    

    // Attach coefficients from L to L_R_T
    for (std::size_t i = 0; i < L.num_coefficients(); i++)
    {
      name = L.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed).
      if (name == "__discrete_primal_solution")
        continue;

      // Test whether L_R_T has coefficient named 'name'
      try {
        L_R_T->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to L_R_T";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      L_R_T->set_coefficient(name, L.coefficient(i));
    }
    
    // Attach subdomains from L to L_R_T
    L_R_T->dx = L.cell_domains();
    L_R_T->ds = L.exterior_facet_domains();
    L_R_T->dS = L.interior_facet_domains();


    // Attach bubble function to _a_R_T and _L_R_T
    a_R_T->set_coefficient("__cell_bubble", b_T);
    L_R_T->set_coefficient("__cell_bubble", b_T);

    // Create bilinear and linear form for computing facet residual R_dT
    V_R_dT.reset(new Form_6::TestSpace(mesh));
    a_R_dT.reset(new Form_5(V_R_dT, V_R_dT));
    L_R_dT.reset(new Form_6(V_R_dT));
    
    // Attach coefficients from a to L_R_dT
    for (std::size_t i = 0; i < a.num_coefficients(); i++)
    {
      name = a.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed).
      if (name == "__discrete_primal_solution")
        continue;

      // Test whether L_R_dT has coefficient named 'name'
      try {
        L_R_dT->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to L_R_dT";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      L_R_dT->set_coefficient(name, a.coefficient(i));
    }
    

    // Attach coefficients from L to L_R_dT
    for (std::size_t i = 0; i < L.num_coefficients(); i++)
    {
      name = L.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed).
      if (name == "__discrete_primal_solution")
        continue;

      // Test whether L_R_dT has coefficient named 'name'
      try {
        L_R_dT->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to L_R_dT";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      L_R_dT->set_coefficient(name, L.coefficient(i));
    }
    
    // Attach subdomains from L to L_R_dT
    L_R_dT->dx = L.cell_domains();
    L_R_dT->ds = L.exterior_facet_domains();
    L_R_dT->dS = L.interior_facet_domains();


    // Initialize (fake) cone and attach to a_R_dT and L_R_dT
    V_b_e.reset(new CoefficientSpace___cell_cone(mesh));
    b_e.reset(new dolfin::Function(V_b_e));
    a_R_dT->set_coefficient("__cell_cone", b_e);
    L_R_dT->set_coefficient("__cell_cone", b_e);

    // Create error indicator form
    V_eta_T.reset(new Form_7::TestSpace(mesh));
    eta_T.reset(new Form_7(V_eta_T));

    // Update error control
    _ec.reset(new dolfin::ErrorControl(a_star, L_star, residual,
                                       a_R_T, L_R_T, a_R_dT, L_R_dT, eta_T,
                                       false));

  }

};

// Class typedefs
typedef Form_lhs BilinearForm;
typedef Form_rhs LinearForm;
typedef Form_goal GoalFunctional;

}

#endif
