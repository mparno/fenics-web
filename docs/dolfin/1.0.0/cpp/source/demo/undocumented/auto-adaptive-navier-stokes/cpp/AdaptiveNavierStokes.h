// This code conforms with the UFC specification version 2.0.5
// and was automatically generated by FFC version 1.0.0.
//
// This code was generated with the option '-l dolfin' and
// contains DOLFIN-specific wrappers that depend on DOLFIN.
// 
// This code was generated with the following parameters:
// 
//   cache_dir:                      ''
//   convert_exceptions_to_warnings: False
//   cpp_optimize:                   False
//   cpp_optimize_flags:             '-O2'
//   epsilon:                        1e-14
//   error_control:                  True
//   form_postfix:                   True
//   format:                         'dolfin'
//   log_level:                      10
//   log_prefix:                     ''
//   no_ferari:                      True
//   optimize:                       True
//   output_dir:                     '.'
//   precision:                      15
//   quadrature_degree:              'auto'
//   quadrature_rule:                'auto'
//   representation:                 'auto'
//   split:                          False
//   swig_binary:                    'swig'
//   swig_path:                      ''

#ifndef __ADAPTIVENAVIERSTOKES_H
#define __ADAPTIVENAVIERSTOKES_H

#include <cmath>
#include <stdexcept>
#include <fstream>
#include <ufc.h>

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_0: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_0() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_0()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 0, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 1;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Compute constants
    
    // Get coordinates and map to the reference (FIAT) element
    
    // Reset values.
    *values = 0.0;
    
    // Array of basisvalues.
    double basisvalues[1] = {0.0};
    
    // Declare helper variables.
    
    // Compute basisvalues.
    basisvalues[0] = 1.0;
    
    // Table(s) of coefficients.
    static const double coefficients0[1] = \
    {1.0};
    
    // Compute value(s).
    for (unsigned int r = 0; r < 1; r++)
    {
      *values += coefficients0[r]*basisvalues[r];
    }// end loop over 'r'
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Element is constant, calling evaluate_basis.
    evaluate_basis(0, values, coordinates, c);
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    
    // Get coordinates and map to the reference (FIAT) element
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    
    // Array of basisvalues.
    double basisvalues[1] = {0.0};
    
    // Declare helper variables.
    
    // Compute basisvalues.
    basisvalues[0] = 1.0;
    
    // Table(s) of coefficients.
    static const double coefficients0[1] = \
    {1.0};
    
    // Tables of derivatives of the polynomial base (transpose).
    static const double dmats0[1][1] = \
    {{0.0}};
    
    static const double dmats1[1][1] = \
    {{0.0}};
    
    // Compute reference derivatives.
    // Declare pointer to array of derivatives on FIAT element.
    double *derivatives = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      derivatives[r] = 0.0;
    }// end loop over 'r'
    
    // Declare derivative matrix (of polynomial basis).
    double dmats[1][1] = \
    {{1.0}};
    
    // Declare (auxiliary) derivative matrix (of polynomial basis).
    double dmats_old[1][1] = \
    {{1.0}};
    
    // Loop possible derivatives.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      // Resetting dmats values to compute next derivative.
      for (unsigned int t = 0; t < 1; t++)
      {
        for (unsigned int u = 0; u < 1; u++)
        {
          dmats[t][u] = 0.0;
          if (t == u)
          {
          dmats[t][u] = 1.0;
          }
          
        }// end loop over 'u'
      }// end loop over 't'
      
      // Looping derivative order to generate dmats.
      for (unsigned int s = 0; s < n; s++)
      {
        // Updating dmats_old with new values and resetting dmats.
        for (unsigned int t = 0; t < 1; t++)
        {
          for (unsigned int u = 0; u < 1; u++)
          {
            dmats_old[t][u] = dmats[t][u];
            dmats[t][u] = 0.0;
          }// end loop over 'u'
        }// end loop over 't'
        
        // Update dmats using an inner product.
        if (combinations[r][s] == 0)
        {
        for (unsigned int t = 0; t < 1; t++)
        {
          for (unsigned int u = 0; u < 1; u++)
          {
            for (unsigned int tu = 0; tu < 1; tu++)
            {
              dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
        if (combinations[r][s] == 1)
        {
        for (unsigned int t = 0; t < 1; t++)
        {
          for (unsigned int u = 0; u < 1; u++)
          {
            for (unsigned int tu = 0; tu < 1; tu++)
            {
              dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
      }// end loop over 's'
      for (unsigned int s = 0; s < 1; s++)
      {
        for (unsigned int t = 0; t < 1; t++)
        {
          derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
        }// end loop over 't'
      }// end loop over 's'
    }// end loop over 'r'
    
    // Transform derivatives back to physical element
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r] += transform[r][s]*derivatives[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;
    
    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      delete [] combinations[r];
    }// end loop over 'r'
    delete [] combinations;
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      delete [] transform[r];
    }// end loop over 'r'
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Element is constant, calling evaluate_basis_derivatives.
    evaluate_basis_derivatives(0, n, values, coordinates, c);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
    vertex_values[2] = dof_values[0];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_0();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_1: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_1() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_1()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 1;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    *values = 0.0;
    
    // Array of basisvalues.
    double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
    
    // Declare helper variables.
    double tmp0 = (1.0 + Y + 2.0*X)/2.0;
    double tmp1 = (1.0 - Y)/2.0;
    double tmp2 = tmp1*tmp1;
    
    // Compute basisvalues.
    basisvalues[0] = 1.0;
    basisvalues[1] = tmp0;
    basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
    basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
    basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
    basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
    basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
    basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
    basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
    basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
    basisvalues[0] *= std::sqrt(0.5);
    basisvalues[2] *= std::sqrt(1.0);
    basisvalues[5] *= std::sqrt(1.5);
    basisvalues[9] *= std::sqrt(2.0);
    basisvalues[1] *= std::sqrt(3.0);
    basisvalues[4] *= std::sqrt(4.5);
    basisvalues[8] *= std::sqrt(6.0);
    basisvalues[3] *= std::sqrt(7.5);
    basisvalues[7] *= std::sqrt(10.0);
    basisvalues[6] *= std::sqrt(14.0);
    
    // Table(s) of coefficients.
    static const double coefficients0[10] = \
    {0.636396103067893, 0.0, 0.0, -0.234738238930786, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.0909137290096989};
    
    // Compute value(s).
    for (unsigned int r = 0; r < 10; r++)
    {
      *values += coefficients0[r]*basisvalues[r];
    }// end loop over 'r'
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Element is constant, calling evaluate_basis.
    evaluate_basis(0, values, coordinates, c);
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    
    // Array of basisvalues.
    double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
    
    // Declare helper variables.
    double tmp0 = (1.0 + Y + 2.0*X)/2.0;
    double tmp1 = (1.0 - Y)/2.0;
    double tmp2 = tmp1*tmp1;
    
    // Compute basisvalues.
    basisvalues[0] = 1.0;
    basisvalues[1] = tmp0;
    basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
    basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
    basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
    basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
    basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
    basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
    basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
    basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
    basisvalues[0] *= std::sqrt(0.5);
    basisvalues[2] *= std::sqrt(1.0);
    basisvalues[5] *= std::sqrt(1.5);
    basisvalues[9] *= std::sqrt(2.0);
    basisvalues[1] *= std::sqrt(3.0);
    basisvalues[4] *= std::sqrt(4.5);
    basisvalues[8] *= std::sqrt(6.0);
    basisvalues[3] *= std::sqrt(7.5);
    basisvalues[7] *= std::sqrt(10.0);
    basisvalues[6] *= std::sqrt(14.0);
    
    // Table(s) of coefficients.
    static const double coefficients0[10] = \
    {0.636396103067893, 0.0, 0.0, -0.234738238930786, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.0909137290096989};
    
    // Tables of derivatives of the polynomial base (transpose).
    static const double dmats0[10][10] = \
    {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
    {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
    {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
    
    static const double dmats1[10][10] = \
    {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
    {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
    {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
    {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
    
    // Compute reference derivatives.
    // Declare pointer to array of derivatives on FIAT element.
    double *derivatives = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      derivatives[r] = 0.0;
    }// end loop over 'r'
    
    // Declare derivative matrix (of polynomial basis).
    double dmats[10][10] = \
    {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
    
    // Declare (auxiliary) derivative matrix (of polynomial basis).
    double dmats_old[10][10] = \
    {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
    {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
    
    // Loop possible derivatives.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      // Resetting dmats values to compute next derivative.
      for (unsigned int t = 0; t < 10; t++)
      {
        for (unsigned int u = 0; u < 10; u++)
        {
          dmats[t][u] = 0.0;
          if (t == u)
          {
          dmats[t][u] = 1.0;
          }
          
        }// end loop over 'u'
      }// end loop over 't'
      
      // Looping derivative order to generate dmats.
      for (unsigned int s = 0; s < n; s++)
      {
        // Updating dmats_old with new values and resetting dmats.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats_old[t][u] = dmats[t][u];
            dmats[t][u] = 0.0;
          }// end loop over 'u'
        }// end loop over 't'
        
        // Update dmats using an inner product.
        if (combinations[r][s] == 0)
        {
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            for (unsigned int tu = 0; tu < 10; tu++)
            {
              dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
        if (combinations[r][s] == 1)
        {
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            for (unsigned int tu = 0; tu < 10; tu++)
            {
              dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
      }// end loop over 's'
      for (unsigned int s = 0; s < 10; s++)
      {
        for (unsigned int t = 0; t < 10; t++)
        {
          derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
        }// end loop over 't'
      }// end loop over 's'
    }// end loop over 'r'
    
    // Transform derivatives back to physical element
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r] += transform[r][s]*derivatives[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;
    
    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      delete [] combinations[r];
    }// end loop over 'r'
    delete [] combinations;
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      delete [] transform[r];
    }// end loop over 'r'
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Element is constant, calling evaluate_basis_derivatives.
    evaluate_basis_derivatives(0, n, values, coordinates, c);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = 0;
    vertex_values[1] = 0;
    vertex_values[2] = 0;
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_1();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_2: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_2() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_2()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 6;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 6; r++)
    {
      evaluate_basis(r, &dof_values, coordinates, c);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 6; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_2();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_3: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_3() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_3()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 12;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    values[0] = 0.0;
    values[1] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {0.0, 0.0};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 2; s++)
      {
        values[r*2 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[2*num_derivatives];
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[2];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[2];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[3] = dof_values[7];
    vertex_values[5] = dof_values[8];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_2();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_3();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_4: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_4() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_4()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 3;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 3; r++)
    {
      evaluate_basis(r, &dof_values, coordinates, c);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 3; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_4();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_5: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_5() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_5()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    values[0] = 0.0;
    values[1] = 0.0;
    values[2] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.0, 0.0, 0.0};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 15; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[3*num_derivatives];
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 15; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[3];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 12:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 13:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 14:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[3];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[12] = vals[2];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[13] = vals[2];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[14] = vals[2];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[4] = dof_values[7];
    vertex_values[7] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[12];
    vertex_values[5] = dof_values[13];
    vertex_values[8] = dof_values[14];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_3();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_4();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_5();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_6: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_6() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_6()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 10;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807677, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930786, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.0909137290096989};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 10; r++)
    {
      evaluate_basis(r, &dof_values, coordinates, c);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807677, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930786, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.0909137290096989};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 10; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 7:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 8:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 9:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_6();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_7: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_7() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_7()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 20;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    values[0] = 0.0;
    values[1] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807677, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930786, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.0909137290096989};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 15:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 16:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 17:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 18:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807677, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 19:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930786, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.0909137290096989};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {0.0, 0.0};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 20; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 2; s++)
      {
        values[r*2 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807677, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930786, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.0909137290096989};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 15:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 16:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 17:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 18:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807677, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 19:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930786, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.0909137290096989};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[2*num_derivatives];
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 20; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[2];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 7:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 8:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 9:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 10:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 12:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 13:
      {
        y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 14:
      {
        y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 15:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 16:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 17:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 18:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 19:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[2];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[12] = vals[1];
    y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[13] = vals[1];
    y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[14] = vals[1];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[15] = vals[1];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[16] = vals[1];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    f.evaluate(vals, y, c);
    values[17] = vals[1];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    f.evaluate(vals, y, c);
    values[18] = vals[1];
    y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[19] = vals[1];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[10];
    vertex_values[3] = dof_values[11];
    vertex_values[5] = dof_values[12];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_6();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_6();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_7();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_8: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_8() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_8()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 6;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 6; r++)
    {
      evaluate_basis(r, &dof_values, coordinates, c);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 6; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_8();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_9: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_9() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_9()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 26;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    values[0] = 0.0;
    values[1] = 0.0;
    values[2] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807677, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930786, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.0909137290096989};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 15:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 16:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 17:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 18:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807677, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524247};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 19:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930786, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.0909137290096989};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 10; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 20:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 21:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 22:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 23:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 24:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 25:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.0, 0.0, 0.0};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 26; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807677, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930786, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.0909137290096989};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, -0.0288675134594813, -0.0166666666666666, 0.0782460796435952, 0.0606091526731326, 0.0349927106111883, -0.0601337794302955, -0.0508223195384204, -0.0393667994375868, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0288675134594813, -0.0166666666666666, 0.0782460796435952, -0.0606091526731327, 0.0349927106111883, 0.0601337794302955, -0.0508223195384204, 0.0393667994375868, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.0471404520791032, 0.0, 0.0333333333333333, 0.0, 0.0, 0.104978131833565, 0.0, 0.0, 0.0, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, 0.117369119465393, 0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, -0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, 0.151522881682832, 0.0262445329583912, 0.0, 0.0, 0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 15:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, 0.117369119465393, -0.0606091526731326, -0.0787335988751736, 0.0, 0.101644639076841, 0.131222664791956, 0.090913729009699};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 16:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.0, 0.3, 0.0, -0.151522881682832, 0.0262445329583912, 0.0, 0.0, -0.131222664791956, -0.136370593514548};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 17:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, -0.259807621135332, -0.15, -0.0782460796435952, 0.090913729009699, 0.0962299541807677, 0.180401338290886, 0.0508223195384204, -0.0131222664791956, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 18:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.106066017177982, 0.259807621135332, -0.15, -0.0782460796435952, -0.090913729009699, 0.0962299541807677, -0.180401338290886, 0.0508223195384204, 0.0131222664791956, -0.0227284322524247};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 19:
      {
        
      // Array of basisvalues.
      double basisvalues[10] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[6] = basisvalues[3]*1.66666666666667*tmp0 - basisvalues[1]*0.666666666666667*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[7] = basisvalues[3]*(2.5 + 3.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[9] = basisvalues[5]*(0.05 + Y*1.75) - basisvalues[2]*0.7;
      basisvalues[8] = basisvalues[4]*(0.54 + Y*2.1) - basisvalues[1]*0.56;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[9] *= std::sqrt(2.0);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[8] *= std::sqrt(6.0);
      basisvalues[3] *= std::sqrt(7.5);
      basisvalues[7] *= std::sqrt(10.0);
      basisvalues[6] *= std::sqrt(14.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[10] = \
      {0.636396103067893, 0.0, 0.0, -0.234738238930786, 0.0, -0.262445329583912, 0.0, -0.203289278153682, 0.0, 0.0909137290096989};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4, 0.0, 7.07106781186548, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {5.29150262212918, 0.0, -2.99332590941915, 13.6626010212795, 0.0, 0.611010092660779, 0.0, 0.0, 0.0, 0.0},
      {0.0, 4.38178046004133, 0.0, 0.0, 12.5219806739988, 0.0, 0.0, 0.0, 0.0, 0.0},
      {3.46410161513775, 0.0, 7.83836717690617, 0.0, 0.0, 8.4, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[10][10] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175277, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.0, 6.12372435695795, 3.53553390593274, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.64575131106459, 5.18459255872629, -1.49666295470958, 6.83130051063973, -1.05830052442584, 0.30550504633039, 0.0, 0.0, 0.0, 0.0},
      {2.23606797749979, 2.19089023002066, 2.52982212813471, 8.08290376865476, 6.26099033699941, -1.80739222823013, 0.0, 0.0, 0.0, 0.0},
      {1.73205080756888, -5.09116882454314, 3.91918358845308, 0.0, 9.69948452238571, 4.2, 0.0, 0.0, 0.0, 0.0},
      {5, 0.0, -2.82842712474619, 0.0, 0.0, 12.1243556529821, 0.0, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[10][10] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 10; t++)
        {
          for (unsigned int u = 0; u < 10; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 10; t++)
          {
            for (unsigned int u = 0; u < 10; u++)
            {
              for (unsigned int tu = 0; tu < 10; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 10; s++)
        {
          for (unsigned int t = 0; t < 10; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 20:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 21:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 22:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 23:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 24:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 25:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[3*num_derivatives];
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 26; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[3];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 7:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 8:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 9:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 10:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 12:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 13:
      {
        y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 14:
      {
        y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 15:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 16:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 17:
      {
        y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
      y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 18:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
      y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 19:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 20:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 21:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 22:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 23:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 24:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 25:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[3];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[6] = vals[0];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    f.evaluate(vals, y, c);
    values[8] = vals[0];
    y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[12] = vals[1];
    y[0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[13] = vals[1];
    y[0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[14] = vals[1];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[15] = vals[1];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    f.evaluate(vals, y, c);
    values[16] = vals[1];
    y[0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    y[1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    f.evaluate(vals, y, c);
    values[17] = vals[1];
    y[0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    y[1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    f.evaluate(vals, y, c);
    values[18] = vals[1];
    y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[19] = vals[1];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[20] = vals[2];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[21] = vals[2];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[22] = vals[2];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[23] = vals[2];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[24] = vals[2];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[25] = vals[2];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[10];
    vertex_values[4] = dof_values[11];
    vertex_values[7] = dof_values[12];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[20];
    vertex_values[5] = dof_values[21];
    vertex_values[8] = dof_values[22];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_7();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_8();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_9();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_10: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_10() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_10()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Real', Cell('triangle', Space(2)), 0, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 1;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Compute constants
    
    // Get coordinates and map to the reference (FIAT) element
    
    // Reset values.
    *values = 0.0;
    
    // Array of basisvalues.
    double basisvalues[1] = {0.0};
    
    // Declare helper variables.
    
    // Compute basisvalues.
    basisvalues[0] = 1.0;
    
    // Table(s) of coefficients.
    static const double coefficients0[1] = \
    {1.0};
    
    // Compute value(s).
    for (unsigned int r = 0; r < 1; r++)
    {
      *values += coefficients0[r]*basisvalues[r];
    }// end loop over 'r'
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Element is constant, calling evaluate_basis.
    evaluate_basis(0, values, coordinates, c);
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    
    // Get coordinates and map to the reference (FIAT) element
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    
    // Array of basisvalues.
    double basisvalues[1] = {0.0};
    
    // Declare helper variables.
    
    // Compute basisvalues.
    basisvalues[0] = 1.0;
    
    // Table(s) of coefficients.
    static const double coefficients0[1] = \
    {1.0};
    
    // Tables of derivatives of the polynomial base (transpose).
    static const double dmats0[1][1] = \
    {{0.0}};
    
    static const double dmats1[1][1] = \
    {{0.0}};
    
    // Compute reference derivatives.
    // Declare pointer to array of derivatives on FIAT element.
    double *derivatives = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      derivatives[r] = 0.0;
    }// end loop over 'r'
    
    // Declare derivative matrix (of polynomial basis).
    double dmats[1][1] = \
    {{1.0}};
    
    // Declare (auxiliary) derivative matrix (of polynomial basis).
    double dmats_old[1][1] = \
    {{1.0}};
    
    // Loop possible derivatives.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      // Resetting dmats values to compute next derivative.
      for (unsigned int t = 0; t < 1; t++)
      {
        for (unsigned int u = 0; u < 1; u++)
        {
          dmats[t][u] = 0.0;
          if (t == u)
          {
          dmats[t][u] = 1.0;
          }
          
        }// end loop over 'u'
      }// end loop over 't'
      
      // Looping derivative order to generate dmats.
      for (unsigned int s = 0; s < n; s++)
      {
        // Updating dmats_old with new values and resetting dmats.
        for (unsigned int t = 0; t < 1; t++)
        {
          for (unsigned int u = 0; u < 1; u++)
          {
            dmats_old[t][u] = dmats[t][u];
            dmats[t][u] = 0.0;
          }// end loop over 'u'
        }// end loop over 't'
        
        // Update dmats using an inner product.
        if (combinations[r][s] == 0)
        {
        for (unsigned int t = 0; t < 1; t++)
        {
          for (unsigned int u = 0; u < 1; u++)
          {
            for (unsigned int tu = 0; tu < 1; tu++)
            {
              dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
        if (combinations[r][s] == 1)
        {
        for (unsigned int t = 0; t < 1; t++)
        {
          for (unsigned int u = 0; u < 1; u++)
          {
            for (unsigned int tu = 0; tu < 1; tu++)
            {
              dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
            }// end loop over 'tu'
          }// end loop over 'u'
        }// end loop over 't'
        }
        
      }// end loop over 's'
      for (unsigned int s = 0; s < 1; s++)
      {
        for (unsigned int t = 0; t < 1; t++)
        {
          derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
        }// end loop over 't'
      }// end loop over 's'
    }// end loop over 'r'
    
    // Transform derivatives back to physical element
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r] += transform[r][s]*derivatives[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer to array of derivatives on FIAT element
    delete [] derivatives;
    
    // Delete pointer to array of combinations of derivatives and transform
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      delete [] combinations[r];
    }// end loop over 'r'
    delete [] combinations;
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      delete [] transform[r];
    }// end loop over 'r'
    delete [] transform;
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Element is constant, calling evaluate_basis_derivatives.
    evaluate_basis_derivatives(0, n, values, coordinates, c);
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
      y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    y[1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[0];
    vertex_values[2] = dof_values[0];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_10();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_11: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_11() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_11()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 12;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    values[0] = 0.0;
    values[1] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[2] = {0.0, 0.0};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 2; s++)
      {
        values[r*2 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[2*num_derivatives];
    for (unsigned int r = 0; r < 2*num_derivatives; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 12; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 2*num_derivatives; s++)
      {
        values[r*2*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[2];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[2];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[2] = dof_values[1];
    vertex_values[4] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[3] = dof_values[7];
    vertex_values[5] = dof_values[8];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_8();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_8();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_11();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_12: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_12() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_12()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 3;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 0;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    return 1;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    *values = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        *values += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values = 0.0;
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 3; r++)
    {
      evaluate_basis(r, &dof_values, coordinates, c);
      values[r] = dof_values;
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[num_derivatives];
    for (unsigned int r = 0; r < num_derivatives; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 3; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < num_derivatives; s++)
      {
        values[r*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[1];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[1] = dof_values[1];
    vertex_values[2] = dof_values[2];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 0;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_12();
  }

};

/// This class defines the interface for a finite element.

class adaptivenavierstokes_finite_element_13: public ufc::finite_element
{
public:

  /// Constructor
  adaptivenavierstokes_finite_element_13() : ufc::finite_element()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_finite_element_13()
  {
    // Do nothing
  }

  /// Return a string identifying the finite element
  virtual const char* signature() const
  {
    return "MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) })";
  }

  /// Return the cell shape
  virtual ufc::shape cell_shape() const
  {
    return ufc::triangle;
  }

  /// Return the topological dimension of the cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the finite element function space
  virtual unsigned int space_dimension() const
  {
    return 15;
  }

  /// Return the rank of the value space
  virtual unsigned int value_rank() const
  {
    return 1;
  }

  /// Return the dimension of the value space for axis i
  virtual unsigned int value_dimension(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Evaluate basis function i at given point in cell
  virtual void evaluate_basis(unsigned int i,
                              double* values,
                              const double* coordinates,
                              const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Reset values.
    values[0] = 0.0;
    values[1] = 0.0;
    values[2] = 0.0;
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[0] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 6; r++)
      {
        values[1] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Compute value(s).
      for (unsigned int r = 0; r < 3; r++)
      {
        values[2] += coefficients0[r]*basisvalues[r];
      }// end loop over 'r'
        break;
      }
    }
    
  }

  /// Evaluate all basis functions at given point in cell
  virtual void evaluate_basis_all(double* values,
                                  const double* coordinates,
                                  const ufc::cell& c) const
  {
    // Helper variable to hold values of a single dof.
    double dof_values[3] = {0.0, 0.0, 0.0};
    
    // Loop dofs and call evaluate_basis.
    for (unsigned int r = 0; r < 15; r++)
    {
      evaluate_basis(r, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 3; s++)
      {
        values[r*3 + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
  }

  /// Evaluate order n derivatives of basis function i at given point in cell
  virtual void evaluate_basis_derivatives(unsigned int i,
                                          unsigned int n,
                                          double* values,
                                          const double* coordinates,
                                          const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Compute constants
    const double C0 = x[1][0] + x[2][0];
    const double C1 = x[1][1] + x[2][1];
    
    // Get coordinates and map to the reference (FIAT) element
    double X = (J_01*(C1 - 2.0*coordinates[1]) + J_11*(2.0*coordinates[0] - C0)) / detJ;
    double Y = (J_00*(2.0*coordinates[1] - C1) + J_10*(C0 - 2.0*coordinates[0])) / detJ;
    
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Declare pointer to two dimensional array that holds combinations of derivatives and initialise
    unsigned int **combinations = new unsigned int *[num_derivatives];
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      combinations[row] = new unsigned int [n];
      for (unsigned int col = 0; col < n; col++)
        combinations[row][col] = 0;
    }
    
    // Generate combinations of derivatives
    for (unsigned int row = 1; row < num_derivatives; row++)
    {
      for (unsigned int num = 0; num < row; num++)
      {
        for (unsigned int col = n-1; col+1 > 0; col--)
        {
          if (combinations[row][col] + 1 > 1)
            combinations[row][col] = 0;
          else
          {
            combinations[row][col] += 1;
            break;
          }
        }
      }
    }
    
    // Compute inverse of Jacobian
    const double Jinv[2][2] = {{K_00, K_01}, {K_10, K_11}};
    
    // Declare transformation matrix
    // Declare pointer to two dimensional array and initialise
    double **transform = new double *[num_derivatives];
    
    for (unsigned int j = 0; j < num_derivatives; j++)
    {
      transform[j] = new double [num_derivatives];
      for (unsigned int k = 0; k < num_derivatives; k++)
        transform[j][k] = 1;
    }
    
    // Construct transformation matrix
    for (unsigned int row = 0; row < num_derivatives; row++)
    {
      for (unsigned int col = 0; col < num_derivatives; col++)
      {
        for (unsigned int k = 0; k < n; k++)
          transform[row][col] *= Jinv[combinations[col][k]][combinations[row][k]];
      }
    }
    
    // Reset values. Assuming that values is always an array.
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      values[r] = 0.0;
    }// end loop over 'r'
    
    switch (i)
    {
    case 0:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 1:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 2:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 3:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 4:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 5:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 6:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, -0.173205080756888, -0.1, 0.121716123890037, 0.0942809041582064, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 7:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.173205080756888, -0.1, 0.121716123890037, -0.0942809041582063, 0.0544331053951818};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 8:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.0, 0.0, 0.2, 0.0, 0.0, 0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 9:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.23094010767585, 0.133333333333333, 0.0, 0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 10:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, -0.23094010767585, 0.133333333333333, 0.0, -0.188561808316413, -0.163299316185545};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 11:
      {
        
      // Array of basisvalues.
      double basisvalues[6] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      double tmp1 = (1.0 - Y)/2.0;
      double tmp2 = tmp1*tmp1;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[3] = basisvalues[1]*1.5*tmp0 - basisvalues[0]*0.5*tmp2;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[4] = basisvalues[1]*(1.5 + 2.5*Y);
      basisvalues[5] = basisvalues[2]*(0.111111111111111 + Y*1.66666666666667) - basisvalues[0]*0.555555555555556;
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[5] *= std::sqrt(1.5);
      basisvalues[1] *= std::sqrt(3.0);
      basisvalues[4] *= std::sqrt(4.5);
      basisvalues[3] *= std::sqrt(7.5);
      
      // Table(s) of coefficients.
      static const double coefficients0[6] = \
      {0.471404520791032, 0.0, -0.266666666666667, -0.243432247780074, 0.0, 0.0544331053951817};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.89897948556635, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 9.48683298050514, 0.0, 0.0, 0.0, 0.0},
      {4.0, 0.0, 7.07106781186548, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 0.0}};
      
      static const double dmats1[6][6] = \
      {{0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0, 0.0, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0, 0.0, 0.0, 0.0},
      {2.58198889747161, 4.74341649025257, -0.912870929175278, 0.0, 0.0, 0.0},
      {2, 6.12372435695794, 3.53553390593274, 0.0, 0.0, 0.0},
      {-2.3094010767585, 0.0, 8.16496580927726, 0.0, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[6][6] = \
      {{1.0, 0.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 1.0, 0.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 1.0, 0.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 1.0, 0.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 1.0, 0.0},
      {0.0, 0.0, 0.0, 0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 6; t++)
        {
          for (unsigned int u = 0; u < 6; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 6; t++)
          {
            for (unsigned int u = 0; u < 6; u++)
            {
              for (unsigned int tu = 0; tu < 6; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 6; s++)
        {
          for (unsigned int t = 0; t < 6; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 12:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, -0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 13:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.288675134594813, -0.166666666666667};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    case 14:
      {
        
      // Array of basisvalues.
      double basisvalues[3] = {0.0, 0.0, 0.0};
      
      // Declare helper variables.
      double tmp0 = (1.0 + Y + 2.0*X)/2.0;
      
      // Compute basisvalues.
      basisvalues[0] = 1.0;
      basisvalues[1] = tmp0;
      basisvalues[2] = basisvalues[0]*(0.5 + 1.5*Y);
      basisvalues[0] *= std::sqrt(0.5);
      basisvalues[2] *= std::sqrt(1.0);
      basisvalues[1] *= std::sqrt(3.0);
      
      // Table(s) of coefficients.
      static const double coefficients0[3] = \
      {0.471404520791032, 0.0, 0.333333333333333};
      
      // Tables of derivatives of the polynomial base (transpose).
      static const double dmats0[3][3] = \
      {{0.0, 0.0, 0.0},
      {4.89897948556636, 0.0, 0.0},
      {0.0, 0.0, 0.0}};
      
      static const double dmats1[3][3] = \
      {{0.0, 0.0, 0.0},
      {2.44948974278318, 0.0, 0.0},
      {4.24264068711928, 0.0, 0.0}};
      
      // Compute reference derivatives.
      // Declare pointer to array of derivatives on FIAT element.
      double *derivatives = new double[num_derivatives];
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        derivatives[r] = 0.0;
      }// end loop over 'r'
      
      // Declare derivative matrix (of polynomial basis).
      double dmats[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Declare (auxiliary) derivative matrix (of polynomial basis).
      double dmats_old[3][3] = \
      {{1.0, 0.0, 0.0},
      {0.0, 1.0, 0.0},
      {0.0, 0.0, 1.0}};
      
      // Loop possible derivatives.
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        // Resetting dmats values to compute next derivative.
        for (unsigned int t = 0; t < 3; t++)
        {
          for (unsigned int u = 0; u < 3; u++)
          {
            dmats[t][u] = 0.0;
            if (t == u)
            {
            dmats[t][u] = 1.0;
            }
            
          }// end loop over 'u'
        }// end loop over 't'
        
        // Looping derivative order to generate dmats.
        for (unsigned int s = 0; s < n; s++)
        {
          // Updating dmats_old with new values and resetting dmats.
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              dmats_old[t][u] = dmats[t][u];
              dmats[t][u] = 0.0;
            }// end loop over 'u'
          }// end loop over 't'
          
          // Update dmats using an inner product.
          if (combinations[r][s] == 0)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats0[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
          if (combinations[r][s] == 1)
          {
          for (unsigned int t = 0; t < 3; t++)
          {
            for (unsigned int u = 0; u < 3; u++)
            {
              for (unsigned int tu = 0; tu < 3; tu++)
              {
                dmats[t][u] += dmats1[t][tu]*dmats_old[tu][u];
              }// end loop over 'tu'
            }// end loop over 'u'
          }// end loop over 't'
          }
          
        }// end loop over 's'
        for (unsigned int s = 0; s < 3; s++)
        {
          for (unsigned int t = 0; t < 3; t++)
          {
            derivatives[r] += coefficients0[s]*dmats[s][t]*basisvalues[t];
          }// end loop over 't'
        }// end loop over 's'
      }// end loop over 'r'
      
      // Transform derivatives back to physical element
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        for (unsigned int s = 0; s < num_derivatives; s++)
        {
          values[2*num_derivatives + r] += transform[r][s]*derivatives[s];
        }// end loop over 's'
      }// end loop over 'r'
      
      // Delete pointer to array of derivatives on FIAT element
      delete [] derivatives;
      
      // Delete pointer to array of combinations of derivatives and transform
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] combinations[r];
      }// end loop over 'r'
      delete [] combinations;
      for (unsigned int r = 0; r < num_derivatives; r++)
      {
        delete [] transform[r];
      }// end loop over 'r'
      delete [] transform;
        break;
      }
    }
    
  }

  /// Evaluate order n derivatives of all basis functions at given point in cell
  virtual void evaluate_basis_derivatives_all(unsigned int n,
                                              double* values,
                                              const double* coordinates,
                                              const ufc::cell& c) const
  {
    // Compute number of derivatives.
    unsigned int num_derivatives = 1;
    for (unsigned int r = 0; r < n; r++)
    {
      num_derivatives *= 2;
    }// end loop over 'r'
    
    // Helper variable to hold values of a single dof.
    double *dof_values = new double[3*num_derivatives];
    for (unsigned int r = 0; r < 3*num_derivatives; r++)
    {
      dof_values[r] = 0.0;
    }// end loop over 'r'
    
    // Loop dofs and call evaluate_basis_derivatives.
    for (unsigned int r = 0; r < 15; r++)
    {
      evaluate_basis_derivatives(r, n, dof_values, coordinates, c);
      for (unsigned int s = 0; s < 3*num_derivatives; s++)
      {
        values[r*3*num_derivatives + s] = dof_values[s];
      }// end loop over 's'
    }// end loop over 'r'
    
    // Delete pointer.
    delete [] dof_values;
  }

  /// Evaluate linear functional for dof i on the function f
  virtual double evaluate_dof(unsigned int i,
                              const ufc::function& f,
                              const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[3];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    switch (i)
    {
    case 0:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 1:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 2:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 3:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 4:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 5:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[0];
        break;
      }
    case 6:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 7:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 8:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 9:
      {
        y[0] = 0.5*x[1][0] + 0.5*x[2][0];
      y[1] = 0.5*x[1][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 10:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[2][0];
      y[1] = 0.5*x[0][1] + 0.5*x[2][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 11:
      {
        y[0] = 0.5*x[0][0] + 0.5*x[1][0];
      y[1] = 0.5*x[0][1] + 0.5*x[1][1];
      f.evaluate(vals, y, c);
      return vals[1];
        break;
      }
    case 12:
      {
        y[0] = x[0][0];
      y[1] = x[0][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 13:
      {
        y[0] = x[1][0];
      y[1] = x[1][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    case 14:
      {
        y[0] = x[2][0];
      y[1] = x[2][1];
      f.evaluate(vals, y, c);
      return vals[2];
        break;
      }
    }
    
    return 0.0;
  }

  /// Evaluate linear functionals for all dofs on the function f
  virtual void evaluate_dofs(double* values,
                             const ufc::function& f,
                             const ufc::cell& c) const
  {
    // Declare variables for result of evaluation.
    double vals[3];
    
    // Declare variable for physical coordinates.
    double y[2];
    const double * const * x = c.coordinates;
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[0] = vals[0];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[1] = vals[0];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[2] = vals[0];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[3] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[4] = vals[0];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[5] = vals[0];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[6] = vals[1];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[7] = vals[1];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[8] = vals[1];
    y[0] = 0.5*x[1][0] + 0.5*x[2][0];
    y[1] = 0.5*x[1][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[9] = vals[1];
    y[0] = 0.5*x[0][0] + 0.5*x[2][0];
    y[1] = 0.5*x[0][1] + 0.5*x[2][1];
    f.evaluate(vals, y, c);
    values[10] = vals[1];
    y[0] = 0.5*x[0][0] + 0.5*x[1][0];
    y[1] = 0.5*x[0][1] + 0.5*x[1][1];
    f.evaluate(vals, y, c);
    values[11] = vals[1];
    y[0] = x[0][0];
    y[1] = x[0][1];
    f.evaluate(vals, y, c);
    values[12] = vals[2];
    y[0] = x[1][0];
    y[1] = x[1][1];
    f.evaluate(vals, y, c);
    values[13] = vals[2];
    y[0] = x[2][0];
    y[1] = x[2][1];
    f.evaluate(vals, y, c);
    values[14] = vals[2];
  }

  /// Interpolate vertex values from dof values
  virtual void interpolate_vertex_values(double* vertex_values,
                                         const double* dof_values,
                                         const ufc::cell& c) const
  {
    // Evaluate function and change variables
    vertex_values[0] = dof_values[0];
    vertex_values[3] = dof_values[1];
    vertex_values[6] = dof_values[2];
    // Evaluate function and change variables
    vertex_values[1] = dof_values[6];
    vertex_values[4] = dof_values[7];
    vertex_values[7] = dof_values[8];
    // Evaluate function and change variables
    vertex_values[2] = dof_values[12];
    vertex_values[5] = dof_values[13];
    vertex_values[8] = dof_values[14];
  }

  /// Map coordinate xhat from reference cell to coordinate x in cell
  virtual void map_from_reference_cell(double* x,
                                       const double* xhat,
                                       const ufc::cell& c) const
  {
    throw std::runtime_error("map_from_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Map from coordinate x in cell to coordinate xhat in reference cell
  virtual void map_to_reference_cell(double* xhat,
                                     const double* x,
                                     const ufc::cell& c) const
  {
    throw std::runtime_error("map_to_reference_cell not yet implemented (introduced in UFC 2.0).");
  }

  /// Return the number of sub elements (for a mixed element)
  virtual unsigned int num_sub_elements() const
  {
    return 2;
  }

  /// Create a new finite element for sub element i (for a mixed element)
  virtual ufc::finite_element* create_sub_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_11();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::finite_element* create() const
  {
    return new adaptivenavierstokes_finite_element_13();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_0: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_0() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_0()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 0, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 1;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 1;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 1;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = c.entity_indices[2][0];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[0][1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_0();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_1: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_1() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_1()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 1;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 1;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 1;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = c.entity_indices[2][0];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[0][1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_1();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_2: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_2() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_2()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 6*m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 6;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 6;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 6;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 6*c.entity_indices[2][0];
    dofs[1] = 6*c.entity_indices[2][0] + 1;
    dofs[2] = 6*c.entity_indices[2][0] + 2;
    dofs[3] = 6*c.entity_indices[2][0] + 3;
    dofs[4] = 6*c.entity_indices[2][0] + 4;
    dofs[5] = 6*c.entity_indices[2][0] + 5;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      dofs[3] = 3;
      dofs[4] = 4;
      dofs[5] = 5;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[3][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[5][1] = 0.5*x[0][1] + 0.5*x[1][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_2();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_3: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_3() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_3()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 12*m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 12;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 12;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 12;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + 6*c.entity_indices[2][0];
    dofs[1] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[2] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[3] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[4] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[5] = offset + 6*c.entity_indices[2][0] + 5;
    offset += 6*m.num_entities[2];
    dofs[6] = offset + 6*c.entity_indices[2][0];
    dofs[7] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[8] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[9] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[10] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[11] = offset + 6*c.entity_indices[2][0] + 5;
    offset += 6*m.num_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      dofs[3] = 3;
      dofs[4] = 4;
      dofs[5] = 5;
      dofs[6] = 6;
      dofs[7] = 7;
      dofs[8] = 8;
      dofs[9] = 9;
      dofs[10] = 10;
      dofs[11] = 11;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[3][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[5][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[6][0] = x[0][0];
    coordinates[6][1] = x[0][1];
    coordinates[7][0] = x[1][0];
    coordinates[7][1] = x[1][1];
    coordinates[8][0] = x[2][0];
    coordinates[8][1] = x[2][1];
    coordinates[9][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[9][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[10][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[10][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[11][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[11][1] = 0.5*x[0][1] + 0.5*x[1][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_2();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_3();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_4: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_4() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_4()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 3*m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 3;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 3;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 3;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 3*c.entity_indices[2][0];
    dofs[1] = 3*c.entity_indices[2][0] + 1;
    dofs[2] = 3*c.entity_indices[2][0] + 2;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_4();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_5: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_5() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_5()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 15*m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 15;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 15;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 15;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + 6*c.entity_indices[2][0];
    dofs[1] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[2] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[3] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[4] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[5] = offset + 6*c.entity_indices[2][0] + 5;
    offset += 6*m.num_entities[2];
    dofs[6] = offset + 6*c.entity_indices[2][0];
    dofs[7] = offset + 6*c.entity_indices[2][0] + 1;
    dofs[8] = offset + 6*c.entity_indices[2][0] + 2;
    dofs[9] = offset + 6*c.entity_indices[2][0] + 3;
    dofs[10] = offset + 6*c.entity_indices[2][0] + 4;
    dofs[11] = offset + 6*c.entity_indices[2][0] + 5;
    offset += 6*m.num_entities[2];
    dofs[12] = offset + 3*c.entity_indices[2][0];
    dofs[13] = offset + 3*c.entity_indices[2][0] + 1;
    dofs[14] = offset + 3*c.entity_indices[2][0] + 2;
    offset += 3*m.num_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 2;
      dofs[3] = 3;
      dofs[4] = 4;
      dofs[5] = 5;
      dofs[6] = 6;
      dofs[7] = 7;
      dofs[8] = 8;
      dofs[9] = 9;
      dofs[10] = 10;
      dofs[11] = 11;
      dofs[12] = 12;
      dofs[13] = 13;
      dofs[14] = 14;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[3][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[5][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[6][0] = x[0][0];
    coordinates[6][1] = x[0][1];
    coordinates[7][0] = x[1][0];
    coordinates[7][1] = x[1][1];
    coordinates[8][0] = x[2][0];
    coordinates[8][1] = x[2][1];
    coordinates[9][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[9][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[10][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[10][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[11][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[11][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[12][0] = x[0][0];
    coordinates[12][1] = x[0][1];
    coordinates[13][0] = x[1][0];
    coordinates[13][1] = x[1][1];
    coordinates[14][0] = x[2][0];
    coordinates[14][1] = x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_3();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_4();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_5();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_6: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_6() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_6()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = m.num_entities[0] + 2*m.num_entities[1] + m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 10;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 10;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 4;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 2;
        break;
      }
    case 2:
      {
        return 1;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + 2*c.entity_indices[1][0];
    dofs[4] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[5] = offset + 2*c.entity_indices[1][1];
    dofs[6] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[7] = offset + 2*c.entity_indices[1][2];
    dofs[8] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*m.num_entities[1];
    dofs[9] = offset + c.entity_indices[2][0];
    offset += m.num_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 5;
      dofs[3] = 6;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 7;
      dofs[3] = 8;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 4;
          break;
        }
      case 1:
        {
          dofs[0] = 5;
        dofs[1] = 6;
          break;
        }
      case 2:
        {
          dofs[0] = 7;
        dofs[1] = 8;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 9;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[3][1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    coordinates[4][0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    coordinates[4][1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    coordinates[5][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    coordinates[5][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    coordinates[6][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    coordinates[6][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    coordinates[7][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    coordinates[7][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    coordinates[8][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    coordinates[8][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    coordinates[9][0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[9][1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_6();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_7: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_7() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_7()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 2*m.num_entities[0] + 4*m.num_entities[1] + 2*m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 20;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 20;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 8;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 2;
        break;
      }
    case 1:
      {
        return 4;
        break;
      }
    case 2:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + 2*c.entity_indices[1][0];
    dofs[4] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[5] = offset + 2*c.entity_indices[1][1];
    dofs[6] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[7] = offset + 2*c.entity_indices[1][2];
    dofs[8] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*m.num_entities[1];
    dofs[9] = offset + c.entity_indices[2][0];
    offset += m.num_entities[2];
    dofs[10] = offset + c.entity_indices[0][0];
    dofs[11] = offset + c.entity_indices[0][1];
    dofs[12] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[13] = offset + 2*c.entity_indices[1][0];
    dofs[14] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[15] = offset + 2*c.entity_indices[1][1];
    dofs[16] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[17] = offset + 2*c.entity_indices[1][2];
    dofs[18] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*m.num_entities[1];
    dofs[19] = offset + c.entity_indices[2][0];
    offset += m.num_entities[2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 11;
      dofs[5] = 12;
      dofs[6] = 13;
      dofs[7] = 14;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 10;
      dofs[5] = 12;
      dofs[6] = 15;
      dofs[7] = 16;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 7;
      dofs[3] = 8;
      dofs[4] = 10;
      dofs[5] = 11;
      dofs[6] = 17;
      dofs[7] = 18;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 10;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 11;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 12;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 4;
        dofs[2] = 13;
        dofs[3] = 14;
          break;
        }
      case 1:
        {
          dofs[0] = 5;
        dofs[1] = 6;
        dofs[2] = 15;
        dofs[3] = 16;
          break;
        }
      case 2:
        {
          dofs[0] = 7;
        dofs[1] = 8;
        dofs[2] = 17;
        dofs[3] = 18;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 9;
      dofs[1] = 19;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[3][1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    coordinates[4][0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    coordinates[4][1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    coordinates[5][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    coordinates[5][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    coordinates[6][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    coordinates[6][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    coordinates[7][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    coordinates[7][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    coordinates[8][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    coordinates[8][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    coordinates[9][0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[9][1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    coordinates[10][0] = x[0][0];
    coordinates[10][1] = x[0][1];
    coordinates[11][0] = x[1][0];
    coordinates[11][1] = x[1][1];
    coordinates[12][0] = x[2][0];
    coordinates[12][1] = x[2][1];
    coordinates[13][0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[13][1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    coordinates[14][0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    coordinates[14][1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    coordinates[15][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    coordinates[15][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    coordinates[16][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    coordinates[16][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    coordinates[17][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    coordinates[17][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    coordinates[18][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    coordinates[18][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    coordinates[19][0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[19][1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_6();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_6();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_7();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_8: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_8() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_8()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = m.num_entities[0] + m.num_entities[1];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 6;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 6;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 3;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 1;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[3][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[5][1] = 0.5*x[0][1] + 0.5*x[1][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_8();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_9: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_9() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_9()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return true;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 3*m.num_entities[0] + 5*m.num_entities[1] + 2*m.num_entities[2];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 26;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 26;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 11;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 3;
        break;
      }
    case 1:
      {
        return 5;
        break;
      }
    case 2:
      {
        return 2;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + 2*c.entity_indices[1][0];
    dofs[4] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[5] = offset + 2*c.entity_indices[1][1];
    dofs[6] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[7] = offset + 2*c.entity_indices[1][2];
    dofs[8] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*m.num_entities[1];
    dofs[9] = offset + c.entity_indices[2][0];
    offset += m.num_entities[2];
    dofs[10] = offset + c.entity_indices[0][0];
    dofs[11] = offset + c.entity_indices[0][1];
    dofs[12] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[13] = offset + 2*c.entity_indices[1][0];
    dofs[14] = offset + 2*c.entity_indices[1][0] + 1;
    dofs[15] = offset + 2*c.entity_indices[1][1];
    dofs[16] = offset + 2*c.entity_indices[1][1] + 1;
    dofs[17] = offset + 2*c.entity_indices[1][2];
    dofs[18] = offset + 2*c.entity_indices[1][2] + 1;
    offset += 2*m.num_entities[1];
    dofs[19] = offset + c.entity_indices[2][0];
    offset += m.num_entities[2];
    dofs[20] = offset + c.entity_indices[0][0];
    dofs[21] = offset + c.entity_indices[0][1];
    dofs[22] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[23] = offset + c.entity_indices[1][0];
    dofs[24] = offset + c.entity_indices[1][1];
    dofs[25] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 4;
      dofs[4] = 11;
      dofs[5] = 12;
      dofs[6] = 13;
      dofs[7] = 14;
      dofs[8] = 21;
      dofs[9] = 22;
      dofs[10] = 23;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 10;
      dofs[5] = 12;
      dofs[6] = 15;
      dofs[7] = 16;
      dofs[8] = 20;
      dofs[9] = 22;
      dofs[10] = 24;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 7;
      dofs[3] = 8;
      dofs[4] = 10;
      dofs[5] = 11;
      dofs[6] = 17;
      dofs[7] = 18;
      dofs[8] = 20;
      dofs[9] = 21;
      dofs[10] = 25;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 10;
        dofs[2] = 20;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 11;
        dofs[2] = 21;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 12;
        dofs[2] = 22;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 4;
        dofs[2] = 13;
        dofs[3] = 14;
        dofs[4] = 23;
          break;
        }
      case 1:
        {
          dofs[0] = 5;
        dofs[1] = 6;
        dofs[2] = 15;
        dofs[3] = 16;
        dofs[4] = 24;
          break;
        }
      case 2:
        {
          dofs[0] = 7;
        dofs[1] = 8;
        dofs[2] = 17;
        dofs[3] = 18;
        dofs[4] = 25;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 9;
      dofs[1] = 19;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[3][1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    coordinates[4][0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    coordinates[4][1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    coordinates[5][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    coordinates[5][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    coordinates[6][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    coordinates[6][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    coordinates[7][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    coordinates[7][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    coordinates[8][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    coordinates[8][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    coordinates[9][0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[9][1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    coordinates[10][0] = x[0][0];
    coordinates[10][1] = x[0][1];
    coordinates[11][0] = x[1][0];
    coordinates[11][1] = x[1][1];
    coordinates[12][0] = x[2][0];
    coordinates[12][1] = x[2][1];
    coordinates[13][0] = 0.666666666666667*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[13][1] = 0.666666666666667*x[1][1] + 0.333333333333333*x[2][1];
    coordinates[14][0] = 0.333333333333333*x[1][0] + 0.666666666666667*x[2][0];
    coordinates[14][1] = 0.333333333333333*x[1][1] + 0.666666666666667*x[2][1];
    coordinates[15][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[2][0];
    coordinates[15][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[2][1];
    coordinates[16][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[2][0];
    coordinates[16][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[2][1];
    coordinates[17][0] = 0.666666666666667*x[0][0] + 0.333333333333333*x[1][0];
    coordinates[17][1] = 0.666666666666667*x[0][1] + 0.333333333333333*x[1][1];
    coordinates[18][0] = 0.333333333333333*x[0][0] + 0.666666666666667*x[1][0];
    coordinates[18][1] = 0.333333333333333*x[0][1] + 0.666666666666667*x[1][1];
    coordinates[19][0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[19][1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
    coordinates[20][0] = x[0][0];
    coordinates[20][1] = x[0][1];
    coordinates[21][0] = x[1][0];
    coordinates[21][1] = x[1][1];
    coordinates[22][0] = x[2][0];
    coordinates[22][1] = x[2][1];
    coordinates[23][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[23][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[24][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[24][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[25][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[25][1] = 0.5*x[0][1] + 0.5*x[1][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_7();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_8();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_9();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_10: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_10() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_10()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Real', Cell('triangle', Space(2)), 0, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return false;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 1;
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 1;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 1;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 0;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 0;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 1;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = 0;
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        if (i > 0)
      {
      throw std::runtime_error("i is larger than number of entities (0)");
      }
      
      dofs[0] = 0;
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = 0.333333333333333*x[0][0] + 0.333333333333333*x[1][0] + 0.333333333333333*x[2][0];
    coordinates[0][1] = 0.333333333333333*x[0][1] + 0.333333333333333*x[1][1] + 0.333333333333333*x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_10();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_11: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_11() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_11()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 2*m.num_entities[0] + 2*m.num_entities[1];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 12;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 12;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 6;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 2;
        break;
      }
    case 1:
      {
        return 2;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
    dofs[6] = offset + c.entity_indices[0][0];
    dofs[7] = offset + c.entity_indices[0][1];
    dofs[8] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[9] = offset + c.entity_indices[1][0];
    dofs[10] = offset + c.entity_indices[1][1];
    dofs[11] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 7;
      dofs[4] = 8;
      dofs[5] = 9;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
      dofs[3] = 6;
      dofs[4] = 8;
      dofs[5] = 10;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 7;
      dofs[5] = 11;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 6;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 7;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 8;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 9;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
        dofs[1] = 10;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
        dofs[1] = 11;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[3][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[5][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[6][0] = x[0][0];
    coordinates[6][1] = x[0][1];
    coordinates[7][0] = x[1][0];
    coordinates[7][1] = x[1][1];
    coordinates[8][0] = x[2][0];
    coordinates[8][1] = x[2][1];
    coordinates[9][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[9][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[10][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[10][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[11][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[11][1] = 0.5*x[0][1] + 0.5*x[1][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_8();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_8();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_11();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_12: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_12() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_12()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return false;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = m.num_entities[0];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 3;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 3;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 2;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 1;
        break;
      }
    case 1:
      {
        return 0;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    dofs[0] = c.entity_indices[0][0];
    dofs[1] = c.entity_indices[0][1];
    dofs[2] = c.entity_indices[0][2];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 0;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_12();
  }

};

/// This class defines the interface for a local-to-global mapping of
/// degrees of freedom (dofs).

class adaptivenavierstokes_dofmap_13: public ufc::dofmap
{
private:

  unsigned int _global_dimension;
public:

  /// Constructor
  adaptivenavierstokes_dofmap_13() : ufc::dofmap()
  {
    _global_dimension = 0;
  }

  /// Destructor
  virtual ~adaptivenavierstokes_dofmap_13()
  {
    // Do nothing
  }

  /// Return a string identifying the dofmap
  virtual const char* signature() const
  {
    return "FFC dofmap for MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) })";
  }

  /// Return true iff mesh entities of topological dimension d are needed
  virtual bool needs_mesh_entities(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return true;
        break;
      }
    case 1:
      {
        return true;
        break;
      }
    case 2:
      {
        return false;
        break;
      }
    }
    
    return false;
  }

  /// Initialize dofmap for mesh (return true iff init_cell() is needed)
  virtual bool init_mesh(const ufc::mesh& m)
  {
    _global_dimension = 3*m.num_entities[0] + 2*m.num_entities[1];
    return false;
  }

  /// Initialize dofmap for given cell
  virtual void init_cell(const ufc::mesh& m,
                         const ufc::cell& c)
  {
    // Do nothing
  }

  /// Finish initialization of dofmap for cells
  virtual void init_cell_finalize()
  {
    // Do nothing
  }

  /// Return the topological dimension of the associated cell shape
  virtual unsigned int topological_dimension() const
  {
    return 2;
  }

  /// Return the geometric dimension of the associated cell shape
  virtual unsigned int geometric_dimension() const
  {
    return 2;
  }

  /// Return the dimension of the global finite element function space
  virtual unsigned int global_dimension() const
  {
    return _global_dimension;
  }

  /// Return the dimension of the local finite element function space for a cell
  virtual unsigned int local_dimension(const ufc::cell& c) const
  {
    return 15;
  }

  /// Return the maximum dimension of the local finite element function space
  virtual unsigned int max_local_dimension() const
  {
    return 15;
  }

  /// Return the number of dofs on each cell facet
  virtual unsigned int num_facet_dofs() const
  {
    return 8;
  }

  /// Return the number of dofs associated with each cell entity of dimension d
  virtual unsigned int num_entity_dofs(unsigned int d) const
  {
    switch (d)
    {
    case 0:
      {
        return 3;
        break;
      }
    case 1:
      {
        return 2;
        break;
      }
    case 2:
      {
        return 0;
        break;
      }
    }
    
    return 0;
  }

  /// Tabulate the local-to-global mapping of dofs on a cell
  virtual void tabulate_dofs(unsigned int* dofs,
                             const ufc::mesh& m,
                             const ufc::cell& c) const
  {
    unsigned int offset = 0;
    dofs[0] = offset + c.entity_indices[0][0];
    dofs[1] = offset + c.entity_indices[0][1];
    dofs[2] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[3] = offset + c.entity_indices[1][0];
    dofs[4] = offset + c.entity_indices[1][1];
    dofs[5] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
    dofs[6] = offset + c.entity_indices[0][0];
    dofs[7] = offset + c.entity_indices[0][1];
    dofs[8] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
    dofs[9] = offset + c.entity_indices[1][0];
    dofs[10] = offset + c.entity_indices[1][1];
    dofs[11] = offset + c.entity_indices[1][2];
    offset += m.num_entities[1];
    dofs[12] = offset + c.entity_indices[0][0];
    dofs[13] = offset + c.entity_indices[0][1];
    dofs[14] = offset + c.entity_indices[0][2];
    offset += m.num_entities[0];
  }

  /// Tabulate the local-to-local mapping from facet dofs to cell dofs
  virtual void tabulate_facet_dofs(unsigned int* dofs,
                                   unsigned int facet) const
  {
    switch (facet)
    {
    case 0:
      {
        dofs[0] = 1;
      dofs[1] = 2;
      dofs[2] = 3;
      dofs[3] = 7;
      dofs[4] = 8;
      dofs[5] = 9;
      dofs[6] = 13;
      dofs[7] = 14;
        break;
      }
    case 1:
      {
        dofs[0] = 0;
      dofs[1] = 2;
      dofs[2] = 4;
      dofs[3] = 6;
      dofs[4] = 8;
      dofs[5] = 10;
      dofs[6] = 12;
      dofs[7] = 14;
        break;
      }
    case 2:
      {
        dofs[0] = 0;
      dofs[1] = 1;
      dofs[2] = 5;
      dofs[3] = 6;
      dofs[4] = 7;
      dofs[5] = 11;
      dofs[6] = 12;
      dofs[7] = 13;
        break;
      }
    }
    
  }

  /// Tabulate the local-to-local mapping of dofs on entity (d, i)
  virtual void tabulate_entity_dofs(unsigned int* dofs,
                                    unsigned int d, unsigned int i) const
  {
    if (d > 2)
    {
    throw std::runtime_error("d is larger than dimension (2)");
    }
    
    switch (d)
    {
    case 0:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 0;
        dofs[1] = 6;
        dofs[2] = 12;
          break;
        }
      case 1:
        {
          dofs[0] = 1;
        dofs[1] = 7;
        dofs[2] = 13;
          break;
        }
      case 2:
        {
          dofs[0] = 2;
        dofs[1] = 8;
        dofs[2] = 14;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        if (i > 2)
      {
      throw std::runtime_error("i is larger than number of entities (2)");
      }
      
      switch (i)
      {
      case 0:
        {
          dofs[0] = 3;
        dofs[1] = 9;
          break;
        }
      case 1:
        {
          dofs[0] = 4;
        dofs[1] = 10;
          break;
        }
      case 2:
        {
          dofs[0] = 5;
        dofs[1] = 11;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        
        break;
      }
    }
    
  }

  /// Tabulate the coordinates of all dofs on a cell
  virtual void tabulate_coordinates(double** coordinates,
                                    const ufc::cell& c) const
  {
    const double * const * x = c.coordinates;
    
    coordinates[0][0] = x[0][0];
    coordinates[0][1] = x[0][1];
    coordinates[1][0] = x[1][0];
    coordinates[1][1] = x[1][1];
    coordinates[2][0] = x[2][0];
    coordinates[2][1] = x[2][1];
    coordinates[3][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[3][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[4][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[4][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[5][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[5][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[6][0] = x[0][0];
    coordinates[6][1] = x[0][1];
    coordinates[7][0] = x[1][0];
    coordinates[7][1] = x[1][1];
    coordinates[8][0] = x[2][0];
    coordinates[8][1] = x[2][1];
    coordinates[9][0] = 0.5*x[1][0] + 0.5*x[2][0];
    coordinates[9][1] = 0.5*x[1][1] + 0.5*x[2][1];
    coordinates[10][0] = 0.5*x[0][0] + 0.5*x[2][0];
    coordinates[10][1] = 0.5*x[0][1] + 0.5*x[2][1];
    coordinates[11][0] = 0.5*x[0][0] + 0.5*x[1][0];
    coordinates[11][1] = 0.5*x[0][1] + 0.5*x[1][1];
    coordinates[12][0] = x[0][0];
    coordinates[12][1] = x[0][1];
    coordinates[13][0] = x[1][0];
    coordinates[13][1] = x[1][1];
    coordinates[14][0] = x[2][0];
    coordinates[14][1] = x[2][1];
  }

  /// Return the number of sub dofmaps (for a mixed element)
  virtual unsigned int num_sub_dofmaps() const
  {
    return 2;
  }

  /// Create a new dofmap for sub dofmap i (for a mixed element)
  virtual ufc::dofmap* create_sub_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_11();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new class instance
  virtual ufc::dofmap* create() const
  {
    return new adaptivenavierstokes_dofmap_13();
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_0_0: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_0_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_0_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      11
    // Number of operations (multiply-add pairs) for geometry tensor:    172
    // Number of operations (multiply-add pairs) for tensor contraction: 2992
    // Total number of operations (multiply-add pairs):                  3175
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0 = det*K_00*(1.0);
    const double G0_1 = det*K_10*(1.0);
    const double G1_0 = det*K_01*(1.0);
    const double G1_1 = det*K_11*(1.0);
    const double G2_0_0_0 = det*w[1][0]*K_00*K_00*(1.0);
    const double G2_0_0_1 = det*w[1][0]*K_00*K_10*(1.0);
    const double G2_0_1_0 = det*w[1][0]*K_10*K_00*(1.0);
    const double G2_0_1_1 = det*w[1][0]*K_10*K_10*(1.0);
    const double G3_0_0_0 = det*w[1][0]*K_00*K_00*(1.0);
    const double G3_0_0_1 = det*w[1][0]*K_00*K_10*(1.0);
    const double G3_0_1_0 = det*w[1][0]*K_10*K_00*(1.0);
    const double G3_0_1_1 = det*w[1][0]*K_10*K_10*(1.0);
    const double G4_0_0_0 = det*w[1][0]*K_01*K_01*(1.0);
    const double G4_0_0_1 = det*w[1][0]*K_01*K_11*(1.0);
    const double G4_0_1_0 = det*w[1][0]*K_11*K_01*(1.0);
    const double G4_0_1_1 = det*w[1][0]*K_11*K_11*(1.0);
    const double G5_0_0_0 = det*w[1][0]*K_01*K_01*(1.0);
    const double G5_0_0_1 = det*w[1][0]*K_01*K_11*(1.0);
    const double G5_0_1_0 = det*w[1][0]*K_11*K_01*(1.0);
    const double G5_0_1_1 = det*w[1][0]*K_11*K_11*(1.0);
    const double G6_0 = det*K_00*(1.0);
    const double G6_1 = det*K_10*(1.0);
    const double G7_0 = det*K_01*(1.0);
    const double G7_1 = det*K_11*(1.0);
    const double G8_0_0 = det*w[0][0]*K_00*(1.0);
    const double G8_0_1 = det*w[0][0]*K_10*(1.0);
    const double G8_1_0 = det*w[0][1]*K_00*(1.0);
    const double G8_2_1 = det*w[0][2]*K_10*(1.0);
    const double G8_3_0 = det*w[0][3]*K_00*(1.0);
    const double G8_3_1 = det*w[0][3]*K_10*(1.0);
    const double G8_4_0 = det*w[0][4]*K_00*(1.0);
    const double G8_4_1 = det*w[0][4]*K_10*(1.0);
    const double G8_5_0 = det*w[0][5]*K_00*(1.0);
    const double G8_5_1 = det*w[0][5]*K_10*(1.0);
    const double G9_0_0 = det*w[0][0]*K_00*(1.0);
    const double G9_0_1 = det*w[0][0]*K_10*(1.0);
    const double G9_1_0 = det*w[0][1]*K_00*(1.0);
    const double G9_1_1 = det*w[0][1]*K_10*(1.0);
    const double G9_2_0 = det*w[0][2]*K_00*(1.0);
    const double G9_2_1 = det*w[0][2]*K_10*(1.0);
    const double G9_3_0 = det*w[0][3]*K_00*(1.0);
    const double G9_3_1 = det*w[0][3]*K_10*(1.0);
    const double G9_4_0 = det*w[0][4]*K_00*(1.0);
    const double G9_4_1 = det*w[0][4]*K_10*(1.0);
    const double G9_5_0 = det*w[0][5]*K_00*(1.0);
    const double G9_5_1 = det*w[0][5]*K_10*(1.0);
    const double G10_0_0 = det*w[0][0]*K_01*(1.0);
    const double G10_0_1 = det*w[0][0]*K_11*(1.0);
    const double G10_1_0 = det*w[0][1]*K_01*(1.0);
    const double G10_2_1 = det*w[0][2]*K_11*(1.0);
    const double G10_3_0 = det*w[0][3]*K_01*(1.0);
    const double G10_3_1 = det*w[0][3]*K_11*(1.0);
    const double G10_4_0 = det*w[0][4]*K_01*(1.0);
    const double G10_4_1 = det*w[0][4]*K_11*(1.0);
    const double G10_5_0 = det*w[0][5]*K_01*(1.0);
    const double G10_5_1 = det*w[0][5]*K_11*(1.0);
    const double G11_6_0 = det*w[0][6]*K_01*(1.0);
    const double G11_6_1 = det*w[0][6]*K_11*(1.0);
    const double G11_7_0 = det*w[0][7]*K_01*(1.0);
    const double G11_7_1 = det*w[0][7]*K_11*(1.0);
    const double G11_8_0 = det*w[0][8]*K_01*(1.0);
    const double G11_8_1 = det*w[0][8]*K_11*(1.0);
    const double G11_9_0 = det*w[0][9]*K_01*(1.0);
    const double G11_9_1 = det*w[0][9]*K_11*(1.0);
    const double G11_10_0 = det*w[0][10]*K_01*(1.0);
    const double G11_10_1 = det*w[0][10]*K_11*(1.0);
    const double G11_11_0 = det*w[0][11]*K_01*(1.0);
    const double G11_11_1 = det*w[0][11]*K_11*(1.0);
    const double G12_6_0 = det*w[0][6]*K_00*(1.0);
    const double G12_6_1 = det*w[0][6]*K_10*(1.0);
    const double G12_7_0 = det*w[0][7]*K_00*(1.0);
    const double G12_8_1 = det*w[0][8]*K_10*(1.0);
    const double G12_9_0 = det*w[0][9]*K_00*(1.0);
    const double G12_9_1 = det*w[0][9]*K_10*(1.0);
    const double G12_10_0 = det*w[0][10]*K_00*(1.0);
    const double G12_10_1 = det*w[0][10]*K_10*(1.0);
    const double G12_11_0 = det*w[0][11]*K_00*(1.0);
    const double G12_11_1 = det*w[0][11]*K_10*(1.0);
    const double G13_0_0 = det*w[0][0]*K_00*(1.0);
    const double G13_0_1 = det*w[0][0]*K_10*(1.0);
    const double G13_1_0 = det*w[0][1]*K_00*(1.0);
    const double G13_1_1 = det*w[0][1]*K_10*(1.0);
    const double G13_2_0 = det*w[0][2]*K_00*(1.0);
    const double G13_2_1 = det*w[0][2]*K_10*(1.0);
    const double G13_3_0 = det*w[0][3]*K_00*(1.0);
    const double G13_3_1 = det*w[0][3]*K_10*(1.0);
    const double G13_4_0 = det*w[0][4]*K_00*(1.0);
    const double G13_4_1 = det*w[0][4]*K_10*(1.0);
    const double G13_5_0 = det*w[0][5]*K_00*(1.0);
    const double G13_5_1 = det*w[0][5]*K_10*(1.0);
    const double G14_6_0 = det*w[0][6]*K_01*(1.0);
    const double G14_6_1 = det*w[0][6]*K_11*(1.0);
    const double G14_7_0 = det*w[0][7]*K_01*(1.0);
    const double G14_8_1 = det*w[0][8]*K_11*(1.0);
    const double G14_9_0 = det*w[0][9]*K_01*(1.0);
    const double G14_9_1 = det*w[0][9]*K_11*(1.0);
    const double G14_10_0 = det*w[0][10]*K_01*(1.0);
    const double G14_10_1 = det*w[0][10]*K_11*(1.0);
    const double G14_11_0 = det*w[0][11]*K_01*(1.0);
    const double G14_11_1 = det*w[0][11]*K_11*(1.0);
    const double G15_6_0 = det*w[0][6]*K_01*(1.0);
    const double G15_6_1 = det*w[0][6]*K_11*(1.0);
    const double G15_7_0 = det*w[0][7]*K_01*(1.0);
    const double G15_7_1 = det*w[0][7]*K_11*(1.0);
    const double G15_8_0 = det*w[0][8]*K_01*(1.0);
    const double G15_8_1 = det*w[0][8]*K_11*(1.0);
    const double G15_9_0 = det*w[0][9]*K_01*(1.0);
    const double G15_9_1 = det*w[0][9]*K_11*(1.0);
    const double G15_10_0 = det*w[0][10]*K_01*(1.0);
    const double G15_10_1 = det*w[0][10]*K_11*(1.0);
    const double G15_11_0 = det*w[0][11]*K_01*(1.0);
    const double G15_11_1 = det*w[0][11]*K_11*(1.0);
    
    // Compute element tensor
    A[0] = 0.5*G2_0_0_0 + 0.5*G2_0_0_1 + 0.5*G2_0_1_0 + 0.5*G2_0_1_1 + 0.5*G4_0_0_0 + 0.5*G4_0_0_1 + 0.5*G4_0_1_0 + 0.5*G4_0_1_1 - 0.030952380952381*G8_0_0 - 0.0309523809523809*G8_0_1 - 0.00714285714285714*G8_1_0 - 0.00714285714285714*G8_2_1 + 0.00952380952380952*G8_3_0 + 0.00952380952380952*G8_3_1 - 0.00952380952380952*G8_4_0 + 0.0380952380952381*G8_4_1 + 0.0380952380952381*G8_5_0 - 0.00952380952380953*G8_5_1 - 0.030952380952381*G9_0_0 - 0.0309523809523809*G9_0_1 + 0.00357142857142857*G9_1_0 + 0.00357142857142857*G9_1_1 + 0.00357142857142857*G9_2_0 + 0.00357142857142857*G9_2_1 - 0.00476190476190477*G9_3_0 - 0.00476190476190477*G9_3_1 - 0.0190476190476191*G9_4_0 - 0.0190476190476191*G9_4_1 - 0.019047619047619*G9_5_0 - 0.019047619047619*G9_5_1 - 0.030952380952381*G11_6_0 - 0.0309523809523809*G11_6_1 + 0.00357142857142857*G11_7_0 + 0.00357142857142857*G11_7_1 + 0.00357142857142857*G11_8_0 + 0.00357142857142857*G11_8_1 - 0.00476190476190477*G11_9_0 - 0.00476190476190477*G11_9_1 - 0.0190476190476191*G11_10_0 - 0.0190476190476191*G11_10_1 - 0.019047619047619*G11_11_0 - 0.019047619047619*G11_11_1;
    A[1] = 0.166666666666667*G2_0_0_0 + 0.166666666666667*G2_0_1_0 + 0.166666666666667*G4_0_0_0 + 0.166666666666667*G4_0_1_0 + 0.00357142857142857*G8_0_0 + 0.00357142857142857*G8_0_1 - 0.00357142857142857*G8_1_0 + 0.00436507936507937*G8_2_1 + 0.00158730158730159*G8_3_0 - 0.00634920634920635*G8_3_1 - 0.00158730158730159*G8_4_0 - 0.00793650793650794*G8_4_1 + 0.00634920634920635*G8_5_1 + 0.00357142857142857*G9_0_0 + 0.00357142857142857*G9_0_1 + 0.00714285714285713*G9_1_0 + 0.00714285714285714*G9_1_1 - 0.00436507936507936*G9_2_0 - 0.00436507936507936*G9_2_1 + 0.00634920634920635*G9_3_0 + 0.00634920634920635*G9_3_1 + 0.00793650793650794*G9_4_0 + 0.00793650793650794*G9_4_1 + 0.0126984126984127*G9_5_0 + 0.0126984126984127*G9_5_1 + 0.00357142857142857*G11_6_0 + 0.00357142857142857*G11_6_1 + 0.00714285714285713*G11_7_0 + 0.00714285714285714*G11_7_1 - 0.00436507936507936*G11_8_0 - 0.00436507936507936*G11_8_1 + 0.00634920634920635*G11_9_0 + 0.00634920634920635*G11_9_1 + 0.00793650793650794*G11_10_0 + 0.00793650793650794*G11_10_1 + 0.0126984126984127*G11_11_0 + 0.0126984126984127*G11_11_1;
    A[2] = 0.166666666666667*G2_0_0_1 + 0.166666666666667*G2_0_1_1 + 0.166666666666667*G4_0_0_1 + 0.166666666666667*G4_0_1_1 + 0.00357142857142857*G8_0_0 + 0.00357142857142857*G8_0_1 + 0.00436507936507937*G8_1_0 - 0.00357142857142857*G8_2_1 - 0.00634920634920634*G8_3_0 + 0.00158730158730159*G8_3_1 + 0.00634920634920634*G8_4_0 - 0.00793650793650794*G8_5_0 - 0.00158730158730159*G8_5_1 + 0.00357142857142857*G9_0_0 + 0.00357142857142857*G9_0_1 - 0.00436507936507936*G9_1_0 - 0.00436507936507936*G9_1_1 + 0.00714285714285713*G9_2_0 + 0.00714285714285712*G9_2_1 + 0.00634920634920634*G9_3_0 + 0.00634920634920634*G9_3_1 + 0.0126984126984127*G9_4_0 + 0.0126984126984127*G9_4_1 + 0.00793650793650794*G9_5_0 + 0.00793650793650794*G9_5_1 + 0.00357142857142857*G11_6_0 + 0.00357142857142857*G11_6_1 - 0.00436507936507936*G11_7_0 - 0.00436507936507936*G11_7_1 + 0.00714285714285713*G11_8_0 + 0.00714285714285712*G11_8_1 + 0.00634920634920634*G11_9_0 + 0.00634920634920634*G11_9_1 + 0.0126984126984127*G11_10_0 + 0.0126984126984127*G11_10_1 + 0.00793650793650794*G11_11_0 + 0.00793650793650794*G11_11_1;
    A[3] = -0.00476190476190477*G8_0_0 - 0.00476190476190477*G8_0_1 - 0.00793650793650794*G8_1_0 - 0.00793650793650794*G8_2_1 - 0.019047619047619*G8_3_0 - 0.019047619047619*G8_3_1 + 0.0190476190476191*G8_4_0 + 0.0126984126984127*G8_4_1 + 0.0126984126984127*G8_5_0 + 0.0190476190476191*G8_5_1 - 0.00476190476190477*G9_0_0 - 0.00476190476190477*G9_0_1 + 0.00634920634920635*G9_1_0 + 0.00634920634920635*G9_1_1 + 0.00634920634920635*G9_2_0 + 0.00634920634920634*G9_2_1 + 0.0380952380952381*G9_3_0 + 0.0380952380952381*G9_3_1 - 0.00634920634920635*G9_4_0 - 0.00634920634920636*G9_4_1 - 0.00634920634920635*G9_5_0 - 0.00634920634920635*G9_5_1 - 0.00476190476190477*G11_6_0 - 0.00476190476190477*G11_6_1 + 0.00634920634920635*G11_7_0 + 0.00634920634920635*G11_7_1 + 0.00634920634920635*G11_8_0 + 0.00634920634920634*G11_8_1 + 0.0380952380952381*G11_9_0 + 0.0380952380952381*G11_9_1 - 0.00634920634920635*G11_10_0 - 0.00634920634920636*G11_10_1 - 0.00634920634920635*G11_11_0 - 0.00634920634920635*G11_11_1;
    A[4] = -0.666666666666667*G2_0_0_1 - 0.666666666666667*G2_0_1_1 - 0.666666666666667*G4_0_0_1 - 0.666666666666667*G4_0_1_1 - 0.0190476190476191*G8_0_0 - 0.0190476190476191*G8_0_1 - 0.00634920634920635*G8_1_0 - 0.0126984126984127*G8_2_1 - 0.0126984126984127*G8_3_0 - 0.00634920634920635*G8_3_1 + 0.0126984126984127*G8_4_0 + 0.0317460317460318*G8_4_1 + 0.0253968253968254*G8_5_0 + 0.00634920634920635*G8_5_1 - 0.0190476190476191*G9_0_0 - 0.0190476190476191*G9_0_1 + 0.00793650793650794*G9_1_0 + 0.00793650793650794*G9_1_1 + 0.0126984126984127*G9_2_0 + 0.0126984126984127*G9_2_1 - 0.00634920634920635*G9_3_0 - 0.00634920634920636*G9_3_1 - 0.0634920634920635*G9_4_0 - 0.0634920634920635*G9_4_1 - 0.0317460317460317*G9_5_0 - 0.0317460317460317*G9_5_1 - 0.0190476190476191*G11_6_0 - 0.0190476190476191*G11_6_1 + 0.00793650793650794*G11_7_0 + 0.00793650793650794*G11_7_1 + 0.0126984126984127*G11_8_0 + 0.0126984126984127*G11_8_1 - 0.00634920634920635*G11_9_0 - 0.00634920634920636*G11_9_1 - 0.0634920634920635*G11_10_0 - 0.0634920634920635*G11_10_1 - 0.0317460317460317*G11_11_0 - 0.0317460317460317*G11_11_1;
    A[5] = -0.666666666666667*G2_0_0_0 - 0.666666666666667*G2_0_1_0 - 0.666666666666667*G4_0_0_0 - 0.666666666666667*G4_0_1_0 - 0.019047619047619*G8_0_0 - 0.019047619047619*G8_0_1 - 0.0126984126984127*G8_1_0 - 0.00634920634920635*G8_2_1 - 0.00634920634920636*G8_3_0 - 0.0126984126984127*G8_3_1 + 0.00634920634920636*G8_4_0 + 0.0253968253968254*G8_4_1 + 0.0317460317460318*G8_5_0 + 0.0126984126984127*G8_5_1 - 0.019047619047619*G9_0_0 - 0.019047619047619*G9_0_1 + 0.0126984126984127*G9_1_0 + 0.0126984126984127*G9_1_1 + 0.00793650793650794*G9_2_0 + 0.00793650793650794*G9_2_1 - 0.00634920634920635*G9_3_0 - 0.00634920634920635*G9_3_1 - 0.0317460317460317*G9_4_0 - 0.0317460317460317*G9_4_1 - 0.0634920634920635*G9_5_0 - 0.0634920634920635*G9_5_1 - 0.019047619047619*G11_6_0 - 0.019047619047619*G11_6_1 + 0.0126984126984127*G11_7_0 + 0.0126984126984127*G11_7_1 + 0.00793650793650794*G11_8_0 + 0.00793650793650794*G11_8_1 - 0.00634920634920635*G11_9_0 - 0.00634920634920635*G11_9_1 - 0.0317460317460317*G11_10_0 - 0.0317460317460317*G11_10_1 - 0.0634920634920635*G11_11_0 - 0.0634920634920635*G11_11_1;
    A[6] = -0.030952380952381*G12_6_0 - 0.0309523809523809*G12_6_1 - 0.00714285714285714*G12_7_0 - 0.00714285714285714*G12_8_1 + 0.00952380952380952*G12_9_0 + 0.00952380952380952*G12_9_1 - 0.00952380952380952*G12_10_0 + 0.0380952380952381*G12_10_1 + 0.0380952380952381*G12_11_0 - 0.00952380952380953*G12_11_1;
    A[7] = 0.00357142857142857*G12_6_0 + 0.00357142857142857*G12_6_1 - 0.00357142857142857*G12_7_0 + 0.00436507936507937*G12_8_1 + 0.00158730158730159*G12_9_0 - 0.00634920634920635*G12_9_1 - 0.00158730158730159*G12_10_0 - 0.00793650793650794*G12_10_1 + 0.00634920634920635*G12_11_1;
    A[8] = 0.00357142857142857*G12_6_0 + 0.00357142857142857*G12_6_1 + 0.00436507936507937*G12_7_0 - 0.00357142857142857*G12_8_1 - 0.00634920634920634*G12_9_0 + 0.00158730158730159*G12_9_1 + 0.00634920634920634*G12_10_0 - 0.00793650793650794*G12_11_0 - 0.00158730158730159*G12_11_1;
    A[9] = -0.00476190476190477*G12_6_0 - 0.00476190476190477*G12_6_1 - 0.00793650793650794*G12_7_0 - 0.00793650793650794*G12_8_1 - 0.019047619047619*G12_9_0 - 0.019047619047619*G12_9_1 + 0.0190476190476191*G12_10_0 + 0.0126984126984127*G12_10_1 + 0.0126984126984127*G12_11_0 + 0.0190476190476191*G12_11_1;
    A[10] = -0.0190476190476191*G12_6_0 - 0.0190476190476191*G12_6_1 - 0.00634920634920635*G12_7_0 - 0.0126984126984127*G12_8_1 - 0.0126984126984127*G12_9_0 - 0.00634920634920635*G12_9_1 + 0.0126984126984127*G12_10_0 + 0.0317460317460318*G12_10_1 + 0.0253968253968254*G12_11_0 + 0.00634920634920635*G12_11_1;
    A[11] = -0.019047619047619*G12_6_0 - 0.019047619047619*G12_6_1 - 0.0126984126984127*G12_7_0 - 0.00634920634920635*G12_8_1 - 0.00634920634920636*G12_9_0 - 0.0126984126984127*G12_9_1 + 0.00634920634920636*G12_10_0 + 0.0253968253968254*G12_10_1 + 0.0317460317460318*G12_11_0 + 0.0126984126984127*G12_11_1;
    A[12] = -0.166666666666667*G0_0 - 0.166666666666667*G0_1;
    A[13] = 0.0;
    A[14] = 0.0;
    A[15] = 0.166666666666667*G2_0_0_0 + 0.166666666666667*G2_0_0_1 + 0.166666666666667*G4_0_0_0 + 0.166666666666667*G4_0_0_1 + 0.00357142857142857*G8_0_0 + 0.00357142857142857*G8_0_1 - 0.00357142857142857*G8_1_0 + 0.00436507936507937*G8_2_1 + 0.00158730158730159*G8_3_0 - 0.00634920634920635*G8_3_1 - 0.00158730158730159*G8_4_0 - 0.00793650793650794*G8_4_1 + 0.00634920634920635*G8_5_1 - 0.00714285714285714*G9_0_0 - 0.00357142857142857*G9_1_0 + 0.00436507936507937*G9_2_0 - 0.00793650793650794*G9_3_0 - 0.00634920634920635*G9_4_0 - 0.0126984126984127*G9_5_0 - 0.00714285714285714*G11_6_0 - 0.00357142857142857*G11_7_0 + 0.00436507936507937*G11_8_0 - 0.00793650793650794*G11_9_0 - 0.00634920634920635*G11_10_0 - 0.0126984126984127*G11_11_0;
    A[16] = 0.5*G2_0_0_0 + 0.5*G4_0_0_0 + 0.00714285714285713*G8_0_0 + 0.00714285714285714*G8_0_1 + 0.0309523809523809*G8_1_0 - 0.00714285714285713*G8_2_1 + 0.00952380952380951*G8_3_0 + 0.0476190476190476*G8_3_1 - 0.00952380952380952*G8_4_0 - 0.0380952380952381*G8_5_0 - 0.0476190476190476*G8_5_1 - 0.00357142857142857*G9_0_0 + 0.0309523809523809*G9_1_0 - 0.00357142857142857*G9_2_0 + 0.019047619047619*G9_3_0 + 0.00476190476190476*G9_4_0 + 0.0190476190476191*G9_5_0 - 0.00357142857142857*G11_6_0 + 0.0309523809523809*G11_7_0 - 0.00357142857142857*G11_8_0 + 0.019047619047619*G11_9_0 + 0.00476190476190476*G11_10_0 + 0.0190476190476191*G11_11_0;
    A[17] = -0.166666666666667*G2_0_0_1 - 0.166666666666667*G4_0_0_1 - 0.00436507936507936*G8_0_0 - 0.00436507936507936*G8_0_1 - 0.00357142857142857*G8_1_0 - 0.00357142857142857*G8_2_1 - 0.00634920634920634*G8_3_0 - 0.00634920634920634*G8_3_1 + 0.00634920634920634*G8_4_0 + 0.00793650793650793*G8_4_1 + 0.00793650793650793*G8_5_0 + 0.00634920634920634*G8_5_1 + 0.00436507936507937*G9_0_0 - 0.00357142857142857*G9_1_0 - 0.00714285714285714*G9_2_0 - 0.0126984126984127*G9_3_0 - 0.00634920634920635*G9_4_0 - 0.00793650793650794*G9_5_0 + 0.00436507936507937*G11_6_0 - 0.00357142857142857*G11_7_0 - 0.00714285714285714*G11_8_0 - 0.0126984126984127*G11_9_0 - 0.00634920634920635*G11_10_0 - 0.00793650793650794*G11_11_0;
    A[18] = 0.666666666666666*G2_0_0_1 + 0.666666666666666*G4_0_0_1 + 0.00634920634920635*G8_0_0 + 0.00634920634920635*G8_0_1 + 0.019047619047619*G8_1_0 - 0.0126984126984127*G8_2_1 - 0.0126984126984127*G8_3_0 + 0.019047619047619*G8_3_1 + 0.0126984126984127*G8_4_0 + 0.00634920634920635*G8_4_1 - 0.0253968253968254*G8_5_0 - 0.019047619047619*G8_5_1 - 0.00793650793650794*G9_0_0 + 0.019047619047619*G9_1_0 - 0.0126984126984127*G9_2_0 + 0.0634920634920634*G9_3_0 + 0.00634920634920634*G9_4_0 + 0.0317460317460318*G9_5_0 - 0.00793650793650794*G11_6_0 + 0.019047619047619*G11_7_0 - 0.0126984126984127*G11_8_0 + 0.0634920634920634*G11_9_0 + 0.00634920634920634*G11_10_0 + 0.0317460317460318*G11_11_0;
    A[19] = 0.00793650793650794*G8_0_0 + 0.00793650793650794*G8_0_1 + 0.00476190476190476*G8_1_0 - 0.00793650793650794*G8_2_1 - 0.019047619047619*G8_3_0 - 0.00634920634920635*G8_3_1 + 0.0190476190476191*G8_4_0 - 0.0126984126984127*G8_5_0 + 0.00634920634920635*G8_5_1 - 0.00634920634920635*G9_0_0 + 0.00476190476190476*G9_1_0 - 0.00634920634920635*G9_2_0 + 0.00634920634920634*G9_3_0 - 0.0380952380952381*G9_4_0 + 0.00634920634920634*G9_5_0 - 0.00634920634920635*G11_6_0 + 0.00476190476190476*G11_7_0 - 0.00634920634920635*G11_8_0 + 0.00634920634920634*G11_9_0 - 0.0380952380952381*G11_10_0 + 0.00634920634920634*G11_11_0;
    A[20] = -0.666666666666667*G2_0_0_0 - 0.666666666666667*G2_0_0_1 - 0.666666666666667*G4_0_0_0 - 0.666666666666667*G4_0_0_1 + 0.0126984126984127*G8_0_0 + 0.0126984126984127*G8_0_1 + 0.0190476190476191*G8_1_0 - 0.00634920634920635*G8_2_1 - 0.00634920634920636*G8_3_0 + 0.0190476190476191*G8_3_1 + 0.00634920634920636*G8_4_0 - 0.00634920634920634*G8_4_1 - 0.0317460317460318*G8_5_0 - 0.0190476190476191*G8_5_1 - 0.0126984126984127*G9_0_0 + 0.0190476190476191*G9_1_0 - 0.00793650793650794*G9_2_0 + 0.0317460317460318*G9_3_0 + 0.00634920634920634*G9_4_0 + 0.0634920634920635*G9_5_0 - 0.0126984126984127*G11_6_0 + 0.0190476190476191*G11_7_0 - 0.00793650793650794*G11_8_0 + 0.0317460317460318*G11_9_0 + 0.00634920634920634*G11_10_0 + 0.0634920634920635*G11_11_0;
    A[21] = 0.00357142857142857*G12_6_0 + 0.00357142857142857*G12_6_1 - 0.00357142857142857*G12_7_0 + 0.00436507936507937*G12_8_1 + 0.00158730158730159*G12_9_0 - 0.00634920634920635*G12_9_1 - 0.00158730158730159*G12_10_0 - 0.00793650793650794*G12_10_1 + 0.00634920634920635*G12_11_1;
    A[22] = 0.00714285714285713*G12_6_0 + 0.00714285714285714*G12_6_1 + 0.0309523809523809*G12_7_0 - 0.00714285714285713*G12_8_1 + 0.00952380952380951*G12_9_0 + 0.0476190476190476*G12_9_1 - 0.00952380952380952*G12_10_0 - 0.0380952380952381*G12_11_0 - 0.0476190476190476*G12_11_1;
    A[23] = -0.00436507936507936*G12_6_0 - 0.00436507936507936*G12_6_1 - 0.00357142857142857*G12_7_0 - 0.00357142857142857*G12_8_1 - 0.00634920634920634*G12_9_0 - 0.00634920634920634*G12_9_1 + 0.00634920634920634*G12_10_0 + 0.00793650793650793*G12_10_1 + 0.00793650793650793*G12_11_0 + 0.00634920634920634*G12_11_1;
    A[24] = 0.00634920634920635*G12_6_0 + 0.00634920634920635*G12_6_1 + 0.019047619047619*G12_7_0 - 0.0126984126984127*G12_8_1 - 0.0126984126984127*G12_9_0 + 0.019047619047619*G12_9_1 + 0.0126984126984127*G12_10_0 + 0.00634920634920635*G12_10_1 - 0.0253968253968254*G12_11_0 - 0.019047619047619*G12_11_1;
    A[25] = 0.00793650793650794*G12_6_0 + 0.00793650793650794*G12_6_1 + 0.00476190476190476*G12_7_0 - 0.00793650793650794*G12_8_1 - 0.019047619047619*G12_9_0 - 0.00634920634920635*G12_9_1 + 0.0190476190476191*G12_10_0 - 0.0126984126984127*G12_11_0 + 0.00634920634920635*G12_11_1;
    A[26] = 0.0126984126984127*G12_6_0 + 0.0126984126984127*G12_6_1 + 0.0190476190476191*G12_7_0 - 0.00634920634920635*G12_8_1 - 0.00634920634920636*G12_9_0 + 0.0190476190476191*G12_9_1 + 0.00634920634920636*G12_10_0 - 0.00634920634920634*G12_10_1 - 0.0317460317460318*G12_11_0 - 0.0190476190476191*G12_11_1;
    A[27] = 0.0;
    A[28] = 0.166666666666667*G0_0;
    A[29] = 0.0;
    A[30] = 0.166666666666667*G2_0_1_0 + 0.166666666666667*G2_0_1_1 + 0.166666666666667*G4_0_1_0 + 0.166666666666667*G4_0_1_1 + 0.00357142857142857*G8_0_0 + 0.00357142857142857*G8_0_1 + 0.00436507936507937*G8_1_0 - 0.00357142857142857*G8_2_1 - 0.00634920634920634*G8_3_0 + 0.00158730158730159*G8_3_1 + 0.00634920634920634*G8_4_0 - 0.00793650793650794*G8_5_0 - 0.00158730158730159*G8_5_1 - 0.00714285714285714*G9_0_1 + 0.00436507936507937*G9_1_1 - 0.00357142857142857*G9_2_1 - 0.00793650793650794*G9_3_1 - 0.0126984126984127*G9_4_1 - 0.00634920634920635*G9_5_1 - 0.00714285714285714*G11_6_1 + 0.00436507936507937*G11_7_1 - 0.00357142857142857*G11_8_1 - 0.00793650793650794*G11_9_1 - 0.0126984126984127*G11_10_1 - 0.00634920634920635*G11_11_1;
    A[31] = -0.166666666666667*G2_0_1_0 - 0.166666666666667*G4_0_1_0 - 0.00436507936507936*G8_0_0 - 0.00436507936507936*G8_0_1 - 0.00357142857142857*G8_1_0 - 0.00357142857142857*G8_2_1 - 0.00634920634920634*G8_3_0 - 0.00634920634920634*G8_3_1 + 0.00634920634920634*G8_4_0 + 0.00793650793650793*G8_4_1 + 0.00793650793650793*G8_5_0 + 0.00634920634920634*G8_5_1 + 0.00436507936507937*G9_0_1 - 0.00714285714285713*G9_1_1 - 0.00357142857142857*G9_2_1 - 0.0126984126984127*G9_3_1 - 0.00793650793650794*G9_4_1 - 0.00634920634920635*G9_5_1 + 0.00436507936507937*G11_6_1 - 0.00714285714285713*G11_7_1 - 0.00357142857142857*G11_8_1 - 0.0126984126984127*G11_9_1 - 0.00793650793650794*G11_10_1 - 0.00634920634920635*G11_11_1;
    A[32] = 0.5*G2_0_1_1 + 0.5*G4_0_1_1 + 0.00714285714285713*G8_0_0 + 0.00714285714285712*G8_0_1 - 0.00714285714285714*G8_1_0 + 0.0309523809523809*G8_2_1 + 0.0476190476190475*G8_3_0 + 0.0095238095238095*G8_3_1 - 0.0476190476190476*G8_4_0 - 0.038095238095238*G8_4_1 - 0.00952380952380951*G8_5_1 - 0.00357142857142857*G9_0_1 - 0.00357142857142857*G9_1_1 + 0.0309523809523809*G9_2_1 + 0.019047619047619*G9_3_1 + 0.019047619047619*G9_4_1 + 0.00476190476190476*G9_5_1 - 0.00357142857142857*G11_6_1 - 0.00357142857142857*G11_7_1 + 0.0309523809523809*G11_8_1 + 0.019047619047619*G11_9_1 + 0.019047619047619*G11_10_1 + 0.00476190476190476*G11_11_1;
    A[33] = 0.666666666666666*G2_0_1_0 + 0.666666666666666*G4_0_1_0 + 0.00634920634920635*G8_0_0 + 0.00634920634920634*G8_0_1 - 0.0126984126984127*G8_1_0 + 0.019047619047619*G8_2_1 + 0.019047619047619*G8_3_0 - 0.0126984126984127*G8_3_1 - 0.019047619047619*G8_4_0 - 0.0253968253968254*G8_4_1 + 0.00634920634920635*G8_5_0 + 0.0126984126984127*G8_5_1 - 0.00793650793650794*G9_0_1 - 0.0126984126984127*G9_1_1 + 0.019047619047619*G9_2_1 + 0.0634920634920635*G9_3_1 + 0.0317460317460318*G9_4_1 + 0.00634920634920637*G9_5_1 - 0.00793650793650794*G11_6_1 - 0.0126984126984127*G11_7_1 + 0.019047619047619*G11_8_1 + 0.0634920634920635*G11_9_1 + 0.0317460317460318*G11_10_1 + 0.00634920634920637*G11_11_1;
    A[34] = -0.666666666666667*G2_0_1_0 - 0.666666666666667*G2_0_1_1 - 0.666666666666667*G4_0_1_0 - 0.666666666666667*G4_0_1_1 + 0.0126984126984127*G8_0_0 + 0.0126984126984127*G8_0_1 - 0.00634920634920635*G8_1_0 + 0.019047619047619*G8_2_1 + 0.019047619047619*G8_3_0 - 0.00634920634920636*G8_3_1 - 0.019047619047619*G8_4_0 - 0.0317460317460317*G8_4_1 - 0.00634920634920635*G8_5_0 + 0.00634920634920635*G8_5_1 - 0.0126984126984127*G9_0_1 - 0.00793650793650794*G9_1_1 + 0.019047619047619*G9_2_1 + 0.0317460317460318*G9_3_1 + 0.0634920634920635*G9_4_1 + 0.00634920634920636*G9_5_1 - 0.0126984126984127*G11_6_1 - 0.00793650793650794*G11_7_1 + 0.019047619047619*G11_8_1 + 0.0317460317460318*G11_9_1 + 0.0634920634920635*G11_10_1 + 0.00634920634920636*G11_11_1;
    A[35] = 0.00793650793650794*G8_0_0 + 0.00793650793650794*G8_0_1 - 0.00793650793650794*G8_1_0 + 0.00476190476190476*G8_2_1 - 0.00634920634920634*G8_3_0 - 0.019047619047619*G8_3_1 + 0.00634920634920635*G8_4_0 - 0.0126984126984127*G8_4_1 + 0.019047619047619*G8_5_1 - 0.00634920634920635*G9_0_1 - 0.00634920634920635*G9_1_1 + 0.00476190476190476*G9_2_1 + 0.00634920634920637*G9_3_1 + 0.00634920634920636*G9_4_1 - 0.0380952380952381*G9_5_1 - 0.00634920634920635*G11_6_1 - 0.00634920634920635*G11_7_1 + 0.00476190476190476*G11_8_1 + 0.00634920634920637*G11_9_1 + 0.00634920634920636*G11_10_1 - 0.0380952380952381*G11_11_1;
    A[36] = 0.00357142857142857*G12_6_0 + 0.00357142857142857*G12_6_1 + 0.00436507936507937*G12_7_0 - 0.00357142857142857*G12_8_1 - 0.00634920634920634*G12_9_0 + 0.00158730158730159*G12_9_1 + 0.00634920634920634*G12_10_0 - 0.00793650793650794*G12_11_0 - 0.00158730158730159*G12_11_1;
    A[37] = -0.00436507936507936*G12_6_0 - 0.00436507936507936*G12_6_1 - 0.00357142857142857*G12_7_0 - 0.00357142857142857*G12_8_1 - 0.00634920634920634*G12_9_0 - 0.00634920634920634*G12_9_1 + 0.00634920634920634*G12_10_0 + 0.00793650793650793*G12_10_1 + 0.00793650793650793*G12_11_0 + 0.00634920634920634*G12_11_1;
    A[38] = 0.00714285714285713*G12_6_0 + 0.00714285714285712*G12_6_1 - 0.00714285714285714*G12_7_0 + 0.0309523809523809*G12_8_1 + 0.0476190476190475*G12_9_0 + 0.0095238095238095*G12_9_1 - 0.0476190476190476*G12_10_0 - 0.038095238095238*G12_10_1 - 0.00952380952380951*G12_11_1;
    A[39] = 0.00634920634920635*G12_6_0 + 0.00634920634920634*G12_6_1 - 0.0126984126984127*G12_7_0 + 0.019047619047619*G12_8_1 + 0.019047619047619*G12_9_0 - 0.0126984126984127*G12_9_1 - 0.019047619047619*G12_10_0 - 0.0253968253968254*G12_10_1 + 0.00634920634920635*G12_11_0 + 0.0126984126984127*G12_11_1;
    A[40] = 0.0126984126984127*G12_6_0 + 0.0126984126984127*G12_6_1 - 0.00634920634920635*G12_7_0 + 0.019047619047619*G12_8_1 + 0.019047619047619*G12_9_0 - 0.00634920634920636*G12_9_1 - 0.019047619047619*G12_10_0 - 0.0317460317460317*G12_10_1 - 0.00634920634920635*G12_11_0 + 0.00634920634920635*G12_11_1;
    A[41] = 0.00793650793650794*G12_6_0 + 0.00793650793650794*G12_6_1 - 0.00793650793650794*G12_7_0 + 0.00476190476190476*G12_8_1 - 0.00634920634920634*G12_9_0 - 0.019047619047619*G12_9_1 + 0.00634920634920635*G12_10_0 - 0.0126984126984127*G12_10_1 + 0.019047619047619*G12_11_1;
    A[42] = 0.0;
    A[43] = 0.0;
    A[44] = 0.166666666666667*G0_1;
    A[45] = -0.00476190476190477*G8_0_0 - 0.00476190476190477*G8_0_1 - 0.00793650793650794*G8_1_0 - 0.00793650793650794*G8_2_1 - 0.019047619047619*G8_3_0 - 0.019047619047619*G8_3_1 + 0.0190476190476191*G8_4_0 + 0.0126984126984127*G8_4_1 + 0.0126984126984127*G8_5_0 + 0.0190476190476191*G8_5_1 + 0.00952380952380952*G9_0_0 + 0.00952380952380952*G9_0_1 + 0.00158730158730159*G9_1_0 - 0.00634920634920635*G9_1_1 - 0.00634920634920634*G9_2_0 + 0.00158730158730159*G9_2_1 - 0.019047619047619*G9_3_0 - 0.019047619047619*G9_3_1 - 0.0126984126984127*G9_4_0 - 0.00634920634920635*G9_4_1 - 0.00634920634920636*G9_5_0 - 0.0126984126984127*G9_5_1 + 0.00952380952380952*G11_6_0 + 0.00952380952380952*G11_6_1 + 0.00158730158730159*G11_7_0 - 0.00634920634920635*G11_7_1 - 0.00634920634920634*G11_8_0 + 0.00158730158730159*G11_8_1 - 0.019047619047619*G11_9_0 - 0.019047619047619*G11_9_1 - 0.0126984126984127*G11_10_0 - 0.00634920634920635*G11_10_1 - 0.00634920634920636*G11_11_0 - 0.0126984126984127*G11_11_1;
    A[46] = 0.666666666666666*G2_0_1_0 + 0.666666666666666*G4_0_1_0 + 0.00634920634920635*G8_0_0 + 0.00634920634920635*G8_0_1 + 0.019047619047619*G8_1_0 - 0.0126984126984127*G8_2_1 - 0.0126984126984127*G8_3_0 + 0.019047619047619*G8_3_1 + 0.0126984126984127*G8_4_0 + 0.00634920634920635*G8_4_1 - 0.0253968253968254*G8_5_0 - 0.019047619047619*G8_5_1 + 0.00158730158730159*G9_0_0 - 0.00634920634920635*G9_0_1 + 0.00952380952380951*G9_1_0 + 0.0476190476190476*G9_1_1 - 0.00634920634920634*G9_2_0 - 0.00634920634920634*G9_2_1 - 0.0126984126984127*G9_3_0 + 0.019047619047619*G9_3_1 - 0.019047619047619*G9_4_0 - 0.00634920634920635*G9_4_1 - 0.00634920634920636*G9_5_0 + 0.0190476190476191*G9_5_1 + 0.00158730158730159*G11_6_0 - 0.00634920634920635*G11_6_1 + 0.00952380952380951*G11_7_0 + 0.0476190476190476*G11_7_1 - 0.00634920634920634*G11_8_0 - 0.00634920634920634*G11_8_1 - 0.0126984126984127*G11_9_0 + 0.019047619047619*G11_9_1 - 0.019047619047619*G11_10_0 - 0.00634920634920635*G11_10_1 - 0.00634920634920636*G11_11_0 + 0.0190476190476191*G11_11_1;
    A[47] = 0.666666666666666*G2_0_0_1 + 0.666666666666666*G4_0_0_1 + 0.00634920634920634*G8_0_0 + 0.00634920634920634*G8_0_1 - 0.0126984126984127*G8_1_0 + 0.019047619047619*G8_2_1 + 0.019047619047619*G8_3_0 - 0.0126984126984127*G8_3_1 - 0.019047619047619*G8_4_0 - 0.0253968253968254*G8_4_1 + 0.00634920634920635*G8_5_0 + 0.0126984126984127*G8_5_1 - 0.00634920634920634*G9_0_0 + 0.00158730158730159*G9_0_1 - 0.00634920634920634*G9_1_0 - 0.00634920634920634*G9_1_1 + 0.0476190476190475*G9_2_0 + 0.0095238095238095*G9_2_1 + 0.019047619047619*G9_3_0 - 0.0126984126984127*G9_3_1 + 0.019047619047619*G9_4_0 - 0.00634920634920636*G9_4_1 - 0.00634920634920634*G9_5_0 - 0.019047619047619*G9_5_1 - 0.00634920634920634*G11_6_0 + 0.00158730158730159*G11_6_1 - 0.00634920634920634*G11_7_0 - 0.00634920634920634*G11_7_1 + 0.0476190476190475*G11_8_0 + 0.0095238095238095*G11_8_1 + 0.019047619047619*G11_9_0 - 0.0126984126984127*G11_9_1 + 0.019047619047619*G11_10_0 - 0.00634920634920636*G11_10_1 - 0.00634920634920634*G11_11_0 - 0.019047619047619*G11_11_1;
    A[48] = 1.33333333333333*G2_0_0_0 + 0.666666666666666*G2_0_0_1 + 0.666666666666666*G2_0_1_0 + 1.33333333333333*G2_0_1_1 + 1.33333333333333*G4_0_0_0 + 0.666666666666666*G4_0_0_1 + 0.666666666666666*G4_0_1_0 + 1.33333333333333*G4_0_1_1 + 0.0380952380952381*G8_0_0 + 0.0380952380952381*G8_0_1 + 0.0634920634920634*G8_1_0 + 0.0634920634920635*G8_2_1 + 0.152380952380952*G8_3_0 + 0.152380952380952*G8_3_1 - 0.152380952380952*G8_4_0 - 0.101587301587302*G8_4_1 - 0.101587301587302*G8_5_0 - 0.152380952380952*G8_5_1 - 0.019047619047619*G9_0_0 - 0.019047619047619*G9_0_1 - 0.0126984126984127*G9_1_0 + 0.019047619047619*G9_1_1 + 0.019047619047619*G9_2_0 - 0.0126984126984127*G9_2_1 + 0.152380952380952*G9_3_0 + 0.152380952380952*G9_3_1 + 0.0761904761904762*G9_4_0 + 0.0507936507936508*G9_4_1 + 0.0507936507936508*G9_5_0 + 0.0761904761904762*G9_5_1 - 0.019047619047619*G11_6_0 - 0.019047619047619*G11_6_1 - 0.0126984126984127*G11_7_0 + 0.019047619047619*G11_7_1 + 0.019047619047619*G11_8_0 - 0.0126984126984127*G11_8_1 + 0.152380952380952*G11_9_0 + 0.152380952380952*G11_9_1 + 0.0761904761904762*G11_10_0 + 0.0507936507936508*G11_10_1 + 0.0507936507936508*G11_11_0 + 0.0761904761904762*G11_11_1;
    A[49] = -1.33333333333333*G2_0_0_0 - 0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_0 - 1.33333333333333*G4_0_0_0 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_0 - 0.00634920634920635*G8_0_0 - 0.00634920634920636*G8_0_1 + 0.00634920634920634*G8_1_0 + 0.0317460317460318*G8_2_1 + 0.0761904761904762*G8_3_0 + 0.0507936507936508*G8_3_1 - 0.0761904761904763*G8_4_0 - 0.0253968253968254*G8_4_1 - 0.0507936507936508*G8_5_1 - 0.0126984126984127*G9_0_0 - 0.00634920634920635*G9_0_1 - 0.019047619047619*G9_1_0 - 0.00634920634920635*G9_1_1 + 0.019047619047619*G9_2_0 - 0.00634920634920636*G9_2_1 + 0.0761904761904762*G9_3_0 + 0.0507936507936508*G9_3_1 + 0.152380952380952*G9_4_0 + 0.0507936507936508*G9_4_1 + 0.0507936507936508*G9_5_0 + 0.0507936507936508*G9_5_1 - 0.0126984126984127*G11_6_0 - 0.00634920634920635*G11_6_1 - 0.019047619047619*G11_7_0 - 0.00634920634920635*G11_7_1 + 0.019047619047619*G11_8_0 - 0.00634920634920636*G11_8_1 + 0.0761904761904762*G11_9_0 + 0.0507936507936508*G11_9_1 + 0.152380952380952*G11_10_0 + 0.0507936507936508*G11_10_1 + 0.0507936507936508*G11_11_0 + 0.0507936507936508*G11_11_1;
    A[50] = -0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_0 - 1.33333333333333*G2_0_1_1 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_0 - 1.33333333333333*G4_0_1_1 - 0.00634920634920635*G8_0_0 - 0.00634920634920635*G8_0_1 + 0.0317460317460318*G8_1_0 + 0.00634920634920637*G8_2_1 + 0.0507936507936508*G8_3_0 + 0.0761904761904762*G8_3_1 - 0.0507936507936508*G8_4_0 - 0.0253968253968254*G8_5_0 - 0.0761904761904762*G8_5_1 - 0.00634920634920636*G9_0_0 - 0.0126984126984127*G9_0_1 - 0.00634920634920636*G9_1_0 + 0.0190476190476191*G9_1_1 - 0.00634920634920634*G9_2_0 - 0.019047619047619*G9_2_1 + 0.0507936507936508*G9_3_0 + 0.0761904761904762*G9_3_1 + 0.0507936507936508*G9_4_0 + 0.0507936507936508*G9_4_1 + 0.0507936507936508*G9_5_0 + 0.152380952380952*G9_5_1 - 0.00634920634920636*G11_6_0 - 0.0126984126984127*G11_6_1 - 0.00634920634920636*G11_7_0 + 0.0190476190476191*G11_7_1 - 0.00634920634920634*G11_8_0 - 0.019047619047619*G11_8_1 + 0.0507936507936508*G11_9_0 + 0.0761904761904762*G11_9_1 + 0.0507936507936508*G11_10_0 + 0.0507936507936508*G11_10_1 + 0.0507936507936508*G11_11_0 + 0.152380952380952*G11_11_1;
    A[51] = -0.00476190476190477*G12_6_0 - 0.00476190476190477*G12_6_1 - 0.00793650793650794*G12_7_0 - 0.00793650793650794*G12_8_1 - 0.019047619047619*G12_9_0 - 0.019047619047619*G12_9_1 + 0.0190476190476191*G12_10_0 + 0.0126984126984127*G12_10_1 + 0.0126984126984127*G12_11_0 + 0.0190476190476191*G12_11_1;
    A[52] = 0.00634920634920635*G12_6_0 + 0.00634920634920635*G12_6_1 + 0.019047619047619*G12_7_0 - 0.0126984126984127*G12_8_1 - 0.0126984126984127*G12_9_0 + 0.019047619047619*G12_9_1 + 0.0126984126984127*G12_10_0 + 0.00634920634920635*G12_10_1 - 0.0253968253968254*G12_11_0 - 0.019047619047619*G12_11_1;
    A[53] = 0.00634920634920634*G12_6_0 + 0.00634920634920634*G12_6_1 - 0.0126984126984127*G12_7_0 + 0.019047619047619*G12_8_1 + 0.019047619047619*G12_9_0 - 0.0126984126984127*G12_9_1 - 0.019047619047619*G12_10_0 - 0.0253968253968254*G12_10_1 + 0.00634920634920635*G12_11_0 + 0.0126984126984127*G12_11_1;
    A[54] = 0.0380952380952381*G12_6_0 + 0.0380952380952381*G12_6_1 + 0.0634920634920634*G12_7_0 + 0.0634920634920635*G12_8_1 + 0.152380952380952*G12_9_0 + 0.152380952380952*G12_9_1 - 0.152380952380952*G12_10_0 - 0.101587301587302*G12_10_1 - 0.101587301587302*G12_11_0 - 0.152380952380952*G12_11_1;
    A[55] = -0.00634920634920635*G12_6_0 - 0.00634920634920636*G12_6_1 + 0.00634920634920634*G12_7_0 + 0.0317460317460318*G12_8_1 + 0.0761904761904762*G12_9_0 + 0.0507936507936508*G12_9_1 - 0.0761904761904763*G12_10_0 - 0.0253968253968254*G12_10_1 - 0.0507936507936508*G12_11_1;
    A[56] = -0.00634920634920635*G12_6_0 - 0.00634920634920635*G12_6_1 + 0.0317460317460318*G12_7_0 + 0.00634920634920637*G12_8_1 + 0.0507936507936508*G12_9_0 + 0.0761904761904762*G12_9_1 - 0.0507936507936508*G12_10_0 - 0.0253968253968254*G12_11_0 - 0.0761904761904762*G12_11_1;
    A[57] = 0.166666666666667*G0_0 + 0.166666666666667*G0_1;
    A[58] = 0.166666666666667*G0_0 + 0.333333333333333*G0_1;
    A[59] = 0.333333333333333*G0_0 + 0.166666666666667*G0_1;
    A[60] = -0.666666666666667*G2_0_1_0 - 0.666666666666667*G2_0_1_1 - 0.666666666666667*G4_0_1_0 - 0.666666666666667*G4_0_1_1 - 0.0190476190476191*G8_0_0 - 0.0190476190476191*G8_0_1 - 0.00634920634920635*G8_1_0 - 0.0126984126984127*G8_2_1 - 0.0126984126984127*G8_3_0 - 0.00634920634920635*G8_3_1 + 0.0126984126984127*G8_4_0 + 0.0317460317460318*G8_4_1 + 0.0253968253968254*G8_5_0 + 0.00634920634920635*G8_5_1 - 0.00952380952380952*G9_0_0 + 0.0380952380952381*G9_0_1 - 0.00158730158730159*G9_1_0 - 0.00793650793650794*G9_1_1 + 0.00634920634920634*G9_2_0 + 0.0190476190476191*G9_3_0 + 0.0126984126984127*G9_3_1 + 0.0126984126984127*G9_4_0 + 0.0317460317460318*G9_4_1 + 0.00634920634920636*G9_5_0 + 0.0253968253968254*G9_5_1 - 0.00952380952380952*G11_6_0 + 0.0380952380952381*G11_6_1 - 0.00158730158730159*G11_7_0 - 0.00793650793650794*G11_7_1 + 0.00634920634920634*G11_8_0 + 0.0190476190476191*G11_9_0 + 0.0126984126984127*G11_9_1 + 0.0126984126984127*G11_10_0 + 0.0317460317460318*G11_10_1 + 0.00634920634920636*G11_11_0 + 0.0253968253968254*G11_11_1;
    A[61] = 0.00793650793650794*G8_0_0 + 0.00793650793650794*G8_0_1 + 0.00476190476190476*G8_1_0 - 0.00793650793650794*G8_2_1 - 0.019047619047619*G8_3_0 - 0.00634920634920635*G8_3_1 + 0.0190476190476191*G8_4_0 - 0.0126984126984127*G8_5_0 + 0.00634920634920635*G8_5_1 - 0.00158730158730159*G9_0_0 - 0.00793650793650794*G9_0_1 - 0.00952380952380952*G9_1_0 + 0.00634920634920634*G9_2_0 + 0.00793650793650793*G9_2_1 + 0.0126984126984127*G9_3_0 + 0.00634920634920635*G9_3_1 + 0.0190476190476191*G9_4_0 + 0.00634920634920636*G9_5_0 - 0.00634920634920634*G9_5_1 - 0.00158730158730159*G11_6_0 - 0.00793650793650794*G11_6_1 - 0.00952380952380952*G11_7_0 + 0.00634920634920634*G11_8_0 + 0.00793650793650793*G11_8_1 + 0.0126984126984127*G11_9_0 + 0.00634920634920635*G11_9_1 + 0.0190476190476191*G11_10_0 + 0.00634920634920636*G11_11_0 - 0.00634920634920634*G11_11_1;
    A[62] = -0.666666666666667*G2_0_0_1 - 0.666666666666667*G2_0_1_1 - 0.666666666666667*G4_0_0_1 - 0.666666666666667*G4_0_1_1 + 0.0126984126984127*G8_0_0 + 0.0126984126984127*G8_0_1 - 0.00634920634920635*G8_1_0 + 0.019047619047619*G8_2_1 + 0.019047619047619*G8_3_0 - 0.00634920634920636*G8_3_1 - 0.019047619047619*G8_4_0 - 0.0317460317460317*G8_4_1 - 0.00634920634920635*G8_5_0 + 0.00634920634920635*G8_5_1 + 0.00634920634920634*G9_0_0 + 0.00634920634920634*G9_1_0 + 0.00793650793650793*G9_1_1 - 0.0476190476190476*G9_2_0 - 0.038095238095238*G9_2_1 - 0.019047619047619*G9_3_0 - 0.0253968253968254*G9_3_1 - 0.019047619047619*G9_4_0 - 0.0317460317460317*G9_4_1 + 0.00634920634920635*G9_5_0 - 0.0126984126984127*G9_5_1 + 0.00634920634920634*G11_6_0 + 0.00634920634920634*G11_7_0 + 0.00793650793650793*G11_7_1 - 0.0476190476190476*G11_8_0 - 0.038095238095238*G11_8_1 - 0.019047619047619*G11_9_0 - 0.0253968253968254*G11_9_1 - 0.019047619047619*G11_10_0 - 0.0317460317460317*G11_10_1 + 0.00634920634920635*G11_11_0 - 0.0126984126984127*G11_11_1;
    A[63] = -1.33333333333333*G2_0_0_0 - 0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_0 - 1.33333333333333*G4_0_0_0 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_0 - 0.00634920634920635*G8_0_0 - 0.00634920634920636*G8_0_1 + 0.00634920634920634*G8_1_0 + 0.0317460317460318*G8_2_1 + 0.0761904761904762*G8_3_0 + 0.0507936507936508*G8_3_1 - 0.0761904761904762*G8_4_0 - 0.0253968253968254*G8_4_1 - 0.0507936507936508*G8_5_1 + 0.0190476190476191*G9_0_0 + 0.0126984126984127*G9_0_1 + 0.0126984126984127*G9_1_0 + 0.00634920634920635*G9_1_1 - 0.019047619047619*G9_2_0 - 0.0253968253968254*G9_2_1 - 0.152380952380952*G9_3_0 - 0.101587301587302*G9_3_1 - 0.0761904761904762*G9_4_0 - 0.0253968253968254*G9_4_1 - 0.0507936507936508*G9_5_0 + 0.0190476190476191*G11_6_0 + 0.0126984126984127*G11_6_1 + 0.0126984126984127*G11_7_0 + 0.00634920634920635*G11_7_1 - 0.019047619047619*G11_8_0 - 0.0253968253968254*G11_8_1 - 0.152380952380952*G11_9_0 - 0.101587301587302*G11_9_1 - 0.0761904761904762*G11_10_0 - 0.0253968253968254*G11_10_1 - 0.0507936507936508*G11_11_0;
    A[64] = 1.33333333333333*G2_0_0_0 + 0.666666666666666*G2_0_0_1 + 0.666666666666666*G2_0_1_0 + 1.33333333333333*G2_0_1_1 + 1.33333333333333*G4_0_0_0 + 0.666666666666666*G4_0_0_1 + 0.666666666666666*G4_0_1_0 + 1.33333333333333*G4_0_1_1 - 0.0634920634920635*G8_0_0 - 0.0634920634920635*G8_0_1 - 0.0380952380952381*G8_1_0 + 0.0634920634920635*G8_2_1 + 0.152380952380952*G8_3_0 + 0.0507936507936508*G8_3_1 - 0.152380952380953*G8_4_0 + 0.101587301587302*G8_5_0 - 0.0507936507936508*G8_5_1 + 0.0126984126984127*G9_0_0 + 0.0317460317460318*G9_0_1 + 0.0190476190476191*G9_1_0 - 0.019047619047619*G9_2_0 - 0.0317460317460317*G9_2_1 - 0.0761904761904763*G9_3_0 - 0.0253968253968254*G9_3_1 - 0.152380952380953*G9_4_0 - 0.0507936507936508*G9_5_0 + 0.0253968253968254*G9_5_1 + 0.0126984126984127*G11_6_0 + 0.0317460317460318*G11_6_1 + 0.0190476190476191*G11_7_0 - 0.019047619047619*G11_8_0 - 0.0317460317460317*G11_8_1 - 0.0761904761904763*G11_9_0 - 0.0253968253968254*G11_9_1 - 0.152380952380953*G11_10_0 - 0.0507936507936508*G11_11_0 + 0.0253968253968254*G11_11_1;
    A[65] = 0.666666666666667*G2_0_0_1 + 0.666666666666667*G2_0_1_0 + 0.666666666666667*G4_0_0_1 + 0.666666666666667*G4_0_1_0 - 0.0317460317460317*G8_0_0 - 0.0317460317460317*G8_0_1 + 0.00634920634920634*G8_1_0 + 0.00634920634920636*G8_2_1 + 0.0507936507936508*G8_3_0 + 0.0507936507936508*G8_3_1 - 0.0507936507936508*G8_4_0 + 0.0253968253968254*G8_4_1 + 0.0253968253968254*G8_5_0 - 0.0507936507936508*G8_5_1 + 0.00634920634920636*G9_0_0 + 0.0253968253968254*G9_0_1 + 0.00634920634920636*G9_1_0 - 0.00634920634920634*G9_1_1 + 0.00634920634920635*G9_2_0 - 0.0126984126984127*G9_2_1 - 0.0507936507936508*G9_3_0 - 0.0507936507936508*G9_4_0 + 0.0253968253968254*G9_4_1 - 0.0507936507936508*G9_5_0 + 0.101587301587302*G9_5_1 + 0.00634920634920636*G11_6_0 + 0.0253968253968254*G11_6_1 + 0.00634920634920636*G11_7_0 - 0.00634920634920634*G11_7_1 + 0.00634920634920635*G11_8_0 - 0.0126984126984127*G11_8_1 - 0.0507936507936508*G11_9_0 - 0.0507936507936508*G11_10_0 + 0.0253968253968254*G11_10_1 - 0.0507936507936508*G11_11_0 + 0.101587301587302*G11_11_1;
    A[66] = -0.0190476190476191*G12_6_0 - 0.0190476190476191*G12_6_1 - 0.00634920634920635*G12_7_0 - 0.0126984126984127*G12_8_1 - 0.0126984126984127*G12_9_0 - 0.00634920634920635*G12_9_1 + 0.0126984126984127*G12_10_0 + 0.0317460317460318*G12_10_1 + 0.0253968253968254*G12_11_0 + 0.00634920634920635*G12_11_1;
    A[67] = 0.00793650793650794*G12_6_0 + 0.00793650793650794*G12_6_1 + 0.00476190476190476*G12_7_0 - 0.00793650793650794*G12_8_1 - 0.019047619047619*G12_9_0 - 0.00634920634920635*G12_9_1 + 0.0190476190476191*G12_10_0 - 0.0126984126984127*G12_11_0 + 0.00634920634920635*G12_11_1;
    A[68] = 0.0126984126984127*G12_6_0 + 0.0126984126984127*G12_6_1 - 0.00634920634920635*G12_7_0 + 0.019047619047619*G12_8_1 + 0.019047619047619*G12_9_0 - 0.00634920634920636*G12_9_1 - 0.019047619047619*G12_10_0 - 0.0317460317460317*G12_10_1 - 0.00634920634920635*G12_11_0 + 0.00634920634920635*G12_11_1;
    A[69] = -0.00634920634920635*G12_6_0 - 0.00634920634920636*G12_6_1 + 0.00634920634920634*G12_7_0 + 0.0317460317460318*G12_8_1 + 0.0761904761904762*G12_9_0 + 0.0507936507936508*G12_9_1 - 0.0761904761904762*G12_10_0 - 0.0253968253968254*G12_10_1 - 0.0507936507936508*G12_11_1;
    A[70] = -0.0634920634920635*G12_6_0 - 0.0634920634920635*G12_6_1 - 0.0380952380952381*G12_7_0 + 0.0634920634920635*G12_8_1 + 0.152380952380952*G12_9_0 + 0.0507936507936508*G12_9_1 - 0.152380952380953*G12_10_0 + 0.101587301587302*G12_11_0 - 0.0507936507936508*G12_11_1;
    A[71] = -0.0317460317460317*G12_6_0 - 0.0317460317460317*G12_6_1 + 0.00634920634920634*G12_7_0 + 0.00634920634920636*G12_8_1 + 0.0507936507936508*G12_9_0 + 0.0507936507936508*G12_9_1 - 0.0507936507936508*G12_10_0 + 0.0253968253968254*G12_10_1 + 0.0253968253968254*G12_11_0 - 0.0507936507936508*G12_11_1;
    A[72] = -0.166666666666667*G0_0 + 0.166666666666667*G0_1;
    A[73] = -0.166666666666667*G0_0;
    A[74] = -0.333333333333333*G0_0 - 0.166666666666667*G0_1;
    A[75] = -0.666666666666667*G2_0_0_0 - 0.666666666666667*G2_0_0_1 - 0.666666666666667*G4_0_0_0 - 0.666666666666667*G4_0_0_1 - 0.019047619047619*G8_0_0 - 0.019047619047619*G8_0_1 - 0.0126984126984127*G8_1_0 - 0.00634920634920635*G8_2_1 - 0.00634920634920636*G8_3_0 - 0.0126984126984127*G8_3_1 + 0.00634920634920636*G8_4_0 + 0.0253968253968254*G8_4_1 + 0.0317460317460317*G8_5_0 + 0.0126984126984127*G8_5_1 + 0.0380952380952381*G9_0_0 - 0.00952380952380953*G9_0_1 + 0.00634920634920635*G9_1_1 - 0.00793650793650794*G9_2_0 - 0.00158730158730159*G9_2_1 + 0.0126984126984127*G9_3_0 + 0.0190476190476191*G9_3_1 + 0.0253968253968254*G9_4_0 + 0.00634920634920635*G9_4_1 + 0.0317460317460317*G9_5_0 + 0.0126984126984127*G9_5_1 + 0.0380952380952381*G11_6_0 - 0.00952380952380953*G11_6_1 + 0.00634920634920635*G11_7_1 - 0.00793650793650794*G11_8_0 - 0.00158730158730159*G11_8_1 + 0.0126984126984127*G11_9_0 + 0.0190476190476191*G11_9_1 + 0.0253968253968254*G11_10_0 + 0.00634920634920635*G11_10_1 + 0.0317460317460317*G11_11_0 + 0.0126984126984127*G11_11_1;
    A[76] = -0.666666666666667*G2_0_0_0 - 0.666666666666667*G2_0_1_0 - 0.666666666666667*G4_0_0_0 - 0.666666666666667*G4_0_1_0 + 0.0126984126984127*G8_0_0 + 0.0126984126984127*G8_0_1 + 0.0190476190476191*G8_1_0 - 0.00634920634920635*G8_2_1 - 0.00634920634920636*G8_3_0 + 0.0190476190476191*G8_3_1 + 0.00634920634920636*G8_4_0 - 0.00634920634920634*G8_4_1 - 0.0317460317460318*G8_5_0 - 0.0190476190476191*G8_5_1 + 0.00634920634920635*G9_0_1 - 0.0380952380952381*G9_1_0 - 0.0476190476190476*G9_1_1 + 0.00793650793650793*G9_2_0 + 0.00634920634920634*G9_2_1 - 0.0253968253968254*G9_3_0 - 0.019047619047619*G9_3_1 - 0.0126984126984127*G9_4_0 + 0.00634920634920635*G9_4_1 - 0.0317460317460318*G9_5_0 - 0.0190476190476191*G9_5_1 + 0.00634920634920635*G11_6_1 - 0.0380952380952381*G11_7_0 - 0.0476190476190476*G11_7_1 + 0.00793650793650793*G11_8_0 + 0.00634920634920634*G11_8_1 - 0.0253968253968254*G11_9_0 - 0.019047619047619*G11_9_1 - 0.0126984126984127*G11_10_0 + 0.00634920634920635*G11_10_1 - 0.0317460317460318*G11_11_0 - 0.0190476190476191*G11_11_1;
    A[77] = 0.00793650793650794*G8_0_0 + 0.00793650793650794*G8_0_1 - 0.00793650793650794*G8_1_0 + 0.00476190476190476*G8_2_1 - 0.00634920634920634*G8_3_0 - 0.019047619047619*G8_3_1 + 0.00634920634920635*G8_4_0 - 0.0126984126984127*G8_4_1 + 0.019047619047619*G8_5_1 - 0.00793650793650794*G9_0_0 - 0.00158730158730159*G9_0_1 + 0.00793650793650793*G9_1_0 + 0.00634920634920634*G9_1_1 - 0.00952380952380951*G9_2_1 + 0.00634920634920635*G9_3_0 + 0.0126984126984127*G9_3_1 - 0.00634920634920635*G9_4_0 + 0.00634920634920635*G9_4_1 + 0.019047619047619*G9_5_1 - 0.00793650793650794*G11_6_0 - 0.00158730158730159*G11_6_1 + 0.00793650793650793*G11_7_0 + 0.00634920634920634*G11_7_1 - 0.00952380952380951*G11_8_1 + 0.00634920634920635*G11_9_0 + 0.0126984126984127*G11_9_1 - 0.00634920634920635*G11_10_0 + 0.00634920634920635*G11_10_1 + 0.019047619047619*G11_11_1;
    A[78] = -0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_0 - 1.33333333333333*G2_0_1_1 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_0 - 1.33333333333333*G4_0_1_1 - 0.00634920634920635*G8_0_0 - 0.00634920634920635*G8_0_1 + 0.0317460317460318*G8_1_0 + 0.00634920634920637*G8_2_1 + 0.0507936507936508*G8_3_0 + 0.0761904761904762*G8_3_1 - 0.0507936507936508*G8_4_0 - 0.0253968253968254*G8_5_0 - 0.0761904761904762*G8_5_1 + 0.0126984126984127*G9_0_0 + 0.0190476190476191*G9_0_1 - 0.0253968253968254*G9_1_0 - 0.019047619047619*G9_1_1 + 0.00634920634920635*G9_2_0 + 0.0126984126984127*G9_2_1 - 0.101587301587302*G9_3_0 - 0.152380952380952*G9_3_1 - 0.0507936507936508*G9_4_1 - 0.0253968253968254*G9_5_0 - 0.0761904761904762*G9_5_1 + 0.0126984126984127*G11_6_0 + 0.0190476190476191*G11_6_1 - 0.0253968253968254*G11_7_0 - 0.019047619047619*G11_7_1 + 0.00634920634920635*G11_8_0 + 0.0126984126984127*G11_8_1 - 0.101587301587302*G11_9_0 - 0.152380952380952*G11_9_1 - 0.0507936507936508*G11_10_1 - 0.0253968253968254*G11_11_0 - 0.0761904761904762*G11_11_1;
    A[79] = 0.666666666666667*G2_0_0_1 + 0.666666666666667*G2_0_1_0 + 0.666666666666667*G4_0_0_1 + 0.666666666666667*G4_0_1_0 - 0.0317460317460317*G8_0_0 - 0.0317460317460317*G8_0_1 + 0.00634920634920634*G8_1_0 + 0.00634920634920636*G8_2_1 + 0.0507936507936508*G8_3_0 + 0.0507936507936508*G8_3_1 - 0.0507936507936508*G8_4_0 + 0.0253968253968254*G8_4_1 + 0.0253968253968254*G8_5_0 - 0.0507936507936508*G8_5_1 + 0.0253968253968254*G9_0_0 + 0.00634920634920635*G9_0_1 - 0.0126984126984127*G9_1_0 + 0.00634920634920635*G9_1_1 - 0.00634920634920635*G9_2_0 + 0.00634920634920635*G9_2_1 - 0.0507936507936508*G9_3_1 + 0.101587301587302*G9_4_0 - 0.0507936507936508*G9_4_1 + 0.0253968253968254*G9_5_0 - 0.0507936507936508*G9_5_1 + 0.0253968253968254*G11_6_0 + 0.00634920634920635*G11_6_1 - 0.0126984126984127*G11_7_0 + 0.00634920634920635*G11_7_1 - 0.00634920634920635*G11_8_0 + 0.00634920634920635*G11_8_1 - 0.0507936507936508*G11_9_1 + 0.101587301587302*G11_10_0 - 0.0507936507936508*G11_10_1 + 0.0253968253968254*G11_11_0 - 0.0507936507936508*G11_11_1;
    A[80] = 1.33333333333333*G2_0_0_0 + 0.666666666666666*G2_0_0_1 + 0.666666666666666*G2_0_1_0 + 1.33333333333333*G2_0_1_1 + 1.33333333333333*G4_0_0_0 + 0.666666666666666*G4_0_0_1 + 0.666666666666666*G4_0_1_0 + 1.33333333333333*G4_0_1_1 - 0.0634920634920635*G8_0_0 - 0.0634920634920635*G8_0_1 + 0.0634920634920635*G8_1_0 - 0.0380952380952381*G8_2_1 + 0.0507936507936508*G8_3_0 + 0.152380952380952*G8_3_1 - 0.0507936507936508*G8_4_0 + 0.101587301587302*G8_4_1 - 0.152380952380952*G8_5_1 + 0.0317460317460318*G9_0_0 + 0.0126984126984127*G9_0_1 - 0.0317460317460318*G9_1_0 - 0.0190476190476191*G9_1_1 + 0.019047619047619*G9_2_1 - 0.0253968253968254*G9_3_0 - 0.0761904761904762*G9_3_1 + 0.0253968253968254*G9_4_0 - 0.0507936507936508*G9_4_1 - 0.152380952380952*G9_5_1 + 0.0317460317460318*G11_6_0 + 0.0126984126984127*G11_6_1 - 0.0317460317460318*G11_7_0 - 0.0190476190476191*G11_7_1 + 0.019047619047619*G11_8_1 - 0.0253968253968254*G11_9_0 - 0.0761904761904762*G11_9_1 + 0.0253968253968254*G11_10_0 - 0.0507936507936508*G11_10_1 - 0.152380952380952*G11_11_1;
    A[81] = -0.019047619047619*G12_6_0 - 0.019047619047619*G12_6_1 - 0.0126984126984127*G12_7_0 - 0.00634920634920635*G12_8_1 - 0.00634920634920636*G12_9_0 - 0.0126984126984127*G12_9_1 + 0.00634920634920636*G12_10_0 + 0.0253968253968254*G12_10_1 + 0.0317460317460317*G12_11_0 + 0.0126984126984127*G12_11_1;
    A[82] = 0.0126984126984127*G12_6_0 + 0.0126984126984127*G12_6_1 + 0.0190476190476191*G12_7_0 - 0.00634920634920635*G12_8_1 - 0.00634920634920636*G12_9_0 + 0.0190476190476191*G12_9_1 + 0.00634920634920636*G12_10_0 - 0.00634920634920634*G12_10_1 - 0.0317460317460318*G12_11_0 - 0.0190476190476191*G12_11_1;
    A[83] = 0.00793650793650794*G12_6_0 + 0.00793650793650794*G12_6_1 - 0.00793650793650794*G12_7_0 + 0.00476190476190476*G12_8_1 - 0.00634920634920634*G12_9_0 - 0.019047619047619*G12_9_1 + 0.00634920634920635*G12_10_0 - 0.0126984126984127*G12_10_1 + 0.019047619047619*G12_11_1;
    A[84] = -0.00634920634920635*G12_6_0 - 0.00634920634920635*G12_6_1 + 0.0317460317460318*G12_7_0 + 0.00634920634920637*G12_8_1 + 0.0507936507936508*G12_9_0 + 0.0761904761904762*G12_9_1 - 0.0507936507936508*G12_10_0 - 0.0253968253968254*G12_11_0 - 0.0761904761904762*G12_11_1;
    A[85] = -0.0317460317460317*G12_6_0 - 0.0317460317460317*G12_6_1 + 0.00634920634920634*G12_7_0 + 0.00634920634920636*G12_8_1 + 0.0507936507936508*G12_9_0 + 0.0507936507936508*G12_9_1 - 0.0507936507936508*G12_10_0 + 0.0253968253968254*G12_10_1 + 0.0253968253968254*G12_11_0 - 0.0507936507936508*G12_11_1;
    A[86] = -0.0634920634920635*G12_6_0 - 0.0634920634920635*G12_6_1 + 0.0634920634920635*G12_7_0 - 0.0380952380952381*G12_8_1 + 0.0507936507936508*G12_9_0 + 0.152380952380952*G12_9_1 - 0.0507936507936508*G12_10_0 + 0.101587301587302*G12_10_1 - 0.152380952380952*G12_11_1;
    A[87] = 0.166666666666667*G0_0 - 0.166666666666667*G0_1;
    A[88] = -0.166666666666667*G0_0 - 0.333333333333333*G0_1;
    A[89] = -0.166666666666667*G0_1;
    A[90] = -0.030952380952381*G10_0_0 - 0.0309523809523809*G10_0_1 - 0.00714285714285714*G10_1_0 - 0.00714285714285714*G10_2_1 + 0.00952380952380952*G10_3_0 + 0.00952380952380952*G10_3_1 - 0.00952380952380952*G10_4_0 + 0.0380952380952381*G10_4_1 + 0.0380952380952381*G10_5_0 - 0.00952380952380953*G10_5_1;
    A[91] = 0.00357142857142857*G10_0_0 + 0.00357142857142857*G10_0_1 - 0.00357142857142857*G10_1_0 + 0.00436507936507937*G10_2_1 + 0.00158730158730159*G10_3_0 - 0.00634920634920635*G10_3_1 - 0.00158730158730159*G10_4_0 - 0.00793650793650794*G10_4_1 + 0.00634920634920635*G10_5_1;
    A[92] = 0.00357142857142857*G10_0_0 + 0.00357142857142857*G10_0_1 + 0.00436507936507937*G10_1_0 - 0.00357142857142857*G10_2_1 - 0.00634920634920634*G10_3_0 + 0.00158730158730159*G10_3_1 + 0.00634920634920634*G10_4_0 - 0.00793650793650794*G10_5_0 - 0.00158730158730159*G10_5_1;
    A[93] = -0.00476190476190477*G10_0_0 - 0.00476190476190477*G10_0_1 - 0.00793650793650794*G10_1_0 - 0.00793650793650794*G10_2_1 - 0.019047619047619*G10_3_0 - 0.019047619047619*G10_3_1 + 0.0190476190476191*G10_4_0 + 0.0126984126984127*G10_4_1 + 0.0126984126984127*G10_5_0 + 0.0190476190476191*G10_5_1;
    A[94] = -0.0190476190476191*G10_0_0 - 0.0190476190476191*G10_0_1 - 0.00634920634920635*G10_1_0 - 0.0126984126984127*G10_2_1 - 0.0126984126984127*G10_3_0 - 0.00634920634920635*G10_3_1 + 0.0126984126984127*G10_4_0 + 0.0317460317460318*G10_4_1 + 0.0253968253968254*G10_5_0 + 0.00634920634920635*G10_5_1;
    A[95] = -0.019047619047619*G10_0_0 - 0.019047619047619*G10_0_1 - 0.0126984126984127*G10_1_0 - 0.00634920634920635*G10_2_1 - 0.00634920634920636*G10_3_0 - 0.0126984126984127*G10_3_1 + 0.00634920634920636*G10_4_0 + 0.0253968253968254*G10_4_1 + 0.0317460317460318*G10_5_0 + 0.0126984126984127*G10_5_1;
    A[96] = 0.5*G3_0_0_0 + 0.5*G3_0_0_1 + 0.5*G3_0_1_0 + 0.5*G3_0_1_1 + 0.5*G5_0_0_0 + 0.5*G5_0_0_1 + 0.5*G5_0_1_0 + 0.5*G5_0_1_1 - 0.030952380952381*G13_0_0 - 0.0309523809523809*G13_0_1 + 0.00357142857142857*G13_1_0 + 0.00357142857142857*G13_1_1 + 0.00357142857142857*G13_2_0 + 0.00357142857142857*G13_2_1 - 0.00476190476190477*G13_3_0 - 0.00476190476190477*G13_3_1 - 0.0190476190476191*G13_4_0 - 0.0190476190476191*G13_4_1 - 0.019047619047619*G13_5_0 - 0.019047619047619*G13_5_1 - 0.030952380952381*G14_6_0 - 0.0309523809523809*G14_6_1 - 0.00714285714285714*G14_7_0 - 0.00714285714285714*G14_8_1 + 0.00952380952380952*G14_9_0 + 0.00952380952380952*G14_9_1 - 0.00952380952380952*G14_10_0 + 0.0380952380952381*G14_10_1 + 0.0380952380952381*G14_11_0 - 0.00952380952380953*G14_11_1 - 0.030952380952381*G15_6_0 - 0.0309523809523809*G15_6_1 + 0.00357142857142857*G15_7_0 + 0.00357142857142857*G15_7_1 + 0.00357142857142857*G15_8_0 + 0.00357142857142857*G15_8_1 - 0.00476190476190477*G15_9_0 - 0.00476190476190477*G15_9_1 - 0.0190476190476191*G15_10_0 - 0.0190476190476191*G15_10_1 - 0.019047619047619*G15_11_0 - 0.019047619047619*G15_11_1;
    A[97] = 0.166666666666667*G3_0_0_0 + 0.166666666666667*G3_0_1_0 + 0.166666666666667*G5_0_0_0 + 0.166666666666667*G5_0_1_0 + 0.00357142857142857*G13_0_0 + 0.00357142857142857*G13_0_1 + 0.00714285714285713*G13_1_0 + 0.00714285714285714*G13_1_1 - 0.00436507936507936*G13_2_0 - 0.00436507936507936*G13_2_1 + 0.00634920634920635*G13_3_0 + 0.00634920634920635*G13_3_1 + 0.00793650793650794*G13_4_0 + 0.00793650793650794*G13_4_1 + 0.0126984126984127*G13_5_0 + 0.0126984126984127*G13_5_1 + 0.00357142857142857*G14_6_0 + 0.00357142857142857*G14_6_1 - 0.00357142857142857*G14_7_0 + 0.00436507936507937*G14_8_1 + 0.00158730158730159*G14_9_0 - 0.00634920634920635*G14_9_1 - 0.00158730158730159*G14_10_0 - 0.00793650793650794*G14_10_1 + 0.00634920634920635*G14_11_1 + 0.00357142857142857*G15_6_0 + 0.00357142857142857*G15_6_1 + 0.00714285714285713*G15_7_0 + 0.00714285714285714*G15_7_1 - 0.00436507936507936*G15_8_0 - 0.00436507936507936*G15_8_1 + 0.00634920634920635*G15_9_0 + 0.00634920634920635*G15_9_1 + 0.00793650793650794*G15_10_0 + 0.00793650793650794*G15_10_1 + 0.0126984126984127*G15_11_0 + 0.0126984126984127*G15_11_1;
    A[98] = 0.166666666666667*G3_0_0_1 + 0.166666666666667*G3_0_1_1 + 0.166666666666667*G5_0_0_1 + 0.166666666666667*G5_0_1_1 + 0.00357142857142857*G13_0_0 + 0.00357142857142857*G13_0_1 - 0.00436507936507936*G13_1_0 - 0.00436507936507936*G13_1_1 + 0.00714285714285713*G13_2_0 + 0.00714285714285712*G13_2_1 + 0.00634920634920634*G13_3_0 + 0.00634920634920634*G13_3_1 + 0.0126984126984127*G13_4_0 + 0.0126984126984127*G13_4_1 + 0.00793650793650794*G13_5_0 + 0.00793650793650794*G13_5_1 + 0.00357142857142857*G14_6_0 + 0.00357142857142857*G14_6_1 + 0.00436507936507937*G14_7_0 - 0.00357142857142857*G14_8_1 - 0.00634920634920634*G14_9_0 + 0.00158730158730159*G14_9_1 + 0.00634920634920634*G14_10_0 - 0.00793650793650794*G14_11_0 - 0.00158730158730159*G14_11_1 + 0.00357142857142857*G15_6_0 + 0.00357142857142857*G15_6_1 - 0.00436507936507936*G15_7_0 - 0.00436507936507936*G15_7_1 + 0.00714285714285713*G15_8_0 + 0.00714285714285712*G15_8_1 + 0.00634920634920634*G15_9_0 + 0.00634920634920634*G15_9_1 + 0.0126984126984127*G15_10_0 + 0.0126984126984127*G15_10_1 + 0.00793650793650794*G15_11_0 + 0.00793650793650794*G15_11_1;
    A[99] = -0.00476190476190477*G13_0_0 - 0.00476190476190477*G13_0_1 + 0.00634920634920635*G13_1_0 + 0.00634920634920635*G13_1_1 + 0.00634920634920635*G13_2_0 + 0.00634920634920634*G13_2_1 + 0.0380952380952381*G13_3_0 + 0.0380952380952381*G13_3_1 - 0.00634920634920635*G13_4_0 - 0.00634920634920636*G13_4_1 - 0.00634920634920635*G13_5_0 - 0.00634920634920635*G13_5_1 - 0.00476190476190477*G14_6_0 - 0.00476190476190477*G14_6_1 - 0.00793650793650794*G14_7_0 - 0.00793650793650794*G14_8_1 - 0.019047619047619*G14_9_0 - 0.019047619047619*G14_9_1 + 0.0190476190476191*G14_10_0 + 0.0126984126984127*G14_10_1 + 0.0126984126984127*G14_11_0 + 0.0190476190476191*G14_11_1 - 0.00476190476190477*G15_6_0 - 0.00476190476190477*G15_6_1 + 0.00634920634920635*G15_7_0 + 0.00634920634920635*G15_7_1 + 0.00634920634920635*G15_8_0 + 0.00634920634920634*G15_8_1 + 0.0380952380952381*G15_9_0 + 0.0380952380952381*G15_9_1 - 0.00634920634920635*G15_10_0 - 0.00634920634920636*G15_10_1 - 0.00634920634920635*G15_11_0 - 0.00634920634920635*G15_11_1;
    A[100] = -0.666666666666667*G3_0_0_1 - 0.666666666666667*G3_0_1_1 - 0.666666666666667*G5_0_0_1 - 0.666666666666667*G5_0_1_1 - 0.0190476190476191*G13_0_0 - 0.0190476190476191*G13_0_1 + 0.00793650793650794*G13_1_0 + 0.00793650793650794*G13_1_1 + 0.0126984126984127*G13_2_0 + 0.0126984126984127*G13_2_1 - 0.00634920634920635*G13_3_0 - 0.00634920634920636*G13_3_1 - 0.0634920634920635*G13_4_0 - 0.0634920634920635*G13_4_1 - 0.0317460317460317*G13_5_0 - 0.0317460317460317*G13_5_1 - 0.0190476190476191*G14_6_0 - 0.0190476190476191*G14_6_1 - 0.00634920634920635*G14_7_0 - 0.0126984126984127*G14_8_1 - 0.0126984126984127*G14_9_0 - 0.00634920634920635*G14_9_1 + 0.0126984126984127*G14_10_0 + 0.0317460317460318*G14_10_1 + 0.0253968253968254*G14_11_0 + 0.00634920634920635*G14_11_1 - 0.0190476190476191*G15_6_0 - 0.0190476190476191*G15_6_1 + 0.00793650793650794*G15_7_0 + 0.00793650793650794*G15_7_1 + 0.0126984126984127*G15_8_0 + 0.0126984126984127*G15_8_1 - 0.00634920634920635*G15_9_0 - 0.00634920634920636*G15_9_1 - 0.0634920634920635*G15_10_0 - 0.0634920634920635*G15_10_1 - 0.0317460317460317*G15_11_0 - 0.0317460317460317*G15_11_1;
    A[101] = -0.666666666666667*G3_0_0_0 - 0.666666666666667*G3_0_1_0 - 0.666666666666667*G5_0_0_0 - 0.666666666666667*G5_0_1_0 - 0.019047619047619*G13_0_0 - 0.019047619047619*G13_0_1 + 0.0126984126984127*G13_1_0 + 0.0126984126984127*G13_1_1 + 0.00793650793650794*G13_2_0 + 0.00793650793650794*G13_2_1 - 0.00634920634920635*G13_3_0 - 0.00634920634920635*G13_3_1 - 0.0317460317460317*G13_4_0 - 0.0317460317460317*G13_4_1 - 0.0634920634920635*G13_5_0 - 0.0634920634920635*G13_5_1 - 0.019047619047619*G14_6_0 - 0.019047619047619*G14_6_1 - 0.0126984126984127*G14_7_0 - 0.00634920634920635*G14_8_1 - 0.00634920634920636*G14_9_0 - 0.0126984126984127*G14_9_1 + 0.00634920634920636*G14_10_0 + 0.0253968253968254*G14_10_1 + 0.0317460317460318*G14_11_0 + 0.0126984126984127*G14_11_1 - 0.019047619047619*G15_6_0 - 0.019047619047619*G15_6_1 + 0.0126984126984127*G15_7_0 + 0.0126984126984127*G15_7_1 + 0.00793650793650794*G15_8_0 + 0.00793650793650794*G15_8_1 - 0.00634920634920635*G15_9_0 - 0.00634920634920635*G15_9_1 - 0.0317460317460317*G15_10_0 - 0.0317460317460317*G15_10_1 - 0.0634920634920635*G15_11_0 - 0.0634920634920635*G15_11_1;
    A[102] = -0.166666666666667*G1_0 - 0.166666666666667*G1_1;
    A[103] = 0.0;
    A[104] = 0.0;
    A[105] = 0.00357142857142857*G10_0_0 + 0.00357142857142857*G10_0_1 - 0.00357142857142857*G10_1_0 + 0.00436507936507937*G10_2_1 + 0.00158730158730159*G10_3_0 - 0.00634920634920635*G10_3_1 - 0.00158730158730159*G10_4_0 - 0.00793650793650794*G10_4_1 + 0.00634920634920635*G10_5_1;
    A[106] = 0.00714285714285713*G10_0_0 + 0.00714285714285714*G10_0_1 + 0.0309523809523809*G10_1_0 - 0.00714285714285713*G10_2_1 + 0.00952380952380951*G10_3_0 + 0.0476190476190476*G10_3_1 - 0.00952380952380952*G10_4_0 - 0.0380952380952381*G10_5_0 - 0.0476190476190476*G10_5_1;
    A[107] = -0.00436507936507936*G10_0_0 - 0.00436507936507936*G10_0_1 - 0.00357142857142857*G10_1_0 - 0.00357142857142857*G10_2_1 - 0.00634920634920634*G10_3_0 - 0.00634920634920634*G10_3_1 + 0.00634920634920634*G10_4_0 + 0.00793650793650793*G10_4_1 + 0.00793650793650793*G10_5_0 + 0.00634920634920634*G10_5_1;
    A[108] = 0.00634920634920635*G10_0_0 + 0.00634920634920635*G10_0_1 + 0.019047619047619*G10_1_0 - 0.0126984126984127*G10_2_1 - 0.0126984126984127*G10_3_0 + 0.019047619047619*G10_3_1 + 0.0126984126984127*G10_4_0 + 0.00634920634920635*G10_4_1 - 0.0253968253968254*G10_5_0 - 0.019047619047619*G10_5_1;
    A[109] = 0.00793650793650794*G10_0_0 + 0.00793650793650794*G10_0_1 + 0.00476190476190476*G10_1_0 - 0.00793650793650794*G10_2_1 - 0.019047619047619*G10_3_0 - 0.00634920634920635*G10_3_1 + 0.0190476190476191*G10_4_0 - 0.0126984126984127*G10_5_0 + 0.00634920634920635*G10_5_1;
    A[110] = 0.0126984126984127*G10_0_0 + 0.0126984126984127*G10_0_1 + 0.0190476190476191*G10_1_0 - 0.00634920634920635*G10_2_1 - 0.00634920634920636*G10_3_0 + 0.0190476190476191*G10_3_1 + 0.00634920634920636*G10_4_0 - 0.00634920634920634*G10_4_1 - 0.0317460317460318*G10_5_0 - 0.0190476190476191*G10_5_1;
    A[111] = 0.166666666666667*G3_0_0_0 + 0.166666666666667*G3_0_0_1 + 0.166666666666667*G5_0_0_0 + 0.166666666666667*G5_0_0_1 - 0.00714285714285714*G13_0_0 - 0.00357142857142857*G13_1_0 + 0.00436507936507937*G13_2_0 - 0.00793650793650794*G13_3_0 - 0.00634920634920635*G13_4_0 - 0.0126984126984127*G13_5_0 + 0.00357142857142857*G14_6_0 + 0.00357142857142857*G14_6_1 - 0.00357142857142857*G14_7_0 + 0.00436507936507937*G14_8_1 + 0.00158730158730159*G14_9_0 - 0.00634920634920635*G14_9_1 - 0.00158730158730159*G14_10_0 - 0.00793650793650794*G14_10_1 + 0.00634920634920635*G14_11_1 - 0.00714285714285714*G15_6_0 - 0.00357142857142857*G15_7_0 + 0.00436507936507937*G15_8_0 - 0.00793650793650794*G15_9_0 - 0.00634920634920635*G15_10_0 - 0.0126984126984127*G15_11_0;
    A[112] = 0.5*G3_0_0_0 + 0.5*G5_0_0_0 - 0.00357142857142857*G13_0_0 + 0.0309523809523809*G13_1_0 - 0.00357142857142857*G13_2_0 + 0.019047619047619*G13_3_0 + 0.00476190476190476*G13_4_0 + 0.0190476190476191*G13_5_0 + 0.00714285714285713*G14_6_0 + 0.00714285714285714*G14_6_1 + 0.0309523809523809*G14_7_0 - 0.00714285714285713*G14_8_1 + 0.00952380952380951*G14_9_0 + 0.0476190476190476*G14_9_1 - 0.00952380952380952*G14_10_0 - 0.0380952380952381*G14_11_0 - 0.0476190476190476*G14_11_1 - 0.00357142857142857*G15_6_0 + 0.0309523809523809*G15_7_0 - 0.00357142857142857*G15_8_0 + 0.019047619047619*G15_9_0 + 0.00476190476190476*G15_10_0 + 0.0190476190476191*G15_11_0;
    A[113] = -0.166666666666667*G3_0_0_1 - 0.166666666666667*G5_0_0_1 + 0.00436507936507937*G13_0_0 - 0.00357142857142857*G13_1_0 - 0.00714285714285714*G13_2_0 - 0.0126984126984127*G13_3_0 - 0.00634920634920635*G13_4_0 - 0.00793650793650794*G13_5_0 - 0.00436507936507936*G14_6_0 - 0.00436507936507936*G14_6_1 - 0.00357142857142857*G14_7_0 - 0.00357142857142857*G14_8_1 - 0.00634920634920634*G14_9_0 - 0.00634920634920634*G14_9_1 + 0.00634920634920634*G14_10_0 + 0.00793650793650793*G14_10_1 + 0.00793650793650793*G14_11_0 + 0.00634920634920634*G14_11_1 + 0.00436507936507937*G15_6_0 - 0.00357142857142857*G15_7_0 - 0.00714285714285714*G15_8_0 - 0.0126984126984127*G15_9_0 - 0.00634920634920635*G15_10_0 - 0.00793650793650794*G15_11_0;
    A[114] = 0.666666666666666*G3_0_0_1 + 0.666666666666666*G5_0_0_1 - 0.00793650793650794*G13_0_0 + 0.019047619047619*G13_1_0 - 0.0126984126984127*G13_2_0 + 0.0634920634920634*G13_3_0 + 0.00634920634920634*G13_4_0 + 0.0317460317460318*G13_5_0 + 0.00634920634920635*G14_6_0 + 0.00634920634920635*G14_6_1 + 0.019047619047619*G14_7_0 - 0.0126984126984127*G14_8_1 - 0.0126984126984127*G14_9_0 + 0.019047619047619*G14_9_1 + 0.0126984126984127*G14_10_0 + 0.00634920634920635*G14_10_1 - 0.0253968253968254*G14_11_0 - 0.019047619047619*G14_11_1 - 0.00793650793650794*G15_6_0 + 0.019047619047619*G15_7_0 - 0.0126984126984127*G15_8_0 + 0.0634920634920634*G15_9_0 + 0.00634920634920634*G15_10_0 + 0.0317460317460318*G15_11_0;
    A[115] = -0.00634920634920635*G13_0_0 + 0.00476190476190476*G13_1_0 - 0.00634920634920635*G13_2_0 + 0.00634920634920634*G13_3_0 - 0.0380952380952381*G13_4_0 + 0.00634920634920634*G13_5_0 + 0.00793650793650794*G14_6_0 + 0.00793650793650794*G14_6_1 + 0.00476190476190476*G14_7_0 - 0.00793650793650794*G14_8_1 - 0.019047619047619*G14_9_0 - 0.00634920634920635*G14_9_1 + 0.0190476190476191*G14_10_0 - 0.0126984126984127*G14_11_0 + 0.00634920634920635*G14_11_1 - 0.00634920634920635*G15_6_0 + 0.00476190476190476*G15_7_0 - 0.00634920634920635*G15_8_0 + 0.00634920634920634*G15_9_0 - 0.0380952380952381*G15_10_0 + 0.00634920634920634*G15_11_0;
    A[116] = -0.666666666666667*G3_0_0_0 - 0.666666666666667*G3_0_0_1 - 0.666666666666667*G5_0_0_0 - 0.666666666666667*G5_0_0_1 - 0.0126984126984127*G13_0_0 + 0.0190476190476191*G13_1_0 - 0.00793650793650794*G13_2_0 + 0.0317460317460318*G13_3_0 + 0.00634920634920634*G13_4_0 + 0.0634920634920635*G13_5_0 + 0.0126984126984127*G14_6_0 + 0.0126984126984127*G14_6_1 + 0.0190476190476191*G14_7_0 - 0.00634920634920635*G14_8_1 - 0.00634920634920636*G14_9_0 + 0.0190476190476191*G14_9_1 + 0.00634920634920636*G14_10_0 - 0.00634920634920634*G14_10_1 - 0.0317460317460318*G14_11_0 - 0.0190476190476191*G14_11_1 - 0.0126984126984127*G15_6_0 + 0.0190476190476191*G15_7_0 - 0.00793650793650794*G15_8_0 + 0.0317460317460318*G15_9_0 + 0.00634920634920634*G15_10_0 + 0.0634920634920635*G15_11_0;
    A[117] = 0.0;
    A[118] = 0.166666666666667*G1_0;
    A[119] = 0.0;
    A[120] = 0.00357142857142857*G10_0_0 + 0.00357142857142857*G10_0_1 + 0.00436507936507937*G10_1_0 - 0.00357142857142857*G10_2_1 - 0.00634920634920634*G10_3_0 + 0.00158730158730159*G10_3_1 + 0.00634920634920634*G10_4_0 - 0.00793650793650794*G10_5_0 - 0.00158730158730159*G10_5_1;
    A[121] = -0.00436507936507936*G10_0_0 - 0.00436507936507936*G10_0_1 - 0.00357142857142857*G10_1_0 - 0.00357142857142857*G10_2_1 - 0.00634920634920634*G10_3_0 - 0.00634920634920634*G10_3_1 + 0.00634920634920634*G10_4_0 + 0.00793650793650793*G10_4_1 + 0.00793650793650793*G10_5_0 + 0.00634920634920634*G10_5_1;
    A[122] = 0.00714285714285713*G10_0_0 + 0.00714285714285712*G10_0_1 - 0.00714285714285714*G10_1_0 + 0.0309523809523809*G10_2_1 + 0.0476190476190475*G10_3_0 + 0.0095238095238095*G10_3_1 - 0.0476190476190476*G10_4_0 - 0.038095238095238*G10_4_1 - 0.00952380952380951*G10_5_1;
    A[123] = 0.00634920634920635*G10_0_0 + 0.00634920634920634*G10_0_1 - 0.0126984126984127*G10_1_0 + 0.019047619047619*G10_2_1 + 0.019047619047619*G10_3_0 - 0.0126984126984127*G10_3_1 - 0.019047619047619*G10_4_0 - 0.0253968253968254*G10_4_1 + 0.00634920634920635*G10_5_0 + 0.0126984126984127*G10_5_1;
    A[124] = 0.0126984126984127*G10_0_0 + 0.0126984126984127*G10_0_1 - 0.00634920634920635*G10_1_0 + 0.019047619047619*G10_2_1 + 0.019047619047619*G10_3_0 - 0.00634920634920636*G10_3_1 - 0.019047619047619*G10_4_0 - 0.0317460317460317*G10_4_1 - 0.00634920634920635*G10_5_0 + 0.00634920634920635*G10_5_1;
    A[125] = 0.00793650793650794*G10_0_0 + 0.00793650793650794*G10_0_1 - 0.00793650793650794*G10_1_0 + 0.00476190476190476*G10_2_1 - 0.00634920634920634*G10_3_0 - 0.019047619047619*G10_3_1 + 0.00634920634920635*G10_4_0 - 0.0126984126984127*G10_4_1 + 0.019047619047619*G10_5_1;
    A[126] = 0.166666666666667*G3_0_1_0 + 0.166666666666667*G3_0_1_1 + 0.166666666666667*G5_0_1_0 + 0.166666666666667*G5_0_1_1 - 0.00714285714285714*G13_0_1 + 0.00436507936507937*G13_1_1 - 0.00357142857142857*G13_2_1 - 0.00793650793650794*G13_3_1 - 0.0126984126984127*G13_4_1 - 0.00634920634920635*G13_5_1 + 0.00357142857142857*G14_6_0 + 0.00357142857142857*G14_6_1 + 0.00436507936507937*G14_7_0 - 0.00357142857142857*G14_8_1 - 0.00634920634920634*G14_9_0 + 0.00158730158730159*G14_9_1 + 0.00634920634920634*G14_10_0 - 0.00793650793650794*G14_11_0 - 0.00158730158730159*G14_11_1 - 0.00714285714285714*G15_6_1 + 0.00436507936507937*G15_7_1 - 0.00357142857142857*G15_8_1 - 0.00793650793650794*G15_9_1 - 0.0126984126984127*G15_10_1 - 0.00634920634920635*G15_11_1;
    A[127] = -0.166666666666667*G3_0_1_0 - 0.166666666666667*G5_0_1_0 + 0.00436507936507937*G13_0_1 - 0.00714285714285713*G13_1_1 - 0.00357142857142857*G13_2_1 - 0.0126984126984127*G13_3_1 - 0.00793650793650794*G13_4_1 - 0.00634920634920635*G13_5_1 - 0.00436507936507936*G14_6_0 - 0.00436507936507936*G14_6_1 - 0.00357142857142857*G14_7_0 - 0.00357142857142857*G14_8_1 - 0.00634920634920634*G14_9_0 - 0.00634920634920634*G14_9_1 + 0.00634920634920634*G14_10_0 + 0.00793650793650793*G14_10_1 + 0.00793650793650793*G14_11_0 + 0.00634920634920634*G14_11_1 + 0.00436507936507937*G15_6_1 - 0.00714285714285713*G15_7_1 - 0.00357142857142857*G15_8_1 - 0.0126984126984127*G15_9_1 - 0.00793650793650794*G15_10_1 - 0.00634920634920635*G15_11_1;
    A[128] = 0.5*G3_0_1_1 + 0.5*G5_0_1_1 - 0.00357142857142857*G13_0_1 - 0.00357142857142857*G13_1_1 + 0.0309523809523809*G13_2_1 + 0.019047619047619*G13_3_1 + 0.019047619047619*G13_4_1 + 0.00476190476190476*G13_5_1 + 0.00714285714285713*G14_6_0 + 0.00714285714285712*G14_6_1 - 0.00714285714285714*G14_7_0 + 0.0309523809523809*G14_8_1 + 0.0476190476190475*G14_9_0 + 0.0095238095238095*G14_9_1 - 0.0476190476190476*G14_10_0 - 0.038095238095238*G14_10_1 - 0.00952380952380951*G14_11_1 - 0.00357142857142857*G15_6_1 - 0.00357142857142857*G15_7_1 + 0.0309523809523809*G15_8_1 + 0.019047619047619*G15_9_1 + 0.019047619047619*G15_10_1 + 0.00476190476190476*G15_11_1;
    A[129] = 0.666666666666666*G3_0_1_0 + 0.666666666666666*G5_0_1_0 - 0.00793650793650794*G13_0_1 - 0.0126984126984127*G13_1_1 + 0.019047619047619*G13_2_1 + 0.0634920634920635*G13_3_1 + 0.0317460317460318*G13_4_1 + 0.00634920634920637*G13_5_1 + 0.00634920634920635*G14_6_0 + 0.00634920634920634*G14_6_1 - 0.0126984126984127*G14_7_0 + 0.019047619047619*G14_8_1 + 0.019047619047619*G14_9_0 - 0.0126984126984127*G14_9_1 - 0.019047619047619*G14_10_0 - 0.0253968253968254*G14_10_1 + 0.00634920634920635*G14_11_0 + 0.0126984126984127*G14_11_1 - 0.00793650793650794*G15_6_1 - 0.0126984126984127*G15_7_1 + 0.019047619047619*G15_8_1 + 0.0634920634920635*G15_9_1 + 0.0317460317460318*G15_10_1 + 0.00634920634920637*G15_11_1;
    A[130] = -0.666666666666667*G3_0_1_0 - 0.666666666666667*G3_0_1_1 - 0.666666666666667*G5_0_1_0 - 0.666666666666667*G5_0_1_1 - 0.0126984126984127*G13_0_1 - 0.00793650793650794*G13_1_1 + 0.019047619047619*G13_2_1 + 0.0317460317460318*G13_3_1 + 0.0634920634920635*G13_4_1 + 0.00634920634920636*G13_5_1 + 0.0126984126984127*G14_6_0 + 0.0126984126984127*G14_6_1 - 0.00634920634920635*G14_7_0 + 0.019047619047619*G14_8_1 + 0.019047619047619*G14_9_0 - 0.00634920634920636*G14_9_1 - 0.019047619047619*G14_10_0 - 0.0317460317460317*G14_10_1 - 0.00634920634920635*G14_11_0 + 0.00634920634920635*G14_11_1 - 0.0126984126984127*G15_6_1 - 0.00793650793650794*G15_7_1 + 0.019047619047619*G15_8_1 + 0.0317460317460318*G15_9_1 + 0.0634920634920635*G15_10_1 + 0.00634920634920636*G15_11_1;
    A[131] = -0.00634920634920635*G13_0_1 - 0.00634920634920635*G13_1_1 + 0.00476190476190476*G13_2_1 + 0.00634920634920637*G13_3_1 + 0.00634920634920636*G13_4_1 - 0.0380952380952381*G13_5_1 + 0.00793650793650794*G14_6_0 + 0.00793650793650794*G14_6_1 - 0.00793650793650794*G14_7_0 + 0.00476190476190476*G14_8_1 - 0.00634920634920634*G14_9_0 - 0.019047619047619*G14_9_1 + 0.00634920634920635*G14_10_0 - 0.0126984126984127*G14_10_1 + 0.019047619047619*G14_11_1 - 0.00634920634920635*G15_6_1 - 0.00634920634920635*G15_7_1 + 0.00476190476190476*G15_8_1 + 0.00634920634920637*G15_9_1 + 0.00634920634920636*G15_10_1 - 0.0380952380952381*G15_11_1;
    A[132] = 0.0;
    A[133] = 0.0;
    A[134] = 0.166666666666667*G1_1;
    A[135] = -0.00476190476190477*G10_0_0 - 0.00476190476190477*G10_0_1 - 0.00793650793650794*G10_1_0 - 0.00793650793650794*G10_2_1 - 0.019047619047619*G10_3_0 - 0.019047619047619*G10_3_1 + 0.0190476190476191*G10_4_0 + 0.0126984126984127*G10_4_1 + 0.0126984126984127*G10_5_0 + 0.0190476190476191*G10_5_1;
    A[136] = 0.00634920634920635*G10_0_0 + 0.00634920634920635*G10_0_1 + 0.019047619047619*G10_1_0 - 0.0126984126984127*G10_2_1 - 0.0126984126984127*G10_3_0 + 0.019047619047619*G10_3_1 + 0.0126984126984127*G10_4_0 + 0.00634920634920635*G10_4_1 - 0.0253968253968254*G10_5_0 - 0.019047619047619*G10_5_1;
    A[137] = 0.00634920634920634*G10_0_0 + 0.00634920634920634*G10_0_1 - 0.0126984126984127*G10_1_0 + 0.019047619047619*G10_2_1 + 0.019047619047619*G10_3_0 - 0.0126984126984127*G10_3_1 - 0.019047619047619*G10_4_0 - 0.0253968253968254*G10_4_1 + 0.00634920634920635*G10_5_0 + 0.0126984126984127*G10_5_1;
    A[138] = 0.0380952380952381*G10_0_0 + 0.0380952380952381*G10_0_1 + 0.0634920634920634*G10_1_0 + 0.0634920634920635*G10_2_1 + 0.152380952380952*G10_3_0 + 0.152380952380952*G10_3_1 - 0.152380952380952*G10_4_0 - 0.101587301587302*G10_4_1 - 0.101587301587302*G10_5_0 - 0.152380952380952*G10_5_1;
    A[139] = -0.00634920634920635*G10_0_0 - 0.00634920634920636*G10_0_1 + 0.00634920634920634*G10_1_0 + 0.0317460317460318*G10_2_1 + 0.0761904761904762*G10_3_0 + 0.0507936507936508*G10_3_1 - 0.0761904761904763*G10_4_0 - 0.0253968253968254*G10_4_1 - 0.0507936507936508*G10_5_1;
    A[140] = -0.00634920634920635*G10_0_0 - 0.00634920634920635*G10_0_1 + 0.0317460317460318*G10_1_0 + 0.00634920634920637*G10_2_1 + 0.0507936507936508*G10_3_0 + 0.0761904761904762*G10_3_1 - 0.0507936507936508*G10_4_0 - 0.0253968253968254*G10_5_0 - 0.0761904761904762*G10_5_1;
    A[141] = 0.00952380952380952*G13_0_0 + 0.00952380952380952*G13_0_1 + 0.00158730158730159*G13_1_0 - 0.00634920634920635*G13_1_1 - 0.00634920634920634*G13_2_0 + 0.00158730158730159*G13_2_1 - 0.019047619047619*G13_3_0 - 0.019047619047619*G13_3_1 - 0.0126984126984127*G13_4_0 - 0.00634920634920635*G13_4_1 - 0.00634920634920636*G13_5_0 - 0.0126984126984127*G13_5_1 - 0.00476190476190477*G14_6_0 - 0.00476190476190477*G14_6_1 - 0.00793650793650794*G14_7_0 - 0.00793650793650794*G14_8_1 - 0.019047619047619*G14_9_0 - 0.019047619047619*G14_9_1 + 0.0190476190476191*G14_10_0 + 0.0126984126984127*G14_10_1 + 0.0126984126984127*G14_11_0 + 0.0190476190476191*G14_11_1 + 0.00952380952380952*G15_6_0 + 0.00952380952380952*G15_6_1 + 0.00158730158730159*G15_7_0 - 0.00634920634920635*G15_7_1 - 0.00634920634920634*G15_8_0 + 0.00158730158730159*G15_8_1 - 0.019047619047619*G15_9_0 - 0.019047619047619*G15_9_1 - 0.0126984126984127*G15_10_0 - 0.00634920634920635*G15_10_1 - 0.00634920634920636*G15_11_0 - 0.0126984126984127*G15_11_1;
    A[142] = 0.666666666666666*G3_0_1_0 + 0.666666666666666*G5_0_1_0 + 0.00158730158730159*G13_0_0 - 0.00634920634920635*G13_0_1 + 0.00952380952380951*G13_1_0 + 0.0476190476190476*G13_1_1 - 0.00634920634920634*G13_2_0 - 0.00634920634920634*G13_2_1 - 0.0126984126984127*G13_3_0 + 0.019047619047619*G13_3_1 - 0.019047619047619*G13_4_0 - 0.00634920634920635*G13_4_1 - 0.00634920634920636*G13_5_0 + 0.0190476190476191*G13_5_1 + 0.00634920634920635*G14_6_0 + 0.00634920634920635*G14_6_1 + 0.019047619047619*G14_7_0 - 0.0126984126984127*G14_8_1 - 0.0126984126984127*G14_9_0 + 0.019047619047619*G14_9_1 + 0.0126984126984127*G14_10_0 + 0.00634920634920635*G14_10_1 - 0.0253968253968254*G14_11_0 - 0.019047619047619*G14_11_1 + 0.00158730158730159*G15_6_0 - 0.00634920634920635*G15_6_1 + 0.00952380952380951*G15_7_0 + 0.0476190476190476*G15_7_1 - 0.00634920634920634*G15_8_0 - 0.00634920634920634*G15_8_1 - 0.0126984126984127*G15_9_0 + 0.019047619047619*G15_9_1 - 0.019047619047619*G15_10_0 - 0.00634920634920635*G15_10_1 - 0.00634920634920636*G15_11_0 + 0.0190476190476191*G15_11_1;
    A[143] = 0.666666666666666*G3_0_0_1 + 0.666666666666666*G5_0_0_1 - 0.00634920634920634*G13_0_0 + 0.00158730158730159*G13_0_1 - 0.00634920634920634*G13_1_0 - 0.00634920634920634*G13_1_1 + 0.0476190476190475*G13_2_0 + 0.0095238095238095*G13_2_1 + 0.019047619047619*G13_3_0 - 0.0126984126984127*G13_3_1 + 0.019047619047619*G13_4_0 - 0.00634920634920636*G13_4_1 - 0.00634920634920634*G13_5_0 - 0.019047619047619*G13_5_1 + 0.00634920634920634*G14_6_0 + 0.00634920634920634*G14_6_1 - 0.0126984126984127*G14_7_0 + 0.019047619047619*G14_8_1 + 0.019047619047619*G14_9_0 - 0.0126984126984127*G14_9_1 - 0.019047619047619*G14_10_0 - 0.0253968253968254*G14_10_1 + 0.00634920634920635*G14_11_0 + 0.0126984126984127*G14_11_1 - 0.00634920634920634*G15_6_0 + 0.00158730158730159*G15_6_1 - 0.00634920634920634*G15_7_0 - 0.00634920634920634*G15_7_1 + 0.0476190476190475*G15_8_0 + 0.0095238095238095*G15_8_1 + 0.019047619047619*G15_9_0 - 0.0126984126984127*G15_9_1 + 0.019047619047619*G15_10_0 - 0.00634920634920636*G15_10_1 - 0.00634920634920634*G15_11_0 - 0.019047619047619*G15_11_1;
    A[144] = 1.33333333333333*G3_0_0_0 + 0.666666666666666*G3_0_0_1 + 0.666666666666666*G3_0_1_0 + 1.33333333333333*G3_0_1_1 + 1.33333333333333*G5_0_0_0 + 0.666666666666666*G5_0_0_1 + 0.666666666666666*G5_0_1_0 + 1.33333333333333*G5_0_1_1 - 0.019047619047619*G13_0_0 - 0.019047619047619*G13_0_1 - 0.0126984126984127*G13_1_0 + 0.019047619047619*G13_1_1 + 0.019047619047619*G13_2_0 - 0.0126984126984127*G13_2_1 + 0.152380952380952*G13_3_0 + 0.152380952380952*G13_3_1 + 0.0761904761904762*G13_4_0 + 0.0507936507936508*G13_4_1 + 0.0507936507936508*G13_5_0 + 0.0761904761904762*G13_5_1 + 0.0380952380952381*G14_6_0 + 0.0380952380952381*G14_6_1 + 0.0634920634920634*G14_7_0 + 0.0634920634920635*G14_8_1 + 0.152380952380952*G14_9_0 + 0.152380952380952*G14_9_1 - 0.152380952380952*G14_10_0 - 0.101587301587302*G14_10_1 - 0.101587301587302*G14_11_0 - 0.152380952380952*G14_11_1 - 0.019047619047619*G15_6_0 - 0.019047619047619*G15_6_1 - 0.0126984126984127*G15_7_0 + 0.019047619047619*G15_7_1 + 0.019047619047619*G15_8_0 - 0.0126984126984127*G15_8_1 + 0.152380952380952*G15_9_0 + 0.152380952380952*G15_9_1 + 0.0761904761904762*G15_10_0 + 0.0507936507936508*G15_10_1 + 0.0507936507936508*G15_11_0 + 0.0761904761904762*G15_11_1;
    A[145] = -1.33333333333333*G3_0_0_0 - 0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_0 - 1.33333333333333*G5_0_0_0 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_0 - 0.0126984126984127*G13_0_0 - 0.00634920634920635*G13_0_1 - 0.019047619047619*G13_1_0 - 0.00634920634920635*G13_1_1 + 0.019047619047619*G13_2_0 - 0.00634920634920636*G13_2_1 + 0.0761904761904762*G13_3_0 + 0.0507936507936508*G13_3_1 + 0.152380952380952*G13_4_0 + 0.0507936507936508*G13_4_1 + 0.0507936507936508*G13_5_0 + 0.0507936507936508*G13_5_1 - 0.00634920634920635*G14_6_0 - 0.00634920634920636*G14_6_1 + 0.00634920634920634*G14_7_0 + 0.0317460317460318*G14_8_1 + 0.0761904761904762*G14_9_0 + 0.0507936507936508*G14_9_1 - 0.0761904761904763*G14_10_0 - 0.0253968253968254*G14_10_1 - 0.0507936507936508*G14_11_1 - 0.0126984126984127*G15_6_0 - 0.00634920634920635*G15_6_1 - 0.019047619047619*G15_7_0 - 0.00634920634920635*G15_7_1 + 0.019047619047619*G15_8_0 - 0.00634920634920636*G15_8_1 + 0.0761904761904762*G15_9_0 + 0.0507936507936508*G15_9_1 + 0.152380952380952*G15_10_0 + 0.0507936507936508*G15_10_1 + 0.0507936507936508*G15_11_0 + 0.0507936507936508*G15_11_1;
    A[146] = -0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_0 - 1.33333333333333*G3_0_1_1 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_0 - 1.33333333333333*G5_0_1_1 - 0.00634920634920636*G13_0_0 - 0.0126984126984127*G13_0_1 - 0.00634920634920636*G13_1_0 + 0.0190476190476191*G13_1_1 - 0.00634920634920634*G13_2_0 - 0.019047619047619*G13_2_1 + 0.0507936507936508*G13_3_0 + 0.0761904761904762*G13_3_1 + 0.0507936507936508*G13_4_0 + 0.0507936507936508*G13_4_1 + 0.0507936507936508*G13_5_0 + 0.152380952380952*G13_5_1 - 0.00634920634920635*G14_6_0 - 0.00634920634920635*G14_6_1 + 0.0317460317460318*G14_7_0 + 0.00634920634920637*G14_8_1 + 0.0507936507936508*G14_9_0 + 0.0761904761904762*G14_9_1 - 0.0507936507936508*G14_10_0 - 0.0253968253968254*G14_11_0 - 0.0761904761904762*G14_11_1 - 0.00634920634920636*G15_6_0 - 0.0126984126984127*G15_6_1 - 0.00634920634920636*G15_7_0 + 0.0190476190476191*G15_7_1 - 0.00634920634920634*G15_8_0 - 0.019047619047619*G15_8_1 + 0.0507936507936508*G15_9_0 + 0.0761904761904762*G15_9_1 + 0.0507936507936508*G15_10_0 + 0.0507936507936508*G15_10_1 + 0.0507936507936508*G15_11_0 + 0.152380952380952*G15_11_1;
    A[147] = 0.166666666666667*G1_0 + 0.166666666666667*G1_1;
    A[148] = 0.166666666666667*G1_0 + 0.333333333333333*G1_1;
    A[149] = 0.333333333333333*G1_0 + 0.166666666666667*G1_1;
    A[150] = -0.0190476190476191*G10_0_0 - 0.0190476190476191*G10_0_1 - 0.00634920634920635*G10_1_0 - 0.0126984126984127*G10_2_1 - 0.0126984126984127*G10_3_0 - 0.00634920634920635*G10_3_1 + 0.0126984126984127*G10_4_0 + 0.0317460317460318*G10_4_1 + 0.0253968253968254*G10_5_0 + 0.00634920634920635*G10_5_1;
    A[151] = 0.00793650793650794*G10_0_0 + 0.00793650793650794*G10_0_1 + 0.00476190476190476*G10_1_0 - 0.00793650793650794*G10_2_1 - 0.019047619047619*G10_3_0 - 0.00634920634920635*G10_3_1 + 0.0190476190476191*G10_4_0 - 0.0126984126984127*G10_5_0 + 0.00634920634920635*G10_5_1;
    A[152] = 0.0126984126984127*G10_0_0 + 0.0126984126984127*G10_0_1 - 0.00634920634920635*G10_1_0 + 0.019047619047619*G10_2_1 + 0.019047619047619*G10_3_0 - 0.00634920634920636*G10_3_1 - 0.019047619047619*G10_4_0 - 0.0317460317460317*G10_4_1 - 0.00634920634920635*G10_5_0 + 0.00634920634920635*G10_5_1;
    A[153] = -0.00634920634920635*G10_0_0 - 0.00634920634920636*G10_0_1 + 0.00634920634920634*G10_1_0 + 0.0317460317460318*G10_2_1 + 0.0761904761904762*G10_3_0 + 0.0507936507936508*G10_3_1 - 0.0761904761904762*G10_4_0 - 0.0253968253968254*G10_4_1 - 0.0507936507936508*G10_5_1;
    A[154] = -0.0634920634920635*G10_0_0 - 0.0634920634920635*G10_0_1 - 0.0380952380952381*G10_1_0 + 0.0634920634920635*G10_2_1 + 0.152380952380952*G10_3_0 + 0.0507936507936508*G10_3_1 - 0.152380952380953*G10_4_0 + 0.101587301587302*G10_5_0 - 0.0507936507936508*G10_5_1;
    A[155] = -0.0317460317460317*G10_0_0 - 0.0317460317460317*G10_0_1 + 0.00634920634920634*G10_1_0 + 0.00634920634920636*G10_2_1 + 0.0507936507936508*G10_3_0 + 0.0507936507936508*G10_3_1 - 0.0507936507936508*G10_4_0 + 0.0253968253968254*G10_4_1 + 0.0253968253968254*G10_5_0 - 0.0507936507936508*G10_5_1;
    A[156] = -0.666666666666667*G3_0_1_0 - 0.666666666666667*G3_0_1_1 - 0.666666666666667*G5_0_1_0 - 0.666666666666667*G5_0_1_1 - 0.00952380952380952*G13_0_0 + 0.0380952380952381*G13_0_1 - 0.00158730158730159*G13_1_0 - 0.00793650793650794*G13_1_1 + 0.00634920634920634*G13_2_0 + 0.0190476190476191*G13_3_0 + 0.0126984126984127*G13_3_1 + 0.0126984126984127*G13_4_0 + 0.0317460317460318*G13_4_1 + 0.00634920634920636*G13_5_0 + 0.0253968253968254*G13_5_1 - 0.0190476190476191*G14_6_0 - 0.0190476190476191*G14_6_1 - 0.00634920634920635*G14_7_0 - 0.0126984126984127*G14_8_1 - 0.0126984126984127*G14_9_0 - 0.00634920634920635*G14_9_1 + 0.0126984126984127*G14_10_0 + 0.0317460317460318*G14_10_1 + 0.0253968253968254*G14_11_0 + 0.00634920634920635*G14_11_1 - 0.00952380952380952*G15_6_0 + 0.0380952380952381*G15_6_1 - 0.00158730158730159*G15_7_0 - 0.00793650793650794*G15_7_1 + 0.00634920634920634*G15_8_0 + 0.0190476190476191*G15_9_0 + 0.0126984126984127*G15_9_1 + 0.0126984126984127*G15_10_0 + 0.0317460317460318*G15_10_1 + 0.00634920634920636*G15_11_0 + 0.0253968253968254*G15_11_1;
    A[157] = -0.00158730158730159*G13_0_0 - 0.00793650793650794*G13_0_1 - 0.00952380952380952*G13_1_0 + 0.00634920634920634*G13_2_0 + 0.00793650793650793*G13_2_1 + 0.0126984126984127*G13_3_0 + 0.00634920634920635*G13_3_1 + 0.0190476190476191*G13_4_0 + 0.00634920634920636*G13_5_0 - 0.00634920634920634*G13_5_1 + 0.00793650793650794*G14_6_0 + 0.00793650793650794*G14_6_1 + 0.00476190476190476*G14_7_0 - 0.00793650793650794*G14_8_1 - 0.019047619047619*G14_9_0 - 0.00634920634920635*G14_9_1 + 0.0190476190476191*G14_10_0 - 0.0126984126984127*G14_11_0 + 0.00634920634920635*G14_11_1 - 0.00158730158730159*G15_6_0 - 0.00793650793650794*G15_6_1 - 0.00952380952380952*G15_7_0 + 0.00634920634920634*G15_8_0 + 0.00793650793650793*G15_8_1 + 0.0126984126984127*G15_9_0 + 0.00634920634920635*G15_9_1 + 0.0190476190476191*G15_10_0 + 0.00634920634920636*G15_11_0 - 0.00634920634920634*G15_11_1;
    A[158] = -0.666666666666667*G3_0_0_1 - 0.666666666666667*G3_0_1_1 - 0.666666666666667*G5_0_0_1 - 0.666666666666667*G5_0_1_1 + 0.00634920634920634*G13_0_0 + 0.00634920634920634*G13_1_0 + 0.00793650793650793*G13_1_1 - 0.0476190476190476*G13_2_0 - 0.038095238095238*G13_2_1 - 0.019047619047619*G13_3_0 - 0.0253968253968254*G13_3_1 - 0.019047619047619*G13_4_0 - 0.0317460317460317*G13_4_1 + 0.00634920634920635*G13_5_0 - 0.0126984126984127*G13_5_1 + 0.0126984126984127*G14_6_0 + 0.0126984126984127*G14_6_1 - 0.00634920634920635*G14_7_0 + 0.019047619047619*G14_8_1 + 0.019047619047619*G14_9_0 - 0.00634920634920636*G14_9_1 - 0.019047619047619*G14_10_0 - 0.0317460317460317*G14_10_1 - 0.00634920634920635*G14_11_0 + 0.00634920634920635*G14_11_1 + 0.00634920634920634*G15_6_0 + 0.00634920634920634*G15_7_0 + 0.00793650793650793*G15_7_1 - 0.0476190476190476*G15_8_0 - 0.038095238095238*G15_8_1 - 0.019047619047619*G15_9_0 - 0.0253968253968254*G15_9_1 - 0.019047619047619*G15_10_0 - 0.0317460317460317*G15_10_1 + 0.00634920634920635*G15_11_0 - 0.0126984126984127*G15_11_1;
    A[159] = -1.33333333333333*G3_0_0_0 - 0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_0 - 1.33333333333333*G5_0_0_0 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_0 + 0.0190476190476191*G13_0_0 + 0.0126984126984127*G13_0_1 + 0.0126984126984127*G13_1_0 + 0.00634920634920635*G13_1_1 - 0.019047619047619*G13_2_0 - 0.0253968253968254*G13_2_1 - 0.152380952380952*G13_3_0 - 0.101587301587302*G13_3_1 - 0.0761904761904762*G13_4_0 - 0.0253968253968254*G13_4_1 - 0.0507936507936508*G13_5_0 - 0.00634920634920635*G14_6_0 - 0.00634920634920636*G14_6_1 + 0.00634920634920634*G14_7_0 + 0.0317460317460318*G14_8_1 + 0.0761904761904762*G14_9_0 + 0.0507936507936508*G14_9_1 - 0.0761904761904762*G14_10_0 - 0.0253968253968254*G14_10_1 - 0.0507936507936508*G14_11_1 + 0.0190476190476191*G15_6_0 + 0.0126984126984127*G15_6_1 + 0.0126984126984127*G15_7_0 + 0.00634920634920635*G15_7_1 - 0.019047619047619*G15_8_0 - 0.0253968253968254*G15_8_1 - 0.152380952380952*G15_9_0 - 0.101587301587302*G15_9_1 - 0.0761904761904762*G15_10_0 - 0.0253968253968254*G15_10_1 - 0.0507936507936508*G15_11_0;
    A[160] = 1.33333333333333*G3_0_0_0 + 0.666666666666666*G3_0_0_1 + 0.666666666666666*G3_0_1_0 + 1.33333333333333*G3_0_1_1 + 1.33333333333333*G5_0_0_0 + 0.666666666666666*G5_0_0_1 + 0.666666666666666*G5_0_1_0 + 1.33333333333333*G5_0_1_1 + 0.0126984126984127*G13_0_0 + 0.0317460317460318*G13_0_1 + 0.0190476190476191*G13_1_0 - 0.019047619047619*G13_2_0 - 0.0317460317460317*G13_2_1 - 0.0761904761904763*G13_3_0 - 0.0253968253968254*G13_3_1 - 0.152380952380953*G13_4_0 - 0.0507936507936508*G13_5_0 + 0.0253968253968254*G13_5_1 - 0.0634920634920635*G14_6_0 - 0.0634920634920635*G14_6_1 - 0.0380952380952381*G14_7_0 + 0.0634920634920635*G14_8_1 + 0.152380952380952*G14_9_0 + 0.0507936507936508*G14_9_1 - 0.152380952380953*G14_10_0 + 0.101587301587302*G14_11_0 - 0.0507936507936508*G14_11_1 + 0.0126984126984127*G15_6_0 + 0.0317460317460318*G15_6_1 + 0.0190476190476191*G15_7_0 - 0.019047619047619*G15_8_0 - 0.0317460317460317*G15_8_1 - 0.0761904761904763*G15_9_0 - 0.0253968253968254*G15_9_1 - 0.152380952380953*G15_10_0 - 0.0507936507936508*G15_11_0 + 0.0253968253968254*G15_11_1;
    A[161] = 0.666666666666667*G3_0_0_1 + 0.666666666666667*G3_0_1_0 + 0.666666666666667*G5_0_0_1 + 0.666666666666667*G5_0_1_0 + 0.00634920634920636*G13_0_0 + 0.0253968253968254*G13_0_1 + 0.00634920634920636*G13_1_0 - 0.00634920634920634*G13_1_1 + 0.00634920634920635*G13_2_0 - 0.0126984126984127*G13_2_1 - 0.0507936507936508*G13_3_0 - 0.0507936507936508*G13_4_0 + 0.0253968253968254*G13_4_1 - 0.0507936507936508*G13_5_0 + 0.101587301587302*G13_5_1 - 0.0317460317460317*G14_6_0 - 0.0317460317460317*G14_6_1 + 0.00634920634920634*G14_7_0 + 0.00634920634920636*G14_8_1 + 0.0507936507936508*G14_9_0 + 0.0507936507936508*G14_9_1 - 0.0507936507936508*G14_10_0 + 0.0253968253968254*G14_10_1 + 0.0253968253968254*G14_11_0 - 0.0507936507936508*G14_11_1 + 0.00634920634920636*G15_6_0 + 0.0253968253968254*G15_6_1 + 0.00634920634920636*G15_7_0 - 0.00634920634920634*G15_7_1 + 0.00634920634920635*G15_8_0 - 0.0126984126984127*G15_8_1 - 0.0507936507936508*G15_9_0 - 0.0507936507936508*G15_10_0 + 0.0253968253968254*G15_10_1 - 0.0507936507936508*G15_11_0 + 0.101587301587302*G15_11_1;
    A[162] = -0.166666666666667*G1_0 + 0.166666666666667*G1_1;
    A[163] = -0.166666666666667*G1_0;
    A[164] = -0.333333333333333*G1_0 - 0.166666666666667*G1_1;
    A[165] = -0.019047619047619*G10_0_0 - 0.019047619047619*G10_0_1 - 0.0126984126984127*G10_1_0 - 0.00634920634920635*G10_2_1 - 0.00634920634920636*G10_3_0 - 0.0126984126984127*G10_3_1 + 0.00634920634920636*G10_4_0 + 0.0253968253968254*G10_4_1 + 0.0317460317460317*G10_5_0 + 0.0126984126984127*G10_5_1;
    A[166] = 0.0126984126984127*G10_0_0 + 0.0126984126984127*G10_0_1 + 0.0190476190476191*G10_1_0 - 0.00634920634920635*G10_2_1 - 0.00634920634920636*G10_3_0 + 0.0190476190476191*G10_3_1 + 0.00634920634920636*G10_4_0 - 0.00634920634920634*G10_4_1 - 0.0317460317460318*G10_5_0 - 0.0190476190476191*G10_5_1;
    A[167] = 0.00793650793650794*G10_0_0 + 0.00793650793650794*G10_0_1 - 0.00793650793650794*G10_1_0 + 0.00476190476190476*G10_2_1 - 0.00634920634920634*G10_3_0 - 0.019047619047619*G10_3_1 + 0.00634920634920635*G10_4_0 - 0.0126984126984127*G10_4_1 + 0.019047619047619*G10_5_1;
    A[168] = -0.00634920634920635*G10_0_0 - 0.00634920634920635*G10_0_1 + 0.0317460317460318*G10_1_0 + 0.00634920634920637*G10_2_1 + 0.0507936507936508*G10_3_0 + 0.0761904761904762*G10_3_1 - 0.0507936507936508*G10_4_0 - 0.0253968253968254*G10_5_0 - 0.0761904761904762*G10_5_1;
    A[169] = -0.0317460317460317*G10_0_0 - 0.0317460317460317*G10_0_1 + 0.00634920634920634*G10_1_0 + 0.00634920634920636*G10_2_1 + 0.0507936507936508*G10_3_0 + 0.0507936507936508*G10_3_1 - 0.0507936507936508*G10_4_0 + 0.0253968253968254*G10_4_1 + 0.0253968253968254*G10_5_0 - 0.0507936507936508*G10_5_1;
    A[170] = -0.0634920634920635*G10_0_0 - 0.0634920634920635*G10_0_1 + 0.0634920634920635*G10_1_0 - 0.0380952380952381*G10_2_1 + 0.0507936507936508*G10_3_0 + 0.152380952380952*G10_3_1 - 0.0507936507936508*G10_4_0 + 0.101587301587302*G10_4_1 - 0.152380952380952*G10_5_1;
    A[171] = -0.666666666666667*G3_0_0_0 - 0.666666666666667*G3_0_0_1 - 0.666666666666667*G5_0_0_0 - 0.666666666666667*G5_0_0_1 + 0.0380952380952381*G13_0_0 - 0.00952380952380953*G13_0_1 + 0.00634920634920635*G13_1_1 - 0.00793650793650794*G13_2_0 - 0.00158730158730159*G13_2_1 + 0.0126984126984127*G13_3_0 + 0.0190476190476191*G13_3_1 + 0.0253968253968254*G13_4_0 + 0.00634920634920635*G13_4_1 + 0.0317460317460317*G13_5_0 + 0.0126984126984127*G13_5_1 - 0.019047619047619*G14_6_0 - 0.019047619047619*G14_6_1 - 0.0126984126984127*G14_7_0 - 0.00634920634920635*G14_8_1 - 0.00634920634920636*G14_9_0 - 0.0126984126984127*G14_9_1 + 0.00634920634920636*G14_10_0 + 0.0253968253968254*G14_10_1 + 0.0317460317460317*G14_11_0 + 0.0126984126984127*G14_11_1 + 0.0380952380952381*G15_6_0 - 0.00952380952380953*G15_6_1 + 0.00634920634920635*G15_7_1 - 0.00793650793650794*G15_8_0 - 0.00158730158730159*G15_8_1 + 0.0126984126984127*G15_9_0 + 0.0190476190476191*G15_9_1 + 0.0253968253968254*G15_10_0 + 0.00634920634920635*G15_10_1 + 0.0317460317460317*G15_11_0 + 0.0126984126984127*G15_11_1;
    A[172] = -0.666666666666667*G3_0_0_0 - 0.666666666666667*G3_0_1_0 - 0.666666666666667*G5_0_0_0 - 0.666666666666667*G5_0_1_0 + 0.00634920634920635*G13_0_1 - 0.0380952380952381*G13_1_0 - 0.0476190476190476*G13_1_1 + 0.00793650793650793*G13_2_0 + 0.00634920634920634*G13_2_1 - 0.0253968253968254*G13_3_0 - 0.019047619047619*G13_3_1 - 0.0126984126984127*G13_4_0 + 0.00634920634920635*G13_4_1 - 0.0317460317460318*G13_5_0 - 0.0190476190476191*G13_5_1 + 0.0126984126984127*G14_6_0 + 0.0126984126984127*G14_6_1 + 0.0190476190476191*G14_7_0 - 0.00634920634920635*G14_8_1 - 0.00634920634920636*G14_9_0 + 0.0190476190476191*G14_9_1 + 0.00634920634920636*G14_10_0 - 0.00634920634920634*G14_10_1 - 0.0317460317460318*G14_11_0 - 0.0190476190476191*G14_11_1 + 0.00634920634920635*G15_6_1 - 0.0380952380952381*G15_7_0 - 0.0476190476190476*G15_7_1 + 0.00793650793650793*G15_8_0 + 0.00634920634920634*G15_8_1 - 0.0253968253968254*G15_9_0 - 0.019047619047619*G15_9_1 - 0.0126984126984127*G15_10_0 + 0.00634920634920635*G15_10_1 - 0.0317460317460318*G15_11_0 - 0.0190476190476191*G15_11_1;
    A[173] = -0.00793650793650794*G13_0_0 - 0.00158730158730159*G13_0_1 + 0.00793650793650793*G13_1_0 + 0.00634920634920634*G13_1_1 - 0.00952380952380951*G13_2_1 + 0.00634920634920635*G13_3_0 + 0.0126984126984127*G13_3_1 - 0.00634920634920635*G13_4_0 + 0.00634920634920635*G13_4_1 + 0.019047619047619*G13_5_1 + 0.00793650793650794*G14_6_0 + 0.00793650793650794*G14_6_1 - 0.00793650793650794*G14_7_0 + 0.00476190476190476*G14_8_1 - 0.00634920634920634*G14_9_0 - 0.019047619047619*G14_9_1 + 0.00634920634920635*G14_10_0 - 0.0126984126984127*G14_10_1 + 0.019047619047619*G14_11_1 - 0.00793650793650794*G15_6_0 - 0.00158730158730159*G15_6_1 + 0.00793650793650793*G15_7_0 + 0.00634920634920634*G15_7_1 - 0.00952380952380951*G15_8_1 + 0.00634920634920635*G15_9_0 + 0.0126984126984127*G15_9_1 - 0.00634920634920635*G15_10_0 + 0.00634920634920635*G15_10_1 + 0.019047619047619*G15_11_1;
    A[174] = -0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_0 - 1.33333333333333*G3_0_1_1 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_0 - 1.33333333333333*G5_0_1_1 + 0.0126984126984127*G13_0_0 + 0.0190476190476191*G13_0_1 - 0.0253968253968254*G13_1_0 - 0.019047619047619*G13_1_1 + 0.00634920634920635*G13_2_0 + 0.0126984126984127*G13_2_1 - 0.101587301587302*G13_3_0 - 0.152380952380952*G13_3_1 - 0.0507936507936508*G13_4_1 - 0.0253968253968254*G13_5_0 - 0.0761904761904762*G13_5_1 - 0.00634920634920635*G14_6_0 - 0.00634920634920635*G14_6_1 + 0.0317460317460318*G14_7_0 + 0.00634920634920637*G14_8_1 + 0.0507936507936508*G14_9_0 + 0.0761904761904762*G14_9_1 - 0.0507936507936508*G14_10_0 - 0.0253968253968254*G14_11_0 - 0.0761904761904762*G14_11_1 + 0.0126984126984127*G15_6_0 + 0.0190476190476191*G15_6_1 - 0.0253968253968254*G15_7_0 - 0.019047619047619*G15_7_1 + 0.00634920634920635*G15_8_0 + 0.0126984126984127*G15_8_1 - 0.101587301587302*G15_9_0 - 0.152380952380952*G15_9_1 - 0.0507936507936508*G15_10_1 - 0.0253968253968254*G15_11_0 - 0.0761904761904762*G15_11_1;
    A[175] = 0.666666666666667*G3_0_0_1 + 0.666666666666667*G3_0_1_0 + 0.666666666666667*G5_0_0_1 + 0.666666666666667*G5_0_1_0 + 0.0253968253968254*G13_0_0 + 0.00634920634920635*G13_0_1 - 0.0126984126984127*G13_1_0 + 0.00634920634920635*G13_1_1 - 0.00634920634920635*G13_2_0 + 0.00634920634920635*G13_2_1 - 0.0507936507936508*G13_3_1 + 0.101587301587302*G13_4_0 - 0.0507936507936508*G13_4_1 + 0.0253968253968254*G13_5_0 - 0.0507936507936508*G13_5_1 - 0.0317460317460317*G14_6_0 - 0.0317460317460317*G14_6_1 + 0.00634920634920634*G14_7_0 + 0.00634920634920636*G14_8_1 + 0.0507936507936508*G14_9_0 + 0.0507936507936508*G14_9_1 - 0.0507936507936508*G14_10_0 + 0.0253968253968254*G14_10_1 + 0.0253968253968254*G14_11_0 - 0.0507936507936508*G14_11_1 + 0.0253968253968254*G15_6_0 + 0.00634920634920635*G15_6_1 - 0.0126984126984127*G15_7_0 + 0.00634920634920635*G15_7_1 - 0.00634920634920635*G15_8_0 + 0.00634920634920635*G15_8_1 - 0.0507936507936508*G15_9_1 + 0.101587301587302*G15_10_0 - 0.0507936507936508*G15_10_1 + 0.0253968253968254*G15_11_0 - 0.0507936507936508*G15_11_1;
    A[176] = 1.33333333333333*G3_0_0_0 + 0.666666666666666*G3_0_0_1 + 0.666666666666666*G3_0_1_0 + 1.33333333333333*G3_0_1_1 + 1.33333333333333*G5_0_0_0 + 0.666666666666666*G5_0_0_1 + 0.666666666666666*G5_0_1_0 + 1.33333333333333*G5_0_1_1 + 0.0317460317460318*G13_0_0 + 0.0126984126984127*G13_0_1 - 0.0317460317460318*G13_1_0 - 0.0190476190476191*G13_1_1 + 0.019047619047619*G13_2_1 - 0.0253968253968254*G13_3_0 - 0.0761904761904762*G13_3_1 + 0.0253968253968254*G13_4_0 - 0.0507936507936508*G13_4_1 - 0.152380952380952*G13_5_1 - 0.0634920634920635*G14_6_0 - 0.0634920634920635*G14_6_1 + 0.0634920634920635*G14_7_0 - 0.0380952380952381*G14_8_1 + 0.0507936507936508*G14_9_0 + 0.152380952380952*G14_9_1 - 0.0507936507936508*G14_10_0 + 0.101587301587302*G14_10_1 - 0.152380952380952*G14_11_1 + 0.0317460317460318*G15_6_0 + 0.0126984126984127*G15_6_1 - 0.0317460317460318*G15_7_0 - 0.0190476190476191*G15_7_1 + 0.019047619047619*G15_8_1 - 0.0253968253968254*G15_9_0 - 0.0761904761904762*G15_9_1 + 0.0253968253968254*G15_10_0 - 0.0507936507936508*G15_10_1 - 0.152380952380952*G15_11_1;
    A[177] = 0.166666666666667*G1_0 - 0.166666666666667*G1_1;
    A[178] = -0.166666666666667*G1_0 - 0.333333333333333*G1_1;
    A[179] = -0.166666666666667*G1_1;
    A[180] = 0.166666666666667*G6_0 + 0.166666666666667*G6_1;
    A[181] = 0.0;
    A[182] = 0.0;
    A[183] = -0.166666666666667*G6_0 - 0.166666666666667*G6_1;
    A[184] = 0.166666666666667*G6_0 - 0.166666666666667*G6_1;
    A[185] = -0.166666666666667*G6_0 + 0.166666666666667*G6_1;
    A[186] = 0.166666666666667*G7_0 + 0.166666666666667*G7_1;
    A[187] = 0.0;
    A[188] = 0.0;
    A[189] = -0.166666666666667*G7_0 - 0.166666666666667*G7_1;
    A[190] = 0.166666666666667*G7_0 - 0.166666666666667*G7_1;
    A[191] = -0.166666666666667*G7_0 + 0.166666666666667*G7_1;
    A[192] = 0.0;
    A[193] = 0.0;
    A[194] = 0.0;
    A[195] = 0.0;
    A[196] = -0.166666666666667*G6_0;
    A[197] = 0.0;
    A[198] = -0.166666666666667*G6_0 - 0.333333333333333*G6_1;
    A[199] = 0.166666666666667*G6_0;
    A[200] = 0.166666666666667*G6_0 + 0.333333333333333*G6_1;
    A[201] = 0.0;
    A[202] = -0.166666666666667*G7_0;
    A[203] = 0.0;
    A[204] = -0.166666666666667*G7_0 - 0.333333333333333*G7_1;
    A[205] = 0.166666666666667*G7_0;
    A[206] = 0.166666666666667*G7_0 + 0.333333333333333*G7_1;
    A[207] = 0.0;
    A[208] = 0.0;
    A[209] = 0.0;
    A[210] = 0.0;
    A[211] = 0.0;
    A[212] = -0.166666666666667*G6_1;
    A[213] = -0.333333333333333*G6_0 - 0.166666666666667*G6_1;
    A[214] = 0.333333333333333*G6_0 + 0.166666666666667*G6_1;
    A[215] = 0.166666666666667*G6_1;
    A[216] = 0.0;
    A[217] = 0.0;
    A[218] = -0.166666666666667*G7_1;
    A[219] = -0.333333333333333*G7_0 - 0.166666666666667*G7_1;
    A[220] = 0.333333333333333*G7_0 + 0.166666666666667*G7_1;
    A[221] = 0.166666666666667*G7_1;
    A[222] = 0.0;
    A[223] = 0.0;
    A[224] = 0.0;
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_1_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_1_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_1_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      9
    // Number of operations (multiply-add pairs) for geometry tensor:    0
    // Number of operations (multiply-add pairs) for tensor contraction: 4
    // Total number of operations (multiply-add pairs):                  13
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x[v1][0] - x[v0][0];
    const double dx1 = x[v1][1] - x[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    // Compute geometry tensor
    const double G0_ = det;
    
    // Compute element tensor
    switch (facet)
    {
    case 0:
      {
        A[0] = 0.0;
      A[1] = 0.166666666666667*G0_;
      A[2] = 0.166666666666667*G0_;
      A[3] = 0.666666666666666*G0_;
      A[4] = 0.0;
      A[5] = 0.0;
      A[6] = 0.0;
      A[7] = 0.0;
      A[8] = 0.0;
      A[9] = 0.0;
      A[10] = 0.0;
      A[11] = 0.0;
      A[12] = 0.0;
      A[13] = 0.0;
      A[14] = 0.0;
        break;
      }
    case 1:
      {
        A[0] = 0.166666666666667*G0_;
      A[1] = 0.0;
      A[2] = 0.166666666666666*G0_;
      A[3] = 0.0;
      A[4] = 0.666666666666666*G0_;
      A[5] = 0.0;
      A[6] = 0.0;
      A[7] = 0.0;
      A[8] = 0.0;
      A[9] = 0.0;
      A[10] = 0.0;
      A[11] = 0.0;
      A[12] = 0.0;
      A[13] = 0.0;
      A[14] = 0.0;
        break;
      }
    case 2:
      {
        A[0] = 0.166666666666666*G0_;
      A[1] = 0.166666666666667*G0_;
      A[2] = 0.0;
      A[3] = 0.0;
      A[4] = 0.0;
      A[5] = 0.666666666666666*G0_;
      A[6] = 0.0;
      A[7] = 0.0;
      A[8] = 0.0;
      A[9] = 0.0;
      A[10] = 0.0;
      A[11] = 0.0;
      A[12] = 0.0;
      A[13] = 0.0;
      A[14] = 0.0;
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_2_0: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_2_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_2_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Cell Volume.
    
    // Compute circumradius, assuming triangle is embedded in 2D.
    
    
    // Facet Area.
    
    // Array of quadrature weights.
    static const double W12[12] = {0.0254224531851035, 0.0254224531851035, 0.0254224531851035, 0.0583931378631895, 0.0583931378631895, 0.0583931378631895, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187, 0.041425537809187};
    // Quadrature points on the UFC reference element: (0.873821971016996, 0.063089014491502), (0.063089014491502, 0.873821971016996), (0.063089014491502, 0.063089014491502), (0.501426509658179, 0.24928674517091), (0.24928674517091, 0.501426509658179), (0.24928674517091, 0.24928674517091), (0.636502499121399, 0.310352451033785), (0.636502499121399, 0.053145049844816), (0.310352451033785, 0.636502499121399), (0.310352451033785, 0.053145049844816), (0.053145049844816, 0.636502499121399), (0.053145049844816, 0.310352451033785)
    
    // Value of basis functions at quadrature points.
    static const double FE0_C0[12][6] = \
    {{-0.0551285669924842, 0.65330770304706, -0.0551285669924841, 0.220514267969936, 0.0159208949980358, 0.220514267969937},
    {-0.0551285669924841, -0.055128566992484, 0.65330770304706, 0.220514267969936, 0.220514267969936, 0.0159208949980359},
    {0.653307703047059, -0.0551285669924842, -0.0551285669924842, 0.0159208949980359, 0.220514267969937, 0.220514267969937},
    {-0.124998982535098, 0.00143057951778881, -0.124998982535098, 0.499995930140389, 0.248575525271626, 0.499995930140391},
    {-0.124998982535098, -0.124998982535098, 0.00143057951778877, 0.499995930140389, 0.499995930140391, 0.248575525271626},
    {0.00143057951778977, -0.124998982535098, -0.124998982535098, 0.248575525271625, 0.49999593014039, 0.49999593014039},
    {-0.0474962571988001, 0.173768363654174, -0.117715163308429, 0.790160442765823, 0.0659747859186054, 0.135307828168627},
    {-0.117715163308429, 0.173768363654174, -0.0474962571988, 0.135307828168627, 0.0659747859186052, 0.790160442765823},
    {-0.0474962571988, -0.117715163308429, 0.173768363654174, 0.790160442765823, 0.135307828168627, 0.0659747859186053},
    {0.173768363654174, -0.117715163308429, -0.0474962571988, 0.0659747859186053, 0.135307828168627, 0.790160442765823},
    {-0.117715163308429, -0.0474962571988, 0.173768363654174, 0.135307828168627, 0.790160442765823, 0.0659747859186053},
    {0.173768363654174, -0.0474962571988001, -0.117715163308429, 0.0659747859186055, 0.790160442765823, 0.135307828168627}};
    
    // Array of non-zero columns
    static const unsigned int nzc15[6] = {20, 21, 22, 23, 24, 25};
    
    // Array of non-zero columns
    static const unsigned int nzc3[6] = {6, 7, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc0[6] = {0, 1, 2, 3, 4, 5};
    
    static const double FE0_C0_D01[12][5] = \
    {{0.747643942033992, -0.747643942033992, 3.49528788406798, 0.0, -3.49528788406798},
    {0.747643942033992, 2.49528788406798, 0.252356057966006, -3.24293182610197, -0.252356057966007},
    {-2.49528788406798, -0.747643942033992, 0.252356057966008, 3.24293182610198, -0.252356057966008},
    {0.00285301931635612, -0.00285301931635984, 2.00570603863272, 0.0, -2.00570603863272},
    {0.0028530193163559, 1.00570603863272, 0.99714698068364, -1.00855905794907, -0.99714698068364},
    {-1.00570603863272, -0.00285301931636006, 0.99714698068364, 1.00855905794908, -0.99714698068364},
    {0.787419800620737, 0.24140980413514, 2.5460099964856, -1.02882960475588, -2.5460099964856},
    {-0.24140980413514, -0.787419800620736, 2.5460099964856, 1.02882960475588, -2.5460099964856},
    {0.787419800620736, 1.5460099964856, 1.24140980413514, -2.33342979710633, -1.24140980413514},
    {-1.5460099964856, -0.787419800620736, 1.24140980413514, 2.33342979710633, -1.24140980413514},
    {-0.24140980413514, 1.5460099964856, 0.212580199379263, -1.30460019235046, -0.212580199379264},
    {-1.5460099964856, 0.24140980413514, 0.212580199379264, 1.30460019235046, -0.212580199379264}};
    
    // Array of non-zero columns
    static const unsigned int nzc4[5] = {6, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc1[5] = {0, 2, 3, 4, 5};
    
    static const double FE0_C0_D10[12][5] = \
    {{0.747643942033992, 2.49528788406798, 0.252356057966007, -0.252356057966007, -3.24293182610198},
    {0.747643942033992, -0.747643942033993, 3.49528788406798, -3.49528788406798, 0.0},
    {-2.49528788406798, -0.747643942033992, 0.252356057966007, -0.252356057966007, 3.24293182610198},
    {0.00285301931635615, 1.00570603863272, 0.99714698068364, -0.99714698068364, -1.00855905794907},
    {0.00285301931635618, -0.00285301931636006, 2.00570603863272, -2.00570603863272, 0.0},
    {-1.00570603863272, -0.00285301931636001, 0.99714698068364, -0.99714698068364, 1.00855905794908},
    {0.787419800620736, 1.5460099964856, 1.24140980413514, -1.24140980413514, -2.33342979710633},
    {-0.241409804135141, 1.5460099964856, 0.212580199379263, -0.212580199379263, -1.30460019235046},
    {0.787419800620736, 0.24140980413514, 2.5460099964856, -2.5460099964856, -1.02882960475588},
    {-1.5460099964856, 0.24140980413514, 0.212580199379263, -0.212580199379263, 1.30460019235046},
    {-0.24140980413514, -0.787419800620736, 2.5460099964856, -2.5460099964856, 1.02882960475588},
    {-1.5460099964856, -0.787419800620736, 1.24140980413514, -1.24140980413514, 2.33342979710633}};
    
    // Array of non-zero columns
    static const unsigned int nzc5[5] = {6, 7, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc2[5] = {0, 1, 3, 4, 5};
    
    static const double FE0_C2[12][3] = \
    {{0.063089014491502, 0.873821971016996, 0.063089014491502},
    {0.063089014491502, 0.0630890144915021, 0.873821971016996},
    {0.873821971016996, 0.0630890144915021, 0.063089014491502},
    {0.249286745170911, 0.501426509658179, 0.24928674517091},
    {0.249286745170911, 0.24928674517091, 0.501426509658179},
    {0.50142650965818, 0.24928674517091, 0.24928674517091},
    {0.0531450498448159, 0.636502499121399, 0.310352451033785},
    {0.310352451033785, 0.636502499121399, 0.053145049844816},
    {0.053145049844816, 0.310352451033785, 0.636502499121399},
    {0.636502499121399, 0.310352451033785, 0.053145049844816},
    {0.310352451033785, 0.0531450498448161, 0.636502499121399},
    {0.636502499121399, 0.053145049844816, 0.310352451033785}};
    
    // Array of non-zero columns
    static const unsigned int nzc6[3] = {12, 13, 14};
    
    static const double FE1_C0[12][10] = \
    {{0.0463079953908666, 0.440268993398561, 0.0463079953908666, 0.402250914961474, -0.201125457480737, -0.0145210435563256, -0.0145210435563258, -0.201125457480737, 0.402250914961474, 0.0939061879708835},
    {0.0463079953908666, 0.0463079953908666, 0.440268993398561, -0.201125457480737, 0.402250914961473, -0.201125457480737, 0.402250914961474, -0.0145210435563259, -0.0145210435563256, 0.0939061879708835},
    {0.440268993398561, 0.0463079953908666, 0.0463079953908666, -0.0145210435563258, -0.0145210435563257, 0.402250914961474, -0.201125457480737, 0.402250914961474, -0.201125457480737, 0.0939061879708836},
    {0.0393516858174584, -0.0626737220523998, 0.0393516858174587, 0.283654926157929, -0.141827463078965, -0.0705102461991972, -0.0705102461991981, -0.141827463078964, 0.28365492615793, 0.841335916657949},
    {0.0393516858174583, 0.0393516858174587, -0.0626737220523998, -0.141827463078965, 0.283654926157929, -0.141827463078964, 0.28365492615793, -0.0705102461991974, -0.0705102461991981, 0.841335916657949},
    {-0.0626737220523999, 0.0393516858174587, 0.0393516858174587, -0.0705102461991978, -0.0705102461991978, 0.283654926157931, -0.141827463078965, 0.283654926157931, -0.141827463078965, 0.841335916657947},
    {0.0411107284664351, -0.0261932265993555, 0.0114358260653798, 0.808488952668145, -0.0612852214487413, -0.0623880968176903, -0.00511703591602503, -0.127951879895303, 0.138446419692862, 0.283453533784293},
    {0.0114358260653798, -0.0261932265993555, 0.0411107284664351, 0.138446419692862, -0.127951879895303, -0.0051170359160251, -0.0623880968176904, -0.0612852214487414, 0.808488952668146, 0.283453533784293},
    {0.0411107284664351, 0.0114358260653799, -0.0261932265993555, -0.0612852214487415, 0.808488952668146, -0.127951879895303, 0.138446419692862, -0.0623880968176905, -0.0051170359160251, 0.283453533784293},
    {-0.0261932265993555, 0.0114358260653798, 0.0411107284664351, -0.00511703591602523, -0.0623880968176904, 0.138446419692862, -0.127951879895303, 0.808488952668146, -0.0612852214487412, 0.283453533784293},
    {0.0114358260653798, 0.0411107284664351, -0.0261932265993555, -0.127951879895303, 0.138446419692862, -0.0612852214487415, 0.808488952668146, -0.00511703591602531, -0.0623880968176904, 0.283453533784293},
    {-0.0261932265993555, 0.0411107284664351, 0.0114358260653798, -0.0623880968176905, -0.00511703591602505, 0.808488952668145, -0.0612852214487413, 0.138446419692862, -0.127951879895303, 0.283453533784293}};
    
    // Array of non-zero columns
    static const unsigned int nzc9[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc12[10] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
    
    static const double FE1_C0_D01[12][9] = \
    {{-0.485931890194852, 0.485931890194853, 6.37592643035589, -2.44372756077941, -0.0537330206183695, 0.0537330206183699, 2.44372756077941, -6.37592643035589, 0.0},
    {-0.485931890194853, 3.44372756077941, -0.230167544593387, 1.20457074358531, 2.21356001618602, -5.17135568677058, 0.176434523975019, 0.230167544593388, -1.38100526756033},
    {-3.44372756077941, 0.485931890194853, -0.230167544593388, -0.176434523975019, 5.17135568677058, -2.21356001618602, -1.20457074358531, 0.230167544593387, 1.38100526756033},
    {0.404638308746458, -0.404638308746456, 1.13786605847598, 1.11855323498582, -0.838942397791738, 0.838942397791737, -1.11855323498584, -1.13786605847598, 1.27536869953815e-14},
    {0.404638308746459, -0.118553234985828, -0.282847955477362, 2.25318217517853, -1.40140119046319, 1.11531611670257, -0.55609444231438, 0.282847955477361, -1.69708773286415},
    {0.118553234985824, -0.404638308746456, -0.282847955477361, 0.556094442314373, -1.11531611670255, 1.40140119046319, -2.25318217517854, 0.282847955477361, 1.69708773286417},
    {-0.559823901757263, -0.492870367157913, 2.60506707768882, 2.46932174262301, 0.750232850760382, 0.302461418154796, 1.95093340590806, -2.60506707768882, -4.42025514853108},
    {0.492870367157913, 0.559823901757264, 2.60506707768882, -1.95093340590807, -0.302461418154794, -0.750232850760384, -2.46932174262301, -2.60506707768882, 4.42025514853108},
    {-0.559823901757263, 0.740805831642528, -0.0962843375058812, 3.93699695901727, 1.749910031967, -1.93089196185226, 0.951256224701447, 0.096284337505881, -4.88825318371872},
    {-0.740805831642527, 0.559823901757265, -0.0962843375058804, -0.951256224701448, 1.93089196185226, -1.749910031967, -3.93699695901727, 0.0962843375058803, 4.88825318371872},
    {0.492870367157913, 0.740805831642527, -0.201023373941065, 0.674175115836561, -2.56560608012889, 1.33192988132845, -0.206177080648915, 0.201023373941065, -0.467998035187646},
    {-0.740805831642527, -0.492870367157913, -0.201023373941065, 0.206177080648914, -1.33192988132845, 2.56560608012889, -0.67417511583656, 0.201023373941065, 0.467998035187646}};
    
    // Array of non-zero columns
    static const unsigned int nzc13[9] = {10, 12, 13, 14, 15, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc10[9] = {0, 2, 3, 4, 5, 6, 7, 8, 9};
    
    static const double FE1_C0_D10[12][9] = \
    {{-0.485931890194853, 3.44372756077941, 1.20457074358531, -0.23016754459339, 0.176434523975019, 0.230167544593389, 2.21356001618602, -5.17135568677058, -1.38100526756033},
    {-0.485931890194853, 0.485931890194854, -2.44372756077941, 6.37592643035589, 2.44372756077941, -6.37592643035589, -0.0537330206183692, 0.0537330206183693, 0.0},
    {-3.44372756077941, 0.485931890194852, -0.176434523975019, -0.230167544593388, -1.20457074358531, 0.230167544593388, 5.17135568677058, -2.21356001618602, 1.38100526756033},
    {0.404638308746458, -0.118553234985828, 2.25318217517853, -0.282847955477361, -0.556094442314379, 0.282847955477361, -1.40140119046319, 1.11531611670256, -1.69708773286415},
    {0.404638308746458, -0.404638308746456, 1.11855323498582, 1.13786605847598, -1.11855323498583, -1.13786605847598, -0.838942397791738, 0.838942397791736, 1.38861919184857e-14},
    {0.118553234985824, -0.404638308746456, 0.556094442314373, -0.282847955477361, -2.25318217517854, 0.282847955477361, -1.11531611670255, 1.40140119046318, 1.69708773286417},
    {-0.559823901757263, 0.740805831642527, 3.93699695901727, -0.0962843375058806, 0.951256224701447, 0.0962843375058803, 1.749910031967, -1.93089196185226, -4.88825318371872},
    {0.492870367157913, 0.740805831642527, 0.674175115836558, -0.201023373941065, -0.206177080648913, 0.201023373941065, -2.56560608012889, 1.33192988132845, -0.467998035187645},
    {-0.559823901757264, -0.492870367157913, 2.46932174262301, 2.60506707768882, 1.95093340590807, -2.60506707768882, 0.750232850760382, 0.302461418154795, -4.42025514853108},
    {-0.740805831642527, -0.492870367157913, 0.206177080648913, -0.201023373941064, -0.674175115836559, 0.201023373941064, -1.33192988132845, 2.56560608012889, 0.467998035187646},
    {0.492870367157913, 0.559823901757263, -1.95093340590806, 2.60506707768882, -2.46932174262301, -2.60506707768882, -0.302461418154795, -0.750232850760381, 4.42025514853107},
    {-0.740805831642527, 0.559823901757263, -0.951256224701446, -0.0962843375058805, -3.93699695901727, 0.0962843375058807, 1.93089196185226, -1.749910031967, 4.88825318371872}};
    
    // Array of non-zero columns
    static const unsigned int nzc14[9] = {10, 11, 13, 14, 15, 16, 17, 18, 19};
    
    // Array of non-zero columns
    static const unsigned int nzc11[9] = {0, 1, 3, 4, 5, 6, 7, 8, 9};
    
    // Reset values in the element tensor.
    A[0] = 0.0;
    // Number of operations to compute geometry constants: 23.
    double G[11];
    G[0] =  - det*w[2][0]*(K_00*K_10 + K_01*K_11);
    G[1] =  - K_00*det;
    G[2] =  - K_01*det;
    G[3] =  - det*w[2][0]*(K_00*K_00 + K_01*K_01);
    G[4] =  - det*w[2][0]*(K_10*K_10 + K_11*K_11);
    G[5] =  - K_10*det;
    G[6] =  - K_11*det;
    G[7] = K_10*det;
    G[8] = K_01*det;
    G[9] = K_11*det;
    G[10] = K_00*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 3024
    for (unsigned int ip = 0; ip < 12; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      double F10 = 0.0;
      double F11 = 0.0;
      double F12 = 0.0;
      double F13 = 0.0;
      
      // Total number of operations to compute function values = 72
      for (unsigned int r = 0; r < 9; r++)
      {
        F9 += FE1_C0_D10[ip][r]*w[3][nzc11[r]];
        F10 += FE1_C0_D01[ip][r]*w[3][nzc10[r]];
        F11 += FE1_C0_D10[ip][r]*w[3][nzc14[r]];
        F12 += FE1_C0_D01[ip][r]*w[3][nzc13[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 40
      for (unsigned int r = 0; r < 10; r++)
      {
        F4 += FE1_C0[ip][r]*w[3][nzc9[r]];
        F7 += FE1_C0[ip][r]*w[3][nzc12[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 6
      for (unsigned int r = 0; r < 3; r++)
      {
        F13 += FE0_C2[ip][r]*w[0][nzc6[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 40
      for (unsigned int r = 0; r < 5; r++)
      {
        F0 += FE0_C0_D10[ip][r]*w[0][nzc2[r]];
        F1 += FE0_C0_D01[ip][r]*w[0][nzc1[r]];
        F5 += FE0_C0_D10[ip][r]*w[0][nzc5[r]];
        F6 += FE0_C0_D01[ip][r]*w[0][nzc4[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 36
      for (unsigned int r = 0; r < 6; r++)
      {
        F2 += FE0_C0[ip][r]*w[0][nzc0[r]];
        F3 += FE0_C0[ip][r]*w[0][nzc3[r]];
        F8 += FE0_C0[ip][r]*w[3][nzc15[r]];
      }// end loop over 'r'
      
      // Number of operations to compute ip constants: 57
      double I[1];
      // Number of operations: 57
      I[0] = W12[ip]*(F0*(F10*G[0] + F3*F4*G[2] + F9*G[3] + G[1]*(F8 + F2*F4)) + F1*(F10*G[4] + F3*F4*G[6] + F9*G[0] + G[5]*(F8 + F2*F4)) + F13*(F10*G[7] + F11*G[8] + F12*G[9] + F9*G[10]) + F5*(F11*G[3] + F12*G[0] + F2*F7*G[1] + G[2]*(F8 + F3*F7)) + F6*(F11*G[0] + F12*G[4] + F2*F7*G[5] + G[6]*(F8 + F3*F7)));
      
      
      // Number of operations for primary indices: 1
      // Number of operations to compute entry: 1
      A[0] += I[0];
    }// end loop over 'ip'
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not yet implemented (introduced in UFC 2.0).");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_2_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_2_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_2_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x[v1][0] - x[v0][0];
    const double dx1 = x[v1][1] - x[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    const bool direction = dx1*(x[facet][0] - x[v0][0]) - dx0*(x[facet][1] - x[v0][1]) < 0;// Compute facet normals from the facet scale factor constants
    const double n0 = direction ? dx1 / det : -dx1 / det;
    const double n1 = direction ? -dx0 / det : dx0 / det;
    
    // Cell Volume.
    
    // Compute circumradius, assuming triangle is embedded in 2D.
    
    
    // Facet Area.
    
    // Array of quadrature weights.
    static const double W3[3] = {0.277777777777778, 0.444444444444444, 0.277777777777778};
    // Quadrature points on the UFC reference element: (0.112701665379258), (0.5), (0.887298334620742)
    
    // Value of basis functions at quadrature points.
    static const double FE0_f0[3][2] = \
    {{0.887298334620742, 0.112701665379258},
    {0.5, 0.5},
    {0.112701665379258, 0.887298334620742}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[2] = {1, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 1};
    
    static const double FE1_f0_C0[3][4] = \
    {{0.488014084041408, 0.0619859159585921, 0.747852751738001, -0.297852751738001},
    {-0.0625, -0.0625, 0.5625, 0.5625},
    {0.0619859159585921, 0.488014084041408, -0.297852751738001, 0.747852751738001}};
    
    // Array of non-zero columns
    static const unsigned int nzc3[4] = {1, 2, 3, 4};
    
    // Array of non-zero columns
    static const unsigned int nzc4[4] = {11, 12, 13, 14};
    
    // Array of non-zero columns
    static const unsigned int nzc9[4] = {0, 1, 7, 8};
    
    // Array of non-zero columns
    static const unsigned int nzc10[4] = {10, 11, 17, 18};
    
    // Array of non-zero columns
    static const unsigned int nzc7[4] = {10, 12, 15, 16};
    
    // Array of non-zero columns
    static const unsigned int nzc6[4] = {0, 2, 5, 6};
    
    // Reset values in the element tensor.
    A[0] = 0.0;
    // Number of operations to compute geometry constants: 2.
    double G[2];
    G[0] =  - det*n0;
    G[1] =  - det*n1;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    switch (facet)
    {
    case 0:
      {
        // Total number of operations to compute element tensor (from this point): 78
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 78
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        double F1 = 0.0;
        double F2 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc0[r]];
        }// end loop over 'r'
        
        // Total number of operations to compute function values = 16
        for (unsigned int r = 0; r < 4; r++)
        {
          F1 += FE1_f0_C0[ip][r]*w[3][nzc3[r]];
          F2 += FE1_f0_C0[ip][r]*w[3][nzc4[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 5
        double I[1];
        // Number of operations: 5
        I[0] = F0*W3[ip]*(F1*G[0] + F2*G[1]);
        
        
        // Number of operations for primary indices: 1
        // Number of operations to compute entry: 1
        A[0] += I[0];
      }// end loop over 'ip'
        break;
      }
    case 1:
      {
        // Total number of operations to compute element tensor (from this point): 78
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 78
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        double F1 = 0.0;
        double F2 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc1[r]];
        }// end loop over 'r'
        
        // Total number of operations to compute function values = 16
        for (unsigned int r = 0; r < 4; r++)
        {
          F1 += FE1_f0_C0[ip][r]*w[3][nzc6[r]];
          F2 += FE1_f0_C0[ip][r]*w[3][nzc7[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 5
        double I[1];
        // Number of operations: 5
        I[0] = F0*W3[ip]*(F1*G[0] + F2*G[1]);
        
        
        // Number of operations for primary indices: 1
        // Number of operations to compute entry: 1
        A[0] += I[0];
      }// end loop over 'ip'
        break;
      }
    case 2:
      {
        // Total number of operations to compute element tensor (from this point): 78
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 78
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        double F1 = 0.0;
        double F2 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc2[r]];
        }// end loop over 'r'
        
        // Total number of operations to compute function values = 16
        for (unsigned int r = 0; r < 4; r++)
        {
          F1 += FE1_f0_C0[ip][r]*w[3][nzc9[r]];
          F2 += FE1_f0_C0[ip][r]*w[3][nzc10[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 5
        double I[1];
        // Number of operations: 5
        I[0] = F0*W3[ip]*(F1*G[0] + F2*G[1]);
        
        
        // Number of operations for primary indices: 1
        // Number of operations to compute entry: 1
        A[0] += I[0];
      }// end loop over 'ip'
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not yet implemented (introduced in UFC 2.0).");
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_3_0: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_3_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_3_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      9
    // Number of operations (multiply-add pairs) for geometry tensor:    1
    // Number of operations (multiply-add pairs) for tensor contraction: 34
    // Total number of operations (multiply-add pairs):                  44
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0 = det*w[0][0]*(1.0);
    
    // Compute element tensor
    A[0] = 0.00357142857142857*G0_0;
    A[1] = 0.0;
    A[2] = 0.0;
    A[3] = -0.00714285714285714*G0_0;
    A[4] = -0.00357142857142857*G0_0;
    A[5] = -0.00357142857142857*G0_0;
    A[6] = 0.0;
    A[7] = 0.0;
    A[8] = 0.0;
    A[9] = 0.0;
    A[10] = 0.0;
    A[11] = 0.0;
    A[12] = 0.0;
    A[13] = 0.0;
    A[14] = 0.0;
    A[15] = 0.0;
    A[16] = 0.00357142857142857*G0_0;
    A[17] = 0.0;
    A[18] = -0.00357142857142857*G0_0;
    A[19] = -0.00714285714285714*G0_0;
    A[20] = -0.00357142857142857*G0_0;
    A[21] = 0.0;
    A[22] = 0.0;
    A[23] = 0.0;
    A[24] = 0.0;
    A[25] = 0.0;
    A[26] = 0.0;
    A[27] = 0.0;
    A[28] = 0.0;
    A[29] = 0.0;
    A[30] = 0.0;
    A[31] = 0.0;
    A[32] = 0.00357142857142857*G0_0;
    A[33] = -0.00357142857142857*G0_0;
    A[34] = -0.00357142857142857*G0_0;
    A[35] = -0.00714285714285714*G0_0;
    A[36] = 0.0;
    A[37] = 0.0;
    A[38] = 0.0;
    A[39] = 0.0;
    A[40] = 0.0;
    A[41] = 0.0;
    A[42] = 0.0;
    A[43] = 0.0;
    A[44] = 0.0;
    A[45] = -0.00714285714285714*G0_0;
    A[46] = -0.00357142857142857*G0_0;
    A[47] = -0.00357142857142857*G0_0;
    A[48] = 0.0428571428571428*G0_0;
    A[49] = 0.0285714285714286*G0_0;
    A[50] = 0.0285714285714286*G0_0;
    A[51] = 0.0;
    A[52] = 0.0;
    A[53] = 0.0;
    A[54] = 0.0;
    A[55] = 0.0;
    A[56] = 0.0;
    A[57] = 0.0;
    A[58] = 0.0;
    A[59] = 0.0;
    A[60] = -0.00357142857142857*G0_0;
    A[61] = -0.00714285714285714*G0_0;
    A[62] = -0.00357142857142857*G0_0;
    A[63] = 0.0285714285714286*G0_0;
    A[64] = 0.0428571428571428*G0_0;
    A[65] = 0.0285714285714285*G0_0;
    A[66] = 0.0;
    A[67] = 0.0;
    A[68] = 0.0;
    A[69] = 0.0;
    A[70] = 0.0;
    A[71] = 0.0;
    A[72] = 0.0;
    A[73] = 0.0;
    A[74] = 0.0;
    A[75] = -0.00357142857142857*G0_0;
    A[76] = -0.00357142857142857*G0_0;
    A[77] = -0.00714285714285714*G0_0;
    A[78] = 0.0285714285714286*G0_0;
    A[79] = 0.0285714285714286*G0_0;
    A[80] = 0.0428571428571428*G0_0;
    A[81] = 0.0;
    A[82] = 0.0;
    A[83] = 0.0;
    A[84] = 0.0;
    A[85] = 0.0;
    A[86] = 0.0;
    A[87] = 0.0;
    A[88] = 0.0;
    A[89] = 0.0;
    A[90] = 0.0;
    A[91] = 0.0;
    A[92] = 0.0;
    A[93] = 0.0;
    A[94] = 0.0;
    A[95] = 0.0;
    A[96] = 0.00357142857142857*G0_0;
    A[97] = 0.0;
    A[98] = 0.0;
    A[99] = -0.00714285714285714*G0_0;
    A[100] = -0.00357142857142857*G0_0;
    A[101] = -0.00357142857142857*G0_0;
    A[102] = 0.0;
    A[103] = 0.0;
    A[104] = 0.0;
    A[105] = 0.0;
    A[106] = 0.0;
    A[107] = 0.0;
    A[108] = 0.0;
    A[109] = 0.0;
    A[110] = 0.0;
    A[111] = 0.0;
    A[112] = 0.00357142857142857*G0_0;
    A[113] = 0.0;
    A[114] = -0.00357142857142857*G0_0;
    A[115] = -0.00714285714285714*G0_0;
    A[116] = -0.00357142857142857*G0_0;
    A[117] = 0.0;
    A[118] = 0.0;
    A[119] = 0.0;
    A[120] = 0.0;
    A[121] = 0.0;
    A[122] = 0.0;
    A[123] = 0.0;
    A[124] = 0.0;
    A[125] = 0.0;
    A[126] = 0.0;
    A[127] = 0.0;
    A[128] = 0.00357142857142857*G0_0;
    A[129] = -0.00357142857142857*G0_0;
    A[130] = -0.00357142857142857*G0_0;
    A[131] = -0.00714285714285714*G0_0;
    A[132] = 0.0;
    A[133] = 0.0;
    A[134] = 0.0;
    A[135] = 0.0;
    A[136] = 0.0;
    A[137] = 0.0;
    A[138] = 0.0;
    A[139] = 0.0;
    A[140] = 0.0;
    A[141] = -0.00714285714285714*G0_0;
    A[142] = -0.00357142857142857*G0_0;
    A[143] = -0.00357142857142857*G0_0;
    A[144] = 0.0428571428571428*G0_0;
    A[145] = 0.0285714285714286*G0_0;
    A[146] = 0.0285714285714286*G0_0;
    A[147] = 0.0;
    A[148] = 0.0;
    A[149] = 0.0;
    A[150] = 0.0;
    A[151] = 0.0;
    A[152] = 0.0;
    A[153] = 0.0;
    A[154] = 0.0;
    A[155] = 0.0;
    A[156] = -0.00357142857142857*G0_0;
    A[157] = -0.00714285714285714*G0_0;
    A[158] = -0.00357142857142857*G0_0;
    A[159] = 0.0285714285714286*G0_0;
    A[160] = 0.0428571428571428*G0_0;
    A[161] = 0.0285714285714285*G0_0;
    A[162] = 0.0;
    A[163] = 0.0;
    A[164] = 0.0;
    A[165] = 0.0;
    A[166] = 0.0;
    A[167] = 0.0;
    A[168] = 0.0;
    A[169] = 0.0;
    A[170] = 0.0;
    A[171] = -0.00357142857142857*G0_0;
    A[172] = -0.00357142857142857*G0_0;
    A[173] = -0.00714285714285714*G0_0;
    A[174] = 0.0285714285714286*G0_0;
    A[175] = 0.0285714285714286*G0_0;
    A[176] = 0.0428571428571428*G0_0;
    A[177] = 0.0;
    A[178] = 0.0;
    A[179] = 0.0;
    A[180] = 0.0;
    A[181] = 0.0;
    A[182] = 0.0;
    A[183] = 0.0;
    A[184] = 0.0;
    A[185] = 0.0;
    A[186] = 0.0;
    A[187] = 0.0;
    A[188] = 0.0;
    A[189] = 0.0;
    A[190] = 0.0;
    A[191] = 0.0;
    A[192] = 0.0321428571428571*G0_0;
    A[193] = 0.0214285714285714*G0_0;
    A[194] = 0.0214285714285714*G0_0;
    A[195] = 0.0;
    A[196] = 0.0;
    A[197] = 0.0;
    A[198] = 0.0;
    A[199] = 0.0;
    A[200] = 0.0;
    A[201] = 0.0;
    A[202] = 0.0;
    A[203] = 0.0;
    A[204] = 0.0;
    A[205] = 0.0;
    A[206] = 0.0;
    A[207] = 0.0214285714285714*G0_0;
    A[208] = 0.0321428571428571*G0_0;
    A[209] = 0.0214285714285714*G0_0;
    A[210] = 0.0;
    A[211] = 0.0;
    A[212] = 0.0;
    A[213] = 0.0;
    A[214] = 0.0;
    A[215] = 0.0;
    A[216] = 0.0;
    A[217] = 0.0;
    A[218] = 0.0;
    A[219] = 0.0;
    A[220] = 0.0;
    A[221] = 0.0;
    A[222] = 0.0214285714285714*G0_0;
    A[223] = 0.0214285714285714*G0_0;
    A[224] = 0.0321428571428571*G0_0;
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_4_0: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_4_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_4_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Cell Volume.
    
    // Compute circumradius, assuming triangle is embedded in 2D.
    
    
    // Facet Area.
    
    // Array of quadrature weights.
    static const double W25[25] = {0.0114650803515925, 0.0198040831320473, 0.0173415064313656, 0.0087554991821638, 0.00186555216687783, 0.0231612219294983, 0.0400072873861603, 0.0350325045033716, 0.0176874521104834, 0.0037687016953276, 0.0275289856644697, 0.0475518970579538, 0.0416389652151948, 0.021022967487322, 0.00447940679728133, 0.0231612219294983, 0.0400072873861603, 0.0350325045033716, 0.0176874521104834, 0.0037687016953276, 0.0114650803515925, 0.0198040831320473, 0.0173415064313656, 0.0087554991821638, 0.00186555216687783};
    // Quadrature points on the UFC reference element: (0.0450425935698037, 0.0398098570514687), (0.0376212523451112, 0.198013417873608), (0.0263646449444709, 0.437974810247386), (0.0142857943955714, 0.695464273353636), (0.00462228846504642, 0.901464914201174), (0.221578609552379, 0.0398098570514687), (0.185070710267389, 0.198013417873608), (0.129695936782254, 0.437974810247386), (0.0702762920082817, 0.695464273353636), (0.022738483063764, 0.901464914201174), (0.480095071474266, 0.0398098570514687), (0.400993291063196, 0.198013417873608), (0.281012594876307, 0.437974810247386), (0.152267863323182, 0.695464273353636), (0.0492675428994132, 0.901464914201174), (0.738611533396152, 0.0398098570514687), (0.616915871859002, 0.198013417873608), (0.43232925297036, 0.437974810247386), (0.234259434638082, 0.695464273353636), (0.0757966027350624, 0.901464914201174), (0.915147549378728, 0.0398098570514687), (0.764365329781281, 0.198013417873608), (0.535660544808143, 0.437974810247386), (0.290249932250792, 0.695464273353636), (0.09391279733378, 0.901464914201174)
    
    // Value of basis functions at quadrature points.
    static const double FE0[25][1] = \
    {{0.0443066477812842},
    {0.153742030524499},
    {0.167003080840912},
    {0.0778601276421673},
    {0.010565606073051},
    {0.175913147778989},
    {0.610410534080673},
    {0.663061619658879},
    {0.309132394931336},
    {0.0419492133929461},
    {0.247747270005307},
    {0.859671635180817},
    {0.933822788062264},
    {0.435366587895191},
    {0.0590791718992466},
    {0.175913147778989},
    {0.610410534080673},
    {0.663061619658879},
    {0.309132394931336},
    {0.041949213392946},
    {0.0443066477812842},
    {0.153742030524498},
    {0.167003080840912},
    {0.0778601276421677},
    {0.0105656060730509}};
    
    static const double FE0_D01[25][1] = \
    {{1.06454195761932},
    {0.5752854412384},
    {0.0695371421115227},
    {-0.15629783660457},
    {-0.100783948537444},
    {4.18066660252782},
    {2.09321751667939},
    {-0.0197695576719487},
    {-0.875117679872583},
    {-0.506910012747092},
    {5.70722656015913},
    {2.19762631898684},
    {-1.19092570485194},
    {-2.23320663144433},
    {-1.13361310483317},
    {3.62492541922149},
    {-0.215583167171878},
    {-3.59850532693656},
    {-3.95431694241714},
    {-1.79832091177048},
    {0.129295602035068},
    {-3.31015168346013},
    {-5.95304978565769},
    {-5.33822419894345},
    {-2.27407499327841}};
    
    static const double FE0_D10[25][1] = \
    {{0.935246355584253},
    {3.88543712469853},
    {6.02258692776921},
    {5.18192636233889},
    {2.17329104474096},
    {0.555741183306336},
    {2.30880068385127},
    {3.57873576926462},
    {3.07919926254456},
    {1.29141089902339},
    {0.0},
    {0.0},
    {0.0},
    {0.0},
    {0.0},
    {-0.555741183306334},
    {-2.30880068385127},
    {-3.57873576926462},
    {-3.07919926254455},
    {-1.29141089902339},
    {-0.935246355584247},
    {-3.88543712469853},
    {-6.02258692776921},
    {-5.18192636233889},
    {-2.17329104474097}};
    
    static const double FE1_C0[25][6] = \
    {{0.759842524889053, -0.0409849230988147, -0.036640207614552, 0.00717255684496526, 0.145727572487076, 0.164882476492272},
    {0.404143384962011, -0.0347905350890822, -0.119594790557632, 0.0297980510461641, 0.605418365816316, 0.115025523822223},
    {0.03820389372017, -0.0249744559383749, -0.0543309414249184, 0.0461882014671776, 0.938423301877432, 0.0564900002985143},
    {-0.121759885907613, -0.0138776265525463, 0.271876837668966, 0.0397410384743821, 0.807433832894958, 0.0165858034218534},
    {-0.0762735703276687, -0.00457955736373819, 0.723813068870285, 0.0166673234982246, 0.338636367163553, 0.00173636815934475},
    {0.352482461135478, -0.123384449130048, -0.036640207614552, 0.0352840510877738, 0.117616078244268, 0.65464206627708},
    {0.144254514044104, -0.116568374669637, -0.119594790557632, 0.146585935553368, 0.488630481309112, 0.456692234320686},
    {-0.0585120870225412, -0.0960538647466012, -0.0543309414249184, 0.227214213208259, 0.75739729013635, 0.224285389849452},
    {-0.124504469204174, -0.0603987775714151, 0.271876837668966, 0.19549860142211, 0.65167626994723, 0.0658515377372835},
    {-0.0643063527627087, -0.0217044058396818, 0.723813068870285, 0.0819917787365635, 0.273311911925214, 0.00689399907032831},
    {-0.0191125161665053, -0.0191125161665052, -0.036640207614552, 0.0764500646660208, 0.0764500646660208, 0.921965110615521},
    {-0.0794020521078101, -0.07940205210781, -0.119594790557632, 0.31760820843124, 0.31760820843124, 0.643182477910772},
    {-0.123076437918076, -0.123076437918076, -0.0543309414249183, 0.492305751672305, 0.492305751672305, 0.315872313916462},
    {-0.105896858921168, -0.105896858921168, 0.271876837668966, 0.42358743568467, 0.42358743568467, 0.092742008804029},
    {-0.0444129613327222, -0.0444129613327222, 0.723813068870285, 0.177651845330889, 0.177651845330889, 0.00970916313338213},
    {-0.123384449130048, 0.352482461135478, -0.036640207614552, 0.117616078244268, 0.0352840510877737, 0.65464206627708},
    {-0.116568374669637, 0.144254514044104, -0.119594790557632, 0.488630481309112, 0.146585935553368, 0.456692234320686},
    {-0.0960538647466012, -0.0585120870225412, -0.0543309414249183, 0.75739729013635, 0.227214213208259, 0.224285389849452},
    {-0.0603987775714152, -0.124504469204174, 0.271876837668966, 0.65167626994723, 0.195498601422111, 0.0658515377372835},
    {-0.0217044058396819, -0.0643063527627086, 0.723813068870285, 0.273311911925214, 0.0819917787365634, 0.00689399907032831},
    {-0.0409849230988147, 0.759842524889054, -0.036640207614552, 0.145727572487076, 0.00717255684496518, 0.164882476492272},
    {-0.0347905350890822, 0.404143384962011, -0.119594790557632, 0.605418365816316, 0.0297980510461639, 0.115025523822223},
    {-0.024974455938375, 0.03820389372017, -0.0543309414249183, 0.938423301877431, 0.0461882014671776, 0.0564900002985144},
    {-0.0138776265525464, -0.121759885907613, 0.271876837668966, 0.807433832894958, 0.0397410384743823, 0.0165858034218536},
    {-0.00457955736373822, -0.0762735703276687, 0.723813068870285, 0.338636367163553, 0.0166673234982245, 0.00173636815934475}};
    
    // Array of non-zero columns
    static const unsigned int nzc3[6] = {6, 7, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc0[6] = {0, 1, 2, 3, 4, 5};
    
    static const double FE1_C0_D01[25][5] = \
    {{-2.66059019751491, -0.840760571794125, 0.180170374279214, 3.50135076930903, -0.180170374279214},
    {-2.05746131912512, -0.207946328505567, 0.150485009380445, 2.26540764763069, -0.150485009380444},
    {-1.14264217923257, 0.751899240989545, 0.105458579777884, 0.390742938243027, -0.105458579777884},
    {-0.160999729003171, 1.78185709341454, 0.0571431775822848, -1.62085736441137, -0.0571431775822853},
    {0.624348810664879, 2.60585965680469, 0.0184891538601839, -3.23020846746957, -0.018489153860185},
    {-1.95444613358461, -0.840760571794125, 0.886314438209516, 2.79520670537873, -0.886314438209517},
    {-1.46766348743601, -0.207946328505567, 0.740282841069557, 1.67560981594158, -0.740282841069557},
    {-0.729317011881439, 0.751899240989545, 0.518783747129017, -0.0225822291081058, -0.518783747129016},
    {0.0629622614476708, 1.78185709341454, 0.281105168033126, -1.84481935486221, -0.281105168033127},
    {0.69681358905975, 2.60585965680469, 0.0909539322550548, -3.30267324586444, -0.0909539322550554},
    {-0.920380285897063, -0.840760571794125, 1.92038028589706, 1.76114085769119, -1.92038028589706},
    {-0.603973164252784, -0.207946328505567, 1.60397316425278, 0.811919492758351, -1.60397316425278},
    {-0.124050379505228, 0.751899240989545, 1.12405037950523, -0.627848861484317, -1.12405037950523},
    {0.390928546707272, 1.78185709341454, 0.609071453292727, -2.17278564012182, -0.609071453292728},
    {0.802929828402347, 2.60585965680469, 0.197070171597651, -3.40878948520704, -0.197070171597652},
    {0.113685561790483, -0.840760571794125, 2.95444613358461, 0.727075010003643, -2.95444613358461},
    {0.259717158930442, -0.207946328505567, 2.46766348743601, -0.0517708304248751, -2.46766348743601},
    {0.481216252870984, 0.751899240989545, 1.72931701188144, -1.23311549386053, -1.72931701188144},
    {0.718894831966873, 1.78185709341454, 0.937037738552328, -2.50075192538142, -0.937037738552328},
    {0.909046067744943, 2.60585965680469, 0.303186410940248, -3.51490572454964, -0.303186410940249},
    {0.819829625720786, -0.840760571794124, 3.66059019751491, 0.0209309460733402, -3.66059019751491},
    {0.849514990619555, -0.207946328505566, 3.05746131912512, -0.641568662113988, -3.05746131912512},
    {0.894541420222117, 0.751899240989545, 2.14264217923257, -1.64644066121166, -2.14264217923257},
    {0.942856822417714, 1.78185709341454, 1.16099972900317, -2.72471391583226, -1.16099972900317},
    {0.981510846139814, 2.60585965680469, 0.375651189335118, -3.58737050294451, -0.375651189335119}};
    
    // Array of non-zero columns
    static const unsigned int nzc4[5] = {6, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc1[5] = {0, 2, 3, 4, 5};
    
    static const double FE1_C0_D10[25][5] = \
    {{-2.66059019751491, -0.819829625720785, 0.159239428205874, -0.159239428205874, 3.48041982323569},
    {-2.05746131912512, -0.849514990619555, 0.792053671494433, -0.792053671494433, 2.90697630974468},
    {-1.14264217923257, -0.894541420222116, 1.75189924098954, -1.75189924098955, 2.03718359945469},
    {-0.16099972900317, -0.942856822417715, 2.78185709341454, -2.78185709341454, 1.10385655142089},
    {0.62434881066488, -0.981510846139815, 3.60585965680469, -3.60585965680469, 0.357162035474935},
    {-1.95444613358461, -0.113685561790483, 0.159239428205874, -0.159239428205874, 2.06813169537509},
    {-1.46766348743601, -0.259717158930442, 0.792053671494433, -0.792053671494433, 1.72738064636645},
    {-0.729317011881439, -0.481216252870984, 1.75189924098954, -1.75189924098955, 1.21053326475242},
    {0.0629622614476711, -0.718894831966874, 2.78185709341454, -2.78185709341454, 0.655932570519203},
    {0.69681358905975, -0.909046067744944, 3.60585965680469, -3.60585965680469, 0.212232478685194},
    {-0.920380285897063, 0.920380285897062, 0.159239428205874, -0.159239428205874, 0.0},
    {-0.603973164252784, 0.603973164252784, 0.792053671494433, -0.792053671494433, 0.0},
    {-0.124050379505228, 0.124050379505228, 1.75189924098954, -1.75189924098955, 0.0},
    {0.390928546707272, -0.390928546707272, 2.78185709341454, -2.78185709341454, 0.0},
    {0.802929828402347, -0.802929828402348, 3.60585965680469, -3.60585965680469, 0.0},
    {0.113685561790483, 1.95444613358461, 0.159239428205874, -0.159239428205874, -2.06813169537509},
    {0.259717158930442, 1.46766348743601, 0.792053671494433, -0.792053671494433, -1.72738064636645},
    {0.481216252870983, 0.729317011881439, 1.75189924098954, -1.75189924098955, -1.21053326475242},
    {0.718894831966873, -0.0629622614476716, 2.78185709341454, -2.78185709341454, -0.655932570519201},
    {0.909046067744944, -0.696813589059751, 3.60585965680469, -3.60585965680469, -0.212232478685193},
    {0.819829625720785, 2.66059019751491, 0.159239428205874, -0.159239428205874, -3.4804198232357},
    {0.849514990619555, 2.05746131912512, 0.792053671494433, -0.792053671494433, -2.90697630974468},
    {0.894541420222116, 1.14264217923257, 1.75189924098954, -1.75189924098955, -2.03718359945469},
    {0.942856822417714, 0.16099972900317, 2.78185709341454, -2.78185709341454, -1.10385655142088},
    {0.981510846139815, -0.624348810664881, 3.60585965680469, -3.60585965680469, -0.357162035474934}};
    
    // Array of non-zero columns
    static const unsigned int nzc5[5] = {6, 7, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc2[5] = {0, 1, 3, 4, 5};
    
    static const double FE1_C2[25][3] = \
    {{0.915147549378728, 0.0450425935698037, 0.0398098570514687},
    {0.764365329781281, 0.0376212523451112, 0.198013417873608},
    {0.535660544808143, 0.026364644944471, 0.437974810247386},
    {0.290249932250793, 0.0142857943955714, 0.695464273353636},
    {0.09391279733378, 0.00462228846504648, 0.901464914201173},
    {0.738611533396152, 0.221578609552379, 0.0398098570514687},
    {0.616915871859002, 0.185070710267389, 0.198013417873608},
    {0.43232925297036, 0.129695936782254, 0.437974810247386},
    {0.234259434638082, 0.0702762920082818, 0.695464273353636},
    {0.0757966027350624, 0.0227384830637641, 0.901464914201173},
    {0.480095071474266, 0.480095071474266, 0.0398098570514687},
    {0.400993291063196, 0.400993291063196, 0.198013417873608},
    {0.281012594876307, 0.281012594876307, 0.437974810247386},
    {0.152267863323182, 0.152267863323182, 0.695464273353636},
    {0.0492675428994132, 0.0492675428994133, 0.901464914201173},
    {0.221578609552379, 0.738611533396152, 0.0398098570514687},
    {0.185070710267389, 0.616915871859002, 0.198013417873608},
    {0.129695936782254, 0.43232925297036, 0.437974810247386},
    {0.0702762920082818, 0.234259434638082, 0.695464273353636},
    {0.022738483063764, 0.0757966027350624, 0.901464914201173},
    {0.0450425935698037, 0.915147549378728, 0.0398098570514687},
    {0.0376212523451112, 0.764365329781281, 0.198013417873608},
    {0.0263646449444709, 0.535660544808143, 0.437974810247386},
    {0.0142857943955715, 0.290249932250793, 0.695464273353636},
    {0.00462228846504642, 0.0939127973337801, 0.901464914201173}};
    
    // Array of non-zero columns
    static const unsigned int nzc6[3] = {12, 13, 14};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.0;
    }// end loop over 'r'
    // Number of operations to compute geometry constants: 23.
    double G[11];
    G[0] =  - K_00*det;
    G[1] =  - K_10*det;
    G[2] =  - K_01*det;
    G[3] =  - K_11*det;
    G[4] =  - det*w[2][0]*(K_00*K_10 + K_01*K_11);
    G[5] =  - det*w[2][0]*(K_10*K_10 + K_11*K_11);
    G[6] = K_10*det;
    G[7] =  - det*w[2][0]*(K_00*K_00 + K_01*K_01);
    G[8] = K_00*det;
    G[9] = K_11*det;
    G[10] = K_01*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 5825
    for (unsigned int ip = 0; ip < 25; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      
      // Total number of operations to compute function values = 6
      for (unsigned int r = 0; r < 1; r++)
      {
        F4 += FE0[ip][r]*w[3][r];
        F7 += FE0_D10[ip][r]*w[3][r];
        F8 += FE0_D01[ip][r]*w[3][r];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 6
      for (unsigned int r = 0; r < 3; r++)
      {
        F9 += FE1_C2[ip][r]*w[0][nzc6[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 40
      for (unsigned int r = 0; r < 5; r++)
      {
        F0 += FE1_C0_D10[ip][r]*w[0][nzc2[r]];
        F1 += FE1_C0_D01[ip][r]*w[0][nzc1[r]];
        F5 += FE1_C0_D10[ip][r]*w[0][nzc5[r]];
        F6 += FE1_C0_D01[ip][r]*w[0][nzc4[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 24
      for (unsigned int r = 0; r < 6; r++)
      {
        F2 += FE1_C0[ip][r]*w[0][nzc0[r]];
        F3 += FE1_C0[ip][r]*w[0][nzc3[r]];
      }// end loop over 'r'
      
      // Number of operations to compute ip constants: 87
      double I[7];
      // Number of operations: 9
      I[0] = F4*W25[ip]*(F0*G[0] + F1*G[1] + F5*G[2] + F6*G[3]);
      
      // Number of operations: 7
      I[1] = F4*W25[ip]*(F0*G[4] + F1*G[5] + F9*G[6]);
      
      // Number of operations: 7
      I[2] = F4*W25[ip]*(F0*G[7] + F1*G[4] + F9*G[8]);
      
      // Number of operations: 7
      I[3] = F4*W25[ip]*(F5*G[4] + F6*G[5] + F9*G[9]);
      
      // Number of operations: 7
      I[4] = F4*W25[ip]*(F5*G[7] + F6*G[4] + F9*G[10]);
      
      // Number of operations: 25
      I[5] = W25[ip]*(F4*(F2*(F0*G[0] + F1*G[1]) + F3*(F0*G[2] + F1*G[3])) + F7*(F0*G[7] + F1*G[4] + F9*G[8]) + F8*(F0*G[4] + F1*G[5] + F9*G[6]));
      
      // Number of operations: 25
      I[6] = W25[ip]*(F5*(F4*(F2*G[0] + F3*G[2]) + F7*G[7] + F8*G[4]) + F6*(F4*(F2*G[1] + F3*G[3]) + F7*G[4] + F8*G[5]) + F9*(F7*G[10] + F8*G[9]));
      
      
      // Number of operations for primary indices: 6
      for (unsigned int j = 0; j < 3; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc6[j]] += FE1_C2[ip][j]*I[0];
      }// end loop over 'j'
      
      // Number of operations for primary indices: 40
      for (unsigned int j = 0; j < 5; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc1[j]] += FE1_C0_D01[ip][j]*I[1];
        // Number of operations to compute entry: 2
        A[nzc2[j]] += FE1_C0_D10[ip][j]*I[2];
        // Number of operations to compute entry: 2
        A[nzc4[j]] += FE1_C0_D01[ip][j]*I[3];
        // Number of operations to compute entry: 2
        A[nzc5[j]] += FE1_C0_D10[ip][j]*I[4];
      }// end loop over 'j'
      
      // Number of operations for primary indices: 24
      for (unsigned int j = 0; j < 6; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc0[j]] += FE1_C0[ip][j]*I[5];
        // Number of operations to compute entry: 2
        A[nzc3[j]] += FE1_C0[ip][j]*I[6];
      }// end loop over 'j'
    }// end loop over 'ip'
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not yet implemented (introduced in UFC 2.0).");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_4_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_4_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_4_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Extract vertex coordinates
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    
    
    // Cell Volume.
    
    // Compute circumradius, assuming triangle is embedded in 2D.
    
    
    // Facet Area.
    
    // Array of quadrature weights.
    // Value of basis functions at quadrature points.
    static const double FE1_f0[4][2] = \
    {{0.930568155797026, 0.0694318442029737},
    {0.669990521792428, 0.330009478207572},
    {0.330009478207572, 0.669990521792428},
    {0.0694318442029738, 0.930568155797026}};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 1};
    
    // Array of non-zero columns
    static const unsigned int nzc0[2] = {1, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 2};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.0;
    }// end loop over 'r'
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    switch (facet)
    {
    case 0:
      {
        // Total number of operations to compute element tensor (from this point): 16
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 16
      for (unsigned int ip = 0; ip < 4; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE1_f0[ip][r]*w[1][nzc0[r]];
        }// end loop over 'r'
      }// end loop over 'ip'
        break;
      }
    case 1:
      {
        // Total number of operations to compute element tensor (from this point): 16
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 16
      for (unsigned int ip = 0; ip < 4; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE1_f0[ip][r]*w[1][nzc1[r]];
        }// end loop over 'r'
      }// end loop over 'ip'
        break;
      }
    case 2:
      {
        // Total number of operations to compute element tensor (from this point): 16
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 16
      for (unsigned int ip = 0; ip < 4; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE1_f0[ip][r]*w[1][nzc2[r]];
        }// end loop over 'r'
      }// end loop over 'ip'
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not yet implemented (introduced in UFC 2.0).");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_5_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_5_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_5_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      9
    // Number of operations (multiply-add pairs) for geometry tensor:    6
    // Number of operations (multiply-add pairs) for tensor contraction: 165
    // Total number of operations (multiply-add pairs):                  180
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x[v1][0] - x[v0][0];
    const double dx1 = x[v1][1] - x[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    // Compute geometry tensor
    const double G0_0 = det*w[0][0]*(1.0);
    const double G0_1 = det*w[0][1]*(1.0);
    const double G0_2 = det*w[0][2]*(1.0);
    const double G0_3 = det*w[0][3]*(1.0);
    const double G0_4 = det*w[0][4]*(1.0);
    const double G0_5 = det*w[0][5]*(1.0);
    
    // Compute element tensor
    switch (facet)
    {
    case 0:
      {
        A[0] = 0.0;
      A[1] = 0.0;
      A[2] = 0.0;
      A[3] = 0.0;
      A[4] = 0.0;
      A[5] = 0.0;
      A[6] = 0.0;
      A[7] = 0.0;
      A[8] = 0.0;
      A[9] = 0.0;
      A[10] = 0.0;
      A[11] = 0.0;
      A[12] = 0.0;
      A[13] = 0.0;
      A[14] = 0.0;
      A[15] = 0.0;
      A[16] = 0.0928571428571428*G0_1 - 0.00714285714285714*G0_2 + 0.0476190476190476*G0_3;
      A[17] = -0.00714285714285714*G0_1 - 0.00714285714285713*G0_2 - 0.019047619047619*G0_3;
      A[18] = 0.0476190476190476*G0_1 - 0.019047619047619*G0_2 + 0.0380952380952381*G0_3;
      A[19] = 0.0;
      A[20] = 0.0;
      A[21] = 0.0;
      A[22] = 0.0;
      A[23] = 0.0;
      A[24] = 0.0;
      A[25] = 0.0;
      A[26] = 0.0;
      A[27] = 0.0;
      A[28] = 0.0;
      A[29] = 0.0;
      A[30] = 0.0;
      A[31] = -0.00714285714285714*G0_1 - 0.00714285714285713*G0_2 - 0.019047619047619*G0_3;
      A[32] = -0.00714285714285713*G0_1 + 0.0928571428571428*G0_2 + 0.0476190476190476*G0_3;
      A[33] = -0.019047619047619*G0_1 + 0.0476190476190476*G0_2 + 0.0380952380952381*G0_3;
      A[34] = 0.0;
      A[35] = 0.0;
      A[36] = 0.0;
      A[37] = 0.0;
      A[38] = 0.0;
      A[39] = 0.0;
      A[40] = 0.0;
      A[41] = 0.0;
      A[42] = 0.0;
      A[43] = 0.0;
      A[44] = 0.0;
      A[45] = 0.0;
      A[46] = 0.0476190476190476*G0_1 - 0.019047619047619*G0_2 + 0.0380952380952381*G0_3;
      A[47] = -0.019047619047619*G0_1 + 0.0476190476190476*G0_2 + 0.0380952380952381*G0_3;
      A[48] = 0.0380952380952381*G0_1 + 0.0380952380952381*G0_2 + 0.457142857142857*G0_3;
      A[49] = 0.0;
      A[50] = 0.0;
      A[51] = 0.0;
      A[52] = 0.0;
      A[53] = 0.0;
      A[54] = 0.0;
      A[55] = 0.0;
      A[56] = 0.0;
      A[57] = 0.0;
      A[58] = 0.0;
      A[59] = 0.0;
      A[60] = 0.0;
      A[61] = 0.0;
      A[62] = 0.0;
      A[63] = 0.0;
      A[64] = 0.0;
      A[65] = 0.0;
      A[66] = 0.0;
      A[67] = 0.0;
      A[68] = 0.0;
      A[69] = 0.0;
      A[70] = 0.0;
      A[71] = 0.0;
      A[72] = 0.0;
      A[73] = 0.0;
      A[74] = 0.0;
      A[75] = 0.0;
      A[76] = 0.0;
      A[77] = 0.0;
      A[78] = 0.0;
      A[79] = 0.0;
      A[80] = 0.0;
      A[81] = 0.0;
      A[82] = 0.0;
      A[83] = 0.0;
      A[84] = 0.0;
      A[85] = 0.0;
      A[86] = 0.0;
      A[87] = 0.0;
      A[88] = 0.0;
      A[89] = 0.0;
      A[90] = 0.0;
      A[91] = 0.0;
      A[92] = 0.0;
      A[93] = 0.0;
      A[94] = 0.0;
      A[95] = 0.0;
      A[96] = 0.0;
      A[97] = 0.0;
      A[98] = 0.0;
      A[99] = 0.0;
      A[100] = 0.0;
      A[101] = 0.0;
      A[102] = 0.0;
      A[103] = 0.0;
      A[104] = 0.0;
      A[105] = 0.0;
      A[106] = 0.0;
      A[107] = 0.0;
      A[108] = 0.0;
      A[109] = 0.0;
      A[110] = 0.0;
      A[111] = 0.0;
      A[112] = 0.0928571428571428*G0_1 - 0.00714285714285714*G0_2 + 0.0476190476190476*G0_3;
      A[113] = -0.00714285714285714*G0_1 - 0.00714285714285713*G0_2 - 0.019047619047619*G0_3;
      A[114] = 0.0476190476190476*G0_1 - 0.019047619047619*G0_2 + 0.0380952380952381*G0_3;
      A[115] = 0.0;
      A[116] = 0.0;
      A[117] = 0.0;
      A[118] = 0.0;
      A[119] = 0.0;
      A[120] = 0.0;
      A[121] = 0.0;
      A[122] = 0.0;
      A[123] = 0.0;
      A[124] = 0.0;
      A[125] = 0.0;
      A[126] = 0.0;
      A[127] = -0.00714285714285714*G0_1 - 0.00714285714285713*G0_2 - 0.019047619047619*G0_3;
      A[128] = -0.00714285714285713*G0_1 + 0.0928571428571428*G0_2 + 0.0476190476190476*G0_3;
      A[129] = -0.019047619047619*G0_1 + 0.0476190476190476*G0_2 + 0.0380952380952381*G0_3;
      A[130] = 0.0;
      A[131] = 0.0;
      A[132] = 0.0;
      A[133] = 0.0;
      A[134] = 0.0;
      A[135] = 0.0;
      A[136] = 0.0;
      A[137] = 0.0;
      A[138] = 0.0;
      A[139] = 0.0;
      A[140] = 0.0;
      A[141] = 0.0;
      A[142] = 0.0476190476190476*G0_1 - 0.019047619047619*G0_2 + 0.0380952380952381*G0_3;
      A[143] = -0.019047619047619*G0_1 + 0.0476190476190476*G0_2 + 0.0380952380952381*G0_3;
      A[144] = 0.0380952380952381*G0_1 + 0.0380952380952381*G0_2 + 0.457142857142857*G0_3;
      A[145] = 0.0;
      A[146] = 0.0;
      A[147] = 0.0;
      A[148] = 0.0;
      A[149] = 0.0;
      A[150] = 0.0;
      A[151] = 0.0;
      A[152] = 0.0;
      A[153] = 0.0;
      A[154] = 0.0;
      A[155] = 0.0;
      A[156] = 0.0;
      A[157] = 0.0;
      A[158] = 0.0;
      A[159] = 0.0;
      A[160] = 0.0;
      A[161] = 0.0;
      A[162] = 0.0;
      A[163] = 0.0;
      A[164] = 0.0;
      A[165] = 0.0;
      A[166] = 0.0;
      A[167] = 0.0;
      A[168] = 0.0;
      A[169] = 0.0;
      A[170] = 0.0;
      A[171] = 0.0;
      A[172] = 0.0;
      A[173] = 0.0;
      A[174] = 0.0;
      A[175] = 0.0;
      A[176] = 0.0;
      A[177] = 0.0;
      A[178] = 0.0;
      A[179] = 0.0;
      A[180] = 0.0;
      A[181] = 0.0;
      A[182] = 0.0;
      A[183] = 0.0;
      A[184] = 0.0;
      A[185] = 0.0;
      A[186] = 0.0;
      A[187] = 0.0;
      A[188] = 0.0;
      A[189] = 0.0;
      A[190] = 0.0;
      A[191] = 0.0;
      A[192] = 0.0;
      A[193] = 0.0;
      A[194] = 0.0;
      A[195] = 0.0;
      A[196] = 0.0;
      A[197] = 0.0;
      A[198] = 0.0;
      A[199] = 0.0;
      A[200] = 0.0;
      A[201] = 0.0;
      A[202] = 0.0;
      A[203] = 0.0;
      A[204] = 0.0;
      A[205] = 0.0;
      A[206] = 0.0;
      A[207] = 0.0;
      A[208] = 0.15*G0_1 - 0.0166666666666666*G0_2 + 0.2*G0_3;
      A[209] = 0.0166666666666667*G0_1 + 0.0166666666666667*G0_2 + 0.133333333333333*G0_3;
      A[210] = 0.0;
      A[211] = 0.0;
      A[212] = 0.0;
      A[213] = 0.0;
      A[214] = 0.0;
      A[215] = 0.0;
      A[216] = 0.0;
      A[217] = 0.0;
      A[218] = 0.0;
      A[219] = 0.0;
      A[220] = 0.0;
      A[221] = 0.0;
      A[222] = 0.0;
      A[223] = 0.0166666666666667*G0_1 + 0.0166666666666667*G0_2 + 0.133333333333333*G0_3;
      A[224] = -0.0166666666666666*G0_1 + 0.15*G0_2 + 0.2*G0_3;
        break;
      }
    case 1:
      {
        A[0] = 0.0928571428571428*G0_0 - 0.00714285714285714*G0_2 + 0.0476190476190476*G0_4;
      A[1] = 0.0;
      A[2] = -0.00714285714285714*G0_0 - 0.00714285714285714*G0_2 - 0.019047619047619*G0_4;
      A[3] = 0.0;
      A[4] = 0.0476190476190476*G0_0 - 0.019047619047619*G0_2 + 0.0380952380952381*G0_4;
      A[5] = 0.0;
      A[6] = 0.0;
      A[7] = 0.0;
      A[8] = 0.0;
      A[9] = 0.0;
      A[10] = 0.0;
      A[11] = 0.0;
      A[12] = 0.0;
      A[13] = 0.0;
      A[14] = 0.0;
      A[15] = 0.0;
      A[16] = 0.0;
      A[17] = 0.0;
      A[18] = 0.0;
      A[19] = 0.0;
      A[20] = 0.0;
      A[21] = 0.0;
      A[22] = 0.0;
      A[23] = 0.0;
      A[24] = 0.0;
      A[25] = 0.0;
      A[26] = 0.0;
      A[27] = 0.0;
      A[28] = 0.0;
      A[29] = 0.0;
      A[30] = -0.00714285714285714*G0_0 - 0.00714285714285714*G0_2 - 0.019047619047619*G0_4;
      A[31] = 0.0;
      A[32] = -0.00714285714285714*G0_0 + 0.0928571428571428*G0_2 + 0.0476190476190476*G0_4;
      A[33] = 0.0;
      A[34] = -0.019047619047619*G0_0 + 0.0476190476190476*G0_2 + 0.0380952380952381*G0_4;
      A[35] = 0.0;
      A[36] = 0.0;
      A[37] = 0.0;
      A[38] = 0.0;
      A[39] = 0.0;
      A[40] = 0.0;
      A[41] = 0.0;
      A[42] = 0.0;
      A[43] = 0.0;
      A[44] = 0.0;
      A[45] = 0.0;
      A[46] = 0.0;
      A[47] = 0.0;
      A[48] = 0.0;
      A[49] = 0.0;
      A[50] = 0.0;
      A[51] = 0.0;
      A[52] = 0.0;
      A[53] = 0.0;
      A[54] = 0.0;
      A[55] = 0.0;
      A[56] = 0.0;
      A[57] = 0.0;
      A[58] = 0.0;
      A[59] = 0.0;
      A[60] = 0.0476190476190476*G0_0 - 0.019047619047619*G0_2 + 0.0380952380952381*G0_4;
      A[61] = 0.0;
      A[62] = -0.019047619047619*G0_0 + 0.0476190476190476*G0_2 + 0.0380952380952381*G0_4;
      A[63] = 0.0;
      A[64] = 0.0380952380952381*G0_0 + 0.0380952380952381*G0_2 + 0.457142857142857*G0_4;
      A[65] = 0.0;
      A[66] = 0.0;
      A[67] = 0.0;
      A[68] = 0.0;
      A[69] = 0.0;
      A[70] = 0.0;
      A[71] = 0.0;
      A[72] = 0.0;
      A[73] = 0.0;
      A[74] = 0.0;
      A[75] = 0.0;
      A[76] = 0.0;
      A[77] = 0.0;
      A[78] = 0.0;
      A[79] = 0.0;
      A[80] = 0.0;
      A[81] = 0.0;
      A[82] = 0.0;
      A[83] = 0.0;
      A[84] = 0.0;
      A[85] = 0.0;
      A[86] = 0.0;
      A[87] = 0.0;
      A[88] = 0.0;
      A[89] = 0.0;
      A[90] = 0.0;
      A[91] = 0.0;
      A[92] = 0.0;
      A[93] = 0.0;
      A[94] = 0.0;
      A[95] = 0.0;
      A[96] = 0.0928571428571428*G0_0 - 0.00714285714285714*G0_2 + 0.0476190476190476*G0_4;
      A[97] = 0.0;
      A[98] = -0.00714285714285714*G0_0 - 0.00714285714285714*G0_2 - 0.019047619047619*G0_4;
      A[99] = 0.0;
      A[100] = 0.0476190476190476*G0_0 - 0.019047619047619*G0_2 + 0.0380952380952381*G0_4;
      A[101] = 0.0;
      A[102] = 0.0;
      A[103] = 0.0;
      A[104] = 0.0;
      A[105] = 0.0;
      A[106] = 0.0;
      A[107] = 0.0;
      A[108] = 0.0;
      A[109] = 0.0;
      A[110] = 0.0;
      A[111] = 0.0;
      A[112] = 0.0;
      A[113] = 0.0;
      A[114] = 0.0;
      A[115] = 0.0;
      A[116] = 0.0;
      A[117] = 0.0;
      A[118] = 0.0;
      A[119] = 0.0;
      A[120] = 0.0;
      A[121] = 0.0;
      A[122] = 0.0;
      A[123] = 0.0;
      A[124] = 0.0;
      A[125] = 0.0;
      A[126] = -0.00714285714285714*G0_0 - 0.00714285714285714*G0_2 - 0.019047619047619*G0_4;
      A[127] = 0.0;
      A[128] = -0.00714285714285714*G0_0 + 0.0928571428571428*G0_2 + 0.0476190476190476*G0_4;
      A[129] = 0.0;
      A[130] = -0.019047619047619*G0_0 + 0.0476190476190476*G0_2 + 0.0380952380952381*G0_4;
      A[131] = 0.0;
      A[132] = 0.0;
      A[133] = 0.0;
      A[134] = 0.0;
      A[135] = 0.0;
      A[136] = 0.0;
      A[137] = 0.0;
      A[138] = 0.0;
      A[139] = 0.0;
      A[140] = 0.0;
      A[141] = 0.0;
      A[142] = 0.0;
      A[143] = 0.0;
      A[144] = 0.0;
      A[145] = 0.0;
      A[146] = 0.0;
      A[147] = 0.0;
      A[148] = 0.0;
      A[149] = 0.0;
      A[150] = 0.0;
      A[151] = 0.0;
      A[152] = 0.0;
      A[153] = 0.0;
      A[154] = 0.0;
      A[155] = 0.0;
      A[156] = 0.0476190476190476*G0_0 - 0.019047619047619*G0_2 + 0.0380952380952381*G0_4;
      A[157] = 0.0;
      A[158] = -0.019047619047619*G0_0 + 0.0476190476190476*G0_2 + 0.0380952380952381*G0_4;
      A[159] = 0.0;
      A[160] = 0.0380952380952381*G0_0 + 0.0380952380952381*G0_2 + 0.457142857142857*G0_4;
      A[161] = 0.0;
      A[162] = 0.0;
      A[163] = 0.0;
      A[164] = 0.0;
      A[165] = 0.0;
      A[166] = 0.0;
      A[167] = 0.0;
      A[168] = 0.0;
      A[169] = 0.0;
      A[170] = 0.0;
      A[171] = 0.0;
      A[172] = 0.0;
      A[173] = 0.0;
      A[174] = 0.0;
      A[175] = 0.0;
      A[176] = 0.0;
      A[177] = 0.0;
      A[178] = 0.0;
      A[179] = 0.0;
      A[180] = 0.0;
      A[181] = 0.0;
      A[182] = 0.0;
      A[183] = 0.0;
      A[184] = 0.0;
      A[185] = 0.0;
      A[186] = 0.0;
      A[187] = 0.0;
      A[188] = 0.0;
      A[189] = 0.0;
      A[190] = 0.0;
      A[191] = 0.0;
      A[192] = 0.15*G0_0 - 0.0166666666666667*G0_2 + 0.2*G0_4;
      A[193] = 0.0;
      A[194] = 0.0166666666666666*G0_0 + 0.0166666666666667*G0_2 + 0.133333333333333*G0_4;
      A[195] = 0.0;
      A[196] = 0.0;
      A[197] = 0.0;
      A[198] = 0.0;
      A[199] = 0.0;
      A[200] = 0.0;
      A[201] = 0.0;
      A[202] = 0.0;
      A[203] = 0.0;
      A[204] = 0.0;
      A[205] = 0.0;
      A[206] = 0.0;
      A[207] = 0.0;
      A[208] = 0.0;
      A[209] = 0.0;
      A[210] = 0.0;
      A[211] = 0.0;
      A[212] = 0.0;
      A[213] = 0.0;
      A[214] = 0.0;
      A[215] = 0.0;
      A[216] = 0.0;
      A[217] = 0.0;
      A[218] = 0.0;
      A[219] = 0.0;
      A[220] = 0.0;
      A[221] = 0.0;
      A[222] = 0.0166666666666666*G0_0 + 0.0166666666666667*G0_2 + 0.133333333333333*G0_4;
      A[223] = 0.0;
      A[224] = -0.0166666666666667*G0_0 + 0.15*G0_2 + 0.2*G0_4;
        break;
      }
    case 2:
      {
        A[0] = 0.0928571428571428*G0_0 - 0.00714285714285714*G0_1 + 0.0476190476190476*G0_5;
      A[1] = -0.00714285714285714*G0_0 - 0.00714285714285715*G0_1 - 0.019047619047619*G0_5;
      A[2] = 0.0;
      A[3] = 0.0;
      A[4] = 0.0;
      A[5] = 0.0476190476190476*G0_0 - 0.019047619047619*G0_1 + 0.038095238095238*G0_5;
      A[6] = 0.0;
      A[7] = 0.0;
      A[8] = 0.0;
      A[9] = 0.0;
      A[10] = 0.0;
      A[11] = 0.0;
      A[12] = 0.0;
      A[13] = 0.0;
      A[14] = 0.0;
      A[15] = -0.00714285714285714*G0_0 - 0.00714285714285715*G0_1 - 0.019047619047619*G0_5;
      A[16] = -0.00714285714285715*G0_0 + 0.0928571428571427*G0_1 + 0.0476190476190476*G0_5;
      A[17] = 0.0;
      A[18] = 0.0;
      A[19] = 0.0;
      A[20] = -0.019047619047619*G0_0 + 0.0476190476190476*G0_1 + 0.0380952380952381*G0_5;
      A[21] = 0.0;
      A[22] = 0.0;
      A[23] = 0.0;
      A[24] = 0.0;
      A[25] = 0.0;
      A[26] = 0.0;
      A[27] = 0.0;
      A[28] = 0.0;
      A[29] = 0.0;
      A[30] = 0.0;
      A[31] = 0.0;
      A[32] = 0.0;
      A[33] = 0.0;
      A[34] = 0.0;
      A[35] = 0.0;
      A[36] = 0.0;
      A[37] = 0.0;
      A[38] = 0.0;
      A[39] = 0.0;
      A[40] = 0.0;
      A[41] = 0.0;
      A[42] = 0.0;
      A[43] = 0.0;
      A[44] = 0.0;
      A[45] = 0.0;
      A[46] = 0.0;
      A[47] = 0.0;
      A[48] = 0.0;
      A[49] = 0.0;
      A[50] = 0.0;
      A[51] = 0.0;
      A[52] = 0.0;
      A[53] = 0.0;
      A[54] = 0.0;
      A[55] = 0.0;
      A[56] = 0.0;
      A[57] = 0.0;
      A[58] = 0.0;
      A[59] = 0.0;
      A[60] = 0.0;
      A[61] = 0.0;
      A[62] = 0.0;
      A[63] = 0.0;
      A[64] = 0.0;
      A[65] = 0.0;
      A[66] = 0.0;
      A[67] = 0.0;
      A[68] = 0.0;
      A[69] = 0.0;
      A[70] = 0.0;
      A[71] = 0.0;
      A[72] = 0.0;
      A[73] = 0.0;
      A[74] = 0.0;
      A[75] = 0.0476190476190476*G0_0 - 0.019047619047619*G0_1 + 0.038095238095238*G0_5;
      A[76] = -0.019047619047619*G0_0 + 0.0476190476190476*G0_1 + 0.0380952380952381*G0_5;
      A[77] = 0.0;
      A[78] = 0.0;
      A[79] = 0.0;
      A[80] = 0.038095238095238*G0_0 + 0.0380952380952381*G0_1 + 0.457142857142857*G0_5;
      A[81] = 0.0;
      A[82] = 0.0;
      A[83] = 0.0;
      A[84] = 0.0;
      A[85] = 0.0;
      A[86] = 0.0;
      A[87] = 0.0;
      A[88] = 0.0;
      A[89] = 0.0;
      A[90] = 0.0;
      A[91] = 0.0;
      A[92] = 0.0;
      A[93] = 0.0;
      A[94] = 0.0;
      A[95] = 0.0;
      A[96] = 0.0928571428571428*G0_0 - 0.00714285714285714*G0_1 + 0.0476190476190476*G0_5;
      A[97] = -0.00714285714285714*G0_0 - 0.00714285714285715*G0_1 - 0.019047619047619*G0_5;
      A[98] = 0.0;
      A[99] = 0.0;
      A[100] = 0.0;
      A[101] = 0.0476190476190476*G0_0 - 0.019047619047619*G0_1 + 0.038095238095238*G0_5;
      A[102] = 0.0;
      A[103] = 0.0;
      A[104] = 0.0;
      A[105] = 0.0;
      A[106] = 0.0;
      A[107] = 0.0;
      A[108] = 0.0;
      A[109] = 0.0;
      A[110] = 0.0;
      A[111] = -0.00714285714285714*G0_0 - 0.00714285714285715*G0_1 - 0.019047619047619*G0_5;
      A[112] = -0.00714285714285715*G0_0 + 0.0928571428571427*G0_1 + 0.0476190476190476*G0_5;
      A[113] = 0.0;
      A[114] = 0.0;
      A[115] = 0.0;
      A[116] = -0.019047619047619*G0_0 + 0.0476190476190476*G0_1 + 0.0380952380952381*G0_5;
      A[117] = 0.0;
      A[118] = 0.0;
      A[119] = 0.0;
      A[120] = 0.0;
      A[121] = 0.0;
      A[122] = 0.0;
      A[123] = 0.0;
      A[124] = 0.0;
      A[125] = 0.0;
      A[126] = 0.0;
      A[127] = 0.0;
      A[128] = 0.0;
      A[129] = 0.0;
      A[130] = 0.0;
      A[131] = 0.0;
      A[132] = 0.0;
      A[133] = 0.0;
      A[134] = 0.0;
      A[135] = 0.0;
      A[136] = 0.0;
      A[137] = 0.0;
      A[138] = 0.0;
      A[139] = 0.0;
      A[140] = 0.0;
      A[141] = 0.0;
      A[142] = 0.0;
      A[143] = 0.0;
      A[144] = 0.0;
      A[145] = 0.0;
      A[146] = 0.0;
      A[147] = 0.0;
      A[148] = 0.0;
      A[149] = 0.0;
      A[150] = 0.0;
      A[151] = 0.0;
      A[152] = 0.0;
      A[153] = 0.0;
      A[154] = 0.0;
      A[155] = 0.0;
      A[156] = 0.0;
      A[157] = 0.0;
      A[158] = 0.0;
      A[159] = 0.0;
      A[160] = 0.0;
      A[161] = 0.0;
      A[162] = 0.0;
      A[163] = 0.0;
      A[164] = 0.0;
      A[165] = 0.0;
      A[166] = 0.0;
      A[167] = 0.0;
      A[168] = 0.0;
      A[169] = 0.0;
      A[170] = 0.0;
      A[171] = 0.0476190476190476*G0_0 - 0.019047619047619*G0_1 + 0.038095238095238*G0_5;
      A[172] = -0.019047619047619*G0_0 + 0.0476190476190476*G0_1 + 0.0380952380952381*G0_5;
      A[173] = 0.0;
      A[174] = 0.0;
      A[175] = 0.0;
      A[176] = 0.038095238095238*G0_0 + 0.0380952380952381*G0_1 + 0.457142857142857*G0_5;
      A[177] = 0.0;
      A[178] = 0.0;
      A[179] = 0.0;
      A[180] = 0.0;
      A[181] = 0.0;
      A[182] = 0.0;
      A[183] = 0.0;
      A[184] = 0.0;
      A[185] = 0.0;
      A[186] = 0.0;
      A[187] = 0.0;
      A[188] = 0.0;
      A[189] = 0.0;
      A[190] = 0.0;
      A[191] = 0.0;
      A[192] = 0.15*G0_0 - 0.0166666666666667*G0_1 + 0.2*G0_5;
      A[193] = 0.0166666666666666*G0_0 + 0.0166666666666667*G0_1 + 0.133333333333333*G0_5;
      A[194] = 0.0;
      A[195] = 0.0;
      A[196] = 0.0;
      A[197] = 0.0;
      A[198] = 0.0;
      A[199] = 0.0;
      A[200] = 0.0;
      A[201] = 0.0;
      A[202] = 0.0;
      A[203] = 0.0;
      A[204] = 0.0;
      A[205] = 0.0;
      A[206] = 0.0;
      A[207] = 0.0166666666666666*G0_0 + 0.0166666666666667*G0_1 + 0.133333333333333*G0_5;
      A[208] = -0.0166666666666667*G0_0 + 0.15*G0_1 + 0.2*G0_5;
      A[209] = 0.0;
      A[210] = 0.0;
      A[211] = 0.0;
      A[212] = 0.0;
      A[213] = 0.0;
      A[214] = 0.0;
      A[215] = 0.0;
      A[216] = 0.0;
      A[217] = 0.0;
      A[218] = 0.0;
      A[219] = 0.0;
      A[220] = 0.0;
      A[221] = 0.0;
      A[222] = 0.0;
      A[223] = 0.0;
      A[224] = 0.0;
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the
/// interior facet tensor corresponding to the local contribution to
/// a form from the integral over an interior facet.

class adaptivenavierstokes_interior_facet_integral_5_0: public ufc::interior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_interior_facet_integral_5_0() : ufc::interior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_interior_facet_integral_5_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local interior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c0,
                               const ufc::cell& c1,
                               unsigned int facet0,
                               unsigned int facet1) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      12
    // Number of operations (multiply-add pairs) for geometry tensor:    12
    // Number of operations (multiply-add pairs) for tensor contraction: 990
    // Total number of operations (multiply-add pairs):                  1014
    
    // Extract vertex coordinates
    const double * const * x0 = c0.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet0][0];
    const unsigned int v1 = edge_vertices[facet0][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x0[v1][0] - x0[v0][0];
    const double dx1 = x0[v1][1] - x0[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    // Compute geometry tensor
    const double G0_6 = det*w[0][6]*(1.0);
    const double G0_7 = det*w[0][7]*(1.0);
    const double G0_8 = det*w[0][8]*(1.0);
    const double G0_9 = det*w[0][9]*(1.0);
    const double G0_10 = det*w[0][10]*(1.0);
    const double G0_11 = det*w[0][11]*(1.0);
    const double G1_0 = det*w[0][0]*(1.0);
    const double G1_1 = det*w[0][1]*(1.0);
    const double G1_2 = det*w[0][2]*(1.0);
    const double G1_3 = det*w[0][3]*(1.0);
    const double G1_4 = det*w[0][4]*(1.0);
    const double G1_5 = det*w[0][5]*(1.0);
    
    // Compute element tensor
    switch (facet0)
    {
    case 0:
      {
        switch (facet1)
      {
      case 0:
        {
          A[0] = 0.0;
        A[1] = 0.0;
        A[2] = 0.0;
        A[3] = 0.0;
        A[4] = 0.0;
        A[5] = 0.0;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = 0.0;
        A[31] = 0.0928571428571428*G1_1 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_3;
        A[32] = -0.00714285714285714*G1_1 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_3;
        A[33] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_3;
        A[34] = 0.0;
        A[35] = 0.0;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = 0.0;
        A[61] = -0.00714285714285714*G1_1 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_3;
        A[62] = -0.00714285714285713*G1_1 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_3;
        A[63] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[64] = 0.0;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_3;
        A[92] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[93] = 0.0380952380952381*G1_1 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_3;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0;
        A[121] = 0.0;
        A[122] = 0.0;
        A[123] = 0.0;
        A[124] = 0.0;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0;
        A[151] = 0.0;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.0;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0;
        A[187] = 0.0;
        A[188] = 0.0;
        A[189] = 0.0;
        A[190] = 0.0;
        A[191] = 0.0;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = 0.0;
        A[217] = 0.0928571428571428*G1_1 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_3;
        A[218] = -0.00714285714285714*G1_1 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_3;
        A[219] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_3;
        A[220] = 0.0;
        A[221] = 0.0;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = 0.0;
        A[247] = -0.00714285714285714*G1_1 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_3;
        A[248] = -0.00714285714285713*G1_1 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_3;
        A[249] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[250] = 0.0;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_3;
        A[278] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[279] = 0.0380952380952381*G1_1 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_3;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0;
        A[307] = 0.0;
        A[308] = 0.0;
        A[309] = 0.0;
        A[310] = 0.0;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0;
        A[337] = 0.0;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.0;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.0;
        A[373] = 0.0;
        A[374] = 0.0;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0;
        A[403] = 0.15*G1_1 - 0.0166666666666666*G1_2 + 0.2*G1_3;
        A[404] = 0.0166666666666667*G1_1 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_3;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0;
        A[433] = 0.0166666666666667*G1_1 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_3;
        A[434] = -0.0166666666666666*G1_1 + 0.15*G1_2 + 0.2*G1_3;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0;
        A[466] = 0.0;
        A[467] = 0.0;
        A[468] = 0.0;
        A[469] = 0.0;
        A[470] = 0.0;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = 0.0;
        A[496] = 0.0928571428571428*G0_7 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_9;
        A[497] = -0.00714285714285714*G0_7 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_9;
        A[498] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_9;
        A[499] = 0.0;
        A[500] = 0.0;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = 0.0;
        A[526] = -0.00714285714285714*G0_7 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_9;
        A[527] = -0.00714285714285713*G0_7 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_9;
        A[528] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[529] = 0.0;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_9;
        A[557] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[558] = 0.0380952380952381*G0_7 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_9;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0;
        A[586] = 0.0;
        A[587] = 0.0;
        A[588] = 0.0;
        A[589] = 0.0;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0;
        A[616] = 0.0;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.0;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0;
        A[652] = 0.0;
        A[653] = 0.0;
        A[654] = 0.0;
        A[655] = 0.0;
        A[656] = 0.0;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = 0.0;
        A[682] = 0.0928571428571428*G0_7 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_9;
        A[683] = -0.00714285714285714*G0_7 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_9;
        A[684] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_9;
        A[685] = 0.0;
        A[686] = 0.0;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = 0.0;
        A[712] = -0.00714285714285714*G0_7 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_9;
        A[713] = -0.00714285714285713*G0_7 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_9;
        A[714] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[715] = 0.0;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_9;
        A[743] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[744] = 0.0380952380952381*G0_7 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_9;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0;
        A[772] = 0.0;
        A[773] = 0.0;
        A[774] = 0.0;
        A[775] = 0.0;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0;
        A[802] = 0.0;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.0;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.0;
        A[838] = 0.0;
        A[839] = 0.0;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0;
        A[868] = 0.15*G0_7 - 0.0166666666666666*G0_8 + 0.2*G0_9;
        A[869] = 0.0166666666666667*G0_7 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_9;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0;
        A[898] = 0.0166666666666667*G0_7 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_9;
        A[899] = -0.0166666666666666*G0_7 + 0.15*G0_8 + 0.2*G0_9;
          break;
        }
      case 1:
        {
          A[0] = 0.0;
        A[1] = 0.0;
        A[2] = 0.0;
        A[3] = 0.0;
        A[4] = 0.0;
        A[5] = 0.0;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = 0.0;
        A[31] = 0.0928571428571428*G1_1 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_3;
        A[32] = -0.00714285714285714*G1_1 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_3;
        A[33] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_3;
        A[34] = 0.0;
        A[35] = 0.0;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = 0.0;
        A[61] = -0.00714285714285714*G1_1 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_3;
        A[62] = -0.00714285714285713*G1_1 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_3;
        A[63] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[64] = 0.0;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_3;
        A[92] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[93] = 0.0380952380952381*G1_1 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_3;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0;
        A[121] = 0.0;
        A[122] = 0.0;
        A[123] = 0.0;
        A[124] = 0.0;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0;
        A[151] = 0.0;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.0;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0;
        A[187] = 0.0;
        A[188] = 0.0;
        A[189] = 0.0;
        A[190] = 0.0;
        A[191] = 0.0;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = 0.0;
        A[217] = 0.0928571428571428*G1_1 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_3;
        A[218] = -0.00714285714285714*G1_1 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_3;
        A[219] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_3;
        A[220] = 0.0;
        A[221] = 0.0;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = 0.0;
        A[247] = -0.00714285714285714*G1_1 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_3;
        A[248] = -0.00714285714285713*G1_1 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_3;
        A[249] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[250] = 0.0;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_3;
        A[278] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[279] = 0.0380952380952381*G1_1 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_3;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0;
        A[307] = 0.0;
        A[308] = 0.0;
        A[309] = 0.0;
        A[310] = 0.0;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0;
        A[337] = 0.0;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.0;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.0;
        A[373] = 0.0;
        A[374] = 0.0;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0;
        A[403] = 0.15*G1_1 - 0.0166666666666666*G1_2 + 0.2*G1_3;
        A[404] = 0.0166666666666667*G1_1 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_3;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0;
        A[433] = 0.0166666666666667*G1_1 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_3;
        A[434] = -0.0166666666666666*G1_1 + 0.15*G1_2 + 0.2*G1_3;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_10;
        A[466] = 0.0;
        A[467] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_10;
        A[468] = 0.0;
        A[469] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[470] = 0.0;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = 0.0;
        A[496] = 0.0;
        A[497] = 0.0;
        A[498] = 0.0;
        A[499] = 0.0;
        A[500] = 0.0;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_10;
        A[526] = 0.0;
        A[527] = -0.00714285714285714*G0_6 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_10;
        A[528] = 0.0;
        A[529] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0;
        A[557] = 0.0;
        A[558] = 0.0;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[586] = 0.0;
        A[587] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[588] = 0.0;
        A[589] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_10;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0;
        A[616] = 0.0;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.0;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_10;
        A[652] = 0.0;
        A[653] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_10;
        A[654] = 0.0;
        A[655] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[656] = 0.0;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = 0.0;
        A[682] = 0.0;
        A[683] = 0.0;
        A[684] = 0.0;
        A[685] = 0.0;
        A[686] = 0.0;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_10;
        A[712] = 0.0;
        A[713] = -0.00714285714285714*G0_6 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_10;
        A[714] = 0.0;
        A[715] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0;
        A[743] = 0.0;
        A[744] = 0.0;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[772] = 0.0;
        A[773] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[774] = 0.0;
        A[775] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_10;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0;
        A[802] = 0.0;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.0;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.15*G0_6 - 0.0166666666666667*G0_8 + 0.2*G0_10;
        A[838] = 0.0;
        A[839] = 0.0166666666666666*G0_6 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_10;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0;
        A[868] = 0.0;
        A[869] = 0.0;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0166666666666666*G0_6 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_10;
        A[898] = 0.0;
        A[899] = -0.0166666666666667*G0_6 + 0.15*G0_8 + 0.2*G0_10;
          break;
        }
      case 2:
        {
          A[0] = 0.0;
        A[1] = 0.0;
        A[2] = 0.0;
        A[3] = 0.0;
        A[4] = 0.0;
        A[5] = 0.0;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = 0.0;
        A[31] = 0.0928571428571428*G1_1 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_3;
        A[32] = -0.00714285714285714*G1_1 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_3;
        A[33] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_3;
        A[34] = 0.0;
        A[35] = 0.0;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = 0.0;
        A[61] = -0.00714285714285714*G1_1 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_3;
        A[62] = -0.00714285714285713*G1_1 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_3;
        A[63] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[64] = 0.0;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_3;
        A[92] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[93] = 0.0380952380952381*G1_1 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_3;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0;
        A[121] = 0.0;
        A[122] = 0.0;
        A[123] = 0.0;
        A[124] = 0.0;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0;
        A[151] = 0.0;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.0;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0;
        A[187] = 0.0;
        A[188] = 0.0;
        A[189] = 0.0;
        A[190] = 0.0;
        A[191] = 0.0;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = 0.0;
        A[217] = 0.0928571428571428*G1_1 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_3;
        A[218] = -0.00714285714285714*G1_1 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_3;
        A[219] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_3;
        A[220] = 0.0;
        A[221] = 0.0;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = 0.0;
        A[247] = -0.00714285714285714*G1_1 - 0.00714285714285713*G1_2 - 0.019047619047619*G1_3;
        A[248] = -0.00714285714285713*G1_1 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_3;
        A[249] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[250] = 0.0;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0476190476190476*G1_1 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_3;
        A[278] = -0.019047619047619*G1_1 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_3;
        A[279] = 0.0380952380952381*G1_1 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_3;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0;
        A[307] = 0.0;
        A[308] = 0.0;
        A[309] = 0.0;
        A[310] = 0.0;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0;
        A[337] = 0.0;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.0;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.0;
        A[373] = 0.0;
        A[374] = 0.0;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0;
        A[403] = 0.15*G1_1 - 0.0166666666666666*G1_2 + 0.2*G1_3;
        A[404] = 0.0166666666666667*G1_1 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_3;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0;
        A[433] = 0.0166666666666667*G1_1 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_3;
        A[434] = -0.0166666666666666*G1_1 + 0.15*G1_2 + 0.2*G1_3;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_7 + 0.0476190476190476*G0_11;
        A[466] = -0.00714285714285714*G0_6 - 0.00714285714285715*G0_7 - 0.019047619047619*G0_11;
        A[467] = 0.0;
        A[468] = 0.0;
        A[469] = 0.0;
        A[470] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = -0.00714285714285714*G0_6 - 0.00714285714285715*G0_7 - 0.019047619047619*G0_11;
        A[496] = -0.00714285714285715*G0_6 + 0.0928571428571427*G0_7 + 0.0476190476190476*G0_11;
        A[497] = 0.0;
        A[498] = 0.0;
        A[499] = 0.0;
        A[500] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = 0.0;
        A[526] = 0.0;
        A[527] = 0.0;
        A[528] = 0.0;
        A[529] = 0.0;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0;
        A[557] = 0.0;
        A[558] = 0.0;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0;
        A[586] = 0.0;
        A[587] = 0.0;
        A[588] = 0.0;
        A[589] = 0.0;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[616] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.038095238095238*G0_6 + 0.0380952380952381*G0_7 + 0.457142857142857*G0_11;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_7 + 0.0476190476190476*G0_11;
        A[652] = -0.00714285714285714*G0_6 - 0.00714285714285715*G0_7 - 0.019047619047619*G0_11;
        A[653] = 0.0;
        A[654] = 0.0;
        A[655] = 0.0;
        A[656] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = -0.00714285714285714*G0_6 - 0.00714285714285715*G0_7 - 0.019047619047619*G0_11;
        A[682] = -0.00714285714285715*G0_6 + 0.0928571428571427*G0_7 + 0.0476190476190476*G0_11;
        A[683] = 0.0;
        A[684] = 0.0;
        A[685] = 0.0;
        A[686] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = 0.0;
        A[712] = 0.0;
        A[713] = 0.0;
        A[714] = 0.0;
        A[715] = 0.0;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0;
        A[743] = 0.0;
        A[744] = 0.0;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0;
        A[772] = 0.0;
        A[773] = 0.0;
        A[774] = 0.0;
        A[775] = 0.0;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[802] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.038095238095238*G0_6 + 0.0380952380952381*G0_7 + 0.457142857142857*G0_11;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.15*G0_6 - 0.0166666666666667*G0_7 + 0.2*G0_11;
        A[838] = 0.0166666666666666*G0_6 + 0.0166666666666667*G0_7 + 0.133333333333333*G0_11;
        A[839] = 0.0;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0166666666666666*G0_6 + 0.0166666666666667*G0_7 + 0.133333333333333*G0_11;
        A[868] = -0.0166666666666667*G0_6 + 0.15*G0_7 + 0.2*G0_11;
        A[869] = 0.0;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0;
        A[898] = 0.0;
        A[899] = 0.0;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        switch (facet1)
      {
      case 0:
        {
          A[0] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_4;
        A[1] = 0.0;
        A[2] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_4;
        A[3] = 0.0;
        A[4] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[5] = 0.0;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = 0.0;
        A[31] = 0.0;
        A[32] = 0.0;
        A[33] = 0.0;
        A[34] = 0.0;
        A[35] = 0.0;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_4;
        A[61] = 0.0;
        A[62] = -0.00714285714285714*G1_0 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_4;
        A[63] = 0.0;
        A[64] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0;
        A[92] = 0.0;
        A[93] = 0.0;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[121] = 0.0;
        A[122] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[123] = 0.0;
        A[124] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_4;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0;
        A[151] = 0.0;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.0;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_4;
        A[187] = 0.0;
        A[188] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_4;
        A[189] = 0.0;
        A[190] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[191] = 0.0;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = 0.0;
        A[217] = 0.0;
        A[218] = 0.0;
        A[219] = 0.0;
        A[220] = 0.0;
        A[221] = 0.0;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_4;
        A[247] = 0.0;
        A[248] = -0.00714285714285714*G1_0 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_4;
        A[249] = 0.0;
        A[250] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0;
        A[278] = 0.0;
        A[279] = 0.0;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[307] = 0.0;
        A[308] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[309] = 0.0;
        A[310] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_4;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0;
        A[337] = 0.0;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.0;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.15*G1_0 - 0.0166666666666667*G1_2 + 0.2*G1_4;
        A[373] = 0.0;
        A[374] = 0.0166666666666666*G1_0 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_4;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0;
        A[403] = 0.0;
        A[404] = 0.0;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0166666666666666*G1_0 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_4;
        A[433] = 0.0;
        A[434] = -0.0166666666666667*G1_0 + 0.15*G1_2 + 0.2*G1_4;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0;
        A[466] = 0.0;
        A[467] = 0.0;
        A[468] = 0.0;
        A[469] = 0.0;
        A[470] = 0.0;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = 0.0;
        A[496] = 0.0928571428571428*G0_7 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_9;
        A[497] = -0.00714285714285714*G0_7 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_9;
        A[498] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_9;
        A[499] = 0.0;
        A[500] = 0.0;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = 0.0;
        A[526] = -0.00714285714285714*G0_7 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_9;
        A[527] = -0.00714285714285713*G0_7 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_9;
        A[528] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[529] = 0.0;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_9;
        A[557] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[558] = 0.0380952380952381*G0_7 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_9;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0;
        A[586] = 0.0;
        A[587] = 0.0;
        A[588] = 0.0;
        A[589] = 0.0;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0;
        A[616] = 0.0;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.0;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0;
        A[652] = 0.0;
        A[653] = 0.0;
        A[654] = 0.0;
        A[655] = 0.0;
        A[656] = 0.0;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = 0.0;
        A[682] = 0.0928571428571428*G0_7 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_9;
        A[683] = -0.00714285714285714*G0_7 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_9;
        A[684] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_9;
        A[685] = 0.0;
        A[686] = 0.0;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = 0.0;
        A[712] = -0.00714285714285714*G0_7 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_9;
        A[713] = -0.00714285714285713*G0_7 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_9;
        A[714] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[715] = 0.0;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_9;
        A[743] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[744] = 0.0380952380952381*G0_7 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_9;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0;
        A[772] = 0.0;
        A[773] = 0.0;
        A[774] = 0.0;
        A[775] = 0.0;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0;
        A[802] = 0.0;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.0;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.0;
        A[838] = 0.0;
        A[839] = 0.0;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0;
        A[868] = 0.15*G0_7 - 0.0166666666666666*G0_8 + 0.2*G0_9;
        A[869] = 0.0166666666666667*G0_7 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_9;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0;
        A[898] = 0.0166666666666667*G0_7 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_9;
        A[899] = -0.0166666666666666*G0_7 + 0.15*G0_8 + 0.2*G0_9;
          break;
        }
      case 1:
        {
          A[0] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_4;
        A[1] = 0.0;
        A[2] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_4;
        A[3] = 0.0;
        A[4] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[5] = 0.0;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = 0.0;
        A[31] = 0.0;
        A[32] = 0.0;
        A[33] = 0.0;
        A[34] = 0.0;
        A[35] = 0.0;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_4;
        A[61] = 0.0;
        A[62] = -0.00714285714285714*G1_0 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_4;
        A[63] = 0.0;
        A[64] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0;
        A[92] = 0.0;
        A[93] = 0.0;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[121] = 0.0;
        A[122] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[123] = 0.0;
        A[124] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_4;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0;
        A[151] = 0.0;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.0;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_4;
        A[187] = 0.0;
        A[188] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_4;
        A[189] = 0.0;
        A[190] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[191] = 0.0;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = 0.0;
        A[217] = 0.0;
        A[218] = 0.0;
        A[219] = 0.0;
        A[220] = 0.0;
        A[221] = 0.0;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_4;
        A[247] = 0.0;
        A[248] = -0.00714285714285714*G1_0 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_4;
        A[249] = 0.0;
        A[250] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0;
        A[278] = 0.0;
        A[279] = 0.0;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[307] = 0.0;
        A[308] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[309] = 0.0;
        A[310] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_4;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0;
        A[337] = 0.0;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.0;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.15*G1_0 - 0.0166666666666667*G1_2 + 0.2*G1_4;
        A[373] = 0.0;
        A[374] = 0.0166666666666666*G1_0 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_4;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0;
        A[403] = 0.0;
        A[404] = 0.0;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0166666666666666*G1_0 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_4;
        A[433] = 0.0;
        A[434] = -0.0166666666666667*G1_0 + 0.15*G1_2 + 0.2*G1_4;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_10;
        A[466] = 0.0;
        A[467] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_10;
        A[468] = 0.0;
        A[469] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[470] = 0.0;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = 0.0;
        A[496] = 0.0;
        A[497] = 0.0;
        A[498] = 0.0;
        A[499] = 0.0;
        A[500] = 0.0;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_10;
        A[526] = 0.0;
        A[527] = -0.00714285714285714*G0_6 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_10;
        A[528] = 0.0;
        A[529] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0;
        A[557] = 0.0;
        A[558] = 0.0;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[586] = 0.0;
        A[587] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[588] = 0.0;
        A[589] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_10;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0;
        A[616] = 0.0;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.0;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_10;
        A[652] = 0.0;
        A[653] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_10;
        A[654] = 0.0;
        A[655] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[656] = 0.0;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = 0.0;
        A[682] = 0.0;
        A[683] = 0.0;
        A[684] = 0.0;
        A[685] = 0.0;
        A[686] = 0.0;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_10;
        A[712] = 0.0;
        A[713] = -0.00714285714285714*G0_6 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_10;
        A[714] = 0.0;
        A[715] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0;
        A[743] = 0.0;
        A[744] = 0.0;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[772] = 0.0;
        A[773] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[774] = 0.0;
        A[775] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_10;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0;
        A[802] = 0.0;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.0;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.15*G0_6 - 0.0166666666666667*G0_8 + 0.2*G0_10;
        A[838] = 0.0;
        A[839] = 0.0166666666666666*G0_6 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_10;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0;
        A[868] = 0.0;
        A[869] = 0.0;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0166666666666666*G0_6 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_10;
        A[898] = 0.0;
        A[899] = -0.0166666666666667*G0_6 + 0.15*G0_8 + 0.2*G0_10;
          break;
        }
      case 2:
        {
          A[0] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_4;
        A[1] = 0.0;
        A[2] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_4;
        A[3] = 0.0;
        A[4] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[5] = 0.0;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = 0.0;
        A[31] = 0.0;
        A[32] = 0.0;
        A[33] = 0.0;
        A[34] = 0.0;
        A[35] = 0.0;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_4;
        A[61] = 0.0;
        A[62] = -0.00714285714285714*G1_0 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_4;
        A[63] = 0.0;
        A[64] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0;
        A[92] = 0.0;
        A[93] = 0.0;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[121] = 0.0;
        A[122] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[123] = 0.0;
        A[124] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_4;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0;
        A[151] = 0.0;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.0;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_2 + 0.0476190476190476*G1_4;
        A[187] = 0.0;
        A[188] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_4;
        A[189] = 0.0;
        A[190] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[191] = 0.0;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = 0.0;
        A[217] = 0.0;
        A[218] = 0.0;
        A[219] = 0.0;
        A[220] = 0.0;
        A[221] = 0.0;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = -0.00714285714285714*G1_0 - 0.00714285714285714*G1_2 - 0.019047619047619*G1_4;
        A[247] = 0.0;
        A[248] = -0.00714285714285714*G1_0 + 0.0928571428571428*G1_2 + 0.0476190476190476*G1_4;
        A[249] = 0.0;
        A[250] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0;
        A[278] = 0.0;
        A[279] = 0.0;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_2 + 0.0380952380952381*G1_4;
        A[307] = 0.0;
        A[308] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_2 + 0.0380952380952381*G1_4;
        A[309] = 0.0;
        A[310] = 0.0380952380952381*G1_0 + 0.0380952380952381*G1_2 + 0.457142857142857*G1_4;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0;
        A[337] = 0.0;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.0;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.15*G1_0 - 0.0166666666666667*G1_2 + 0.2*G1_4;
        A[373] = 0.0;
        A[374] = 0.0166666666666666*G1_0 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_4;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0;
        A[403] = 0.0;
        A[404] = 0.0;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0166666666666666*G1_0 + 0.0166666666666667*G1_2 + 0.133333333333333*G1_4;
        A[433] = 0.0;
        A[434] = -0.0166666666666667*G1_0 + 0.15*G1_2 + 0.2*G1_4;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_7 + 0.0476190476190476*G0_11;
        A[466] = -0.00714285714285714*G0_6 - 0.00714285714285715*G0_7 - 0.019047619047619*G0_11;
        A[467] = 0.0;
        A[468] = 0.0;
        A[469] = 0.0;
        A[470] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = -0.00714285714285714*G0_6 - 0.00714285714285715*G0_7 - 0.019047619047619*G0_11;
        A[496] = -0.00714285714285715*G0_6 + 0.0928571428571427*G0_7 + 0.0476190476190476*G0_11;
        A[497] = 0.0;
        A[498] = 0.0;
        A[499] = 0.0;
        A[500] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = 0.0;
        A[526] = 0.0;
        A[527] = 0.0;
        A[528] = 0.0;
        A[529] = 0.0;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0;
        A[557] = 0.0;
        A[558] = 0.0;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0;
        A[586] = 0.0;
        A[587] = 0.0;
        A[588] = 0.0;
        A[589] = 0.0;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[616] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.038095238095238*G0_6 + 0.0380952380952381*G0_7 + 0.457142857142857*G0_11;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_7 + 0.0476190476190476*G0_11;
        A[652] = -0.00714285714285714*G0_6 - 0.00714285714285715*G0_7 - 0.019047619047619*G0_11;
        A[653] = 0.0;
        A[654] = 0.0;
        A[655] = 0.0;
        A[656] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = -0.00714285714285714*G0_6 - 0.00714285714285715*G0_7 - 0.019047619047619*G0_11;
        A[682] = -0.00714285714285715*G0_6 + 0.0928571428571427*G0_7 + 0.0476190476190476*G0_11;
        A[683] = 0.0;
        A[684] = 0.0;
        A[685] = 0.0;
        A[686] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = 0.0;
        A[712] = 0.0;
        A[713] = 0.0;
        A[714] = 0.0;
        A[715] = 0.0;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0;
        A[743] = 0.0;
        A[744] = 0.0;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0;
        A[772] = 0.0;
        A[773] = 0.0;
        A[774] = 0.0;
        A[775] = 0.0;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[802] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.038095238095238*G0_6 + 0.0380952380952381*G0_7 + 0.457142857142857*G0_11;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.15*G0_6 - 0.0166666666666667*G0_7 + 0.2*G0_11;
        A[838] = 0.0166666666666666*G0_6 + 0.0166666666666667*G0_7 + 0.133333333333333*G0_11;
        A[839] = 0.0;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0166666666666666*G0_6 + 0.0166666666666667*G0_7 + 0.133333333333333*G0_11;
        A[868] = -0.0166666666666667*G0_6 + 0.15*G0_7 + 0.2*G0_11;
        A[869] = 0.0;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0;
        A[898] = 0.0;
        A[899] = 0.0;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        switch (facet1)
      {
      case 0:
        {
          A[0] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_1 + 0.0476190476190476*G1_5;
        A[1] = -0.00714285714285714*G1_0 - 0.00714285714285715*G1_1 - 0.019047619047619*G1_5;
        A[2] = 0.0;
        A[3] = 0.0;
        A[4] = 0.0;
        A[5] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = -0.00714285714285714*G1_0 - 0.00714285714285715*G1_1 - 0.019047619047619*G1_5;
        A[31] = -0.00714285714285715*G1_0 + 0.0928571428571427*G1_1 + 0.0476190476190476*G1_5;
        A[32] = 0.0;
        A[33] = 0.0;
        A[34] = 0.0;
        A[35] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = 0.0;
        A[61] = 0.0;
        A[62] = 0.0;
        A[63] = 0.0;
        A[64] = 0.0;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0;
        A[92] = 0.0;
        A[93] = 0.0;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0;
        A[121] = 0.0;
        A[122] = 0.0;
        A[123] = 0.0;
        A[124] = 0.0;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[151] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.038095238095238*G1_0 + 0.0380952380952381*G1_1 + 0.457142857142857*G1_5;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_1 + 0.0476190476190476*G1_5;
        A[187] = -0.00714285714285714*G1_0 - 0.00714285714285715*G1_1 - 0.019047619047619*G1_5;
        A[188] = 0.0;
        A[189] = 0.0;
        A[190] = 0.0;
        A[191] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = -0.00714285714285714*G1_0 - 0.00714285714285715*G1_1 - 0.019047619047619*G1_5;
        A[217] = -0.00714285714285715*G1_0 + 0.0928571428571427*G1_1 + 0.0476190476190476*G1_5;
        A[218] = 0.0;
        A[219] = 0.0;
        A[220] = 0.0;
        A[221] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = 0.0;
        A[247] = 0.0;
        A[248] = 0.0;
        A[249] = 0.0;
        A[250] = 0.0;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0;
        A[278] = 0.0;
        A[279] = 0.0;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0;
        A[307] = 0.0;
        A[308] = 0.0;
        A[309] = 0.0;
        A[310] = 0.0;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[337] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.038095238095238*G1_0 + 0.0380952380952381*G1_1 + 0.457142857142857*G1_5;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.15*G1_0 - 0.0166666666666667*G1_1 + 0.2*G1_5;
        A[373] = 0.0166666666666666*G1_0 + 0.0166666666666667*G1_1 + 0.133333333333333*G1_5;
        A[374] = 0.0;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0166666666666666*G1_0 + 0.0166666666666667*G1_1 + 0.133333333333333*G1_5;
        A[403] = -0.0166666666666667*G1_0 + 0.15*G1_1 + 0.2*G1_5;
        A[404] = 0.0;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0;
        A[433] = 0.0;
        A[434] = 0.0;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0;
        A[466] = 0.0;
        A[467] = 0.0;
        A[468] = 0.0;
        A[469] = 0.0;
        A[470] = 0.0;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = 0.0;
        A[496] = 0.0928571428571428*G0_7 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_9;
        A[497] = -0.00714285714285714*G0_7 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_9;
        A[498] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_9;
        A[499] = 0.0;
        A[500] = 0.0;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = 0.0;
        A[526] = -0.00714285714285714*G0_7 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_9;
        A[527] = -0.00714285714285713*G0_7 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_9;
        A[528] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[529] = 0.0;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_9;
        A[557] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[558] = 0.0380952380952381*G0_7 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_9;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0;
        A[586] = 0.0;
        A[587] = 0.0;
        A[588] = 0.0;
        A[589] = 0.0;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0;
        A[616] = 0.0;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.0;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0;
        A[652] = 0.0;
        A[653] = 0.0;
        A[654] = 0.0;
        A[655] = 0.0;
        A[656] = 0.0;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = 0.0;
        A[682] = 0.0928571428571428*G0_7 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_9;
        A[683] = -0.00714285714285714*G0_7 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_9;
        A[684] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_9;
        A[685] = 0.0;
        A[686] = 0.0;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = 0.0;
        A[712] = -0.00714285714285714*G0_7 - 0.00714285714285713*G0_8 - 0.019047619047619*G0_9;
        A[713] = -0.00714285714285713*G0_7 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_9;
        A[714] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[715] = 0.0;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0476190476190476*G0_7 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_9;
        A[743] = -0.019047619047619*G0_7 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_9;
        A[744] = 0.0380952380952381*G0_7 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_9;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0;
        A[772] = 0.0;
        A[773] = 0.0;
        A[774] = 0.0;
        A[775] = 0.0;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0;
        A[802] = 0.0;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.0;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.0;
        A[838] = 0.0;
        A[839] = 0.0;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0;
        A[868] = 0.15*G0_7 - 0.0166666666666666*G0_8 + 0.2*G0_9;
        A[869] = 0.0166666666666667*G0_7 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_9;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0;
        A[898] = 0.0166666666666667*G0_7 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_9;
        A[899] = -0.0166666666666666*G0_7 + 0.15*G0_8 + 0.2*G0_9;
          break;
        }
      case 1:
        {
          A[0] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_1 + 0.0476190476190476*G1_5;
        A[1] = -0.00714285714285714*G1_0 - 0.00714285714285715*G1_1 - 0.019047619047619*G1_5;
        A[2] = 0.0;
        A[3] = 0.0;
        A[4] = 0.0;
        A[5] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = -0.00714285714285714*G1_0 - 0.00714285714285715*G1_1 - 0.019047619047619*G1_5;
        A[31] = -0.00714285714285715*G1_0 + 0.0928571428571427*G1_1 + 0.0476190476190476*G1_5;
        A[32] = 0.0;
        A[33] = 0.0;
        A[34] = 0.0;
        A[35] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = 0.0;
        A[61] = 0.0;
        A[62] = 0.0;
        A[63] = 0.0;
        A[64] = 0.0;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0;
        A[92] = 0.0;
        A[93] = 0.0;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0;
        A[121] = 0.0;
        A[122] = 0.0;
        A[123] = 0.0;
        A[124] = 0.0;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[151] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.038095238095238*G1_0 + 0.0380952380952381*G1_1 + 0.457142857142857*G1_5;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_1 + 0.0476190476190476*G1_5;
        A[187] = -0.00714285714285714*G1_0 - 0.00714285714285715*G1_1 - 0.019047619047619*G1_5;
        A[188] = 0.0;
        A[189] = 0.0;
        A[190] = 0.0;
        A[191] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = -0.00714285714285714*G1_0 - 0.00714285714285715*G1_1 - 0.019047619047619*G1_5;
        A[217] = -0.00714285714285715*G1_0 + 0.0928571428571427*G1_1 + 0.0476190476190476*G1_5;
        A[218] = 0.0;
        A[219] = 0.0;
        A[220] = 0.0;
        A[221] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = 0.0;
        A[247] = 0.0;
        A[248] = 0.0;
        A[249] = 0.0;
        A[250] = 0.0;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0;
        A[278] = 0.0;
        A[279] = 0.0;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0;
        A[307] = 0.0;
        A[308] = 0.0;
        A[309] = 0.0;
        A[310] = 0.0;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[337] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.038095238095238*G1_0 + 0.0380952380952381*G1_1 + 0.457142857142857*G1_5;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.15*G1_0 - 0.0166666666666667*G1_1 + 0.2*G1_5;
        A[373] = 0.0166666666666666*G1_0 + 0.0166666666666667*G1_1 + 0.133333333333333*G1_5;
        A[374] = 0.0;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0166666666666666*G1_0 + 0.0166666666666667*G1_1 + 0.133333333333333*G1_5;
        A[403] = -0.0166666666666667*G1_0 + 0.15*G1_1 + 0.2*G1_5;
        A[404] = 0.0;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0;
        A[433] = 0.0;
        A[434] = 0.0;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_10;
        A[466] = 0.0;
        A[467] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_10;
        A[468] = 0.0;
        A[469] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[470] = 0.0;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = 0.0;
        A[496] = 0.0;
        A[497] = 0.0;
        A[498] = 0.0;
        A[499] = 0.0;
        A[500] = 0.0;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_10;
        A[526] = 0.0;
        A[527] = -0.00714285714285714*G0_6 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_10;
        A[528] = 0.0;
        A[529] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0;
        A[557] = 0.0;
        A[558] = 0.0;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[586] = 0.0;
        A[587] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[588] = 0.0;
        A[589] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_10;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0;
        A[616] = 0.0;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.0;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_8 + 0.0476190476190476*G0_10;
        A[652] = 0.0;
        A[653] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_10;
        A[654] = 0.0;
        A[655] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[656] = 0.0;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = 0.0;
        A[682] = 0.0;
        A[683] = 0.0;
        A[684] = 0.0;
        A[685] = 0.0;
        A[686] = 0.0;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = -0.00714285714285714*G0_6 - 0.00714285714285714*G0_8 - 0.019047619047619*G0_10;
        A[712] = 0.0;
        A[713] = -0.00714285714285714*G0_6 + 0.0928571428571428*G0_8 + 0.0476190476190476*G0_10;
        A[714] = 0.0;
        A[715] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0;
        A[743] = 0.0;
        A[744] = 0.0;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_8 + 0.0380952380952381*G0_10;
        A[772] = 0.0;
        A[773] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_8 + 0.0380952380952381*G0_10;
        A[774] = 0.0;
        A[775] = 0.0380952380952381*G0_6 + 0.0380952380952381*G0_8 + 0.457142857142857*G0_10;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0;
        A[802] = 0.0;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.0;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.15*G0_6 - 0.0166666666666667*G0_8 + 0.2*G0_10;
        A[838] = 0.0;
        A[839] = 0.0166666666666666*G0_6 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_10;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0;
        A[868] = 0.0;
        A[869] = 0.0;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0166666666666666*G0_6 + 0.0166666666666667*G0_8 + 0.133333333333333*G0_10;
        A[898] = 0.0;
        A[899] = -0.0166666666666667*G0_6 + 0.15*G0_8 + 0.2*G0_10;
          break;
        }
      case 2:
        {
          A[0] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_1 + 0.0476190476190476*G1_5;
        A[1] = -0.00714285714285714*G1_0 - 0.00714285714285715*G1_1 - 0.019047619047619*G1_5;
        A[2] = 0.0;
        A[3] = 0.0;
        A[4] = 0.0;
        A[5] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[6] = 0.0;
        A[7] = 0.0;
        A[8] = 0.0;
        A[9] = 0.0;
        A[10] = 0.0;
        A[11] = 0.0;
        A[12] = 0.0;
        A[13] = 0.0;
        A[14] = 0.0;
        A[15] = 0.0;
        A[16] = 0.0;
        A[17] = 0.0;
        A[18] = 0.0;
        A[19] = 0.0;
        A[20] = 0.0;
        A[21] = 0.0;
        A[22] = 0.0;
        A[23] = 0.0;
        A[24] = 0.0;
        A[25] = 0.0;
        A[26] = 0.0;
        A[27] = 0.0;
        A[28] = 0.0;
        A[29] = 0.0;
        A[30] = -0.00714285714285714*G1_0 - 0.00714285714285715*G1_1 - 0.019047619047619*G1_5;
        A[31] = -0.00714285714285715*G1_0 + 0.0928571428571427*G1_1 + 0.0476190476190476*G1_5;
        A[32] = 0.0;
        A[33] = 0.0;
        A[34] = 0.0;
        A[35] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[36] = 0.0;
        A[37] = 0.0;
        A[38] = 0.0;
        A[39] = 0.0;
        A[40] = 0.0;
        A[41] = 0.0;
        A[42] = 0.0;
        A[43] = 0.0;
        A[44] = 0.0;
        A[45] = 0.0;
        A[46] = 0.0;
        A[47] = 0.0;
        A[48] = 0.0;
        A[49] = 0.0;
        A[50] = 0.0;
        A[51] = 0.0;
        A[52] = 0.0;
        A[53] = 0.0;
        A[54] = 0.0;
        A[55] = 0.0;
        A[56] = 0.0;
        A[57] = 0.0;
        A[58] = 0.0;
        A[59] = 0.0;
        A[60] = 0.0;
        A[61] = 0.0;
        A[62] = 0.0;
        A[63] = 0.0;
        A[64] = 0.0;
        A[65] = 0.0;
        A[66] = 0.0;
        A[67] = 0.0;
        A[68] = 0.0;
        A[69] = 0.0;
        A[70] = 0.0;
        A[71] = 0.0;
        A[72] = 0.0;
        A[73] = 0.0;
        A[74] = 0.0;
        A[75] = 0.0;
        A[76] = 0.0;
        A[77] = 0.0;
        A[78] = 0.0;
        A[79] = 0.0;
        A[80] = 0.0;
        A[81] = 0.0;
        A[82] = 0.0;
        A[83] = 0.0;
        A[84] = 0.0;
        A[85] = 0.0;
        A[86] = 0.0;
        A[87] = 0.0;
        A[88] = 0.0;
        A[89] = 0.0;
        A[90] = 0.0;
        A[91] = 0.0;
        A[92] = 0.0;
        A[93] = 0.0;
        A[94] = 0.0;
        A[95] = 0.0;
        A[96] = 0.0;
        A[97] = 0.0;
        A[98] = 0.0;
        A[99] = 0.0;
        A[100] = 0.0;
        A[101] = 0.0;
        A[102] = 0.0;
        A[103] = 0.0;
        A[104] = 0.0;
        A[105] = 0.0;
        A[106] = 0.0;
        A[107] = 0.0;
        A[108] = 0.0;
        A[109] = 0.0;
        A[110] = 0.0;
        A[111] = 0.0;
        A[112] = 0.0;
        A[113] = 0.0;
        A[114] = 0.0;
        A[115] = 0.0;
        A[116] = 0.0;
        A[117] = 0.0;
        A[118] = 0.0;
        A[119] = 0.0;
        A[120] = 0.0;
        A[121] = 0.0;
        A[122] = 0.0;
        A[123] = 0.0;
        A[124] = 0.0;
        A[125] = 0.0;
        A[126] = 0.0;
        A[127] = 0.0;
        A[128] = 0.0;
        A[129] = 0.0;
        A[130] = 0.0;
        A[131] = 0.0;
        A[132] = 0.0;
        A[133] = 0.0;
        A[134] = 0.0;
        A[135] = 0.0;
        A[136] = 0.0;
        A[137] = 0.0;
        A[138] = 0.0;
        A[139] = 0.0;
        A[140] = 0.0;
        A[141] = 0.0;
        A[142] = 0.0;
        A[143] = 0.0;
        A[144] = 0.0;
        A[145] = 0.0;
        A[146] = 0.0;
        A[147] = 0.0;
        A[148] = 0.0;
        A[149] = 0.0;
        A[150] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[151] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[152] = 0.0;
        A[153] = 0.0;
        A[154] = 0.0;
        A[155] = 0.038095238095238*G1_0 + 0.0380952380952381*G1_1 + 0.457142857142857*G1_5;
        A[156] = 0.0;
        A[157] = 0.0;
        A[158] = 0.0;
        A[159] = 0.0;
        A[160] = 0.0;
        A[161] = 0.0;
        A[162] = 0.0;
        A[163] = 0.0;
        A[164] = 0.0;
        A[165] = 0.0;
        A[166] = 0.0;
        A[167] = 0.0;
        A[168] = 0.0;
        A[169] = 0.0;
        A[170] = 0.0;
        A[171] = 0.0;
        A[172] = 0.0;
        A[173] = 0.0;
        A[174] = 0.0;
        A[175] = 0.0;
        A[176] = 0.0;
        A[177] = 0.0;
        A[178] = 0.0;
        A[179] = 0.0;
        A[180] = 0.0;
        A[181] = 0.0;
        A[182] = 0.0;
        A[183] = 0.0;
        A[184] = 0.0;
        A[185] = 0.0;
        A[186] = 0.0928571428571428*G1_0 - 0.00714285714285714*G1_1 + 0.0476190476190476*G1_5;
        A[187] = -0.00714285714285714*G1_0 - 0.00714285714285715*G1_1 - 0.019047619047619*G1_5;
        A[188] = 0.0;
        A[189] = 0.0;
        A[190] = 0.0;
        A[191] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[192] = 0.0;
        A[193] = 0.0;
        A[194] = 0.0;
        A[195] = 0.0;
        A[196] = 0.0;
        A[197] = 0.0;
        A[198] = 0.0;
        A[199] = 0.0;
        A[200] = 0.0;
        A[201] = 0.0;
        A[202] = 0.0;
        A[203] = 0.0;
        A[204] = 0.0;
        A[205] = 0.0;
        A[206] = 0.0;
        A[207] = 0.0;
        A[208] = 0.0;
        A[209] = 0.0;
        A[210] = 0.0;
        A[211] = 0.0;
        A[212] = 0.0;
        A[213] = 0.0;
        A[214] = 0.0;
        A[215] = 0.0;
        A[216] = -0.00714285714285714*G1_0 - 0.00714285714285715*G1_1 - 0.019047619047619*G1_5;
        A[217] = -0.00714285714285715*G1_0 + 0.0928571428571427*G1_1 + 0.0476190476190476*G1_5;
        A[218] = 0.0;
        A[219] = 0.0;
        A[220] = 0.0;
        A[221] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[222] = 0.0;
        A[223] = 0.0;
        A[224] = 0.0;
        A[225] = 0.0;
        A[226] = 0.0;
        A[227] = 0.0;
        A[228] = 0.0;
        A[229] = 0.0;
        A[230] = 0.0;
        A[231] = 0.0;
        A[232] = 0.0;
        A[233] = 0.0;
        A[234] = 0.0;
        A[235] = 0.0;
        A[236] = 0.0;
        A[237] = 0.0;
        A[238] = 0.0;
        A[239] = 0.0;
        A[240] = 0.0;
        A[241] = 0.0;
        A[242] = 0.0;
        A[243] = 0.0;
        A[244] = 0.0;
        A[245] = 0.0;
        A[246] = 0.0;
        A[247] = 0.0;
        A[248] = 0.0;
        A[249] = 0.0;
        A[250] = 0.0;
        A[251] = 0.0;
        A[252] = 0.0;
        A[253] = 0.0;
        A[254] = 0.0;
        A[255] = 0.0;
        A[256] = 0.0;
        A[257] = 0.0;
        A[258] = 0.0;
        A[259] = 0.0;
        A[260] = 0.0;
        A[261] = 0.0;
        A[262] = 0.0;
        A[263] = 0.0;
        A[264] = 0.0;
        A[265] = 0.0;
        A[266] = 0.0;
        A[267] = 0.0;
        A[268] = 0.0;
        A[269] = 0.0;
        A[270] = 0.0;
        A[271] = 0.0;
        A[272] = 0.0;
        A[273] = 0.0;
        A[274] = 0.0;
        A[275] = 0.0;
        A[276] = 0.0;
        A[277] = 0.0;
        A[278] = 0.0;
        A[279] = 0.0;
        A[280] = 0.0;
        A[281] = 0.0;
        A[282] = 0.0;
        A[283] = 0.0;
        A[284] = 0.0;
        A[285] = 0.0;
        A[286] = 0.0;
        A[287] = 0.0;
        A[288] = 0.0;
        A[289] = 0.0;
        A[290] = 0.0;
        A[291] = 0.0;
        A[292] = 0.0;
        A[293] = 0.0;
        A[294] = 0.0;
        A[295] = 0.0;
        A[296] = 0.0;
        A[297] = 0.0;
        A[298] = 0.0;
        A[299] = 0.0;
        A[300] = 0.0;
        A[301] = 0.0;
        A[302] = 0.0;
        A[303] = 0.0;
        A[304] = 0.0;
        A[305] = 0.0;
        A[306] = 0.0;
        A[307] = 0.0;
        A[308] = 0.0;
        A[309] = 0.0;
        A[310] = 0.0;
        A[311] = 0.0;
        A[312] = 0.0;
        A[313] = 0.0;
        A[314] = 0.0;
        A[315] = 0.0;
        A[316] = 0.0;
        A[317] = 0.0;
        A[318] = 0.0;
        A[319] = 0.0;
        A[320] = 0.0;
        A[321] = 0.0;
        A[322] = 0.0;
        A[323] = 0.0;
        A[324] = 0.0;
        A[325] = 0.0;
        A[326] = 0.0;
        A[327] = 0.0;
        A[328] = 0.0;
        A[329] = 0.0;
        A[330] = 0.0;
        A[331] = 0.0;
        A[332] = 0.0;
        A[333] = 0.0;
        A[334] = 0.0;
        A[335] = 0.0;
        A[336] = 0.0476190476190476*G1_0 - 0.019047619047619*G1_1 + 0.038095238095238*G1_5;
        A[337] = -0.019047619047619*G1_0 + 0.0476190476190476*G1_1 + 0.0380952380952381*G1_5;
        A[338] = 0.0;
        A[339] = 0.0;
        A[340] = 0.0;
        A[341] = 0.038095238095238*G1_0 + 0.0380952380952381*G1_1 + 0.457142857142857*G1_5;
        A[342] = 0.0;
        A[343] = 0.0;
        A[344] = 0.0;
        A[345] = 0.0;
        A[346] = 0.0;
        A[347] = 0.0;
        A[348] = 0.0;
        A[349] = 0.0;
        A[350] = 0.0;
        A[351] = 0.0;
        A[352] = 0.0;
        A[353] = 0.0;
        A[354] = 0.0;
        A[355] = 0.0;
        A[356] = 0.0;
        A[357] = 0.0;
        A[358] = 0.0;
        A[359] = 0.0;
        A[360] = 0.0;
        A[361] = 0.0;
        A[362] = 0.0;
        A[363] = 0.0;
        A[364] = 0.0;
        A[365] = 0.0;
        A[366] = 0.0;
        A[367] = 0.0;
        A[368] = 0.0;
        A[369] = 0.0;
        A[370] = 0.0;
        A[371] = 0.0;
        A[372] = 0.15*G1_0 - 0.0166666666666667*G1_1 + 0.2*G1_5;
        A[373] = 0.0166666666666666*G1_0 + 0.0166666666666667*G1_1 + 0.133333333333333*G1_5;
        A[374] = 0.0;
        A[375] = 0.0;
        A[376] = 0.0;
        A[377] = 0.0;
        A[378] = 0.0;
        A[379] = 0.0;
        A[380] = 0.0;
        A[381] = 0.0;
        A[382] = 0.0;
        A[383] = 0.0;
        A[384] = 0.0;
        A[385] = 0.0;
        A[386] = 0.0;
        A[387] = 0.0;
        A[388] = 0.0;
        A[389] = 0.0;
        A[390] = 0.0;
        A[391] = 0.0;
        A[392] = 0.0;
        A[393] = 0.0;
        A[394] = 0.0;
        A[395] = 0.0;
        A[396] = 0.0;
        A[397] = 0.0;
        A[398] = 0.0;
        A[399] = 0.0;
        A[400] = 0.0;
        A[401] = 0.0;
        A[402] = 0.0166666666666666*G1_0 + 0.0166666666666667*G1_1 + 0.133333333333333*G1_5;
        A[403] = -0.0166666666666667*G1_0 + 0.15*G1_1 + 0.2*G1_5;
        A[404] = 0.0;
        A[405] = 0.0;
        A[406] = 0.0;
        A[407] = 0.0;
        A[408] = 0.0;
        A[409] = 0.0;
        A[410] = 0.0;
        A[411] = 0.0;
        A[412] = 0.0;
        A[413] = 0.0;
        A[414] = 0.0;
        A[415] = 0.0;
        A[416] = 0.0;
        A[417] = 0.0;
        A[418] = 0.0;
        A[419] = 0.0;
        A[420] = 0.0;
        A[421] = 0.0;
        A[422] = 0.0;
        A[423] = 0.0;
        A[424] = 0.0;
        A[425] = 0.0;
        A[426] = 0.0;
        A[427] = 0.0;
        A[428] = 0.0;
        A[429] = 0.0;
        A[430] = 0.0;
        A[431] = 0.0;
        A[432] = 0.0;
        A[433] = 0.0;
        A[434] = 0.0;
        A[435] = 0.0;
        A[436] = 0.0;
        A[437] = 0.0;
        A[438] = 0.0;
        A[439] = 0.0;
        A[440] = 0.0;
        A[441] = 0.0;
        A[442] = 0.0;
        A[443] = 0.0;
        A[444] = 0.0;
        A[445] = 0.0;
        A[446] = 0.0;
        A[447] = 0.0;
        A[448] = 0.0;
        A[449] = 0.0;
        A[450] = 0.0;
        A[451] = 0.0;
        A[452] = 0.0;
        A[453] = 0.0;
        A[454] = 0.0;
        A[455] = 0.0;
        A[456] = 0.0;
        A[457] = 0.0;
        A[458] = 0.0;
        A[459] = 0.0;
        A[460] = 0.0;
        A[461] = 0.0;
        A[462] = 0.0;
        A[463] = 0.0;
        A[464] = 0.0;
        A[465] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_7 + 0.0476190476190476*G0_11;
        A[466] = -0.00714285714285714*G0_6 - 0.00714285714285715*G0_7 - 0.019047619047619*G0_11;
        A[467] = 0.0;
        A[468] = 0.0;
        A[469] = 0.0;
        A[470] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[471] = 0.0;
        A[472] = 0.0;
        A[473] = 0.0;
        A[474] = 0.0;
        A[475] = 0.0;
        A[476] = 0.0;
        A[477] = 0.0;
        A[478] = 0.0;
        A[479] = 0.0;
        A[480] = 0.0;
        A[481] = 0.0;
        A[482] = 0.0;
        A[483] = 0.0;
        A[484] = 0.0;
        A[485] = 0.0;
        A[486] = 0.0;
        A[487] = 0.0;
        A[488] = 0.0;
        A[489] = 0.0;
        A[490] = 0.0;
        A[491] = 0.0;
        A[492] = 0.0;
        A[493] = 0.0;
        A[494] = 0.0;
        A[495] = -0.00714285714285714*G0_6 - 0.00714285714285715*G0_7 - 0.019047619047619*G0_11;
        A[496] = -0.00714285714285715*G0_6 + 0.0928571428571427*G0_7 + 0.0476190476190476*G0_11;
        A[497] = 0.0;
        A[498] = 0.0;
        A[499] = 0.0;
        A[500] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[501] = 0.0;
        A[502] = 0.0;
        A[503] = 0.0;
        A[504] = 0.0;
        A[505] = 0.0;
        A[506] = 0.0;
        A[507] = 0.0;
        A[508] = 0.0;
        A[509] = 0.0;
        A[510] = 0.0;
        A[511] = 0.0;
        A[512] = 0.0;
        A[513] = 0.0;
        A[514] = 0.0;
        A[515] = 0.0;
        A[516] = 0.0;
        A[517] = 0.0;
        A[518] = 0.0;
        A[519] = 0.0;
        A[520] = 0.0;
        A[521] = 0.0;
        A[522] = 0.0;
        A[523] = 0.0;
        A[524] = 0.0;
        A[525] = 0.0;
        A[526] = 0.0;
        A[527] = 0.0;
        A[528] = 0.0;
        A[529] = 0.0;
        A[530] = 0.0;
        A[531] = 0.0;
        A[532] = 0.0;
        A[533] = 0.0;
        A[534] = 0.0;
        A[535] = 0.0;
        A[536] = 0.0;
        A[537] = 0.0;
        A[538] = 0.0;
        A[539] = 0.0;
        A[540] = 0.0;
        A[541] = 0.0;
        A[542] = 0.0;
        A[543] = 0.0;
        A[544] = 0.0;
        A[545] = 0.0;
        A[546] = 0.0;
        A[547] = 0.0;
        A[548] = 0.0;
        A[549] = 0.0;
        A[550] = 0.0;
        A[551] = 0.0;
        A[552] = 0.0;
        A[553] = 0.0;
        A[554] = 0.0;
        A[555] = 0.0;
        A[556] = 0.0;
        A[557] = 0.0;
        A[558] = 0.0;
        A[559] = 0.0;
        A[560] = 0.0;
        A[561] = 0.0;
        A[562] = 0.0;
        A[563] = 0.0;
        A[564] = 0.0;
        A[565] = 0.0;
        A[566] = 0.0;
        A[567] = 0.0;
        A[568] = 0.0;
        A[569] = 0.0;
        A[570] = 0.0;
        A[571] = 0.0;
        A[572] = 0.0;
        A[573] = 0.0;
        A[574] = 0.0;
        A[575] = 0.0;
        A[576] = 0.0;
        A[577] = 0.0;
        A[578] = 0.0;
        A[579] = 0.0;
        A[580] = 0.0;
        A[581] = 0.0;
        A[582] = 0.0;
        A[583] = 0.0;
        A[584] = 0.0;
        A[585] = 0.0;
        A[586] = 0.0;
        A[587] = 0.0;
        A[588] = 0.0;
        A[589] = 0.0;
        A[590] = 0.0;
        A[591] = 0.0;
        A[592] = 0.0;
        A[593] = 0.0;
        A[594] = 0.0;
        A[595] = 0.0;
        A[596] = 0.0;
        A[597] = 0.0;
        A[598] = 0.0;
        A[599] = 0.0;
        A[600] = 0.0;
        A[601] = 0.0;
        A[602] = 0.0;
        A[603] = 0.0;
        A[604] = 0.0;
        A[605] = 0.0;
        A[606] = 0.0;
        A[607] = 0.0;
        A[608] = 0.0;
        A[609] = 0.0;
        A[610] = 0.0;
        A[611] = 0.0;
        A[612] = 0.0;
        A[613] = 0.0;
        A[614] = 0.0;
        A[615] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[616] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[617] = 0.0;
        A[618] = 0.0;
        A[619] = 0.0;
        A[620] = 0.038095238095238*G0_6 + 0.0380952380952381*G0_7 + 0.457142857142857*G0_11;
        A[621] = 0.0;
        A[622] = 0.0;
        A[623] = 0.0;
        A[624] = 0.0;
        A[625] = 0.0;
        A[626] = 0.0;
        A[627] = 0.0;
        A[628] = 0.0;
        A[629] = 0.0;
        A[630] = 0.0;
        A[631] = 0.0;
        A[632] = 0.0;
        A[633] = 0.0;
        A[634] = 0.0;
        A[635] = 0.0;
        A[636] = 0.0;
        A[637] = 0.0;
        A[638] = 0.0;
        A[639] = 0.0;
        A[640] = 0.0;
        A[641] = 0.0;
        A[642] = 0.0;
        A[643] = 0.0;
        A[644] = 0.0;
        A[645] = 0.0;
        A[646] = 0.0;
        A[647] = 0.0;
        A[648] = 0.0;
        A[649] = 0.0;
        A[650] = 0.0;
        A[651] = 0.0928571428571428*G0_6 - 0.00714285714285714*G0_7 + 0.0476190476190476*G0_11;
        A[652] = -0.00714285714285714*G0_6 - 0.00714285714285715*G0_7 - 0.019047619047619*G0_11;
        A[653] = 0.0;
        A[654] = 0.0;
        A[655] = 0.0;
        A[656] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[657] = 0.0;
        A[658] = 0.0;
        A[659] = 0.0;
        A[660] = 0.0;
        A[661] = 0.0;
        A[662] = 0.0;
        A[663] = 0.0;
        A[664] = 0.0;
        A[665] = 0.0;
        A[666] = 0.0;
        A[667] = 0.0;
        A[668] = 0.0;
        A[669] = 0.0;
        A[670] = 0.0;
        A[671] = 0.0;
        A[672] = 0.0;
        A[673] = 0.0;
        A[674] = 0.0;
        A[675] = 0.0;
        A[676] = 0.0;
        A[677] = 0.0;
        A[678] = 0.0;
        A[679] = 0.0;
        A[680] = 0.0;
        A[681] = -0.00714285714285714*G0_6 - 0.00714285714285715*G0_7 - 0.019047619047619*G0_11;
        A[682] = -0.00714285714285715*G0_6 + 0.0928571428571427*G0_7 + 0.0476190476190476*G0_11;
        A[683] = 0.0;
        A[684] = 0.0;
        A[685] = 0.0;
        A[686] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[687] = 0.0;
        A[688] = 0.0;
        A[689] = 0.0;
        A[690] = 0.0;
        A[691] = 0.0;
        A[692] = 0.0;
        A[693] = 0.0;
        A[694] = 0.0;
        A[695] = 0.0;
        A[696] = 0.0;
        A[697] = 0.0;
        A[698] = 0.0;
        A[699] = 0.0;
        A[700] = 0.0;
        A[701] = 0.0;
        A[702] = 0.0;
        A[703] = 0.0;
        A[704] = 0.0;
        A[705] = 0.0;
        A[706] = 0.0;
        A[707] = 0.0;
        A[708] = 0.0;
        A[709] = 0.0;
        A[710] = 0.0;
        A[711] = 0.0;
        A[712] = 0.0;
        A[713] = 0.0;
        A[714] = 0.0;
        A[715] = 0.0;
        A[716] = 0.0;
        A[717] = 0.0;
        A[718] = 0.0;
        A[719] = 0.0;
        A[720] = 0.0;
        A[721] = 0.0;
        A[722] = 0.0;
        A[723] = 0.0;
        A[724] = 0.0;
        A[725] = 0.0;
        A[726] = 0.0;
        A[727] = 0.0;
        A[728] = 0.0;
        A[729] = 0.0;
        A[730] = 0.0;
        A[731] = 0.0;
        A[732] = 0.0;
        A[733] = 0.0;
        A[734] = 0.0;
        A[735] = 0.0;
        A[736] = 0.0;
        A[737] = 0.0;
        A[738] = 0.0;
        A[739] = 0.0;
        A[740] = 0.0;
        A[741] = 0.0;
        A[742] = 0.0;
        A[743] = 0.0;
        A[744] = 0.0;
        A[745] = 0.0;
        A[746] = 0.0;
        A[747] = 0.0;
        A[748] = 0.0;
        A[749] = 0.0;
        A[750] = 0.0;
        A[751] = 0.0;
        A[752] = 0.0;
        A[753] = 0.0;
        A[754] = 0.0;
        A[755] = 0.0;
        A[756] = 0.0;
        A[757] = 0.0;
        A[758] = 0.0;
        A[759] = 0.0;
        A[760] = 0.0;
        A[761] = 0.0;
        A[762] = 0.0;
        A[763] = 0.0;
        A[764] = 0.0;
        A[765] = 0.0;
        A[766] = 0.0;
        A[767] = 0.0;
        A[768] = 0.0;
        A[769] = 0.0;
        A[770] = 0.0;
        A[771] = 0.0;
        A[772] = 0.0;
        A[773] = 0.0;
        A[774] = 0.0;
        A[775] = 0.0;
        A[776] = 0.0;
        A[777] = 0.0;
        A[778] = 0.0;
        A[779] = 0.0;
        A[780] = 0.0;
        A[781] = 0.0;
        A[782] = 0.0;
        A[783] = 0.0;
        A[784] = 0.0;
        A[785] = 0.0;
        A[786] = 0.0;
        A[787] = 0.0;
        A[788] = 0.0;
        A[789] = 0.0;
        A[790] = 0.0;
        A[791] = 0.0;
        A[792] = 0.0;
        A[793] = 0.0;
        A[794] = 0.0;
        A[795] = 0.0;
        A[796] = 0.0;
        A[797] = 0.0;
        A[798] = 0.0;
        A[799] = 0.0;
        A[800] = 0.0;
        A[801] = 0.0476190476190476*G0_6 - 0.019047619047619*G0_7 + 0.038095238095238*G0_11;
        A[802] = -0.019047619047619*G0_6 + 0.0476190476190476*G0_7 + 0.0380952380952381*G0_11;
        A[803] = 0.0;
        A[804] = 0.0;
        A[805] = 0.0;
        A[806] = 0.038095238095238*G0_6 + 0.0380952380952381*G0_7 + 0.457142857142857*G0_11;
        A[807] = 0.0;
        A[808] = 0.0;
        A[809] = 0.0;
        A[810] = 0.0;
        A[811] = 0.0;
        A[812] = 0.0;
        A[813] = 0.0;
        A[814] = 0.0;
        A[815] = 0.0;
        A[816] = 0.0;
        A[817] = 0.0;
        A[818] = 0.0;
        A[819] = 0.0;
        A[820] = 0.0;
        A[821] = 0.0;
        A[822] = 0.0;
        A[823] = 0.0;
        A[824] = 0.0;
        A[825] = 0.0;
        A[826] = 0.0;
        A[827] = 0.0;
        A[828] = 0.0;
        A[829] = 0.0;
        A[830] = 0.0;
        A[831] = 0.0;
        A[832] = 0.0;
        A[833] = 0.0;
        A[834] = 0.0;
        A[835] = 0.0;
        A[836] = 0.0;
        A[837] = 0.15*G0_6 - 0.0166666666666667*G0_7 + 0.2*G0_11;
        A[838] = 0.0166666666666666*G0_6 + 0.0166666666666667*G0_7 + 0.133333333333333*G0_11;
        A[839] = 0.0;
        A[840] = 0.0;
        A[841] = 0.0;
        A[842] = 0.0;
        A[843] = 0.0;
        A[844] = 0.0;
        A[845] = 0.0;
        A[846] = 0.0;
        A[847] = 0.0;
        A[848] = 0.0;
        A[849] = 0.0;
        A[850] = 0.0;
        A[851] = 0.0;
        A[852] = 0.0;
        A[853] = 0.0;
        A[854] = 0.0;
        A[855] = 0.0;
        A[856] = 0.0;
        A[857] = 0.0;
        A[858] = 0.0;
        A[859] = 0.0;
        A[860] = 0.0;
        A[861] = 0.0;
        A[862] = 0.0;
        A[863] = 0.0;
        A[864] = 0.0;
        A[865] = 0.0;
        A[866] = 0.0;
        A[867] = 0.0166666666666666*G0_6 + 0.0166666666666667*G0_7 + 0.133333333333333*G0_11;
        A[868] = -0.0166666666666667*G0_6 + 0.15*G0_7 + 0.2*G0_11;
        A[869] = 0.0;
        A[870] = 0.0;
        A[871] = 0.0;
        A[872] = 0.0;
        A[873] = 0.0;
        A[874] = 0.0;
        A[875] = 0.0;
        A[876] = 0.0;
        A[877] = 0.0;
        A[878] = 0.0;
        A[879] = 0.0;
        A[880] = 0.0;
        A[881] = 0.0;
        A[882] = 0.0;
        A[883] = 0.0;
        A[884] = 0.0;
        A[885] = 0.0;
        A[886] = 0.0;
        A[887] = 0.0;
        A[888] = 0.0;
        A[889] = 0.0;
        A[890] = 0.0;
        A[891] = 0.0;
        A[892] = 0.0;
        A[893] = 0.0;
        A[894] = 0.0;
        A[895] = 0.0;
        A[896] = 0.0;
        A[897] = 0.0;
        A[898] = 0.0;
        A[899] = 0.0;
          break;
        }
      }
      
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local interior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_6_0: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_6_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_6_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Cell Volume.
    
    // Compute circumradius, assuming triangle is embedded in 2D.
    
    
    // Facet Area.
    
    // Array of quadrature weights.
    static const double W16[16] = {0.0235683681933823, 0.0353880678980859, 0.0225840492823699, 0.00542322591052525, 0.0441850885223617, 0.0663442161070497, 0.0423397245217463, 0.0101672595644788, 0.0441850885223617, 0.0663442161070497, 0.0423397245217463, 0.0101672595644788, 0.0235683681933823, 0.0353880678980859, 0.0225840492823699, 0.00542322591052525};
    // Quadrature points on the UFC reference element: (0.0654669945550145, 0.0571041961145177), (0.0502101232113698, 0.276843013638124), (0.028912084224389, 0.583590432368917), (0.00970378512694614, 0.860240135656219), (0.311164552244357, 0.0571041961145177), (0.238648659731443, 0.276843013638124), (0.137419104134574, 0.583590432368917), (0.0461220799064521, 0.860240135656219), (0.631731251641125, 0.0571041961145177), (0.484508326630433, 0.276843013638124), (0.278990463496509, 0.583590432368917), (0.0936377844373285, 0.860240135656219), (0.877428809330468, 0.0571041961145177), (0.672946863150506, 0.276843013638124), (0.387497483406694, 0.583590432368917), (0.130056079216834, 0.860240135656219)
    
    // Value of basis functions at quadrature points.
    static const double FE0[16][6] = \
    {{0.662333821555697, -0.0568951398028819, -0.0505824176867471, 0.0149537603843904, 0.200419467218139, 0.229770508331402},
    {0.232768098097706, -0.0451680102655679, -0.123558905237647, 0.0556012872999085, 0.745202550451633, 0.135154979653967},
    {-0.0871888841136517, -0.0272402669959927, 0.0975651531361617, 0.067491262932791, 0.904559295532719, 0.0448134395079725},
    {-0.0962269117343234, -0.00951545823536622, 0.619786046331442, 0.0333903417359319, 0.447517836913623, 0.00504814498869303},
    {0.166437496959, -0.117517795097495, -0.0505824176867471, 0.0710752064609914, 0.144298021141538, 0.786289488222712},
    {-0.015011689481988, -0.124742294148215, -0.123558905237647, 0.264272856643007, 0.536530981108534, 0.462509051116308},
    {-0.123319106052515, -0.0996510837722764, 0.0975651531361617, 0.320785897590582, 0.651264660874928, 0.15335447822312},
    {-0.0761017150886653, -0.0418675873966577, 0.619786046331442, 0.158704257101893, 0.322203921547661, 0.0172750775043264},
    {-0.117517795097495, 0.166437496959, -0.0505824176867471, 0.144298021141538, 0.0710752064609913, 0.786289488222712},
    {-0.124742294148215, -0.0150116894819881, -0.123558905237647, 0.536530981108534, 0.264272856643007, 0.462509051116308},
    {-0.0996510837722764, -0.123319106052515, 0.0975651531361617, 0.651264660874928, 0.320785897590582, 0.15335447822312},
    {-0.0418675873966577, -0.0761017150886653, 0.619786046331442, 0.322203921547661, 0.158704257101893, 0.0172750775043264},
    {-0.0568951398028819, 0.662333821555697, -0.0505824176867471, 0.200419467218139, 0.0149537603843903, 0.229770508331402},
    {-0.0451680102655679, 0.232768098097706, -0.123558905237647, 0.745202550451633, 0.0556012872999085, 0.135154979653967},
    {-0.0272402669959926, -0.0871888841136517, 0.0975651531361618, 0.904559295532719, 0.0674912629327909, 0.0448134395079725},
    {-0.00951545823536613, -0.0962269117343234, 0.619786046331442, 0.447517836913623, 0.0333903417359314, 0.00504814498869298}};
    
    // Array of non-zero columns
    static const unsigned int nzc5[6] = {6, 7, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc2[6] = {0, 1, 2, 3, 4, 5};
    
    static const double FE0_D01[16][5] = \
    {{-2.50971523732187, -0.77158321554193, 0.261867978220058, 3.2812984528638, -0.261867978220058},
    {-1.69178745260203, 0.107372054552495, 0.200840492845479, 1.58441539804953, -0.200840492845479},
    {-0.549989933626777, 1.33436172947567, 0.115648336897556, -0.78437179584889, -0.115648336897556},
    {0.479775683132662, 2.44096054262488, 0.0388151405077835, -2.92073622575754, -0.0388151405077839},
    {-1.5269250065645, -0.771583215541929, 1.24465820897743, 2.29850822210643, -1.24465820897743},
    {-0.938033306521733, 0.107372054552495, 0.954594638925771, 0.830661251969238, -0.954594638925771},
    {-0.115961853986035, 1.33436172947567, 0.549676416538297, -1.21839987548963, -0.549676416538297},
    {0.625448862250686, 2.44096054262488, 0.184488319625807, -3.06640940487556, -0.184488319625808},
    {-0.244658208977428, -0.771583215541929, 2.5269250065645, 1.01624142451936, -2.5269250065645},
    {0.0454053610742282, 0.107372054552495, 1.93803330652173, -0.152777415626723, -1.93803330652173},
    {0.450323583461703, 1.33436172947567, 1.11596185398603, -1.78468531293737, -1.11596185398603},
    {0.815511680374192, 2.44096054262488, 0.374551137749313, -3.25647222299907, -0.374551137749313},
    {0.738132021779943, -0.771583215541929, 3.50971523732187, 0.0334511937619879, -3.50971523732187},
    {0.799159507154521, 0.107372054552496, 2.69178745260202, -0.906531561707016, -2.69178745260203},
    {0.884351663102444, 1.33436172947567, 1.54998993362678, -2.21871339257811, -1.54998993362678},
    {0.961184859492216, 2.44096054262488, 0.520224316867337, -3.40214540211709, -0.520224316867337}};
    
    // Array of non-zero columns
    static const unsigned int nzc6[5] = {6, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc3[5] = {0, 2, 3, 4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc0[5] = {0, 2, 3, 4, 5};
    
    static const double FE0_D10[16][5] = \
    {{-2.50971523732187, -0.738132021779942, 0.22841678445807, -0.22841678445807, 3.24784725910181},
    {-1.69178745260203, -0.799159507154521, 1.10737205455249, -1.1073720545525, 2.49094695975655},
    {-0.549989933626777, -0.884351663102444, 2.33436172947567, -2.33436172947567, 1.43434159672922},
    {0.479775683132663, -0.961184859492216, 3.44096054262488, -3.44096054262488, 0.481409176359554},
    {-1.5269250065645, 0.244658208977428, 0.22841678445807, -0.22841678445807, 1.28226679758707},
    {-0.938033306521733, -0.0454053610742284, 1.10737205455249, -1.1073720545525, 0.983438667595962},
    {-0.115961853986035, -0.450323583461703, 2.33436172947567, -2.33436172947567, 0.566285437447738},
    {0.625448862250686, -0.815511680374192, 3.44096054262488, -3.44096054262488, 0.190062818123506},
    {-0.244658208977429, 1.5269250065645, 0.22841678445807, -0.22841678445807, -1.28226679758707},
    {0.0454053610742282, 0.938033306521733, 1.1073720545525, -1.1073720545525, -0.983438667595961},
    {0.450323583461703, 0.115961853986035, 2.33436172947567, -2.33436172947567, -0.566285437447738},
    {0.815511680374192, -0.625448862250687, 3.44096054262488, -3.44096054262488, -0.190062818123505},
    {0.738132021779942, 2.50971523732187, 0.22841678445807, -0.22841678445807, -3.24784725910181},
    {0.799159507154521, 1.69178745260203, 1.10737205455249, -1.1073720545525, -2.49094695975655},
    {0.884351663102444, 0.549989933626776, 2.33436172947567, -2.33436172947567, -1.43434159672922},
    {0.961184859492216, -0.479775683132663, 3.44096054262488, -3.44096054262488, -0.481409176359553}};
    
    // Array of non-zero columns
    static const unsigned int nzc1[5] = {0, 1, 3, 4, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc7[5] = {6, 7, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc4[5] = {0, 1, 3, 4, 5};
    
    static const double FE1_C2[16][3] = \
    {{0.877428809330468, 0.0654669945550145, 0.0571041961145176},
    {0.672946863150506, 0.0502101232113698, 0.276843013638124},
    {0.387497483406694, 0.028912084224389, 0.583590432368917},
    {0.130056079216834, 0.0097037851269462, 0.860240135656219},
    {0.631731251641125, 0.311164552244357, 0.0571041961145176},
    {0.484508326630433, 0.238648659731443, 0.276843013638124},
    {0.278990463496509, 0.137419104134574, 0.583590432368917},
    {0.0936377844373285, 0.0461220799064521, 0.860240135656219},
    {0.311164552244357, 0.631731251641125, 0.0571041961145176},
    {0.238648659731443, 0.484508326630433, 0.276843013638124},
    {0.137419104134574, 0.278990463496509, 0.583590432368917},
    {0.046122079906452, 0.0936377844373286, 0.860240135656219},
    {0.0654669945550144, 0.877428809330468, 0.0571041961145176},
    {0.0502101232113698, 0.672946863150506, 0.276843013638124},
    {0.0289120842243889, 0.387497483406694, 0.583590432368917},
    {0.00970378512694603, 0.130056079216835, 0.860240135656219}};
    
    // Array of non-zero columns
    static const unsigned int nzc8[3] = {12, 13, 14};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.0;
    }// end loop over 'r'
    // Number of operations to compute geometry constants: 23.
    double G[11];
    G[0] =  - K_00*det;
    G[1] =  - K_10*det;
    G[2] =  - K_01*det;
    G[3] =  - K_11*det;
    G[4] = K_10*det;
    G[5] =  - det*w[2][0]*(K_00*K_10 + K_01*K_11);
    G[6] =  - det*w[2][0]*(K_10*K_10 + K_11*K_11);
    G[7] = K_00*det;
    G[8] =  - det*w[2][0]*(K_00*K_00 + K_01*K_01);
    G[9] = K_11*det;
    G[10] = K_01*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 4720
    for (unsigned int ip = 0; ip < 16; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      double F7 = 0.0;
      double F8 = 0.0;
      double F9 = 0.0;
      double F10 = 0.0;
      double F11 = 0.0;
      double F12 = 0.0;
      
      // Total number of operations to compute function values = 12
      for (unsigned int r = 0; r < 3; r++)
      {
        F3 += FE1_C2[ip][r]*w[3][nzc8[r]];
        F12 += FE1_C2[ip][r]*w[0][nzc8[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 60
      for (unsigned int r = 0; r < 5; r++)
      {
        F4 += FE0_D10[ip][r]*w[0][nzc4[r]];
        F5 += FE0_D01[ip][r]*w[0][nzc3[r]];
        F8 += FE0_D10[ip][r]*w[0][nzc7[r]];
        F9 += FE0_D01[ip][r]*w[0][nzc6[r]];
        F10 += FE0_D10[ip][r]*w[4][nzc1[r]];
        F11 += FE0_D01[ip][r]*w[4][nzc0[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 60
      for (unsigned int r = 0; r < 6; r++)
      {
        F0 += FE0[ip][r]*w[3][nzc2[r]];
        F1 += FE0[ip][r]*w[4][r];
        F2 += FE0[ip][r]*w[3][nzc5[r]];
        F6 += FE0[ip][r]*w[0][nzc2[r]];
        F7 += FE0[ip][r]*w[0][nzc5[r]];
      }// end loop over 'r'
      
      // Number of operations to compute ip constants: 93
      double I[7];
      // Number of operations: 11
      I[0] = F1*W16[ip]*(F4*G[0] + F5*G[1] + F8*G[2] + F9*G[3] - F3*det);
      
      // Number of operations: 7
      I[1] = F1*W16[ip]*(F12*G[4] + F4*G[5] + F5*G[6]);
      
      // Number of operations: 7
      I[2] = F1*W16[ip]*(F12*G[7] + F4*G[8] + F5*G[5]);
      
      // Number of operations: 7
      I[3] = F1*W16[ip]*(F12*G[9] + F8*G[5] + F9*G[6]);
      
      // Number of operations: 7
      I[4] = F1*W16[ip]*(F12*G[10] + F8*G[8] + F9*G[5]);
      
      // Number of operations: 27
      I[5] = W16[ip]*(F1*(F6*(F4*G[0] + F5*G[1]) + F7*(F4*G[2] + F5*G[3]) - F0*det) + F10*(F12*G[7] + F4*G[8] + F5*G[5]) + F11*(F12*G[4] + F4*G[5] + F5*G[6]));
      
      // Number of operations: 27
      I[6] = W16[ip]*(F1*(F8*(F6*G[0] + F7*G[2]) + F9*(F6*G[1] + F7*G[3]) - F2*det) + F10*(F12*G[10] + F8*G[8] + F9*G[5]) + F11*(F12*G[9] + F8*G[5] + F9*G[6]));
      
      
      // Number of operations for primary indices: 6
      for (unsigned int j = 0; j < 3; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc8[j]] += FE1_C2[ip][j]*I[0];
      }// end loop over 'j'
      
      // Number of operations for primary indices: 40
      for (unsigned int j = 0; j < 5; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc3[j]] += FE0_D01[ip][j]*I[1];
        // Number of operations to compute entry: 2
        A[nzc4[j]] += FE0_D10[ip][j]*I[2];
        // Number of operations to compute entry: 2
        A[nzc6[j]] += FE0_D01[ip][j]*I[3];
        // Number of operations to compute entry: 2
        A[nzc7[j]] += FE0_D10[ip][j]*I[4];
      }// end loop over 'j'
      
      // Number of operations for primary indices: 24
      for (unsigned int j = 0; j < 6; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc2[j]] += FE0[ip][j]*I[5];
        // Number of operations to compute entry: 2
        A[nzc5[j]] += FE0[ip][j]*I[6];
      }// end loop over 'j'
    }// end loop over 'ip'
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not yet implemented (introduced in UFC 2.0).");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_6_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_6_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_6_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x[v1][0] - x[v0][0];
    const double dx1 = x[v1][1] - x[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    const bool direction = dx1*(x[facet][0] - x[v0][0]) - dx0*(x[facet][1] - x[v0][1]) < 0;// Compute facet normals from the facet scale factor constants
    const double n0 = direction ? dx1 / det : -dx1 / det;
    const double n1 = direction ? -dx0 / det : dx0 / det;
    
    // Cell Volume.
    
    // Compute circumradius, assuming triangle is embedded in 2D.
    
    
    // Facet Area.
    
    // Array of quadrature weights.
    static const double W3[3] = {0.277777777777778, 0.444444444444444, 0.277777777777778};
    // Quadrature points on the UFC reference element: (0.112701665379258), (0.5), (0.887298334620742)
    
    // Value of basis functions at quadrature points.
    static const double FE0_f0[3][2] = \
    {{0.887298334620742, 0.112701665379258},
    {0.5, 0.5},
    {0.112701665379258, 0.887298334620742}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[2] = {1, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 1};
    
    static const double FE1_f0[3][3] = \
    {{0.687298334620742, -0.0872983346207417, 0.4},
    {0.0, 0.0, 1.0},
    {-0.0872983346207416, 0.687298334620742, 0.4}};
    
    // Array of non-zero columns
    static const unsigned int nzc5[3] = {0, 1, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc3[3] = {1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc9[3] = {0, 2, 4};
    
    // Array of non-zero columns
    static const unsigned int nzc10[3] = {6, 8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc13[3] = {6, 7, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc12[3] = {0, 1, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc4[3] = {0, 2, 4};
    
    // Array of non-zero columns
    static const unsigned int nzc6[3] = {1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc7[3] = {7, 8, 9};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.0;
    }// end loop over 'r'
    // Number of operations to compute geometry constants: 2.
    double G[2];
    G[0] =  - det*n0;
    G[1] =  - det*n1;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    switch (facet)
    {
    case 0:
      {
        // Total number of operations to compute element tensor (from this point): 84
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 84
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        double F1 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc0[r]];
        }// end loop over 'r'
        
        // Total number of operations to compute function values = 6
        for (unsigned int r = 0; r < 3; r++)
        {
          F1 += FE1_f0[ip][r]*w[4][nzc3[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 6
        double I[2];
        // Number of operations: 3
        I[0] = F0*F1*G[0]*W3[ip];
        
        // Number of operations: 3
        I[1] = F0*F1*G[1]*W3[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc6[j]] += FE1_f0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc7[j]] += FE1_f0[ip][j]*I[1];
        }// end loop over 'j'
      }// end loop over 'ip'
        break;
      }
    case 1:
      {
        // Total number of operations to compute element tensor (from this point): 84
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 84
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        double F1 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc1[r]];
        }// end loop over 'r'
        
        // Total number of operations to compute function values = 6
        for (unsigned int r = 0; r < 3; r++)
        {
          F1 += FE1_f0[ip][r]*w[4][nzc4[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 6
        double I[2];
        // Number of operations: 3
        I[0] = F0*F1*G[1]*W3[ip];
        
        // Number of operations: 3
        I[1] = F0*F1*G[0]*W3[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc10[j]] += FE1_f0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc9[j]] += FE1_f0[ip][j]*I[1];
        }// end loop over 'j'
      }// end loop over 'ip'
        break;
      }
    case 2:
      {
        // Total number of operations to compute element tensor (from this point): 84
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 84
      for (unsigned int ip = 0; ip < 3; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        double F1 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc2[r]];
        }// end loop over 'r'
        
        // Total number of operations to compute function values = 6
        for (unsigned int r = 0; r < 3; r++)
        {
          F1 += FE1_f0[ip][r]*w[4][nzc5[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 6
        double I[2];
        // Number of operations: 3
        I[0] = F0*F1*G[0]*W3[ip];
        
        // Number of operations: 3
        I[1] = F0*F1*G[1]*W3[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc12[j]] += FE1_f0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc13[j]] += FE1_f0[ip][j]*I[1];
        }// end loop over 'j'
      }// end loop over 'ip'
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not yet implemented (introduced in UFC 2.0).");
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_7_0: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_7_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_7_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      9
    // Number of operations (multiply-add pairs) for geometry tensor:    292
    // Number of operations (multiply-add pairs) for tensor contraction: 194
    // Total number of operations (multiply-add pairs):                  495
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0_0 = det*w[1][0]*w[0][0]*(1.0);
    const double G0_0_1 = det*w[1][0]*w[0][1]*(1.0);
    const double G0_0_2 = det*w[1][0]*w[0][2]*(1.0);
    const double G0_0_3 = det*w[1][0]*w[0][3]*(1.0);
    const double G0_0_4 = det*w[1][0]*w[0][4]*(1.0);
    const double G0_0_5 = det*w[1][0]*w[0][5]*(1.0);
    const double G0_0_6 = det*w[1][0]*w[0][6]*(1.0);
    const double G0_0_7 = det*w[1][0]*w[0][7]*(1.0);
    const double G0_0_8 = det*w[1][0]*w[0][8]*(1.0);
    const double G0_0_9 = det*w[1][0]*w[0][9]*(1.0);
    const double G0_1_0 = det*w[1][1]*w[0][0]*(1.0);
    const double G0_1_1 = det*w[1][1]*w[0][1]*(1.0);
    const double G0_1_2 = det*w[1][1]*w[0][2]*(1.0);
    const double G0_1_3 = det*w[1][1]*w[0][3]*(1.0);
    const double G0_1_4 = det*w[1][1]*w[0][4]*(1.0);
    const double G0_1_5 = det*w[1][1]*w[0][5]*(1.0);
    const double G0_1_6 = det*w[1][1]*w[0][6]*(1.0);
    const double G0_1_7 = det*w[1][1]*w[0][7]*(1.0);
    const double G0_1_8 = det*w[1][1]*w[0][8]*(1.0);
    const double G0_1_9 = det*w[1][1]*w[0][9]*(1.0);
    const double G0_2_0 = det*w[1][2]*w[0][0]*(1.0);
    const double G0_2_1 = det*w[1][2]*w[0][1]*(1.0);
    const double G0_2_2 = det*w[1][2]*w[0][2]*(1.0);
    const double G0_2_3 = det*w[1][2]*w[0][3]*(1.0);
    const double G0_2_4 = det*w[1][2]*w[0][4]*(1.0);
    const double G0_2_5 = det*w[1][2]*w[0][5]*(1.0);
    const double G0_2_6 = det*w[1][2]*w[0][6]*(1.0);
    const double G0_2_7 = det*w[1][2]*w[0][7]*(1.0);
    const double G0_2_8 = det*w[1][2]*w[0][8]*(1.0);
    const double G0_2_9 = det*w[1][2]*w[0][9]*(1.0);
    const double G0_3_0 = det*w[1][3]*w[0][0]*(1.0);
    const double G0_3_1 = det*w[1][3]*w[0][1]*(1.0);
    const double G0_3_2 = det*w[1][3]*w[0][2]*(1.0);
    const double G0_3_3 = det*w[1][3]*w[0][3]*(1.0);
    const double G0_3_4 = det*w[1][3]*w[0][4]*(1.0);
    const double G0_3_5 = det*w[1][3]*w[0][5]*(1.0);
    const double G0_3_6 = det*w[1][3]*w[0][6]*(1.0);
    const double G0_3_7 = det*w[1][3]*w[0][7]*(1.0);
    const double G0_3_8 = det*w[1][3]*w[0][8]*(1.0);
    const double G0_3_9 = det*w[1][3]*w[0][9]*(1.0);
    const double G0_4_0 = det*w[1][4]*w[0][0]*(1.0);
    const double G0_4_1 = det*w[1][4]*w[0][1]*(1.0);
    const double G0_4_2 = det*w[1][4]*w[0][2]*(1.0);
    const double G0_4_3 = det*w[1][4]*w[0][3]*(1.0);
    const double G0_4_4 = det*w[1][4]*w[0][4]*(1.0);
    const double G0_4_5 = det*w[1][4]*w[0][5]*(1.0);
    const double G0_4_6 = det*w[1][4]*w[0][6]*(1.0);
    const double G0_4_7 = det*w[1][4]*w[0][7]*(1.0);
    const double G0_4_8 = det*w[1][4]*w[0][8]*(1.0);
    const double G0_4_9 = det*w[1][4]*w[0][9]*(1.0);
    const double G0_5_0 = det*w[1][5]*w[0][0]*(1.0);
    const double G0_5_1 = det*w[1][5]*w[0][1]*(1.0);
    const double G0_5_2 = det*w[1][5]*w[0][2]*(1.0);
    const double G0_5_3 = det*w[1][5]*w[0][3]*(1.0);
    const double G0_5_4 = det*w[1][5]*w[0][4]*(1.0);
    const double G0_5_5 = det*w[1][5]*w[0][5]*(1.0);
    const double G0_5_6 = det*w[1][5]*w[0][6]*(1.0);
    const double G0_5_7 = det*w[1][5]*w[0][7]*(1.0);
    const double G0_5_8 = det*w[1][5]*w[0][8]*(1.0);
    const double G0_5_9 = det*w[1][5]*w[0][9]*(1.0);
    const double G0_6_10 = det*w[1][6]*w[0][10]*(1.0);
    const double G0_6_11 = det*w[1][6]*w[0][11]*(1.0);
    const double G0_6_12 = det*w[1][6]*w[0][12]*(1.0);
    const double G0_6_13 = det*w[1][6]*w[0][13]*(1.0);
    const double G0_6_14 = det*w[1][6]*w[0][14]*(1.0);
    const double G0_6_15 = det*w[1][6]*w[0][15]*(1.0);
    const double G0_6_16 = det*w[1][6]*w[0][16]*(1.0);
    const double G0_6_17 = det*w[1][6]*w[0][17]*(1.0);
    const double G0_6_18 = det*w[1][6]*w[0][18]*(1.0);
    const double G0_6_19 = det*w[1][6]*w[0][19]*(1.0);
    const double G0_7_10 = det*w[1][7]*w[0][10]*(1.0);
    const double G0_7_11 = det*w[1][7]*w[0][11]*(1.0);
    const double G0_7_12 = det*w[1][7]*w[0][12]*(1.0);
    const double G0_7_13 = det*w[1][7]*w[0][13]*(1.0);
    const double G0_7_14 = det*w[1][7]*w[0][14]*(1.0);
    const double G0_7_15 = det*w[1][7]*w[0][15]*(1.0);
    const double G0_7_16 = det*w[1][7]*w[0][16]*(1.0);
    const double G0_7_17 = det*w[1][7]*w[0][17]*(1.0);
    const double G0_7_18 = det*w[1][7]*w[0][18]*(1.0);
    const double G0_7_19 = det*w[1][7]*w[0][19]*(1.0);
    const double G0_8_10 = det*w[1][8]*w[0][10]*(1.0);
    const double G0_8_11 = det*w[1][8]*w[0][11]*(1.0);
    const double G0_8_12 = det*w[1][8]*w[0][12]*(1.0);
    const double G0_8_13 = det*w[1][8]*w[0][13]*(1.0);
    const double G0_8_14 = det*w[1][8]*w[0][14]*(1.0);
    const double G0_8_15 = det*w[1][8]*w[0][15]*(1.0);
    const double G0_8_16 = det*w[1][8]*w[0][16]*(1.0);
    const double G0_8_17 = det*w[1][8]*w[0][17]*(1.0);
    const double G0_8_18 = det*w[1][8]*w[0][18]*(1.0);
    const double G0_8_19 = det*w[1][8]*w[0][19]*(1.0);
    const double G0_9_10 = det*w[1][9]*w[0][10]*(1.0);
    const double G0_9_11 = det*w[1][9]*w[0][11]*(1.0);
    const double G0_9_12 = det*w[1][9]*w[0][12]*(1.0);
    const double G0_9_13 = det*w[1][9]*w[0][13]*(1.0);
    const double G0_9_14 = det*w[1][9]*w[0][14]*(1.0);
    const double G0_9_15 = det*w[1][9]*w[0][15]*(1.0);
    const double G0_9_16 = det*w[1][9]*w[0][16]*(1.0);
    const double G0_9_17 = det*w[1][9]*w[0][17]*(1.0);
    const double G0_9_18 = det*w[1][9]*w[0][18]*(1.0);
    const double G0_9_19 = det*w[1][9]*w[0][19]*(1.0);
    const double G0_10_10 = det*w[1][10]*w[0][10]*(1.0);
    const double G0_10_11 = det*w[1][10]*w[0][11]*(1.0);
    const double G0_10_12 = det*w[1][10]*w[0][12]*(1.0);
    const double G0_10_13 = det*w[1][10]*w[0][13]*(1.0);
    const double G0_10_14 = det*w[1][10]*w[0][14]*(1.0);
    const double G0_10_15 = det*w[1][10]*w[0][15]*(1.0);
    const double G0_10_16 = det*w[1][10]*w[0][16]*(1.0);
    const double G0_10_17 = det*w[1][10]*w[0][17]*(1.0);
    const double G0_10_18 = det*w[1][10]*w[0][18]*(1.0);
    const double G0_10_19 = det*w[1][10]*w[0][19]*(1.0);
    const double G0_11_10 = det*w[1][11]*w[0][10]*(1.0);
    const double G0_11_11 = det*w[1][11]*w[0][11]*(1.0);
    const double G0_11_12 = det*w[1][11]*w[0][12]*(1.0);
    const double G0_11_13 = det*w[1][11]*w[0][13]*(1.0);
    const double G0_11_14 = det*w[1][11]*w[0][14]*(1.0);
    const double G0_11_15 = det*w[1][11]*w[0][15]*(1.0);
    const double G0_11_16 = det*w[1][11]*w[0][16]*(1.0);
    const double G0_11_17 = det*w[1][11]*w[0][17]*(1.0);
    const double G0_11_18 = det*w[1][11]*w[0][18]*(1.0);
    const double G0_11_19 = det*w[1][11]*w[0][19]*(1.0);
    const double G0_12_20 = det*w[1][12]*w[0][20]*(1.0);
    const double G0_12_21 = det*w[1][12]*w[0][21]*(1.0);
    const double G0_12_22 = det*w[1][12]*w[0][22]*(1.0);
    const double G0_12_23 = det*w[1][12]*w[0][23]*(1.0);
    const double G0_12_24 = det*w[1][12]*w[0][24]*(1.0);
    const double G0_12_25 = det*w[1][12]*w[0][25]*(1.0);
    const double G0_13_20 = det*w[1][13]*w[0][20]*(1.0);
    const double G0_13_21 = det*w[1][13]*w[0][21]*(1.0);
    const double G0_13_22 = det*w[1][13]*w[0][22]*(1.0);
    const double G0_13_23 = det*w[1][13]*w[0][23]*(1.0);
    const double G0_13_24 = det*w[1][13]*w[0][24]*(1.0);
    const double G0_13_25 = det*w[1][13]*w[0][25]*(1.0);
    const double G0_14_20 = det*w[1][14]*w[0][20]*(1.0);
    const double G0_14_21 = det*w[1][14]*w[0][21]*(1.0);
    const double G0_14_22 = det*w[1][14]*w[0][22]*(1.0);
    const double G0_14_23 = det*w[1][14]*w[0][23]*(1.0);
    const double G0_14_24 = det*w[1][14]*w[0][24]*(1.0);
    const double G0_14_25 = det*w[1][14]*w[0][25]*(1.0);
    const double G1_0_0 = det*w[1][0]*w[3][0]*(1.0);
    const double G1_0_1 = det*w[1][0]*w[3][1]*(1.0);
    const double G1_0_2 = det*w[1][0]*w[3][2]*(1.0);
    const double G1_0_3 = det*w[1][0]*w[3][3]*(1.0);
    const double G1_1_0 = det*w[1][1]*w[3][0]*(1.0);
    const double G1_1_1 = det*w[1][1]*w[3][1]*(1.0);
    const double G1_1_2 = det*w[1][1]*w[3][2]*(1.0);
    const double G1_1_4 = det*w[1][1]*w[3][4]*(1.0);
    const double G1_2_0 = det*w[1][2]*w[3][0]*(1.0);
    const double G1_2_1 = det*w[1][2]*w[3][1]*(1.0);
    const double G1_2_2 = det*w[1][2]*w[3][2]*(1.0);
    const double G1_2_5 = det*w[1][2]*w[3][5]*(1.0);
    const double G1_3_0 = det*w[1][3]*w[3][0]*(1.0);
    const double G1_3_3 = det*w[1][3]*w[3][3]*(1.0);
    const double G1_3_4 = det*w[1][3]*w[3][4]*(1.0);
    const double G1_3_5 = det*w[1][3]*w[3][5]*(1.0);
    const double G1_4_1 = det*w[1][4]*w[3][1]*(1.0);
    const double G1_4_3 = det*w[1][4]*w[3][3]*(1.0);
    const double G1_4_4 = det*w[1][4]*w[3][4]*(1.0);
    const double G1_4_5 = det*w[1][4]*w[3][5]*(1.0);
    const double G1_5_2 = det*w[1][5]*w[3][2]*(1.0);
    const double G1_5_3 = det*w[1][5]*w[3][3]*(1.0);
    const double G1_5_4 = det*w[1][5]*w[3][4]*(1.0);
    const double G1_5_5 = det*w[1][5]*w[3][5]*(1.0);
    const double G1_6_6 = det*w[1][6]*w[3][6]*(1.0);
    const double G1_6_7 = det*w[1][6]*w[3][7]*(1.0);
    const double G1_6_8 = det*w[1][6]*w[3][8]*(1.0);
    const double G1_6_9 = det*w[1][6]*w[3][9]*(1.0);
    const double G1_7_6 = det*w[1][7]*w[3][6]*(1.0);
    const double G1_7_7 = det*w[1][7]*w[3][7]*(1.0);
    const double G1_7_8 = det*w[1][7]*w[3][8]*(1.0);
    const double G1_7_10 = det*w[1][7]*w[3][10]*(1.0);
    const double G1_8_6 = det*w[1][8]*w[3][6]*(1.0);
    const double G1_8_7 = det*w[1][8]*w[3][7]*(1.0);
    const double G1_8_8 = det*w[1][8]*w[3][8]*(1.0);
    const double G1_8_11 = det*w[1][8]*w[3][11]*(1.0);
    const double G1_9_6 = det*w[1][9]*w[3][6]*(1.0);
    const double G1_9_9 = det*w[1][9]*w[3][9]*(1.0);
    const double G1_9_10 = det*w[1][9]*w[3][10]*(1.0);
    const double G1_9_11 = det*w[1][9]*w[3][11]*(1.0);
    const double G1_10_7 = det*w[1][10]*w[3][7]*(1.0);
    const double G1_10_9 = det*w[1][10]*w[3][9]*(1.0);
    const double G1_10_10 = det*w[1][10]*w[3][10]*(1.0);
    const double G1_10_11 = det*w[1][10]*w[3][11]*(1.0);
    const double G1_11_8 = det*w[1][11]*w[3][8]*(1.0);
    const double G1_11_9 = det*w[1][11]*w[3][9]*(1.0);
    const double G1_11_10 = det*w[1][11]*w[3][10]*(1.0);
    const double G1_11_11 = det*w[1][11]*w[3][11]*(1.0);
    const double G1_12_12 = det*w[1][12]*w[3][12]*(1.0);
    const double G1_12_13 = det*w[1][12]*w[3][13]*(1.0);
    const double G1_12_14 = det*w[1][12]*w[3][14]*(1.0);
    const double G1_13_12 = det*w[1][13]*w[3][12]*(1.0);
    const double G1_13_13 = det*w[1][13]*w[3][13]*(1.0);
    const double G1_13_14 = det*w[1][13]*w[3][14]*(1.0);
    const double G1_14_12 = det*w[1][14]*w[3][12]*(1.0);
    const double G1_14_13 = det*w[1][14]*w[3][13]*(1.0);
    const double G1_14_14 = det*w[1][14]*w[3][14]*(1.0);
    
    // Compute element tensor
    A[0] = 0.00595238095238095*G0_0_0 + 0.000595238095238095*G0_0_1 + 0.000595238095238097*G0_0_2 - 0.00357142857142857*G0_0_3 - 0.00357142857142857*G0_0_4 + 0.0160714285714286*G0_0_5 - 0.0107142857142857*G0_0_6 + 0.0160714285714286*G0_0_7 - 0.0107142857142857*G0_0_8 - 0.0107142857142857*G0_0_9 + 0.000595238095238095*G0_1_0 + 0.00595238095238094*G0_1_1 + 0.000595238095238097*G0_1_2 + 0.0160714285714286*G0_1_3 - 0.0107142857142857*G0_1_4 - 0.00357142857142857*G0_1_5 - 0.00357142857142858*G0_1_6 - 0.0107142857142857*G0_1_7 + 0.0160714285714286*G0_1_8 - 0.0107142857142857*G0_1_9 + 0.000595238095238096*G0_2_0 + 0.000595238095238096*G0_2_1 + 0.00595238095238094*G0_2_2 - 0.0107142857142857*G0_2_3 + 0.0160714285714286*G0_2_4 - 0.0107142857142857*G0_2_5 + 0.0160714285714286*G0_2_6 - 0.00357142857142857*G0_2_7 - 0.00357142857142857*G0_2_8 - 0.0107142857142857*G0_2_9 + 0.00476190476190477*G0_3_0 + 0.00238095238095238*G0_3_1 + 0.00238095238095237*G0_3_2 + 0.0285714285714285*G0_3_3 + 0.0285714285714286*G0_3_4 - 0.00714285714285714*G0_3_5 + 0.0142857142857143*G0_3_6 - 0.00714285714285716*G0_3_7 + 0.0142857142857143*G0_3_8 + 0.0857142857142858*G0_3_9 + 0.00238095238095239*G0_4_0 + 0.00476190476190476*G0_4_1 + 0.00238095238095238*G0_4_2 - 0.00714285714285715*G0_4_3 + 0.0142857142857143*G0_4_4 + 0.0285714285714286*G0_4_5 + 0.0285714285714286*G0_4_6 + 0.0142857142857143*G0_4_7 - 0.00714285714285714*G0_4_8 + 0.0857142857142858*G0_4_9 + 0.00238095238095238*G0_5_0 + 0.00238095238095238*G0_5_1 + 0.00476190476190476*G0_5_2 + 0.0142857142857143*G0_5_3 - 0.00714285714285713*G0_5_4 + 0.0142857142857143*G0_5_5 - 0.00714285714285714*G0_5_6 + 0.0285714285714286*G0_5_7 + 0.0285714285714286*G0_5_8 + 0.0857142857142857*G0_5_9 + 0.00595238095238095*G0_6_10 + 0.000595238095238095*G0_6_11 + 0.000595238095238097*G0_6_12 - 0.00357142857142857*G0_6_13 - 0.00357142857142857*G0_6_14 + 0.0160714285714286*G0_6_15 - 0.0107142857142857*G0_6_16 + 0.0160714285714286*G0_6_17 - 0.0107142857142857*G0_6_18 - 0.0107142857142857*G0_6_19 + 0.000595238095238095*G0_7_10 + 0.00595238095238094*G0_7_11 + 0.000595238095238097*G0_7_12 + 0.0160714285714286*G0_7_13 - 0.0107142857142857*G0_7_14 - 0.00357142857142857*G0_7_15 - 0.00357142857142858*G0_7_16 - 0.0107142857142857*G0_7_17 + 0.0160714285714286*G0_7_18 - 0.0107142857142857*G0_7_19 + 0.000595238095238096*G0_8_10 + 0.000595238095238096*G0_8_11 + 0.00595238095238094*G0_8_12 - 0.0107142857142857*G0_8_13 + 0.0160714285714286*G0_8_14 - 0.0107142857142857*G0_8_15 + 0.0160714285714286*G0_8_16 - 0.00357142857142857*G0_8_17 - 0.00357142857142857*G0_8_18 - 0.0107142857142857*G0_8_19 + 0.00476190476190477*G0_9_10 + 0.00238095238095238*G0_9_11 + 0.00238095238095237*G0_9_12 + 0.0285714285714285*G0_9_13 + 0.0285714285714286*G0_9_14 - 0.00714285714285714*G0_9_15 + 0.0142857142857143*G0_9_16 - 0.00714285714285716*G0_9_17 + 0.0142857142857143*G0_9_18 + 0.0857142857142858*G0_9_19 + 0.00238095238095239*G0_10_10 + 0.00476190476190476*G0_10_11 + 0.00238095238095238*G0_10_12 - 0.00714285714285715*G0_10_13 + 0.0142857142857143*G0_10_14 + 0.0285714285714286*G0_10_15 + 0.0285714285714286*G0_10_16 + 0.0142857142857143*G0_10_17 - 0.00714285714285714*G0_10_18 + 0.0857142857142858*G0_10_19 + 0.00238095238095238*G0_11_10 + 0.00238095238095238*G0_11_11 + 0.00476190476190476*G0_11_12 + 0.0142857142857143*G0_11_13 - 0.00714285714285713*G0_11_14 + 0.0142857142857143*G0_11_15 - 0.00714285714285714*G0_11_16 + 0.0285714285714286*G0_11_17 + 0.0285714285714286*G0_11_18 + 0.0857142857142857*G0_11_19 + 0.0166666666666667*G0_12_20 - 0.00833333333333333*G0_12_21 - 0.00833333333333334*G0_12_22 + 0.0333333333333333*G0_12_23 + 0.0666666666666667*G0_12_24 + 0.0666666666666667*G0_12_25 - 0.00833333333333334*G0_13_20 + 0.0166666666666667*G0_13_21 - 0.00833333333333333*G0_13_22 + 0.0666666666666667*G0_13_23 + 0.0333333333333333*G0_13_24 + 0.0666666666666667*G0_13_25 - 0.00833333333333333*G0_14_20 - 0.00833333333333333*G0_14_21 + 0.0166666666666666*G0_14_22 + 0.0666666666666667*G0_14_23 + 0.0666666666666667*G0_14_24 + 0.0333333333333333*G0_14_25 - 0.0166666666666667*G1_0_0 + 0.00277777777777778*G1_0_1 + 0.00277777777777778*G1_0_2 + 0.0111111111111111*G1_0_3 + 0.00277777777777778*G1_1_0 - 0.0166666666666667*G1_1_1 + 0.00277777777777777*G1_1_2 + 0.0111111111111111*G1_1_4 + 0.00277777777777778*G1_2_0 + 0.00277777777777777*G1_2_1 - 0.0166666666666666*G1_2_2 + 0.0111111111111111*G1_2_5 + 0.0111111111111111*G1_3_0 - 0.0888888888888889*G1_3_3 - 0.0444444444444445*G1_3_4 - 0.0444444444444445*G1_3_5 + 0.0111111111111111*G1_4_1 - 0.0444444444444445*G1_4_3 - 0.0888888888888889*G1_4_4 - 0.0444444444444445*G1_4_5 + 0.0111111111111111*G1_5_2 - 0.0444444444444445*G1_5_3 - 0.0444444444444445*G1_5_4 - 0.0888888888888889*G1_5_5 - 0.0166666666666667*G1_6_6 + 0.00277777777777778*G1_6_7 + 0.00277777777777778*G1_6_8 + 0.0111111111111111*G1_6_9 + 0.00277777777777778*G1_7_6 - 0.0166666666666667*G1_7_7 + 0.00277777777777777*G1_7_8 + 0.0111111111111111*G1_7_10 + 0.00277777777777778*G1_8_6 + 0.00277777777777777*G1_8_7 - 0.0166666666666666*G1_8_8 + 0.0111111111111111*G1_8_11 + 0.0111111111111111*G1_9_6 - 0.0888888888888889*G1_9_9 - 0.0444444444444445*G1_9_10 - 0.0444444444444445*G1_9_11 + 0.0111111111111111*G1_10_7 - 0.0444444444444445*G1_10_9 - 0.0888888888888889*G1_10_10 - 0.0444444444444445*G1_10_11 + 0.0111111111111111*G1_11_8 - 0.0444444444444445*G1_11_9 - 0.0444444444444445*G1_11_10 - 0.0888888888888889*G1_11_11 - 0.0833333333333334*G1_12_12 - 0.0416666666666667*G1_12_13 - 0.0416666666666667*G1_12_14 - 0.0416666666666667*G1_13_12 - 0.0833333333333333*G1_13_13 - 0.0416666666666667*G1_13_14 - 0.0416666666666667*G1_14_12 - 0.0416666666666667*G1_14_13 - 0.0833333333333333*G1_14_14;
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_7_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_7_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_7_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      9
    // Number of operations (multiply-add pairs) for geometry tensor:    180
    // Number of operations (multiply-add pairs) for tensor contraction: 136
    // Total number of operations (multiply-add pairs):                  325
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x[v1][0] - x[v0][0];
    const double dx1 = x[v1][1] - x[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    // Compute geometry tensor
    const double G0_0_0 = det*w[2][0]*w[0][0]*(1.0);
    const double G0_0_5 = det*w[2][0]*w[0][5]*(1.0);
    const double G0_0_6 = det*w[2][0]*w[0][6]*(1.0);
    const double G0_0_7 = det*w[2][0]*w[0][7]*(1.0);
    const double G0_0_8 = det*w[2][0]*w[0][8]*(1.0);
    const double G0_1_1 = det*w[2][1]*w[0][1]*(1.0);
    const double G0_1_3 = det*w[2][1]*w[0][3]*(1.0);
    const double G0_1_4 = det*w[2][1]*w[0][4]*(1.0);
    const double G0_1_7 = det*w[2][1]*w[0][7]*(1.0);
    const double G0_1_8 = det*w[2][1]*w[0][8]*(1.0);
    const double G0_2_2 = det*w[2][2]*w[0][2]*(1.0);
    const double G0_2_3 = det*w[2][2]*w[0][3]*(1.0);
    const double G0_2_4 = det*w[2][2]*w[0][4]*(1.0);
    const double G0_2_5 = det*w[2][2]*w[0][5]*(1.0);
    const double G0_2_6 = det*w[2][2]*w[0][6]*(1.0);
    const double G0_3_1 = det*w[2][3]*w[0][1]*(1.0);
    const double G0_3_2 = det*w[2][3]*w[0][2]*(1.0);
    const double G0_3_3 = det*w[2][3]*w[0][3]*(1.0);
    const double G0_3_4 = det*w[2][3]*w[0][4]*(1.0);
    const double G0_4_0 = det*w[2][4]*w[0][0]*(1.0);
    const double G0_4_2 = det*w[2][4]*w[0][2]*(1.0);
    const double G0_4_5 = det*w[2][4]*w[0][5]*(1.0);
    const double G0_4_6 = det*w[2][4]*w[0][6]*(1.0);
    const double G0_5_0 = det*w[2][5]*w[0][0]*(1.0);
    const double G0_5_1 = det*w[2][5]*w[0][1]*(1.0);
    const double G0_5_7 = det*w[2][5]*w[0][7]*(1.0);
    const double G0_5_8 = det*w[2][5]*w[0][8]*(1.0);
    const double G0_6_10 = det*w[2][6]*w[0][10]*(1.0);
    const double G0_6_15 = det*w[2][6]*w[0][15]*(1.0);
    const double G0_6_16 = det*w[2][6]*w[0][16]*(1.0);
    const double G0_6_17 = det*w[2][6]*w[0][17]*(1.0);
    const double G0_6_18 = det*w[2][6]*w[0][18]*(1.0);
    const double G0_7_11 = det*w[2][7]*w[0][11]*(1.0);
    const double G0_7_13 = det*w[2][7]*w[0][13]*(1.0);
    const double G0_7_14 = det*w[2][7]*w[0][14]*(1.0);
    const double G0_7_17 = det*w[2][7]*w[0][17]*(1.0);
    const double G0_7_18 = det*w[2][7]*w[0][18]*(1.0);
    const double G0_8_12 = det*w[2][8]*w[0][12]*(1.0);
    const double G0_8_13 = det*w[2][8]*w[0][13]*(1.0);
    const double G0_8_14 = det*w[2][8]*w[0][14]*(1.0);
    const double G0_8_15 = det*w[2][8]*w[0][15]*(1.0);
    const double G0_8_16 = det*w[2][8]*w[0][16]*(1.0);
    const double G0_9_11 = det*w[2][9]*w[0][11]*(1.0);
    const double G0_9_12 = det*w[2][9]*w[0][12]*(1.0);
    const double G0_9_13 = det*w[2][9]*w[0][13]*(1.0);
    const double G0_9_14 = det*w[2][9]*w[0][14]*(1.0);
    const double G0_10_10 = det*w[2][10]*w[0][10]*(1.0);
    const double G0_10_12 = det*w[2][10]*w[0][12]*(1.0);
    const double G0_10_15 = det*w[2][10]*w[0][15]*(1.0);
    const double G0_10_16 = det*w[2][10]*w[0][16]*(1.0);
    const double G0_11_10 = det*w[2][11]*w[0][10]*(1.0);
    const double G0_11_11 = det*w[2][11]*w[0][11]*(1.0);
    const double G0_11_17 = det*w[2][11]*w[0][17]*(1.0);
    const double G0_11_18 = det*w[2][11]*w[0][18]*(1.0);
    const double G0_12_20 = det*w[2][12]*w[0][20]*(1.0);
    const double G0_12_24 = det*w[2][12]*w[0][24]*(1.0);
    const double G0_12_25 = det*w[2][12]*w[0][25]*(1.0);
    const double G0_13_21 = det*w[2][13]*w[0][21]*(1.0);
    const double G0_13_23 = det*w[2][13]*w[0][23]*(1.0);
    const double G0_13_25 = det*w[2][13]*w[0][25]*(1.0);
    const double G0_14_22 = det*w[2][14]*w[0][22]*(1.0);
    const double G0_14_23 = det*w[2][14]*w[0][23]*(1.0);
    const double G0_14_24 = det*w[2][14]*w[0][24]*(1.0);
    const double G1_0_0 = det*w[2][0]*w[3][0]*(1.0);
    const double G1_0_1 = det*w[2][0]*w[3][1]*(1.0);
    const double G1_0_2 = det*w[2][0]*w[3][2]*(1.0);
    const double G1_0_4 = det*w[2][0]*w[3][4]*(1.0);
    const double G1_0_5 = det*w[2][0]*w[3][5]*(1.0);
    const double G1_1_0 = det*w[2][1]*w[3][0]*(1.0);
    const double G1_1_1 = det*w[2][1]*w[3][1]*(1.0);
    const double G1_1_2 = det*w[2][1]*w[3][2]*(1.0);
    const double G1_1_3 = det*w[2][1]*w[3][3]*(1.0);
    const double G1_1_5 = det*w[2][1]*w[3][5]*(1.0);
    const double G1_2_0 = det*w[2][2]*w[3][0]*(1.0);
    const double G1_2_1 = det*w[2][2]*w[3][1]*(1.0);
    const double G1_2_2 = det*w[2][2]*w[3][2]*(1.0);
    const double G1_2_3 = det*w[2][2]*w[3][3]*(1.0);
    const double G1_2_4 = det*w[2][2]*w[3][4]*(1.0);
    const double G1_3_1 = det*w[2][3]*w[3][1]*(1.0);
    const double G1_3_2 = det*w[2][3]*w[3][2]*(1.0);
    const double G1_3_3 = det*w[2][3]*w[3][3]*(1.0);
    const double G1_4_0 = det*w[2][4]*w[3][0]*(1.0);
    const double G1_4_2 = det*w[2][4]*w[3][2]*(1.0);
    const double G1_4_4 = det*w[2][4]*w[3][4]*(1.0);
    const double G1_5_0 = det*w[2][5]*w[3][0]*(1.0);
    const double G1_5_1 = det*w[2][5]*w[3][1]*(1.0);
    const double G1_5_5 = det*w[2][5]*w[3][5]*(1.0);
    const double G1_6_6 = det*w[2][6]*w[3][6]*(1.0);
    const double G1_6_7 = det*w[2][6]*w[3][7]*(1.0);
    const double G1_6_8 = det*w[2][6]*w[3][8]*(1.0);
    const double G1_6_10 = det*w[2][6]*w[3][10]*(1.0);
    const double G1_6_11 = det*w[2][6]*w[3][11]*(1.0);
    const double G1_7_6 = det*w[2][7]*w[3][6]*(1.0);
    const double G1_7_7 = det*w[2][7]*w[3][7]*(1.0);
    const double G1_7_8 = det*w[2][7]*w[3][8]*(1.0);
    const double G1_7_9 = det*w[2][7]*w[3][9]*(1.0);
    const double G1_7_11 = det*w[2][7]*w[3][11]*(1.0);
    const double G1_8_6 = det*w[2][8]*w[3][6]*(1.0);
    const double G1_8_7 = det*w[2][8]*w[3][7]*(1.0);
    const double G1_8_8 = det*w[2][8]*w[3][8]*(1.0);
    const double G1_8_9 = det*w[2][8]*w[3][9]*(1.0);
    const double G1_8_10 = det*w[2][8]*w[3][10]*(1.0);
    const double G1_9_7 = det*w[2][9]*w[3][7]*(1.0);
    const double G1_9_8 = det*w[2][9]*w[3][8]*(1.0);
    const double G1_9_9 = det*w[2][9]*w[3][9]*(1.0);
    const double G1_10_6 = det*w[2][10]*w[3][6]*(1.0);
    const double G1_10_8 = det*w[2][10]*w[3][8]*(1.0);
    const double G1_10_10 = det*w[2][10]*w[3][10]*(1.0);
    const double G1_11_6 = det*w[2][11]*w[3][6]*(1.0);
    const double G1_11_7 = det*w[2][11]*w[3][7]*(1.0);
    const double G1_11_11 = det*w[2][11]*w[3][11]*(1.0);
    const double G1_12_12 = det*w[2][12]*w[3][12]*(1.0);
    const double G1_12_13 = det*w[2][12]*w[3][13]*(1.0);
    const double G1_12_14 = det*w[2][12]*w[3][14]*(1.0);
    const double G1_13_12 = det*w[2][13]*w[3][12]*(1.0);
    const double G1_13_13 = det*w[2][13]*w[3][13]*(1.0);
    const double G1_13_14 = det*w[2][13]*w[3][14]*(1.0);
    const double G1_14_12 = det*w[2][14]*w[3][12]*(1.0);
    const double G1_14_13 = det*w[2][14]*w[3][13]*(1.0);
    const double G1_14_14 = det*w[2][14]*w[3][14]*(1.0);
    
    // Compute element tensor
    switch (facet)
    {
    case 0:
      {
        A[0] = 0.0916666666666666*G0_1_1 + 0.15*G0_1_3 - 0.075*G0_1_4 + 0.0916666666666666*G0_2_2 - 0.075*G0_2_3 + 0.15*G0_2_4 + 0.0333333333333333*G0_3_1 + 0.0333333333333333*G0_3_2 + 0.3*G0_3_3 + 0.3*G0_3_4 + 0.0916666666666666*G0_7_11 + 0.15*G0_7_13 - 0.075*G0_7_14 + 0.0916666666666666*G0_8_12 - 0.075*G0_8_13 + 0.15*G0_8_14 + 0.0333333333333333*G0_9_11 + 0.0333333333333333*G0_9_12 + 0.3*G0_9_13 + 0.3*G0_9_14 + 0.166666666666667*G0_13_21 + 0.333333333333333*G0_13_23 + 0.166666666666667*G0_14_22 + 0.333333333333333*G0_14_23 - 0.133333333333333*G1_1_1 + 0.0333333333333333*G1_1_2 - 0.0666666666666666*G1_1_3 + 0.0333333333333333*G1_2_1 - 0.133333333333333*G1_2_2 - 0.0666666666666666*G1_2_3 - 0.0666666666666666*G1_3_1 - 0.0666666666666666*G1_3_2 - 0.533333333333333*G1_3_3 - 0.133333333333333*G1_7_7 + 0.0333333333333333*G1_7_8 - 0.0666666666666666*G1_7_9 + 0.0333333333333333*G1_8_7 - 0.133333333333333*G1_8_8 - 0.0666666666666666*G1_8_9 - 0.0666666666666666*G1_9_7 - 0.0666666666666666*G1_9_8 - 0.533333333333333*G1_9_9 - 0.333333333333333*G1_13_13 - 0.166666666666667*G1_13_14 - 0.166666666666667*G1_14_13 - 0.333333333333333*G1_14_14;
        break;
      }
    case 1:
      {
        A[0] = 0.0916666666666666*G0_0_0 + 0.15*G0_0_5 - 0.075*G0_0_6 + 0.0916666666666666*G0_2_2 - 0.075*G0_2_5 + 0.15*G0_2_6 + 0.0333333333333333*G0_4_0 + 0.0333333333333333*G0_4_2 + 0.3*G0_4_5 + 0.3*G0_4_6 + 0.0916666666666666*G0_6_10 + 0.15*G0_6_15 - 0.075*G0_6_16 + 0.0916666666666666*G0_8_12 - 0.075*G0_8_15 + 0.15*G0_8_16 + 0.0333333333333333*G0_10_10 + 0.0333333333333333*G0_10_12 + 0.3*G0_10_15 + 0.3*G0_10_16 + 0.166666666666667*G0_12_20 + 0.333333333333333*G0_12_24 + 0.166666666666667*G0_14_22 + 0.333333333333333*G0_14_24 - 0.133333333333333*G1_0_0 + 0.0333333333333333*G1_0_2 - 0.0666666666666666*G1_0_4 + 0.0333333333333333*G1_2_0 - 0.133333333333333*G1_2_2 - 0.0666666666666666*G1_2_4 - 0.0666666666666666*G1_4_0 - 0.0666666666666666*G1_4_2 - 0.533333333333333*G1_4_4 - 0.133333333333333*G1_6_6 + 0.0333333333333333*G1_6_8 - 0.0666666666666666*G1_6_10 + 0.0333333333333333*G1_8_6 - 0.133333333333333*G1_8_8 - 0.0666666666666666*G1_8_10 - 0.0666666666666666*G1_10_6 - 0.0666666666666666*G1_10_8 - 0.533333333333333*G1_10_10 - 0.333333333333333*G1_12_12 - 0.166666666666667*G1_12_14 - 0.166666666666667*G1_14_12 - 0.333333333333333*G1_14_14;
        break;
      }
    case 2:
      {
        A[0] = 0.0916666666666666*G0_0_0 + 0.15*G0_0_7 - 0.0749999999999999*G0_0_8 + 0.0916666666666666*G0_1_1 - 0.075*G0_1_7 + 0.15*G0_1_8 + 0.0333333333333333*G0_5_0 + 0.0333333333333333*G0_5_1 + 0.3*G0_5_7 + 0.3*G0_5_8 + 0.0916666666666666*G0_6_10 + 0.15*G0_6_17 - 0.0749999999999999*G0_6_18 + 0.0916666666666666*G0_7_11 - 0.075*G0_7_17 + 0.15*G0_7_18 + 0.0333333333333333*G0_11_10 + 0.0333333333333333*G0_11_11 + 0.3*G0_11_17 + 0.3*G0_11_18 + 0.166666666666667*G0_12_20 + 0.333333333333333*G0_12_25 + 0.166666666666667*G0_13_21 + 0.333333333333333*G0_13_25 - 0.133333333333333*G1_0_0 + 0.0333333333333333*G1_0_1 - 0.0666666666666666*G1_0_5 + 0.0333333333333333*G1_1_0 - 0.133333333333333*G1_1_1 - 0.0666666666666667*G1_1_5 - 0.0666666666666666*G1_5_0 - 0.0666666666666667*G1_5_1 - 0.533333333333333*G1_5_5 - 0.133333333333333*G1_6_6 + 0.0333333333333333*G1_6_7 - 0.0666666666666666*G1_6_11 + 0.0333333333333333*G1_7_6 - 0.133333333333333*G1_7_7 - 0.0666666666666667*G1_7_11 - 0.0666666666666666*G1_11_6 - 0.0666666666666667*G1_11_7 - 0.533333333333333*G1_11_11 - 0.333333333333333*G1_12_12 - 0.166666666666667*G1_12_13 - 0.166666666666667*G1_13_12 - 0.333333333333333*G1_13_13;
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the
/// interior facet tensor corresponding to the local contribution to
/// a form from the integral over an interior facet.

class adaptivenavierstokes_interior_facet_integral_7_0: public ufc::interior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_interior_facet_integral_7_0() : ufc::interior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_interior_facet_integral_7_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local interior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c0,
                               const ufc::cell& c1,
                               unsigned int facet0,
                               unsigned int facet1) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      12
    // Number of operations (multiply-add pairs) for geometry tensor:    720
    // Number of operations (multiply-add pairs) for tensor contraction: 1647
    // Total number of operations (multiply-add pairs):                  2379
    
    // Extract vertex coordinates
    const double * const * x0 = c0.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet0][0];
    const unsigned int v1 = edge_vertices[facet0][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x0[v1][0] - x0[v0][0];
    const double dx1 = x0[v1][1] - x0[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    // Compute geometry tensor
    const double G0_15_26 = det*w[2][15]*w[0][26]*(1.0);
    const double G0_15_31 = det*w[2][15]*w[0][31]*(1.0);
    const double G0_15_32 = det*w[2][15]*w[0][32]*(1.0);
    const double G0_15_33 = det*w[2][15]*w[0][33]*(1.0);
    const double G0_15_34 = det*w[2][15]*w[0][34]*(1.0);
    const double G0_16_27 = det*w[2][16]*w[0][27]*(1.0);
    const double G0_16_29 = det*w[2][16]*w[0][29]*(1.0);
    const double G0_16_30 = det*w[2][16]*w[0][30]*(1.0);
    const double G0_16_33 = det*w[2][16]*w[0][33]*(1.0);
    const double G0_16_34 = det*w[2][16]*w[0][34]*(1.0);
    const double G0_17_28 = det*w[2][17]*w[0][28]*(1.0);
    const double G0_17_29 = det*w[2][17]*w[0][29]*(1.0);
    const double G0_17_30 = det*w[2][17]*w[0][30]*(1.0);
    const double G0_17_31 = det*w[2][17]*w[0][31]*(1.0);
    const double G0_17_32 = det*w[2][17]*w[0][32]*(1.0);
    const double G0_18_27 = det*w[2][18]*w[0][27]*(1.0);
    const double G0_18_28 = det*w[2][18]*w[0][28]*(1.0);
    const double G0_18_29 = det*w[2][18]*w[0][29]*(1.0);
    const double G0_18_30 = det*w[2][18]*w[0][30]*(1.0);
    const double G0_19_26 = det*w[2][19]*w[0][26]*(1.0);
    const double G0_19_28 = det*w[2][19]*w[0][28]*(1.0);
    const double G0_19_31 = det*w[2][19]*w[0][31]*(1.0);
    const double G0_19_32 = det*w[2][19]*w[0][32]*(1.0);
    const double G0_20_26 = det*w[2][20]*w[0][26]*(1.0);
    const double G0_20_27 = det*w[2][20]*w[0][27]*(1.0);
    const double G0_20_33 = det*w[2][20]*w[0][33]*(1.0);
    const double G0_20_34 = det*w[2][20]*w[0][34]*(1.0);
    const double G0_21_36 = det*w[2][21]*w[0][36]*(1.0);
    const double G0_21_41 = det*w[2][21]*w[0][41]*(1.0);
    const double G0_21_42 = det*w[2][21]*w[0][42]*(1.0);
    const double G0_21_43 = det*w[2][21]*w[0][43]*(1.0);
    const double G0_21_44 = det*w[2][21]*w[0][44]*(1.0);
    const double G0_22_37 = det*w[2][22]*w[0][37]*(1.0);
    const double G0_22_39 = det*w[2][22]*w[0][39]*(1.0);
    const double G0_22_40 = det*w[2][22]*w[0][40]*(1.0);
    const double G0_22_43 = det*w[2][22]*w[0][43]*(1.0);
    const double G0_22_44 = det*w[2][22]*w[0][44]*(1.0);
    const double G0_23_38 = det*w[2][23]*w[0][38]*(1.0);
    const double G0_23_39 = det*w[2][23]*w[0][39]*(1.0);
    const double G0_23_40 = det*w[2][23]*w[0][40]*(1.0);
    const double G0_23_41 = det*w[2][23]*w[0][41]*(1.0);
    const double G0_23_42 = det*w[2][23]*w[0][42]*(1.0);
    const double G0_24_37 = det*w[2][24]*w[0][37]*(1.0);
    const double G0_24_38 = det*w[2][24]*w[0][38]*(1.0);
    const double G0_24_39 = det*w[2][24]*w[0][39]*(1.0);
    const double G0_24_40 = det*w[2][24]*w[0][40]*(1.0);
    const double G0_25_36 = det*w[2][25]*w[0][36]*(1.0);
    const double G0_25_38 = det*w[2][25]*w[0][38]*(1.0);
    const double G0_25_41 = det*w[2][25]*w[0][41]*(1.0);
    const double G0_25_42 = det*w[2][25]*w[0][42]*(1.0);
    const double G0_26_36 = det*w[2][26]*w[0][36]*(1.0);
    const double G0_26_37 = det*w[2][26]*w[0][37]*(1.0);
    const double G0_26_43 = det*w[2][26]*w[0][43]*(1.0);
    const double G0_26_44 = det*w[2][26]*w[0][44]*(1.0);
    const double G0_27_46 = det*w[2][27]*w[0][46]*(1.0);
    const double G0_27_50 = det*w[2][27]*w[0][50]*(1.0);
    const double G0_27_51 = det*w[2][27]*w[0][51]*(1.0);
    const double G0_28_47 = det*w[2][28]*w[0][47]*(1.0);
    const double G0_28_49 = det*w[2][28]*w[0][49]*(1.0);
    const double G0_28_51 = det*w[2][28]*w[0][51]*(1.0);
    const double G0_29_48 = det*w[2][29]*w[0][48]*(1.0);
    const double G0_29_49 = det*w[2][29]*w[0][49]*(1.0);
    const double G0_29_50 = det*w[2][29]*w[0][50]*(1.0);
    const double G1_15_15 = det*w[2][15]*w[3][15]*(1.0);
    const double G1_15_16 = det*w[2][15]*w[3][16]*(1.0);
    const double G1_15_17 = det*w[2][15]*w[3][17]*(1.0);
    const double G1_15_19 = det*w[2][15]*w[3][19]*(1.0);
    const double G1_15_20 = det*w[2][15]*w[3][20]*(1.0);
    const double G1_16_15 = det*w[2][16]*w[3][15]*(1.0);
    const double G1_16_16 = det*w[2][16]*w[3][16]*(1.0);
    const double G1_16_17 = det*w[2][16]*w[3][17]*(1.0);
    const double G1_16_18 = det*w[2][16]*w[3][18]*(1.0);
    const double G1_16_20 = det*w[2][16]*w[3][20]*(1.0);
    const double G1_17_15 = det*w[2][17]*w[3][15]*(1.0);
    const double G1_17_16 = det*w[2][17]*w[3][16]*(1.0);
    const double G1_17_17 = det*w[2][17]*w[3][17]*(1.0);
    const double G1_17_18 = det*w[2][17]*w[3][18]*(1.0);
    const double G1_17_19 = det*w[2][17]*w[3][19]*(1.0);
    const double G1_18_16 = det*w[2][18]*w[3][16]*(1.0);
    const double G1_18_17 = det*w[2][18]*w[3][17]*(1.0);
    const double G1_18_18 = det*w[2][18]*w[3][18]*(1.0);
    const double G1_19_15 = det*w[2][19]*w[3][15]*(1.0);
    const double G1_19_17 = det*w[2][19]*w[3][17]*(1.0);
    const double G1_19_19 = det*w[2][19]*w[3][19]*(1.0);
    const double G1_20_15 = det*w[2][20]*w[3][15]*(1.0);
    const double G1_20_16 = det*w[2][20]*w[3][16]*(1.0);
    const double G1_20_20 = det*w[2][20]*w[3][20]*(1.0);
    const double G1_21_21 = det*w[2][21]*w[3][21]*(1.0);
    const double G1_21_22 = det*w[2][21]*w[3][22]*(1.0);
    const double G1_21_23 = det*w[2][21]*w[3][23]*(1.0);
    const double G1_21_25 = det*w[2][21]*w[3][25]*(1.0);
    const double G1_21_26 = det*w[2][21]*w[3][26]*(1.0);
    const double G1_22_21 = det*w[2][22]*w[3][21]*(1.0);
    const double G1_22_22 = det*w[2][22]*w[3][22]*(1.0);
    const double G1_22_23 = det*w[2][22]*w[3][23]*(1.0);
    const double G1_22_24 = det*w[2][22]*w[3][24]*(1.0);
    const double G1_22_26 = det*w[2][22]*w[3][26]*(1.0);
    const double G1_23_21 = det*w[2][23]*w[3][21]*(1.0);
    const double G1_23_22 = det*w[2][23]*w[3][22]*(1.0);
    const double G1_23_23 = det*w[2][23]*w[3][23]*(1.0);
    const double G1_23_24 = det*w[2][23]*w[3][24]*(1.0);
    const double G1_23_25 = det*w[2][23]*w[3][25]*(1.0);
    const double G1_24_22 = det*w[2][24]*w[3][22]*(1.0);
    const double G1_24_23 = det*w[2][24]*w[3][23]*(1.0);
    const double G1_24_24 = det*w[2][24]*w[3][24]*(1.0);
    const double G1_25_21 = det*w[2][25]*w[3][21]*(1.0);
    const double G1_25_23 = det*w[2][25]*w[3][23]*(1.0);
    const double G1_25_25 = det*w[2][25]*w[3][25]*(1.0);
    const double G1_26_21 = det*w[2][26]*w[3][21]*(1.0);
    const double G1_26_22 = det*w[2][26]*w[3][22]*(1.0);
    const double G1_26_26 = det*w[2][26]*w[3][26]*(1.0);
    const double G1_27_27 = det*w[2][27]*w[3][27]*(1.0);
    const double G1_27_28 = det*w[2][27]*w[3][28]*(1.0);
    const double G1_27_29 = det*w[2][27]*w[3][29]*(1.0);
    const double G1_28_27 = det*w[2][28]*w[3][27]*(1.0);
    const double G1_28_28 = det*w[2][28]*w[3][28]*(1.0);
    const double G1_28_29 = det*w[2][28]*w[3][29]*(1.0);
    const double G1_29_27 = det*w[2][29]*w[3][27]*(1.0);
    const double G1_29_28 = det*w[2][29]*w[3][28]*(1.0);
    const double G1_29_29 = det*w[2][29]*w[3][29]*(1.0);
    const double G2_0_0 = det*w[2][0]*w[0][0]*(1.0);
    const double G2_0_5 = det*w[2][0]*w[0][5]*(1.0);
    const double G2_0_6 = det*w[2][0]*w[0][6]*(1.0);
    const double G2_0_7 = det*w[2][0]*w[0][7]*(1.0);
    const double G2_0_8 = det*w[2][0]*w[0][8]*(1.0);
    const double G2_1_1 = det*w[2][1]*w[0][1]*(1.0);
    const double G2_1_3 = det*w[2][1]*w[0][3]*(1.0);
    const double G2_1_4 = det*w[2][1]*w[0][4]*(1.0);
    const double G2_1_7 = det*w[2][1]*w[0][7]*(1.0);
    const double G2_1_8 = det*w[2][1]*w[0][8]*(1.0);
    const double G2_2_2 = det*w[2][2]*w[0][2]*(1.0);
    const double G2_2_3 = det*w[2][2]*w[0][3]*(1.0);
    const double G2_2_4 = det*w[2][2]*w[0][4]*(1.0);
    const double G2_2_5 = det*w[2][2]*w[0][5]*(1.0);
    const double G2_2_6 = det*w[2][2]*w[0][6]*(1.0);
    const double G2_3_1 = det*w[2][3]*w[0][1]*(1.0);
    const double G2_3_2 = det*w[2][3]*w[0][2]*(1.0);
    const double G2_3_3 = det*w[2][3]*w[0][3]*(1.0);
    const double G2_3_4 = det*w[2][3]*w[0][4]*(1.0);
    const double G2_4_0 = det*w[2][4]*w[0][0]*(1.0);
    const double G2_4_2 = det*w[2][4]*w[0][2]*(1.0);
    const double G2_4_5 = det*w[2][4]*w[0][5]*(1.0);
    const double G2_4_6 = det*w[2][4]*w[0][6]*(1.0);
    const double G2_5_0 = det*w[2][5]*w[0][0]*(1.0);
    const double G2_5_1 = det*w[2][5]*w[0][1]*(1.0);
    const double G2_5_7 = det*w[2][5]*w[0][7]*(1.0);
    const double G2_5_8 = det*w[2][5]*w[0][8]*(1.0);
    const double G2_6_10 = det*w[2][6]*w[0][10]*(1.0);
    const double G2_6_15 = det*w[2][6]*w[0][15]*(1.0);
    const double G2_6_16 = det*w[2][6]*w[0][16]*(1.0);
    const double G2_6_17 = det*w[2][6]*w[0][17]*(1.0);
    const double G2_6_18 = det*w[2][6]*w[0][18]*(1.0);
    const double G2_7_11 = det*w[2][7]*w[0][11]*(1.0);
    const double G2_7_13 = det*w[2][7]*w[0][13]*(1.0);
    const double G2_7_14 = det*w[2][7]*w[0][14]*(1.0);
    const double G2_7_17 = det*w[2][7]*w[0][17]*(1.0);
    const double G2_7_18 = det*w[2][7]*w[0][18]*(1.0);
    const double G2_8_12 = det*w[2][8]*w[0][12]*(1.0);
    const double G2_8_13 = det*w[2][8]*w[0][13]*(1.0);
    const double G2_8_14 = det*w[2][8]*w[0][14]*(1.0);
    const double G2_8_15 = det*w[2][8]*w[0][15]*(1.0);
    const double G2_8_16 = det*w[2][8]*w[0][16]*(1.0);
    const double G2_9_11 = det*w[2][9]*w[0][11]*(1.0);
    const double G2_9_12 = det*w[2][9]*w[0][12]*(1.0);
    const double G2_9_13 = det*w[2][9]*w[0][13]*(1.0);
    const double G2_9_14 = det*w[2][9]*w[0][14]*(1.0);
    const double G2_10_10 = det*w[2][10]*w[0][10]*(1.0);
    const double G2_10_12 = det*w[2][10]*w[0][12]*(1.0);
    const double G2_10_15 = det*w[2][10]*w[0][15]*(1.0);
    const double G2_10_16 = det*w[2][10]*w[0][16]*(1.0);
    const double G2_11_10 = det*w[2][11]*w[0][10]*(1.0);
    const double G2_11_11 = det*w[2][11]*w[0][11]*(1.0);
    const double G2_11_17 = det*w[2][11]*w[0][17]*(1.0);
    const double G2_11_18 = det*w[2][11]*w[0][18]*(1.0);
    const double G2_12_20 = det*w[2][12]*w[0][20]*(1.0);
    const double G2_12_24 = det*w[2][12]*w[0][24]*(1.0);
    const double G2_12_25 = det*w[2][12]*w[0][25]*(1.0);
    const double G2_13_21 = det*w[2][13]*w[0][21]*(1.0);
    const double G2_13_23 = det*w[2][13]*w[0][23]*(1.0);
    const double G2_13_25 = det*w[2][13]*w[0][25]*(1.0);
    const double G2_14_22 = det*w[2][14]*w[0][22]*(1.0);
    const double G2_14_23 = det*w[2][14]*w[0][23]*(1.0);
    const double G2_14_24 = det*w[2][14]*w[0][24]*(1.0);
    const double G3_0_0 = det*w[2][0]*w[3][0]*(1.0);
    const double G3_0_1 = det*w[2][0]*w[3][1]*(1.0);
    const double G3_0_2 = det*w[2][0]*w[3][2]*(1.0);
    const double G3_0_4 = det*w[2][0]*w[3][4]*(1.0);
    const double G3_0_5 = det*w[2][0]*w[3][5]*(1.0);
    const double G3_1_0 = det*w[2][1]*w[3][0]*(1.0);
    const double G3_1_1 = det*w[2][1]*w[3][1]*(1.0);
    const double G3_1_2 = det*w[2][1]*w[3][2]*(1.0);
    const double G3_1_3 = det*w[2][1]*w[3][3]*(1.0);
    const double G3_1_5 = det*w[2][1]*w[3][5]*(1.0);
    const double G3_2_0 = det*w[2][2]*w[3][0]*(1.0);
    const double G3_2_1 = det*w[2][2]*w[3][1]*(1.0);
    const double G3_2_2 = det*w[2][2]*w[3][2]*(1.0);
    const double G3_2_3 = det*w[2][2]*w[3][3]*(1.0);
    const double G3_2_4 = det*w[2][2]*w[3][4]*(1.0);
    const double G3_3_1 = det*w[2][3]*w[3][1]*(1.0);
    const double G3_3_2 = det*w[2][3]*w[3][2]*(1.0);
    const double G3_3_3 = det*w[2][3]*w[3][3]*(1.0);
    const double G3_4_0 = det*w[2][4]*w[3][0]*(1.0);
    const double G3_4_2 = det*w[2][4]*w[3][2]*(1.0);
    const double G3_4_4 = det*w[2][4]*w[3][4]*(1.0);
    const double G3_5_0 = det*w[2][5]*w[3][0]*(1.0);
    const double G3_5_1 = det*w[2][5]*w[3][1]*(1.0);
    const double G3_5_5 = det*w[2][5]*w[3][5]*(1.0);
    const double G3_6_6 = det*w[2][6]*w[3][6]*(1.0);
    const double G3_6_7 = det*w[2][6]*w[3][7]*(1.0);
    const double G3_6_8 = det*w[2][6]*w[3][8]*(1.0);
    const double G3_6_10 = det*w[2][6]*w[3][10]*(1.0);
    const double G3_6_11 = det*w[2][6]*w[3][11]*(1.0);
    const double G3_7_6 = det*w[2][7]*w[3][6]*(1.0);
    const double G3_7_7 = det*w[2][7]*w[3][7]*(1.0);
    const double G3_7_8 = det*w[2][7]*w[3][8]*(1.0);
    const double G3_7_9 = det*w[2][7]*w[3][9]*(1.0);
    const double G3_7_11 = det*w[2][7]*w[3][11]*(1.0);
    const double G3_8_6 = det*w[2][8]*w[3][6]*(1.0);
    const double G3_8_7 = det*w[2][8]*w[3][7]*(1.0);
    const double G3_8_8 = det*w[2][8]*w[3][8]*(1.0);
    const double G3_8_9 = det*w[2][8]*w[3][9]*(1.0);
    const double G3_8_10 = det*w[2][8]*w[3][10]*(1.0);
    const double G3_9_7 = det*w[2][9]*w[3][7]*(1.0);
    const double G3_9_8 = det*w[2][9]*w[3][8]*(1.0);
    const double G3_9_9 = det*w[2][9]*w[3][9]*(1.0);
    const double G3_10_6 = det*w[2][10]*w[3][6]*(1.0);
    const double G3_10_8 = det*w[2][10]*w[3][8]*(1.0);
    const double G3_10_10 = det*w[2][10]*w[3][10]*(1.0);
    const double G3_11_6 = det*w[2][11]*w[3][6]*(1.0);
    const double G3_11_7 = det*w[2][11]*w[3][7]*(1.0);
    const double G3_11_11 = det*w[2][11]*w[3][11]*(1.0);
    const double G3_12_12 = det*w[2][12]*w[3][12]*(1.0);
    const double G3_12_13 = det*w[2][12]*w[3][13]*(1.0);
    const double G3_12_14 = det*w[2][12]*w[3][14]*(1.0);
    const double G3_13_12 = det*w[2][13]*w[3][12]*(1.0);
    const double G3_13_13 = det*w[2][13]*w[3][13]*(1.0);
    const double G3_13_14 = det*w[2][13]*w[3][14]*(1.0);
    const double G3_14_12 = det*w[2][14]*w[3][12]*(1.0);
    const double G3_14_13 = det*w[2][14]*w[3][13]*(1.0);
    const double G3_14_14 = det*w[2][14]*w[3][14]*(1.0);
    const double G4_15_26 = det*w[2][15]*w[0][26]*(1.0);
    const double G4_15_31 = det*w[2][15]*w[0][31]*(1.0);
    const double G4_15_32 = det*w[2][15]*w[0][32]*(1.0);
    const double G4_15_33 = det*w[2][15]*w[0][33]*(1.0);
    const double G4_15_34 = det*w[2][15]*w[0][34]*(1.0);
    const double G4_16_27 = det*w[2][16]*w[0][27]*(1.0);
    const double G4_16_29 = det*w[2][16]*w[0][29]*(1.0);
    const double G4_16_30 = det*w[2][16]*w[0][30]*(1.0);
    const double G4_16_33 = det*w[2][16]*w[0][33]*(1.0);
    const double G4_16_34 = det*w[2][16]*w[0][34]*(1.0);
    const double G4_17_28 = det*w[2][17]*w[0][28]*(1.0);
    const double G4_17_29 = det*w[2][17]*w[0][29]*(1.0);
    const double G4_17_30 = det*w[2][17]*w[0][30]*(1.0);
    const double G4_17_31 = det*w[2][17]*w[0][31]*(1.0);
    const double G4_17_32 = det*w[2][17]*w[0][32]*(1.0);
    const double G4_18_27 = det*w[2][18]*w[0][27]*(1.0);
    const double G4_18_28 = det*w[2][18]*w[0][28]*(1.0);
    const double G4_18_29 = det*w[2][18]*w[0][29]*(1.0);
    const double G4_18_30 = det*w[2][18]*w[0][30]*(1.0);
    const double G4_19_26 = det*w[2][19]*w[0][26]*(1.0);
    const double G4_19_28 = det*w[2][19]*w[0][28]*(1.0);
    const double G4_19_31 = det*w[2][19]*w[0][31]*(1.0);
    const double G4_19_32 = det*w[2][19]*w[0][32]*(1.0);
    const double G4_20_26 = det*w[2][20]*w[0][26]*(1.0);
    const double G4_20_27 = det*w[2][20]*w[0][27]*(1.0);
    const double G4_20_33 = det*w[2][20]*w[0][33]*(1.0);
    const double G4_20_34 = det*w[2][20]*w[0][34]*(1.0);
    const double G4_21_36 = det*w[2][21]*w[0][36]*(1.0);
    const double G4_21_41 = det*w[2][21]*w[0][41]*(1.0);
    const double G4_21_42 = det*w[2][21]*w[0][42]*(1.0);
    const double G4_21_43 = det*w[2][21]*w[0][43]*(1.0);
    const double G4_21_44 = det*w[2][21]*w[0][44]*(1.0);
    const double G4_22_37 = det*w[2][22]*w[0][37]*(1.0);
    const double G4_22_39 = det*w[2][22]*w[0][39]*(1.0);
    const double G4_22_40 = det*w[2][22]*w[0][40]*(1.0);
    const double G4_22_43 = det*w[2][22]*w[0][43]*(1.0);
    const double G4_22_44 = det*w[2][22]*w[0][44]*(1.0);
    const double G4_23_38 = det*w[2][23]*w[0][38]*(1.0);
    const double G4_23_39 = det*w[2][23]*w[0][39]*(1.0);
    const double G4_23_40 = det*w[2][23]*w[0][40]*(1.0);
    const double G4_23_41 = det*w[2][23]*w[0][41]*(1.0);
    const double G4_23_42 = det*w[2][23]*w[0][42]*(1.0);
    const double G4_24_37 = det*w[2][24]*w[0][37]*(1.0);
    const double G4_24_38 = det*w[2][24]*w[0][38]*(1.0);
    const double G4_24_39 = det*w[2][24]*w[0][39]*(1.0);
    const double G4_24_40 = det*w[2][24]*w[0][40]*(1.0);
    const double G4_25_36 = det*w[2][25]*w[0][36]*(1.0);
    const double G4_25_38 = det*w[2][25]*w[0][38]*(1.0);
    const double G4_25_41 = det*w[2][25]*w[0][41]*(1.0);
    const double G4_25_42 = det*w[2][25]*w[0][42]*(1.0);
    const double G4_26_36 = det*w[2][26]*w[0][36]*(1.0);
    const double G4_26_37 = det*w[2][26]*w[0][37]*(1.0);
    const double G4_26_43 = det*w[2][26]*w[0][43]*(1.0);
    const double G4_26_44 = det*w[2][26]*w[0][44]*(1.0);
    const double G4_27_46 = det*w[2][27]*w[0][46]*(1.0);
    const double G4_27_50 = det*w[2][27]*w[0][50]*(1.0);
    const double G4_27_51 = det*w[2][27]*w[0][51]*(1.0);
    const double G4_28_47 = det*w[2][28]*w[0][47]*(1.0);
    const double G4_28_49 = det*w[2][28]*w[0][49]*(1.0);
    const double G4_28_51 = det*w[2][28]*w[0][51]*(1.0);
    const double G4_29_48 = det*w[2][29]*w[0][48]*(1.0);
    const double G4_29_49 = det*w[2][29]*w[0][49]*(1.0);
    const double G4_29_50 = det*w[2][29]*w[0][50]*(1.0);
    const double G5_15_15 = det*w[2][15]*w[3][15]*(1.0);
    const double G5_15_16 = det*w[2][15]*w[3][16]*(1.0);
    const double G5_15_17 = det*w[2][15]*w[3][17]*(1.0);
    const double G5_15_19 = det*w[2][15]*w[3][19]*(1.0);
    const double G5_15_20 = det*w[2][15]*w[3][20]*(1.0);
    const double G5_16_15 = det*w[2][16]*w[3][15]*(1.0);
    const double G5_16_16 = det*w[2][16]*w[3][16]*(1.0);
    const double G5_16_17 = det*w[2][16]*w[3][17]*(1.0);
    const double G5_16_18 = det*w[2][16]*w[3][18]*(1.0);
    const double G5_16_20 = det*w[2][16]*w[3][20]*(1.0);
    const double G5_17_15 = det*w[2][17]*w[3][15]*(1.0);
    const double G5_17_16 = det*w[2][17]*w[3][16]*(1.0);
    const double G5_17_17 = det*w[2][17]*w[3][17]*(1.0);
    const double G5_17_18 = det*w[2][17]*w[3][18]*(1.0);
    const double G5_17_19 = det*w[2][17]*w[3][19]*(1.0);
    const double G5_18_16 = det*w[2][18]*w[3][16]*(1.0);
    const double G5_18_17 = det*w[2][18]*w[3][17]*(1.0);
    const double G5_18_18 = det*w[2][18]*w[3][18]*(1.0);
    const double G5_19_15 = det*w[2][19]*w[3][15]*(1.0);
    const double G5_19_17 = det*w[2][19]*w[3][17]*(1.0);
    const double G5_19_19 = det*w[2][19]*w[3][19]*(1.0);
    const double G5_20_15 = det*w[2][20]*w[3][15]*(1.0);
    const double G5_20_16 = det*w[2][20]*w[3][16]*(1.0);
    const double G5_20_20 = det*w[2][20]*w[3][20]*(1.0);
    const double G5_21_21 = det*w[2][21]*w[3][21]*(1.0);
    const double G5_21_22 = det*w[2][21]*w[3][22]*(1.0);
    const double G5_21_23 = det*w[2][21]*w[3][23]*(1.0);
    const double G5_21_25 = det*w[2][21]*w[3][25]*(1.0);
    const double G5_21_26 = det*w[2][21]*w[3][26]*(1.0);
    const double G5_22_21 = det*w[2][22]*w[3][21]*(1.0);
    const double G5_22_22 = det*w[2][22]*w[3][22]*(1.0);
    const double G5_22_23 = det*w[2][22]*w[3][23]*(1.0);
    const double G5_22_24 = det*w[2][22]*w[3][24]*(1.0);
    const double G5_22_26 = det*w[2][22]*w[3][26]*(1.0);
    const double G5_23_21 = det*w[2][23]*w[3][21]*(1.0);
    const double G5_23_22 = det*w[2][23]*w[3][22]*(1.0);
    const double G5_23_23 = det*w[2][23]*w[3][23]*(1.0);
    const double G5_23_24 = det*w[2][23]*w[3][24]*(1.0);
    const double G5_23_25 = det*w[2][23]*w[3][25]*(1.0);
    const double G5_24_22 = det*w[2][24]*w[3][22]*(1.0);
    const double G5_24_23 = det*w[2][24]*w[3][23]*(1.0);
    const double G5_24_24 = det*w[2][24]*w[3][24]*(1.0);
    const double G5_25_21 = det*w[2][25]*w[3][21]*(1.0);
    const double G5_25_23 = det*w[2][25]*w[3][23]*(1.0);
    const double G5_25_25 = det*w[2][25]*w[3][25]*(1.0);
    const double G5_26_21 = det*w[2][26]*w[3][21]*(1.0);
    const double G5_26_22 = det*w[2][26]*w[3][22]*(1.0);
    const double G5_26_26 = det*w[2][26]*w[3][26]*(1.0);
    const double G5_27_27 = det*w[2][27]*w[3][27]*(1.0);
    const double G5_27_28 = det*w[2][27]*w[3][28]*(1.0);
    const double G5_27_29 = det*w[2][27]*w[3][29]*(1.0);
    const double G5_28_27 = det*w[2][28]*w[3][27]*(1.0);
    const double G5_28_28 = det*w[2][28]*w[3][28]*(1.0);
    const double G5_28_29 = det*w[2][28]*w[3][29]*(1.0);
    const double G5_29_27 = det*w[2][29]*w[3][27]*(1.0);
    const double G5_29_28 = det*w[2][29]*w[3][28]*(1.0);
    const double G5_29_29 = det*w[2][29]*w[3][29]*(1.0);
    const double G6_0_0 = det*w[2][0]*w[0][0]*(1.0);
    const double G6_0_5 = det*w[2][0]*w[0][5]*(1.0);
    const double G6_0_6 = det*w[2][0]*w[0][6]*(1.0);
    const double G6_0_7 = det*w[2][0]*w[0][7]*(1.0);
    const double G6_0_8 = det*w[2][0]*w[0][8]*(1.0);
    const double G6_1_1 = det*w[2][1]*w[0][1]*(1.0);
    const double G6_1_3 = det*w[2][1]*w[0][3]*(1.0);
    const double G6_1_4 = det*w[2][1]*w[0][4]*(1.0);
    const double G6_1_7 = det*w[2][1]*w[0][7]*(1.0);
    const double G6_1_8 = det*w[2][1]*w[0][8]*(1.0);
    const double G6_2_2 = det*w[2][2]*w[0][2]*(1.0);
    const double G6_2_3 = det*w[2][2]*w[0][3]*(1.0);
    const double G6_2_4 = det*w[2][2]*w[0][4]*(1.0);
    const double G6_2_5 = det*w[2][2]*w[0][5]*(1.0);
    const double G6_2_6 = det*w[2][2]*w[0][6]*(1.0);
    const double G6_3_1 = det*w[2][3]*w[0][1]*(1.0);
    const double G6_3_2 = det*w[2][3]*w[0][2]*(1.0);
    const double G6_3_3 = det*w[2][3]*w[0][3]*(1.0);
    const double G6_3_4 = det*w[2][3]*w[0][4]*(1.0);
    const double G6_4_0 = det*w[2][4]*w[0][0]*(1.0);
    const double G6_4_2 = det*w[2][4]*w[0][2]*(1.0);
    const double G6_4_5 = det*w[2][4]*w[0][5]*(1.0);
    const double G6_4_6 = det*w[2][4]*w[0][6]*(1.0);
    const double G6_5_0 = det*w[2][5]*w[0][0]*(1.0);
    const double G6_5_1 = det*w[2][5]*w[0][1]*(1.0);
    const double G6_5_7 = det*w[2][5]*w[0][7]*(1.0);
    const double G6_5_8 = det*w[2][5]*w[0][8]*(1.0);
    const double G6_6_10 = det*w[2][6]*w[0][10]*(1.0);
    const double G6_6_15 = det*w[2][6]*w[0][15]*(1.0);
    const double G6_6_16 = det*w[2][6]*w[0][16]*(1.0);
    const double G6_6_17 = det*w[2][6]*w[0][17]*(1.0);
    const double G6_6_18 = det*w[2][6]*w[0][18]*(1.0);
    const double G6_7_11 = det*w[2][7]*w[0][11]*(1.0);
    const double G6_7_13 = det*w[2][7]*w[0][13]*(1.0);
    const double G6_7_14 = det*w[2][7]*w[0][14]*(1.0);
    const double G6_7_17 = det*w[2][7]*w[0][17]*(1.0);
    const double G6_7_18 = det*w[2][7]*w[0][18]*(1.0);
    const double G6_8_12 = det*w[2][8]*w[0][12]*(1.0);
    const double G6_8_13 = det*w[2][8]*w[0][13]*(1.0);
    const double G6_8_14 = det*w[2][8]*w[0][14]*(1.0);
    const double G6_8_15 = det*w[2][8]*w[0][15]*(1.0);
    const double G6_8_16 = det*w[2][8]*w[0][16]*(1.0);
    const double G6_9_11 = det*w[2][9]*w[0][11]*(1.0);
    const double G6_9_12 = det*w[2][9]*w[0][12]*(1.0);
    const double G6_9_13 = det*w[2][9]*w[0][13]*(1.0);
    const double G6_9_14 = det*w[2][9]*w[0][14]*(1.0);
    const double G6_10_10 = det*w[2][10]*w[0][10]*(1.0);
    const double G6_10_12 = det*w[2][10]*w[0][12]*(1.0);
    const double G6_10_15 = det*w[2][10]*w[0][15]*(1.0);
    const double G6_10_16 = det*w[2][10]*w[0][16]*(1.0);
    const double G6_11_10 = det*w[2][11]*w[0][10]*(1.0);
    const double G6_11_11 = det*w[2][11]*w[0][11]*(1.0);
    const double G6_11_17 = det*w[2][11]*w[0][17]*(1.0);
    const double G6_11_18 = det*w[2][11]*w[0][18]*(1.0);
    const double G6_12_20 = det*w[2][12]*w[0][20]*(1.0);
    const double G6_12_24 = det*w[2][12]*w[0][24]*(1.0);
    const double G6_12_25 = det*w[2][12]*w[0][25]*(1.0);
    const double G6_13_21 = det*w[2][13]*w[0][21]*(1.0);
    const double G6_13_23 = det*w[2][13]*w[0][23]*(1.0);
    const double G6_13_25 = det*w[2][13]*w[0][25]*(1.0);
    const double G6_14_22 = det*w[2][14]*w[0][22]*(1.0);
    const double G6_14_23 = det*w[2][14]*w[0][23]*(1.0);
    const double G6_14_24 = det*w[2][14]*w[0][24]*(1.0);
    const double G7_0_0 = det*w[2][0]*w[3][0]*(1.0);
    const double G7_0_1 = det*w[2][0]*w[3][1]*(1.0);
    const double G7_0_2 = det*w[2][0]*w[3][2]*(1.0);
    const double G7_0_4 = det*w[2][0]*w[3][4]*(1.0);
    const double G7_0_5 = det*w[2][0]*w[3][5]*(1.0);
    const double G7_1_0 = det*w[2][1]*w[3][0]*(1.0);
    const double G7_1_1 = det*w[2][1]*w[3][1]*(1.0);
    const double G7_1_2 = det*w[2][1]*w[3][2]*(1.0);
    const double G7_1_3 = det*w[2][1]*w[3][3]*(1.0);
    const double G7_1_5 = det*w[2][1]*w[3][5]*(1.0);
    const double G7_2_0 = det*w[2][2]*w[3][0]*(1.0);
    const double G7_2_1 = det*w[2][2]*w[3][1]*(1.0);
    const double G7_2_2 = det*w[2][2]*w[3][2]*(1.0);
    const double G7_2_3 = det*w[2][2]*w[3][3]*(1.0);
    const double G7_2_4 = det*w[2][2]*w[3][4]*(1.0);
    const double G7_3_1 = det*w[2][3]*w[3][1]*(1.0);
    const double G7_3_2 = det*w[2][3]*w[3][2]*(1.0);
    const double G7_3_3 = det*w[2][3]*w[3][3]*(1.0);
    const double G7_4_0 = det*w[2][4]*w[3][0]*(1.0);
    const double G7_4_2 = det*w[2][4]*w[3][2]*(1.0);
    const double G7_4_4 = det*w[2][4]*w[3][4]*(1.0);
    const double G7_5_0 = det*w[2][5]*w[3][0]*(1.0);
    const double G7_5_1 = det*w[2][5]*w[3][1]*(1.0);
    const double G7_5_5 = det*w[2][5]*w[3][5]*(1.0);
    const double G7_6_6 = det*w[2][6]*w[3][6]*(1.0);
    const double G7_6_7 = det*w[2][6]*w[3][7]*(1.0);
    const double G7_6_8 = det*w[2][6]*w[3][8]*(1.0);
    const double G7_6_10 = det*w[2][6]*w[3][10]*(1.0);
    const double G7_6_11 = det*w[2][6]*w[3][11]*(1.0);
    const double G7_7_6 = det*w[2][7]*w[3][6]*(1.0);
    const double G7_7_7 = det*w[2][7]*w[3][7]*(1.0);
    const double G7_7_8 = det*w[2][7]*w[3][8]*(1.0);
    const double G7_7_9 = det*w[2][7]*w[3][9]*(1.0);
    const double G7_7_11 = det*w[2][7]*w[3][11]*(1.0);
    const double G7_8_6 = det*w[2][8]*w[3][6]*(1.0);
    const double G7_8_7 = det*w[2][8]*w[3][7]*(1.0);
    const double G7_8_8 = det*w[2][8]*w[3][8]*(1.0);
    const double G7_8_9 = det*w[2][8]*w[3][9]*(1.0);
    const double G7_8_10 = det*w[2][8]*w[3][10]*(1.0);
    const double G7_9_7 = det*w[2][9]*w[3][7]*(1.0);
    const double G7_9_8 = det*w[2][9]*w[3][8]*(1.0);
    const double G7_9_9 = det*w[2][9]*w[3][9]*(1.0);
    const double G7_10_6 = det*w[2][10]*w[3][6]*(1.0);
    const double G7_10_8 = det*w[2][10]*w[3][8]*(1.0);
    const double G7_10_10 = det*w[2][10]*w[3][10]*(1.0);
    const double G7_11_6 = det*w[2][11]*w[3][6]*(1.0);
    const double G7_11_7 = det*w[2][11]*w[3][7]*(1.0);
    const double G7_11_11 = det*w[2][11]*w[3][11]*(1.0);
    const double G7_12_12 = det*w[2][12]*w[3][12]*(1.0);
    const double G7_12_13 = det*w[2][12]*w[3][13]*(1.0);
    const double G7_12_14 = det*w[2][12]*w[3][14]*(1.0);
    const double G7_13_12 = det*w[2][13]*w[3][12]*(1.0);
    const double G7_13_13 = det*w[2][13]*w[3][13]*(1.0);
    const double G7_13_14 = det*w[2][13]*w[3][14]*(1.0);
    const double G7_14_12 = det*w[2][14]*w[3][12]*(1.0);
    const double G7_14_13 = det*w[2][14]*w[3][13]*(1.0);
    const double G7_14_14 = det*w[2][14]*w[3][14]*(1.0);
    
    // Compute element tensor
    switch (facet0)
    {
    case 0:
      {
        switch (facet1)
      {
      case 0:
        {
          A[0] = 0.0458333333333333*G4_16_27 + 0.0749999999999999*G4_16_29 - 0.0375*G4_16_30 + 0.0458333333333333*G4_17_28 - 0.0375*G4_17_29 + 0.0749999999999999*G4_17_30 + 0.0166666666666667*G4_18_27 + 0.0166666666666667*G4_18_28 + 0.15*G4_18_29 + 0.15*G4_18_30 + 0.0458333333333333*G4_22_37 + 0.0749999999999999*G4_22_39 - 0.0375*G4_22_40 + 0.0458333333333333*G4_23_38 - 0.0375*G4_23_39 + 0.0749999999999999*G4_23_40 + 0.0166666666666667*G4_24_37 + 0.0166666666666667*G4_24_38 + 0.15*G4_24_39 + 0.15*G4_24_40 + 0.0833333333333333*G4_28_47 + 0.166666666666667*G4_28_49 + 0.0833333333333333*G4_29_48 + 0.166666666666667*G4_29_49 - 0.0666666666666666*G5_16_16 + 0.0166666666666666*G5_16_17 - 0.0333333333333333*G5_16_18 + 0.0166666666666666*G5_17_16 - 0.0666666666666666*G5_17_17 - 0.0333333333333333*G5_17_18 - 0.0333333333333333*G5_18_16 - 0.0333333333333333*G5_18_17 - 0.266666666666666*G5_18_18 - 0.0666666666666666*G5_22_22 + 0.0166666666666666*G5_22_23 - 0.0333333333333333*G5_22_24 + 0.0166666666666666*G5_23_22 - 0.0666666666666666*G5_23_23 - 0.0333333333333333*G5_23_24 - 0.0333333333333333*G5_24_22 - 0.0333333333333333*G5_24_23 - 0.266666666666666*G5_24_24 - 0.166666666666667*G5_28_28 - 0.0833333333333333*G5_28_29 - 0.0833333333333333*G5_29_28 - 0.166666666666667*G5_29_29 + 0.0458333333333333*G6_1_1 + 0.0749999999999999*G6_1_3 - 0.0375*G6_1_4 + 0.0458333333333333*G6_2_2 - 0.0375*G6_2_3 + 0.0749999999999999*G6_2_4 + 0.0166666666666667*G6_3_1 + 0.0166666666666667*G6_3_2 + 0.15*G6_3_3 + 0.15*G6_3_4 + 0.0458333333333333*G6_7_11 + 0.0749999999999999*G6_7_13 - 0.0375*G6_7_14 + 0.0458333333333333*G6_8_12 - 0.0375*G6_8_13 + 0.0749999999999999*G6_8_14 + 0.0166666666666667*G6_9_11 + 0.0166666666666667*G6_9_12 + 0.15*G6_9_13 + 0.15*G6_9_14 + 0.0833333333333333*G6_13_21 + 0.166666666666667*G6_13_23 + 0.0833333333333333*G6_14_22 + 0.166666666666667*G6_14_23 - 0.0666666666666666*G7_1_1 + 0.0166666666666666*G7_1_2 - 0.0333333333333333*G7_1_3 + 0.0166666666666666*G7_2_1 - 0.0666666666666666*G7_2_2 - 0.0333333333333333*G7_2_3 - 0.0333333333333333*G7_3_1 - 0.0333333333333333*G7_3_2 - 0.266666666666666*G7_3_3 - 0.0666666666666666*G7_7_7 + 0.0166666666666666*G7_7_8 - 0.0333333333333333*G7_7_9 + 0.0166666666666666*G7_8_7 - 0.0666666666666666*G7_8_8 - 0.0333333333333333*G7_8_9 - 0.0333333333333333*G7_9_7 - 0.0333333333333333*G7_9_8 - 0.266666666666666*G7_9_9 - 0.166666666666667*G7_13_13 - 0.0833333333333333*G7_13_14 - 0.0833333333333333*G7_14_13 - 0.166666666666667*G7_14_14;
        A[1] = 0.0458333333333333*G0_16_27 + 0.0749999999999999*G0_16_29 - 0.0375*G0_16_30 + 0.0458333333333333*G0_17_28 - 0.0375*G0_17_29 + 0.0749999999999999*G0_17_30 + 0.0166666666666667*G0_18_27 + 0.0166666666666667*G0_18_28 + 0.15*G0_18_29 + 0.15*G0_18_30 + 0.0458333333333333*G0_22_37 + 0.0749999999999999*G0_22_39 - 0.0375*G0_22_40 + 0.0458333333333333*G0_23_38 - 0.0375*G0_23_39 + 0.0749999999999999*G0_23_40 + 0.0166666666666667*G0_24_37 + 0.0166666666666667*G0_24_38 + 0.15*G0_24_39 + 0.15*G0_24_40 + 0.0833333333333333*G0_28_47 + 0.166666666666667*G0_28_49 + 0.0833333333333333*G0_29_48 + 0.166666666666667*G0_29_49 - 0.0666666666666666*G1_16_16 + 0.0166666666666666*G1_16_17 - 0.0333333333333333*G1_16_18 + 0.0166666666666666*G1_17_16 - 0.0666666666666666*G1_17_17 - 0.0333333333333333*G1_17_18 - 0.0333333333333333*G1_18_16 - 0.0333333333333333*G1_18_17 - 0.266666666666666*G1_18_18 - 0.0666666666666666*G1_22_22 + 0.0166666666666666*G1_22_23 - 0.0333333333333333*G1_22_24 + 0.0166666666666666*G1_23_22 - 0.0666666666666666*G1_23_23 - 0.0333333333333333*G1_23_24 - 0.0333333333333333*G1_24_22 - 0.0333333333333333*G1_24_23 - 0.266666666666666*G1_24_24 - 0.166666666666667*G1_28_28 - 0.0833333333333333*G1_28_29 - 0.0833333333333333*G1_29_28 - 0.166666666666667*G1_29_29 + 0.0458333333333333*G2_1_1 + 0.0749999999999999*G2_1_3 - 0.0375*G2_1_4 + 0.0458333333333333*G2_2_2 - 0.0375*G2_2_3 + 0.0749999999999999*G2_2_4 + 0.0166666666666667*G2_3_1 + 0.0166666666666667*G2_3_2 + 0.15*G2_3_3 + 0.15*G2_3_4 + 0.0458333333333333*G2_7_11 + 0.0749999999999999*G2_7_13 - 0.0375*G2_7_14 + 0.0458333333333333*G2_8_12 - 0.0375*G2_8_13 + 0.0749999999999999*G2_8_14 + 0.0166666666666667*G2_9_11 + 0.0166666666666667*G2_9_12 + 0.15*G2_9_13 + 0.15*G2_9_14 + 0.0833333333333333*G2_13_21 + 0.166666666666667*G2_13_23 + 0.0833333333333333*G2_14_22 + 0.166666666666667*G2_14_23 - 0.0666666666666666*G3_1_1 + 0.0166666666666666*G3_1_2 - 0.0333333333333333*G3_1_3 + 0.0166666666666666*G3_2_1 - 0.0666666666666666*G3_2_2 - 0.0333333333333333*G3_2_3 - 0.0333333333333333*G3_3_1 - 0.0333333333333333*G3_3_2 - 0.266666666666666*G3_3_3 - 0.0666666666666666*G3_7_7 + 0.0166666666666666*G3_7_8 - 0.0333333333333333*G3_7_9 + 0.0166666666666666*G3_8_7 - 0.0666666666666666*G3_8_8 - 0.0333333333333333*G3_8_9 - 0.0333333333333333*G3_9_7 - 0.0333333333333333*G3_9_8 - 0.266666666666666*G3_9_9 - 0.166666666666667*G3_13_13 - 0.0833333333333333*G3_13_14 - 0.0833333333333333*G3_14_13 - 0.166666666666667*G3_14_14;
          break;
        }
      case 1:
        {
          A[0] = 0.0458333333333333*G4_15_26 + 0.0749999999999999*G4_15_31 - 0.0375*G4_15_32 + 0.0458333333333333*G4_17_28 - 0.0375*G4_17_31 + 0.0749999999999999*G4_17_32 + 0.0166666666666666*G4_19_26 + 0.0166666666666667*G4_19_28 + 0.15*G4_19_31 + 0.15*G4_19_32 + 0.0458333333333333*G4_21_36 + 0.0749999999999999*G4_21_41 - 0.0375*G4_21_42 + 0.0458333333333333*G4_23_38 - 0.0375*G4_23_41 + 0.0749999999999999*G4_23_42 + 0.0166666666666666*G4_25_36 + 0.0166666666666667*G4_25_38 + 0.15*G4_25_41 + 0.15*G4_25_42 + 0.0833333333333333*G4_27_46 + 0.166666666666667*G4_27_50 + 0.0833333333333333*G4_29_48 + 0.166666666666667*G4_29_50 - 0.0666666666666667*G5_15_15 + 0.0166666666666667*G5_15_17 - 0.0333333333333333*G5_15_19 + 0.0166666666666667*G5_17_15 - 0.0666666666666666*G5_17_17 - 0.0333333333333333*G5_17_19 - 0.0333333333333333*G5_19_15 - 0.0333333333333333*G5_19_17 - 0.266666666666667*G5_19_19 - 0.0666666666666667*G5_21_21 + 0.0166666666666667*G5_21_23 - 0.0333333333333333*G5_21_25 + 0.0166666666666667*G5_23_21 - 0.0666666666666666*G5_23_23 - 0.0333333333333333*G5_23_25 - 0.0333333333333333*G5_25_21 - 0.0333333333333333*G5_25_23 - 0.266666666666667*G5_25_25 - 0.166666666666667*G5_27_27 - 0.0833333333333333*G5_27_29 - 0.0833333333333333*G5_29_27 - 0.166666666666667*G5_29_29 + 0.0458333333333333*G6_1_1 + 0.0749999999999999*G6_1_3 - 0.0375*G6_1_4 + 0.0458333333333333*G6_2_2 - 0.0375*G6_2_3 + 0.0749999999999999*G6_2_4 + 0.0166666666666667*G6_3_1 + 0.0166666666666667*G6_3_2 + 0.15*G6_3_3 + 0.15*G6_3_4 + 0.0458333333333333*G6_7_11 + 0.0749999999999999*G6_7_13 - 0.0375*G6_7_14 + 0.0458333333333333*G6_8_12 - 0.0375*G6_8_13 + 0.0749999999999999*G6_8_14 + 0.0166666666666667*G6_9_11 + 0.0166666666666667*G6_9_12 + 0.15*G6_9_13 + 0.15*G6_9_14 + 0.0833333333333333*G6_13_21 + 0.166666666666667*G6_13_23 + 0.0833333333333333*G6_14_22 + 0.166666666666667*G6_14_23 - 0.0666666666666666*G7_1_1 + 0.0166666666666666*G7_1_2 - 0.0333333333333333*G7_1_3 + 0.0166666666666666*G7_2_1 - 0.0666666666666666*G7_2_2 - 0.0333333333333333*G7_2_3 - 0.0333333333333333*G7_3_1 - 0.0333333333333333*G7_3_2 - 0.266666666666666*G7_3_3 - 0.0666666666666666*G7_7_7 + 0.0166666666666666*G7_7_8 - 0.0333333333333333*G7_7_9 + 0.0166666666666666*G7_8_7 - 0.0666666666666666*G7_8_8 - 0.0333333333333333*G7_8_9 - 0.0333333333333333*G7_9_7 - 0.0333333333333333*G7_9_8 - 0.266666666666666*G7_9_9 - 0.166666666666667*G7_13_13 - 0.0833333333333333*G7_13_14 - 0.0833333333333333*G7_14_13 - 0.166666666666667*G7_14_14;
        A[1] = 0.0458333333333333*G0_15_26 + 0.0749999999999999*G0_15_31 - 0.0375*G0_15_32 + 0.0458333333333333*G0_17_28 - 0.0375*G0_17_31 + 0.0749999999999999*G0_17_32 + 0.0166666666666666*G0_19_26 + 0.0166666666666667*G0_19_28 + 0.15*G0_19_31 + 0.15*G0_19_32 + 0.0458333333333333*G0_21_36 + 0.0749999999999999*G0_21_41 - 0.0375*G0_21_42 + 0.0458333333333333*G0_23_38 - 0.0375*G0_23_41 + 0.0749999999999999*G0_23_42 + 0.0166666666666666*G0_25_36 + 0.0166666666666667*G0_25_38 + 0.15*G0_25_41 + 0.15*G0_25_42 + 0.0833333333333333*G0_27_46 + 0.166666666666667*G0_27_50 + 0.0833333333333333*G0_29_48 + 0.166666666666667*G0_29_50 - 0.0666666666666667*G1_15_15 + 0.0166666666666667*G1_15_17 - 0.0333333333333333*G1_15_19 + 0.0166666666666667*G1_17_15 - 0.0666666666666666*G1_17_17 - 0.0333333333333333*G1_17_19 - 0.0333333333333333*G1_19_15 - 0.0333333333333333*G1_19_17 - 0.266666666666667*G1_19_19 - 0.0666666666666667*G1_21_21 + 0.0166666666666667*G1_21_23 - 0.0333333333333333*G1_21_25 + 0.0166666666666667*G1_23_21 - 0.0666666666666666*G1_23_23 - 0.0333333333333333*G1_23_25 - 0.0333333333333333*G1_25_21 - 0.0333333333333333*G1_25_23 - 0.266666666666667*G1_25_25 - 0.166666666666667*G1_27_27 - 0.0833333333333333*G1_27_29 - 0.0833333333333333*G1_29_27 - 0.166666666666667*G1_29_29 + 0.0458333333333333*G2_1_1 + 0.0749999999999999*G2_1_3 - 0.0375*G2_1_4 + 0.0458333333333333*G2_2_2 - 0.0375*G2_2_3 + 0.0749999999999999*G2_2_4 + 0.0166666666666667*G2_3_1 + 0.0166666666666667*G2_3_2 + 0.15*G2_3_3 + 0.15*G2_3_4 + 0.0458333333333333*G2_7_11 + 0.0749999999999999*G2_7_13 - 0.0375*G2_7_14 + 0.0458333333333333*G2_8_12 - 0.0375*G2_8_13 + 0.0749999999999999*G2_8_14 + 0.0166666666666667*G2_9_11 + 0.0166666666666667*G2_9_12 + 0.15*G2_9_13 + 0.15*G2_9_14 + 0.0833333333333333*G2_13_21 + 0.166666666666667*G2_13_23 + 0.0833333333333333*G2_14_22 + 0.166666666666667*G2_14_23 - 0.0666666666666666*G3_1_1 + 0.0166666666666666*G3_1_2 - 0.0333333333333333*G3_1_3 + 0.0166666666666666*G3_2_1 - 0.0666666666666666*G3_2_2 - 0.0333333333333333*G3_2_3 - 0.0333333333333333*G3_3_1 - 0.0333333333333333*G3_3_2 - 0.266666666666666*G3_3_3 - 0.0666666666666666*G3_7_7 + 0.0166666666666666*G3_7_8 - 0.0333333333333333*G3_7_9 + 0.0166666666666666*G3_8_7 - 0.0666666666666666*G3_8_8 - 0.0333333333333333*G3_8_9 - 0.0333333333333333*G3_9_7 - 0.0333333333333333*G3_9_8 - 0.266666666666666*G3_9_9 - 0.166666666666667*G3_13_13 - 0.0833333333333333*G3_13_14 - 0.0833333333333333*G3_14_13 - 0.166666666666667*G3_14_14;
          break;
        }
      case 2:
        {
          A[0] = 0.0458333333333333*G4_15_26 + 0.0749999999999999*G4_15_33 - 0.0375*G4_15_34 + 0.0458333333333333*G4_16_27 - 0.0375*G4_16_33 + 0.0749999999999999*G4_16_34 + 0.0166666666666666*G4_20_26 + 0.0166666666666666*G4_20_27 + 0.15*G4_20_33 + 0.15*G4_20_34 + 0.0458333333333333*G4_21_36 + 0.0749999999999999*G4_21_43 - 0.0375*G4_21_44 + 0.0458333333333333*G4_22_37 - 0.0375*G4_22_43 + 0.0749999999999999*G4_22_44 + 0.0166666666666666*G4_26_36 + 0.0166666666666666*G4_26_37 + 0.15*G4_26_43 + 0.15*G4_26_44 + 0.0833333333333333*G4_27_46 + 0.166666666666667*G4_27_51 + 0.0833333333333333*G4_28_47 + 0.166666666666667*G4_28_51 - 0.0666666666666666*G5_15_15 + 0.0166666666666667*G5_15_16 - 0.0333333333333333*G5_15_20 + 0.0166666666666667*G5_16_15 - 0.0666666666666666*G5_16_16 - 0.0333333333333333*G5_16_20 - 0.0333333333333333*G5_20_15 - 0.0333333333333333*G5_20_16 - 0.266666666666667*G5_20_20 - 0.0666666666666666*G5_21_21 + 0.0166666666666667*G5_21_22 - 0.0333333333333333*G5_21_26 + 0.0166666666666667*G5_22_21 - 0.0666666666666666*G5_22_22 - 0.0333333333333333*G5_22_26 - 0.0333333333333333*G5_26_21 - 0.0333333333333333*G5_26_22 - 0.266666666666667*G5_26_26 - 0.166666666666667*G5_27_27 - 0.0833333333333333*G5_27_28 - 0.0833333333333333*G5_28_27 - 0.166666666666667*G5_28_28 + 0.0458333333333333*G6_1_1 + 0.0749999999999999*G6_1_3 - 0.0375*G6_1_4 + 0.0458333333333333*G6_2_2 - 0.0375*G6_2_3 + 0.0749999999999999*G6_2_4 + 0.0166666666666667*G6_3_1 + 0.0166666666666667*G6_3_2 + 0.15*G6_3_3 + 0.15*G6_3_4 + 0.0458333333333333*G6_7_11 + 0.0749999999999999*G6_7_13 - 0.0375*G6_7_14 + 0.0458333333333333*G6_8_12 - 0.0375*G6_8_13 + 0.0749999999999999*G6_8_14 + 0.0166666666666667*G6_9_11 + 0.0166666666666667*G6_9_12 + 0.15*G6_9_13 + 0.15*G6_9_14 + 0.0833333333333333*G6_13_21 + 0.166666666666667*G6_13_23 + 0.0833333333333333*G6_14_22 + 0.166666666666667*G6_14_23 - 0.0666666666666666*G7_1_1 + 0.0166666666666666*G7_1_2 - 0.0333333333333333*G7_1_3 + 0.0166666666666666*G7_2_1 - 0.0666666666666666*G7_2_2 - 0.0333333333333333*G7_2_3 - 0.0333333333333333*G7_3_1 - 0.0333333333333333*G7_3_2 - 0.266666666666666*G7_3_3 - 0.0666666666666666*G7_7_7 + 0.0166666666666666*G7_7_8 - 0.0333333333333333*G7_7_9 + 0.0166666666666666*G7_8_7 - 0.0666666666666666*G7_8_8 - 0.0333333333333333*G7_8_9 - 0.0333333333333333*G7_9_7 - 0.0333333333333333*G7_9_8 - 0.266666666666666*G7_9_9 - 0.166666666666667*G7_13_13 - 0.0833333333333333*G7_13_14 - 0.0833333333333333*G7_14_13 - 0.166666666666667*G7_14_14;
        A[1] = 0.0458333333333333*G0_15_26 + 0.0749999999999999*G0_15_33 - 0.0375*G0_15_34 + 0.0458333333333333*G0_16_27 - 0.0375*G0_16_33 + 0.0749999999999999*G0_16_34 + 0.0166666666666666*G0_20_26 + 0.0166666666666666*G0_20_27 + 0.15*G0_20_33 + 0.15*G0_20_34 + 0.0458333333333333*G0_21_36 + 0.0749999999999999*G0_21_43 - 0.0375*G0_21_44 + 0.0458333333333333*G0_22_37 - 0.0375*G0_22_43 + 0.0749999999999999*G0_22_44 + 0.0166666666666666*G0_26_36 + 0.0166666666666666*G0_26_37 + 0.15*G0_26_43 + 0.15*G0_26_44 + 0.0833333333333333*G0_27_46 + 0.166666666666667*G0_27_51 + 0.0833333333333333*G0_28_47 + 0.166666666666667*G0_28_51 - 0.0666666666666666*G1_15_15 + 0.0166666666666667*G1_15_16 - 0.0333333333333333*G1_15_20 + 0.0166666666666667*G1_16_15 - 0.0666666666666666*G1_16_16 - 0.0333333333333333*G1_16_20 - 0.0333333333333333*G1_20_15 - 0.0333333333333333*G1_20_16 - 0.266666666666667*G1_20_20 - 0.0666666666666666*G1_21_21 + 0.0166666666666667*G1_21_22 - 0.0333333333333333*G1_21_26 + 0.0166666666666667*G1_22_21 - 0.0666666666666666*G1_22_22 - 0.0333333333333333*G1_22_26 - 0.0333333333333333*G1_26_21 - 0.0333333333333333*G1_26_22 - 0.266666666666667*G1_26_26 - 0.166666666666667*G1_27_27 - 0.0833333333333333*G1_27_28 - 0.0833333333333333*G1_28_27 - 0.166666666666667*G1_28_28 + 0.0458333333333333*G2_1_1 + 0.0749999999999999*G2_1_3 - 0.0375*G2_1_4 + 0.0458333333333333*G2_2_2 - 0.0375*G2_2_3 + 0.0749999999999999*G2_2_4 + 0.0166666666666667*G2_3_1 + 0.0166666666666667*G2_3_2 + 0.15*G2_3_3 + 0.15*G2_3_4 + 0.0458333333333333*G2_7_11 + 0.0749999999999999*G2_7_13 - 0.0375*G2_7_14 + 0.0458333333333333*G2_8_12 - 0.0375*G2_8_13 + 0.0749999999999999*G2_8_14 + 0.0166666666666667*G2_9_11 + 0.0166666666666667*G2_9_12 + 0.15*G2_9_13 + 0.15*G2_9_14 + 0.0833333333333333*G2_13_21 + 0.166666666666667*G2_13_23 + 0.0833333333333333*G2_14_22 + 0.166666666666667*G2_14_23 - 0.0666666666666666*G3_1_1 + 0.0166666666666666*G3_1_2 - 0.0333333333333333*G3_1_3 + 0.0166666666666666*G3_2_1 - 0.0666666666666666*G3_2_2 - 0.0333333333333333*G3_2_3 - 0.0333333333333333*G3_3_1 - 0.0333333333333333*G3_3_2 - 0.266666666666666*G3_3_3 - 0.0666666666666666*G3_7_7 + 0.0166666666666666*G3_7_8 - 0.0333333333333333*G3_7_9 + 0.0166666666666666*G3_8_7 - 0.0666666666666666*G3_8_8 - 0.0333333333333333*G3_8_9 - 0.0333333333333333*G3_9_7 - 0.0333333333333333*G3_9_8 - 0.266666666666666*G3_9_9 - 0.166666666666667*G3_13_13 - 0.0833333333333333*G3_13_14 - 0.0833333333333333*G3_14_13 - 0.166666666666667*G3_14_14;
          break;
        }
      }
      
        break;
      }
    case 1:
      {
        switch (facet1)
      {
      case 0:
        {
          A[0] = 0.0458333333333333*G4_16_27 + 0.0749999999999999*G4_16_29 - 0.0375*G4_16_30 + 0.0458333333333333*G4_17_28 - 0.0375*G4_17_29 + 0.0749999999999999*G4_17_30 + 0.0166666666666667*G4_18_27 + 0.0166666666666667*G4_18_28 + 0.15*G4_18_29 + 0.15*G4_18_30 + 0.0458333333333333*G4_22_37 + 0.0749999999999999*G4_22_39 - 0.0375*G4_22_40 + 0.0458333333333333*G4_23_38 - 0.0375*G4_23_39 + 0.0749999999999999*G4_23_40 + 0.0166666666666667*G4_24_37 + 0.0166666666666667*G4_24_38 + 0.15*G4_24_39 + 0.15*G4_24_40 + 0.0833333333333333*G4_28_47 + 0.166666666666667*G4_28_49 + 0.0833333333333333*G4_29_48 + 0.166666666666667*G4_29_49 - 0.0666666666666666*G5_16_16 + 0.0166666666666666*G5_16_17 - 0.0333333333333333*G5_16_18 + 0.0166666666666666*G5_17_16 - 0.0666666666666666*G5_17_17 - 0.0333333333333333*G5_17_18 - 0.0333333333333333*G5_18_16 - 0.0333333333333333*G5_18_17 - 0.266666666666666*G5_18_18 - 0.0666666666666666*G5_22_22 + 0.0166666666666666*G5_22_23 - 0.0333333333333333*G5_22_24 + 0.0166666666666666*G5_23_22 - 0.0666666666666666*G5_23_23 - 0.0333333333333333*G5_23_24 - 0.0333333333333333*G5_24_22 - 0.0333333333333333*G5_24_23 - 0.266666666666666*G5_24_24 - 0.166666666666667*G5_28_28 - 0.0833333333333333*G5_28_29 - 0.0833333333333333*G5_29_28 - 0.166666666666667*G5_29_29 + 0.0458333333333333*G6_0_0 + 0.0749999999999999*G6_0_5 - 0.0375*G6_0_6 + 0.0458333333333333*G6_2_2 - 0.0375*G6_2_5 + 0.0749999999999999*G6_2_6 + 0.0166666666666666*G6_4_0 + 0.0166666666666667*G6_4_2 + 0.15*G6_4_5 + 0.15*G6_4_6 + 0.0458333333333333*G6_6_10 + 0.0749999999999999*G6_6_15 - 0.0375*G6_6_16 + 0.0458333333333333*G6_8_12 - 0.0375*G6_8_15 + 0.0749999999999999*G6_8_16 + 0.0166666666666666*G6_10_10 + 0.0166666666666667*G6_10_12 + 0.15*G6_10_15 + 0.15*G6_10_16 + 0.0833333333333333*G6_12_20 + 0.166666666666667*G6_12_24 + 0.0833333333333333*G6_14_22 + 0.166666666666667*G6_14_24 - 0.0666666666666667*G7_0_0 + 0.0166666666666667*G7_0_2 - 0.0333333333333333*G7_0_4 + 0.0166666666666667*G7_2_0 - 0.0666666666666666*G7_2_2 - 0.0333333333333333*G7_2_4 - 0.0333333333333333*G7_4_0 - 0.0333333333333333*G7_4_2 - 0.266666666666667*G7_4_4 - 0.0666666666666667*G7_6_6 + 0.0166666666666667*G7_6_8 - 0.0333333333333333*G7_6_10 + 0.0166666666666667*G7_8_6 - 0.0666666666666666*G7_8_8 - 0.0333333333333333*G7_8_10 - 0.0333333333333333*G7_10_6 - 0.0333333333333333*G7_10_8 - 0.266666666666667*G7_10_10 - 0.166666666666667*G7_12_12 - 0.0833333333333333*G7_12_14 - 0.0833333333333333*G7_14_12 - 0.166666666666667*G7_14_14;
        A[1] = 0.0458333333333333*G0_16_27 + 0.0749999999999999*G0_16_29 - 0.0375*G0_16_30 + 0.0458333333333333*G0_17_28 - 0.0375*G0_17_29 + 0.0749999999999999*G0_17_30 + 0.0166666666666667*G0_18_27 + 0.0166666666666667*G0_18_28 + 0.15*G0_18_29 + 0.15*G0_18_30 + 0.0458333333333333*G0_22_37 + 0.0749999999999999*G0_22_39 - 0.0375*G0_22_40 + 0.0458333333333333*G0_23_38 - 0.0375*G0_23_39 + 0.0749999999999999*G0_23_40 + 0.0166666666666667*G0_24_37 + 0.0166666666666667*G0_24_38 + 0.15*G0_24_39 + 0.15*G0_24_40 + 0.0833333333333333*G0_28_47 + 0.166666666666667*G0_28_49 + 0.0833333333333333*G0_29_48 + 0.166666666666667*G0_29_49 - 0.0666666666666666*G1_16_16 + 0.0166666666666666*G1_16_17 - 0.0333333333333333*G1_16_18 + 0.0166666666666666*G1_17_16 - 0.0666666666666666*G1_17_17 - 0.0333333333333333*G1_17_18 - 0.0333333333333333*G1_18_16 - 0.0333333333333333*G1_18_17 - 0.266666666666666*G1_18_18 - 0.0666666666666666*G1_22_22 + 0.0166666666666666*G1_22_23 - 0.0333333333333333*G1_22_24 + 0.0166666666666666*G1_23_22 - 0.0666666666666666*G1_23_23 - 0.0333333333333333*G1_23_24 - 0.0333333333333333*G1_24_22 - 0.0333333333333333*G1_24_23 - 0.266666666666666*G1_24_24 - 0.166666666666667*G1_28_28 - 0.0833333333333333*G1_28_29 - 0.0833333333333333*G1_29_28 - 0.166666666666667*G1_29_29 + 0.0458333333333333*G2_0_0 + 0.0749999999999999*G2_0_5 - 0.0375*G2_0_6 + 0.0458333333333333*G2_2_2 - 0.0375*G2_2_5 + 0.0749999999999999*G2_2_6 + 0.0166666666666666*G2_4_0 + 0.0166666666666667*G2_4_2 + 0.15*G2_4_5 + 0.15*G2_4_6 + 0.0458333333333333*G2_6_10 + 0.0749999999999999*G2_6_15 - 0.0375*G2_6_16 + 0.0458333333333333*G2_8_12 - 0.0375*G2_8_15 + 0.0749999999999999*G2_8_16 + 0.0166666666666666*G2_10_10 + 0.0166666666666667*G2_10_12 + 0.15*G2_10_15 + 0.15*G2_10_16 + 0.0833333333333333*G2_12_20 + 0.166666666666667*G2_12_24 + 0.0833333333333333*G2_14_22 + 0.166666666666667*G2_14_24 - 0.0666666666666667*G3_0_0 + 0.0166666666666667*G3_0_2 - 0.0333333333333333*G3_0_4 + 0.0166666666666667*G3_2_0 - 0.0666666666666666*G3_2_2 - 0.0333333333333333*G3_2_4 - 0.0333333333333333*G3_4_0 - 0.0333333333333333*G3_4_2 - 0.266666666666667*G3_4_4 - 0.0666666666666667*G3_6_6 + 0.0166666666666667*G3_6_8 - 0.0333333333333333*G3_6_10 + 0.0166666666666667*G3_8_6 - 0.0666666666666666*G3_8_8 - 0.0333333333333333*G3_8_10 - 0.0333333333333333*G3_10_6 - 0.0333333333333333*G3_10_8 - 0.266666666666667*G3_10_10 - 0.166666666666667*G3_12_12 - 0.0833333333333333*G3_12_14 - 0.0833333333333333*G3_14_12 - 0.166666666666667*G3_14_14;
          break;
        }
      case 1:
        {
          A[0] = 0.0458333333333333*G4_15_26 + 0.0749999999999999*G4_15_31 - 0.0375*G4_15_32 + 0.0458333333333333*G4_17_28 - 0.0375*G4_17_31 + 0.0749999999999999*G4_17_32 + 0.0166666666666666*G4_19_26 + 0.0166666666666667*G4_19_28 + 0.15*G4_19_31 + 0.15*G4_19_32 + 0.0458333333333333*G4_21_36 + 0.0749999999999999*G4_21_41 - 0.0375*G4_21_42 + 0.0458333333333333*G4_23_38 - 0.0375*G4_23_41 + 0.0749999999999999*G4_23_42 + 0.0166666666666666*G4_25_36 + 0.0166666666666667*G4_25_38 + 0.15*G4_25_41 + 0.15*G4_25_42 + 0.0833333333333333*G4_27_46 + 0.166666666666667*G4_27_50 + 0.0833333333333333*G4_29_48 + 0.166666666666667*G4_29_50 - 0.0666666666666667*G5_15_15 + 0.0166666666666667*G5_15_17 - 0.0333333333333333*G5_15_19 + 0.0166666666666667*G5_17_15 - 0.0666666666666666*G5_17_17 - 0.0333333333333333*G5_17_19 - 0.0333333333333333*G5_19_15 - 0.0333333333333333*G5_19_17 - 0.266666666666667*G5_19_19 - 0.0666666666666667*G5_21_21 + 0.0166666666666667*G5_21_23 - 0.0333333333333333*G5_21_25 + 0.0166666666666667*G5_23_21 - 0.0666666666666666*G5_23_23 - 0.0333333333333333*G5_23_25 - 0.0333333333333333*G5_25_21 - 0.0333333333333333*G5_25_23 - 0.266666666666667*G5_25_25 - 0.166666666666667*G5_27_27 - 0.0833333333333333*G5_27_29 - 0.0833333333333333*G5_29_27 - 0.166666666666667*G5_29_29 + 0.0458333333333333*G6_0_0 + 0.0749999999999999*G6_0_5 - 0.0375*G6_0_6 + 0.0458333333333333*G6_2_2 - 0.0375*G6_2_5 + 0.0749999999999999*G6_2_6 + 0.0166666666666666*G6_4_0 + 0.0166666666666667*G6_4_2 + 0.15*G6_4_5 + 0.15*G6_4_6 + 0.0458333333333333*G6_6_10 + 0.0749999999999999*G6_6_15 - 0.0375*G6_6_16 + 0.0458333333333333*G6_8_12 - 0.0375*G6_8_15 + 0.0749999999999999*G6_8_16 + 0.0166666666666666*G6_10_10 + 0.0166666666666667*G6_10_12 + 0.15*G6_10_15 + 0.15*G6_10_16 + 0.0833333333333333*G6_12_20 + 0.166666666666667*G6_12_24 + 0.0833333333333333*G6_14_22 + 0.166666666666667*G6_14_24 - 0.0666666666666667*G7_0_0 + 0.0166666666666667*G7_0_2 - 0.0333333333333333*G7_0_4 + 0.0166666666666667*G7_2_0 - 0.0666666666666666*G7_2_2 - 0.0333333333333333*G7_2_4 - 0.0333333333333333*G7_4_0 - 0.0333333333333333*G7_4_2 - 0.266666666666667*G7_4_4 - 0.0666666666666667*G7_6_6 + 0.0166666666666667*G7_6_8 - 0.0333333333333333*G7_6_10 + 0.0166666666666667*G7_8_6 - 0.0666666666666666*G7_8_8 - 0.0333333333333333*G7_8_10 - 0.0333333333333333*G7_10_6 - 0.0333333333333333*G7_10_8 - 0.266666666666667*G7_10_10 - 0.166666666666667*G7_12_12 - 0.0833333333333333*G7_12_14 - 0.0833333333333333*G7_14_12 - 0.166666666666667*G7_14_14;
        A[1] = 0.0458333333333333*G0_15_26 + 0.0749999999999999*G0_15_31 - 0.0375*G0_15_32 + 0.0458333333333333*G0_17_28 - 0.0375*G0_17_31 + 0.0749999999999999*G0_17_32 + 0.0166666666666666*G0_19_26 + 0.0166666666666667*G0_19_28 + 0.15*G0_19_31 + 0.15*G0_19_32 + 0.0458333333333333*G0_21_36 + 0.0749999999999999*G0_21_41 - 0.0375*G0_21_42 + 0.0458333333333333*G0_23_38 - 0.0375*G0_23_41 + 0.0749999999999999*G0_23_42 + 0.0166666666666666*G0_25_36 + 0.0166666666666667*G0_25_38 + 0.15*G0_25_41 + 0.15*G0_25_42 + 0.0833333333333333*G0_27_46 + 0.166666666666667*G0_27_50 + 0.0833333333333333*G0_29_48 + 0.166666666666667*G0_29_50 - 0.0666666666666667*G1_15_15 + 0.0166666666666667*G1_15_17 - 0.0333333333333333*G1_15_19 + 0.0166666666666667*G1_17_15 - 0.0666666666666666*G1_17_17 - 0.0333333333333333*G1_17_19 - 0.0333333333333333*G1_19_15 - 0.0333333333333333*G1_19_17 - 0.266666666666667*G1_19_19 - 0.0666666666666667*G1_21_21 + 0.0166666666666667*G1_21_23 - 0.0333333333333333*G1_21_25 + 0.0166666666666667*G1_23_21 - 0.0666666666666666*G1_23_23 - 0.0333333333333333*G1_23_25 - 0.0333333333333333*G1_25_21 - 0.0333333333333333*G1_25_23 - 0.266666666666667*G1_25_25 - 0.166666666666667*G1_27_27 - 0.0833333333333333*G1_27_29 - 0.0833333333333333*G1_29_27 - 0.166666666666667*G1_29_29 + 0.0458333333333333*G2_0_0 + 0.0749999999999999*G2_0_5 - 0.0375*G2_0_6 + 0.0458333333333333*G2_2_2 - 0.0375*G2_2_5 + 0.0749999999999999*G2_2_6 + 0.0166666666666666*G2_4_0 + 0.0166666666666667*G2_4_2 + 0.15*G2_4_5 + 0.15*G2_4_6 + 0.0458333333333333*G2_6_10 + 0.0749999999999999*G2_6_15 - 0.0375*G2_6_16 + 0.0458333333333333*G2_8_12 - 0.0375*G2_8_15 + 0.0749999999999999*G2_8_16 + 0.0166666666666666*G2_10_10 + 0.0166666666666667*G2_10_12 + 0.15*G2_10_15 + 0.15*G2_10_16 + 0.0833333333333333*G2_12_20 + 0.166666666666667*G2_12_24 + 0.0833333333333333*G2_14_22 + 0.166666666666667*G2_14_24 - 0.0666666666666667*G3_0_0 + 0.0166666666666667*G3_0_2 - 0.0333333333333333*G3_0_4 + 0.0166666666666667*G3_2_0 - 0.0666666666666666*G3_2_2 - 0.0333333333333333*G3_2_4 - 0.0333333333333333*G3_4_0 - 0.0333333333333333*G3_4_2 - 0.266666666666667*G3_4_4 - 0.0666666666666667*G3_6_6 + 0.0166666666666667*G3_6_8 - 0.0333333333333333*G3_6_10 + 0.0166666666666667*G3_8_6 - 0.0666666666666666*G3_8_8 - 0.0333333333333333*G3_8_10 - 0.0333333333333333*G3_10_6 - 0.0333333333333333*G3_10_8 - 0.266666666666667*G3_10_10 - 0.166666666666667*G3_12_12 - 0.0833333333333333*G3_12_14 - 0.0833333333333333*G3_14_12 - 0.166666666666667*G3_14_14;
          break;
        }
      case 2:
        {
          A[0] = 0.0458333333333333*G4_15_26 + 0.0749999999999999*G4_15_33 - 0.0375*G4_15_34 + 0.0458333333333333*G4_16_27 - 0.0375*G4_16_33 + 0.0749999999999999*G4_16_34 + 0.0166666666666666*G4_20_26 + 0.0166666666666666*G4_20_27 + 0.15*G4_20_33 + 0.15*G4_20_34 + 0.0458333333333333*G4_21_36 + 0.0749999999999999*G4_21_43 - 0.0375*G4_21_44 + 0.0458333333333333*G4_22_37 - 0.0375*G4_22_43 + 0.0749999999999999*G4_22_44 + 0.0166666666666666*G4_26_36 + 0.0166666666666666*G4_26_37 + 0.15*G4_26_43 + 0.15*G4_26_44 + 0.0833333333333333*G4_27_46 + 0.166666666666667*G4_27_51 + 0.0833333333333333*G4_28_47 + 0.166666666666667*G4_28_51 - 0.0666666666666666*G5_15_15 + 0.0166666666666667*G5_15_16 - 0.0333333333333333*G5_15_20 + 0.0166666666666667*G5_16_15 - 0.0666666666666666*G5_16_16 - 0.0333333333333333*G5_16_20 - 0.0333333333333333*G5_20_15 - 0.0333333333333333*G5_20_16 - 0.266666666666667*G5_20_20 - 0.0666666666666666*G5_21_21 + 0.0166666666666667*G5_21_22 - 0.0333333333333333*G5_21_26 + 0.0166666666666667*G5_22_21 - 0.0666666666666666*G5_22_22 - 0.0333333333333333*G5_22_26 - 0.0333333333333333*G5_26_21 - 0.0333333333333333*G5_26_22 - 0.266666666666667*G5_26_26 - 0.166666666666667*G5_27_27 - 0.0833333333333333*G5_27_28 - 0.0833333333333333*G5_28_27 - 0.166666666666667*G5_28_28 + 0.0458333333333333*G6_0_0 + 0.0749999999999999*G6_0_5 - 0.0375*G6_0_6 + 0.0458333333333333*G6_2_2 - 0.0375*G6_2_5 + 0.0749999999999999*G6_2_6 + 0.0166666666666666*G6_4_0 + 0.0166666666666667*G6_4_2 + 0.15*G6_4_5 + 0.15*G6_4_6 + 0.0458333333333333*G6_6_10 + 0.0749999999999999*G6_6_15 - 0.0375*G6_6_16 + 0.0458333333333333*G6_8_12 - 0.0375*G6_8_15 + 0.0749999999999999*G6_8_16 + 0.0166666666666666*G6_10_10 + 0.0166666666666667*G6_10_12 + 0.15*G6_10_15 + 0.15*G6_10_16 + 0.0833333333333333*G6_12_20 + 0.166666666666667*G6_12_24 + 0.0833333333333333*G6_14_22 + 0.166666666666667*G6_14_24 - 0.0666666666666667*G7_0_0 + 0.0166666666666667*G7_0_2 - 0.0333333333333333*G7_0_4 + 0.0166666666666667*G7_2_0 - 0.0666666666666666*G7_2_2 - 0.0333333333333333*G7_2_4 - 0.0333333333333333*G7_4_0 - 0.0333333333333333*G7_4_2 - 0.266666666666667*G7_4_4 - 0.0666666666666667*G7_6_6 + 0.0166666666666667*G7_6_8 - 0.0333333333333333*G7_6_10 + 0.0166666666666667*G7_8_6 - 0.0666666666666666*G7_8_8 - 0.0333333333333333*G7_8_10 - 0.0333333333333333*G7_10_6 - 0.0333333333333333*G7_10_8 - 0.266666666666667*G7_10_10 - 0.166666666666667*G7_12_12 - 0.0833333333333333*G7_12_14 - 0.0833333333333333*G7_14_12 - 0.166666666666667*G7_14_14;
        A[1] = 0.0458333333333333*G0_15_26 + 0.0749999999999999*G0_15_33 - 0.0375*G0_15_34 + 0.0458333333333333*G0_16_27 - 0.0375*G0_16_33 + 0.0749999999999999*G0_16_34 + 0.0166666666666666*G0_20_26 + 0.0166666666666666*G0_20_27 + 0.15*G0_20_33 + 0.15*G0_20_34 + 0.0458333333333333*G0_21_36 + 0.0749999999999999*G0_21_43 - 0.0375*G0_21_44 + 0.0458333333333333*G0_22_37 - 0.0375*G0_22_43 + 0.0749999999999999*G0_22_44 + 0.0166666666666666*G0_26_36 + 0.0166666666666666*G0_26_37 + 0.15*G0_26_43 + 0.15*G0_26_44 + 0.0833333333333333*G0_27_46 + 0.166666666666667*G0_27_51 + 0.0833333333333333*G0_28_47 + 0.166666666666667*G0_28_51 - 0.0666666666666666*G1_15_15 + 0.0166666666666667*G1_15_16 - 0.0333333333333333*G1_15_20 + 0.0166666666666667*G1_16_15 - 0.0666666666666666*G1_16_16 - 0.0333333333333333*G1_16_20 - 0.0333333333333333*G1_20_15 - 0.0333333333333333*G1_20_16 - 0.266666666666667*G1_20_20 - 0.0666666666666666*G1_21_21 + 0.0166666666666667*G1_21_22 - 0.0333333333333333*G1_21_26 + 0.0166666666666667*G1_22_21 - 0.0666666666666666*G1_22_22 - 0.0333333333333333*G1_22_26 - 0.0333333333333333*G1_26_21 - 0.0333333333333333*G1_26_22 - 0.266666666666667*G1_26_26 - 0.166666666666667*G1_27_27 - 0.0833333333333333*G1_27_28 - 0.0833333333333333*G1_28_27 - 0.166666666666667*G1_28_28 + 0.0458333333333333*G2_0_0 + 0.0749999999999999*G2_0_5 - 0.0375*G2_0_6 + 0.0458333333333333*G2_2_2 - 0.0375*G2_2_5 + 0.0749999999999999*G2_2_6 + 0.0166666666666666*G2_4_0 + 0.0166666666666667*G2_4_2 + 0.15*G2_4_5 + 0.15*G2_4_6 + 0.0458333333333333*G2_6_10 + 0.0749999999999999*G2_6_15 - 0.0375*G2_6_16 + 0.0458333333333333*G2_8_12 - 0.0375*G2_8_15 + 0.0749999999999999*G2_8_16 + 0.0166666666666666*G2_10_10 + 0.0166666666666667*G2_10_12 + 0.15*G2_10_15 + 0.15*G2_10_16 + 0.0833333333333333*G2_12_20 + 0.166666666666667*G2_12_24 + 0.0833333333333333*G2_14_22 + 0.166666666666667*G2_14_24 - 0.0666666666666667*G3_0_0 + 0.0166666666666667*G3_0_2 - 0.0333333333333333*G3_0_4 + 0.0166666666666667*G3_2_0 - 0.0666666666666666*G3_2_2 - 0.0333333333333333*G3_2_4 - 0.0333333333333333*G3_4_0 - 0.0333333333333333*G3_4_2 - 0.266666666666667*G3_4_4 - 0.0666666666666667*G3_6_6 + 0.0166666666666667*G3_6_8 - 0.0333333333333333*G3_6_10 + 0.0166666666666667*G3_8_6 - 0.0666666666666666*G3_8_8 - 0.0333333333333333*G3_8_10 - 0.0333333333333333*G3_10_6 - 0.0333333333333333*G3_10_8 - 0.266666666666667*G3_10_10 - 0.166666666666667*G3_12_12 - 0.0833333333333333*G3_12_14 - 0.0833333333333333*G3_14_12 - 0.166666666666667*G3_14_14;
          break;
        }
      }
      
        break;
      }
    case 2:
      {
        switch (facet1)
      {
      case 0:
        {
          A[0] = 0.0458333333333333*G4_16_27 + 0.0749999999999999*G4_16_29 - 0.0375*G4_16_30 + 0.0458333333333333*G4_17_28 - 0.0375*G4_17_29 + 0.0749999999999999*G4_17_30 + 0.0166666666666667*G4_18_27 + 0.0166666666666667*G4_18_28 + 0.15*G4_18_29 + 0.15*G4_18_30 + 0.0458333333333333*G4_22_37 + 0.0749999999999999*G4_22_39 - 0.0375*G4_22_40 + 0.0458333333333333*G4_23_38 - 0.0375*G4_23_39 + 0.0749999999999999*G4_23_40 + 0.0166666666666667*G4_24_37 + 0.0166666666666667*G4_24_38 + 0.15*G4_24_39 + 0.15*G4_24_40 + 0.0833333333333333*G4_28_47 + 0.166666666666667*G4_28_49 + 0.0833333333333333*G4_29_48 + 0.166666666666667*G4_29_49 - 0.0666666666666666*G5_16_16 + 0.0166666666666666*G5_16_17 - 0.0333333333333333*G5_16_18 + 0.0166666666666666*G5_17_16 - 0.0666666666666666*G5_17_17 - 0.0333333333333333*G5_17_18 - 0.0333333333333333*G5_18_16 - 0.0333333333333333*G5_18_17 - 0.266666666666666*G5_18_18 - 0.0666666666666666*G5_22_22 + 0.0166666666666666*G5_22_23 - 0.0333333333333333*G5_22_24 + 0.0166666666666666*G5_23_22 - 0.0666666666666666*G5_23_23 - 0.0333333333333333*G5_23_24 - 0.0333333333333333*G5_24_22 - 0.0333333333333333*G5_24_23 - 0.266666666666666*G5_24_24 - 0.166666666666667*G5_28_28 - 0.0833333333333333*G5_28_29 - 0.0833333333333333*G5_29_28 - 0.166666666666667*G5_29_29 + 0.0458333333333333*G6_0_0 + 0.0749999999999999*G6_0_7 - 0.0375*G6_0_8 + 0.0458333333333333*G6_1_1 - 0.0375*G6_1_7 + 0.0749999999999999*G6_1_8 + 0.0166666666666666*G6_5_0 + 0.0166666666666666*G6_5_1 + 0.15*G6_5_7 + 0.15*G6_5_8 + 0.0458333333333333*G6_6_10 + 0.0749999999999999*G6_6_17 - 0.0375*G6_6_18 + 0.0458333333333333*G6_7_11 - 0.0375*G6_7_17 + 0.0749999999999999*G6_7_18 + 0.0166666666666666*G6_11_10 + 0.0166666666666666*G6_11_11 + 0.15*G6_11_17 + 0.15*G6_11_18 + 0.0833333333333333*G6_12_20 + 0.166666666666667*G6_12_25 + 0.0833333333333333*G6_13_21 + 0.166666666666667*G6_13_25 - 0.0666666666666666*G7_0_0 + 0.0166666666666667*G7_0_1 - 0.0333333333333333*G7_0_5 + 0.0166666666666667*G7_1_0 - 0.0666666666666666*G7_1_1 - 0.0333333333333333*G7_1_5 - 0.0333333333333333*G7_5_0 - 0.0333333333333333*G7_5_1 - 0.266666666666667*G7_5_5 - 0.0666666666666666*G7_6_6 + 0.0166666666666667*G7_6_7 - 0.0333333333333333*G7_6_11 + 0.0166666666666667*G7_7_6 - 0.0666666666666666*G7_7_7 - 0.0333333333333333*G7_7_11 - 0.0333333333333333*G7_11_6 - 0.0333333333333333*G7_11_7 - 0.266666666666667*G7_11_11 - 0.166666666666667*G7_12_12 - 0.0833333333333333*G7_12_13 - 0.0833333333333333*G7_13_12 - 0.166666666666667*G7_13_13;
        A[1] = 0.0458333333333333*G0_16_27 + 0.0749999999999999*G0_16_29 - 0.0375*G0_16_30 + 0.0458333333333333*G0_17_28 - 0.0375*G0_17_29 + 0.0749999999999999*G0_17_30 + 0.0166666666666667*G0_18_27 + 0.0166666666666667*G0_18_28 + 0.15*G0_18_29 + 0.15*G0_18_30 + 0.0458333333333333*G0_22_37 + 0.0749999999999999*G0_22_39 - 0.0375*G0_22_40 + 0.0458333333333333*G0_23_38 - 0.0375*G0_23_39 + 0.0749999999999999*G0_23_40 + 0.0166666666666667*G0_24_37 + 0.0166666666666667*G0_24_38 + 0.15*G0_24_39 + 0.15*G0_24_40 + 0.0833333333333333*G0_28_47 + 0.166666666666667*G0_28_49 + 0.0833333333333333*G0_29_48 + 0.166666666666667*G0_29_49 - 0.0666666666666666*G1_16_16 + 0.0166666666666666*G1_16_17 - 0.0333333333333333*G1_16_18 + 0.0166666666666666*G1_17_16 - 0.0666666666666666*G1_17_17 - 0.0333333333333333*G1_17_18 - 0.0333333333333333*G1_18_16 - 0.0333333333333333*G1_18_17 - 0.266666666666666*G1_18_18 - 0.0666666666666666*G1_22_22 + 0.0166666666666666*G1_22_23 - 0.0333333333333333*G1_22_24 + 0.0166666666666666*G1_23_22 - 0.0666666666666666*G1_23_23 - 0.0333333333333333*G1_23_24 - 0.0333333333333333*G1_24_22 - 0.0333333333333333*G1_24_23 - 0.266666666666666*G1_24_24 - 0.166666666666667*G1_28_28 - 0.0833333333333333*G1_28_29 - 0.0833333333333333*G1_29_28 - 0.166666666666667*G1_29_29 + 0.0458333333333333*G2_0_0 + 0.0749999999999999*G2_0_7 - 0.0375*G2_0_8 + 0.0458333333333333*G2_1_1 - 0.0375*G2_1_7 + 0.0749999999999999*G2_1_8 + 0.0166666666666666*G2_5_0 + 0.0166666666666666*G2_5_1 + 0.15*G2_5_7 + 0.15*G2_5_8 + 0.0458333333333333*G2_6_10 + 0.0749999999999999*G2_6_17 - 0.0375*G2_6_18 + 0.0458333333333333*G2_7_11 - 0.0375*G2_7_17 + 0.0749999999999999*G2_7_18 + 0.0166666666666666*G2_11_10 + 0.0166666666666666*G2_11_11 + 0.15*G2_11_17 + 0.15*G2_11_18 + 0.0833333333333333*G2_12_20 + 0.166666666666667*G2_12_25 + 0.0833333333333333*G2_13_21 + 0.166666666666667*G2_13_25 - 0.0666666666666666*G3_0_0 + 0.0166666666666667*G3_0_1 - 0.0333333333333333*G3_0_5 + 0.0166666666666667*G3_1_0 - 0.0666666666666666*G3_1_1 - 0.0333333333333333*G3_1_5 - 0.0333333333333333*G3_5_0 - 0.0333333333333333*G3_5_1 - 0.266666666666667*G3_5_5 - 0.0666666666666666*G3_6_6 + 0.0166666666666667*G3_6_7 - 0.0333333333333333*G3_6_11 + 0.0166666666666667*G3_7_6 - 0.0666666666666666*G3_7_7 - 0.0333333333333333*G3_7_11 - 0.0333333333333333*G3_11_6 - 0.0333333333333333*G3_11_7 - 0.266666666666667*G3_11_11 - 0.166666666666667*G3_12_12 - 0.0833333333333333*G3_12_13 - 0.0833333333333333*G3_13_12 - 0.166666666666667*G3_13_13;
          break;
        }
      case 1:
        {
          A[0] = 0.0458333333333333*G4_15_26 + 0.0749999999999999*G4_15_31 - 0.0375*G4_15_32 + 0.0458333333333333*G4_17_28 - 0.0375*G4_17_31 + 0.0749999999999999*G4_17_32 + 0.0166666666666666*G4_19_26 + 0.0166666666666667*G4_19_28 + 0.15*G4_19_31 + 0.15*G4_19_32 + 0.0458333333333333*G4_21_36 + 0.0749999999999999*G4_21_41 - 0.0375*G4_21_42 + 0.0458333333333333*G4_23_38 - 0.0375*G4_23_41 + 0.0749999999999999*G4_23_42 + 0.0166666666666666*G4_25_36 + 0.0166666666666667*G4_25_38 + 0.15*G4_25_41 + 0.15*G4_25_42 + 0.0833333333333333*G4_27_46 + 0.166666666666667*G4_27_50 + 0.0833333333333333*G4_29_48 + 0.166666666666667*G4_29_50 - 0.0666666666666667*G5_15_15 + 0.0166666666666667*G5_15_17 - 0.0333333333333333*G5_15_19 + 0.0166666666666667*G5_17_15 - 0.0666666666666666*G5_17_17 - 0.0333333333333333*G5_17_19 - 0.0333333333333333*G5_19_15 - 0.0333333333333333*G5_19_17 - 0.266666666666667*G5_19_19 - 0.0666666666666667*G5_21_21 + 0.0166666666666667*G5_21_23 - 0.0333333333333333*G5_21_25 + 0.0166666666666667*G5_23_21 - 0.0666666666666666*G5_23_23 - 0.0333333333333333*G5_23_25 - 0.0333333333333333*G5_25_21 - 0.0333333333333333*G5_25_23 - 0.266666666666667*G5_25_25 - 0.166666666666667*G5_27_27 - 0.0833333333333333*G5_27_29 - 0.0833333333333333*G5_29_27 - 0.166666666666667*G5_29_29 + 0.0458333333333333*G6_0_0 + 0.0749999999999999*G6_0_7 - 0.0375*G6_0_8 + 0.0458333333333333*G6_1_1 - 0.0375*G6_1_7 + 0.0749999999999999*G6_1_8 + 0.0166666666666666*G6_5_0 + 0.0166666666666666*G6_5_1 + 0.15*G6_5_7 + 0.15*G6_5_8 + 0.0458333333333333*G6_6_10 + 0.0749999999999999*G6_6_17 - 0.0375*G6_6_18 + 0.0458333333333333*G6_7_11 - 0.0375*G6_7_17 + 0.0749999999999999*G6_7_18 + 0.0166666666666666*G6_11_10 + 0.0166666666666666*G6_11_11 + 0.15*G6_11_17 + 0.15*G6_11_18 + 0.0833333333333333*G6_12_20 + 0.166666666666667*G6_12_25 + 0.0833333333333333*G6_13_21 + 0.166666666666667*G6_13_25 - 0.0666666666666666*G7_0_0 + 0.0166666666666667*G7_0_1 - 0.0333333333333333*G7_0_5 + 0.0166666666666667*G7_1_0 - 0.0666666666666666*G7_1_1 - 0.0333333333333333*G7_1_5 - 0.0333333333333333*G7_5_0 - 0.0333333333333333*G7_5_1 - 0.266666666666667*G7_5_5 - 0.0666666666666666*G7_6_6 + 0.0166666666666667*G7_6_7 - 0.0333333333333333*G7_6_11 + 0.0166666666666667*G7_7_6 - 0.0666666666666666*G7_7_7 - 0.0333333333333333*G7_7_11 - 0.0333333333333333*G7_11_6 - 0.0333333333333333*G7_11_7 - 0.266666666666667*G7_11_11 - 0.166666666666667*G7_12_12 - 0.0833333333333333*G7_12_13 - 0.0833333333333333*G7_13_12 - 0.166666666666667*G7_13_13;
        A[1] = 0.0458333333333333*G0_15_26 + 0.0749999999999999*G0_15_31 - 0.0375*G0_15_32 + 0.0458333333333333*G0_17_28 - 0.0375*G0_17_31 + 0.0749999999999999*G0_17_32 + 0.0166666666666666*G0_19_26 + 0.0166666666666667*G0_19_28 + 0.15*G0_19_31 + 0.15*G0_19_32 + 0.0458333333333333*G0_21_36 + 0.0749999999999999*G0_21_41 - 0.0375*G0_21_42 + 0.0458333333333333*G0_23_38 - 0.0375*G0_23_41 + 0.0749999999999999*G0_23_42 + 0.0166666666666666*G0_25_36 + 0.0166666666666667*G0_25_38 + 0.15*G0_25_41 + 0.15*G0_25_42 + 0.0833333333333333*G0_27_46 + 0.166666666666667*G0_27_50 + 0.0833333333333333*G0_29_48 + 0.166666666666667*G0_29_50 - 0.0666666666666667*G1_15_15 + 0.0166666666666667*G1_15_17 - 0.0333333333333333*G1_15_19 + 0.0166666666666667*G1_17_15 - 0.0666666666666666*G1_17_17 - 0.0333333333333333*G1_17_19 - 0.0333333333333333*G1_19_15 - 0.0333333333333333*G1_19_17 - 0.266666666666667*G1_19_19 - 0.0666666666666667*G1_21_21 + 0.0166666666666667*G1_21_23 - 0.0333333333333333*G1_21_25 + 0.0166666666666667*G1_23_21 - 0.0666666666666666*G1_23_23 - 0.0333333333333333*G1_23_25 - 0.0333333333333333*G1_25_21 - 0.0333333333333333*G1_25_23 - 0.266666666666667*G1_25_25 - 0.166666666666667*G1_27_27 - 0.0833333333333333*G1_27_29 - 0.0833333333333333*G1_29_27 - 0.166666666666667*G1_29_29 + 0.0458333333333333*G2_0_0 + 0.0749999999999999*G2_0_7 - 0.0375*G2_0_8 + 0.0458333333333333*G2_1_1 - 0.0375*G2_1_7 + 0.0749999999999999*G2_1_8 + 0.0166666666666666*G2_5_0 + 0.0166666666666666*G2_5_1 + 0.15*G2_5_7 + 0.15*G2_5_8 + 0.0458333333333333*G2_6_10 + 0.0749999999999999*G2_6_17 - 0.0375*G2_6_18 + 0.0458333333333333*G2_7_11 - 0.0375*G2_7_17 + 0.0749999999999999*G2_7_18 + 0.0166666666666666*G2_11_10 + 0.0166666666666666*G2_11_11 + 0.15*G2_11_17 + 0.15*G2_11_18 + 0.0833333333333333*G2_12_20 + 0.166666666666667*G2_12_25 + 0.0833333333333333*G2_13_21 + 0.166666666666667*G2_13_25 - 0.0666666666666666*G3_0_0 + 0.0166666666666667*G3_0_1 - 0.0333333333333333*G3_0_5 + 0.0166666666666667*G3_1_0 - 0.0666666666666666*G3_1_1 - 0.0333333333333333*G3_1_5 - 0.0333333333333333*G3_5_0 - 0.0333333333333333*G3_5_1 - 0.266666666666667*G3_5_5 - 0.0666666666666666*G3_6_6 + 0.0166666666666667*G3_6_7 - 0.0333333333333333*G3_6_11 + 0.0166666666666667*G3_7_6 - 0.0666666666666666*G3_7_7 - 0.0333333333333333*G3_7_11 - 0.0333333333333333*G3_11_6 - 0.0333333333333333*G3_11_7 - 0.266666666666667*G3_11_11 - 0.166666666666667*G3_12_12 - 0.0833333333333333*G3_12_13 - 0.0833333333333333*G3_13_12 - 0.166666666666667*G3_13_13;
          break;
        }
      case 2:
        {
          A[0] = 0.0458333333333333*G4_15_26 + 0.0749999999999999*G4_15_33 - 0.0375*G4_15_34 + 0.0458333333333333*G4_16_27 - 0.0375*G4_16_33 + 0.0749999999999999*G4_16_34 + 0.0166666666666666*G4_20_26 + 0.0166666666666666*G4_20_27 + 0.15*G4_20_33 + 0.15*G4_20_34 + 0.0458333333333333*G4_21_36 + 0.0749999999999999*G4_21_43 - 0.0375*G4_21_44 + 0.0458333333333333*G4_22_37 - 0.0375*G4_22_43 + 0.0749999999999999*G4_22_44 + 0.0166666666666666*G4_26_36 + 0.0166666666666666*G4_26_37 + 0.15*G4_26_43 + 0.15*G4_26_44 + 0.0833333333333333*G4_27_46 + 0.166666666666667*G4_27_51 + 0.0833333333333333*G4_28_47 + 0.166666666666667*G4_28_51 - 0.0666666666666666*G5_15_15 + 0.0166666666666667*G5_15_16 - 0.0333333333333333*G5_15_20 + 0.0166666666666667*G5_16_15 - 0.0666666666666666*G5_16_16 - 0.0333333333333333*G5_16_20 - 0.0333333333333333*G5_20_15 - 0.0333333333333333*G5_20_16 - 0.266666666666667*G5_20_20 - 0.0666666666666666*G5_21_21 + 0.0166666666666667*G5_21_22 - 0.0333333333333333*G5_21_26 + 0.0166666666666667*G5_22_21 - 0.0666666666666666*G5_22_22 - 0.0333333333333333*G5_22_26 - 0.0333333333333333*G5_26_21 - 0.0333333333333333*G5_26_22 - 0.266666666666667*G5_26_26 - 0.166666666666667*G5_27_27 - 0.0833333333333333*G5_27_28 - 0.0833333333333333*G5_28_27 - 0.166666666666667*G5_28_28 + 0.0458333333333333*G6_0_0 + 0.0749999999999999*G6_0_7 - 0.0375*G6_0_8 + 0.0458333333333333*G6_1_1 - 0.0375*G6_1_7 + 0.0749999999999999*G6_1_8 + 0.0166666666666666*G6_5_0 + 0.0166666666666666*G6_5_1 + 0.15*G6_5_7 + 0.15*G6_5_8 + 0.0458333333333333*G6_6_10 + 0.0749999999999999*G6_6_17 - 0.0375*G6_6_18 + 0.0458333333333333*G6_7_11 - 0.0375*G6_7_17 + 0.0749999999999999*G6_7_18 + 0.0166666666666666*G6_11_10 + 0.0166666666666666*G6_11_11 + 0.15*G6_11_17 + 0.15*G6_11_18 + 0.0833333333333333*G6_12_20 + 0.166666666666667*G6_12_25 + 0.0833333333333333*G6_13_21 + 0.166666666666667*G6_13_25 - 0.0666666666666666*G7_0_0 + 0.0166666666666667*G7_0_1 - 0.0333333333333333*G7_0_5 + 0.0166666666666667*G7_1_0 - 0.0666666666666666*G7_1_1 - 0.0333333333333333*G7_1_5 - 0.0333333333333333*G7_5_0 - 0.0333333333333333*G7_5_1 - 0.266666666666667*G7_5_5 - 0.0666666666666666*G7_6_6 + 0.0166666666666667*G7_6_7 - 0.0333333333333333*G7_6_11 + 0.0166666666666667*G7_7_6 - 0.0666666666666666*G7_7_7 - 0.0333333333333333*G7_7_11 - 0.0333333333333333*G7_11_6 - 0.0333333333333333*G7_11_7 - 0.266666666666667*G7_11_11 - 0.166666666666667*G7_12_12 - 0.0833333333333333*G7_12_13 - 0.0833333333333333*G7_13_12 - 0.166666666666667*G7_13_13;
        A[1] = 0.0458333333333333*G0_15_26 + 0.0749999999999999*G0_15_33 - 0.0375*G0_15_34 + 0.0458333333333333*G0_16_27 - 0.0375*G0_16_33 + 0.0749999999999999*G0_16_34 + 0.0166666666666666*G0_20_26 + 0.0166666666666666*G0_20_27 + 0.15*G0_20_33 + 0.15*G0_20_34 + 0.0458333333333333*G0_21_36 + 0.0749999999999999*G0_21_43 - 0.0375*G0_21_44 + 0.0458333333333333*G0_22_37 - 0.0375*G0_22_43 + 0.0749999999999999*G0_22_44 + 0.0166666666666666*G0_26_36 + 0.0166666666666666*G0_26_37 + 0.15*G0_26_43 + 0.15*G0_26_44 + 0.0833333333333333*G0_27_46 + 0.166666666666667*G0_27_51 + 0.0833333333333333*G0_28_47 + 0.166666666666667*G0_28_51 - 0.0666666666666666*G1_15_15 + 0.0166666666666667*G1_15_16 - 0.0333333333333333*G1_15_20 + 0.0166666666666667*G1_16_15 - 0.0666666666666666*G1_16_16 - 0.0333333333333333*G1_16_20 - 0.0333333333333333*G1_20_15 - 0.0333333333333333*G1_20_16 - 0.266666666666667*G1_20_20 - 0.0666666666666666*G1_21_21 + 0.0166666666666667*G1_21_22 - 0.0333333333333333*G1_21_26 + 0.0166666666666667*G1_22_21 - 0.0666666666666666*G1_22_22 - 0.0333333333333333*G1_22_26 - 0.0333333333333333*G1_26_21 - 0.0333333333333333*G1_26_22 - 0.266666666666667*G1_26_26 - 0.166666666666667*G1_27_27 - 0.0833333333333333*G1_27_28 - 0.0833333333333333*G1_28_27 - 0.166666666666667*G1_28_28 + 0.0458333333333333*G2_0_0 + 0.0749999999999999*G2_0_7 - 0.0375*G2_0_8 + 0.0458333333333333*G2_1_1 - 0.0375*G2_1_7 + 0.0749999999999999*G2_1_8 + 0.0166666666666666*G2_5_0 + 0.0166666666666666*G2_5_1 + 0.15*G2_5_7 + 0.15*G2_5_8 + 0.0458333333333333*G2_6_10 + 0.0749999999999999*G2_6_17 - 0.0375*G2_6_18 + 0.0458333333333333*G2_7_11 - 0.0375*G2_7_17 + 0.0749999999999999*G2_7_18 + 0.0166666666666666*G2_11_10 + 0.0166666666666666*G2_11_11 + 0.15*G2_11_17 + 0.15*G2_11_18 + 0.0833333333333333*G2_12_20 + 0.166666666666667*G2_12_25 + 0.0833333333333333*G2_13_21 + 0.166666666666667*G2_13_25 - 0.0666666666666666*G3_0_0 + 0.0166666666666667*G3_0_1 - 0.0333333333333333*G3_0_5 + 0.0166666666666667*G3_1_0 - 0.0666666666666666*G3_1_1 - 0.0333333333333333*G3_1_5 - 0.0333333333333333*G3_5_0 - 0.0333333333333333*G3_5_1 - 0.266666666666667*G3_5_5 - 0.0666666666666666*G3_6_6 + 0.0166666666666667*G3_6_7 - 0.0333333333333333*G3_6_11 + 0.0166666666666667*G3_7_6 - 0.0666666666666666*G3_7_7 - 0.0333333333333333*G3_7_11 - 0.0333333333333333*G3_11_6 - 0.0333333333333333*G3_11_7 - 0.266666666666667*G3_11_11 - 0.166666666666667*G3_12_12 - 0.0833333333333333*G3_12_13 - 0.0833333333333333*G3_13_12 - 0.166666666666667*G3_13_13;
          break;
        }
      }
      
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local interior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_8_0: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_8_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_8_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      11
    // Number of operations (multiply-add pairs) for geometry tensor:    172
    // Number of operations (multiply-add pairs) for tensor contraction: 2992
    // Total number of operations (multiply-add pairs):                  3175
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Compute geometry tensor
    const double G0_0 = det*K_00*(1.0);
    const double G0_1 = det*K_10*(1.0);
    const double G1_0 = det*K_01*(1.0);
    const double G1_1 = det*K_11*(1.0);
    const double G2_0_0_0 = det*w[1][0]*K_00*K_00*(1.0);
    const double G2_0_0_1 = det*w[1][0]*K_00*K_10*(1.0);
    const double G2_0_1_0 = det*w[1][0]*K_10*K_00*(1.0);
    const double G2_0_1_1 = det*w[1][0]*K_10*K_10*(1.0);
    const double G3_0_0_0 = det*w[1][0]*K_00*K_00*(1.0);
    const double G3_0_0_1 = det*w[1][0]*K_00*K_10*(1.0);
    const double G3_0_1_0 = det*w[1][0]*K_10*K_00*(1.0);
    const double G3_0_1_1 = det*w[1][0]*K_10*K_10*(1.0);
    const double G4_0_0_0 = det*w[1][0]*K_01*K_01*(1.0);
    const double G4_0_0_1 = det*w[1][0]*K_01*K_11*(1.0);
    const double G4_0_1_0 = det*w[1][0]*K_11*K_01*(1.0);
    const double G4_0_1_1 = det*w[1][0]*K_11*K_11*(1.0);
    const double G5_0_0_0 = det*w[1][0]*K_01*K_01*(1.0);
    const double G5_0_0_1 = det*w[1][0]*K_01*K_11*(1.0);
    const double G5_0_1_0 = det*w[1][0]*K_11*K_01*(1.0);
    const double G5_0_1_1 = det*w[1][0]*K_11*K_11*(1.0);
    const double G6_0 = det*K_00*(1.0);
    const double G6_1 = det*K_10*(1.0);
    const double G7_0 = det*K_01*(1.0);
    const double G7_1 = det*K_11*(1.0);
    const double G8_0_0 = det*w[0][0]*K_00*(1.0);
    const double G8_0_1 = det*w[0][0]*K_10*(1.0);
    const double G8_1_0 = det*w[0][1]*K_00*(1.0);
    const double G8_2_1 = det*w[0][2]*K_10*(1.0);
    const double G8_3_0 = det*w[0][3]*K_00*(1.0);
    const double G8_3_1 = det*w[0][3]*K_10*(1.0);
    const double G8_4_0 = det*w[0][4]*K_00*(1.0);
    const double G8_4_1 = det*w[0][4]*K_10*(1.0);
    const double G8_5_0 = det*w[0][5]*K_00*(1.0);
    const double G8_5_1 = det*w[0][5]*K_10*(1.0);
    const double G9_0_0 = det*w[0][0]*K_00*(1.0);
    const double G9_0_1 = det*w[0][0]*K_10*(1.0);
    const double G9_1_0 = det*w[0][1]*K_00*(1.0);
    const double G9_1_1 = det*w[0][1]*K_10*(1.0);
    const double G9_2_0 = det*w[0][2]*K_00*(1.0);
    const double G9_2_1 = det*w[0][2]*K_10*(1.0);
    const double G9_3_0 = det*w[0][3]*K_00*(1.0);
    const double G9_3_1 = det*w[0][3]*K_10*(1.0);
    const double G9_4_0 = det*w[0][4]*K_00*(1.0);
    const double G9_4_1 = det*w[0][4]*K_10*(1.0);
    const double G9_5_0 = det*w[0][5]*K_00*(1.0);
    const double G9_5_1 = det*w[0][5]*K_10*(1.0);
    const double G10_0_0 = det*w[0][0]*K_01*(1.0);
    const double G10_0_1 = det*w[0][0]*K_11*(1.0);
    const double G10_1_0 = det*w[0][1]*K_01*(1.0);
    const double G10_2_1 = det*w[0][2]*K_11*(1.0);
    const double G10_3_0 = det*w[0][3]*K_01*(1.0);
    const double G10_3_1 = det*w[0][3]*K_11*(1.0);
    const double G10_4_0 = det*w[0][4]*K_01*(1.0);
    const double G10_4_1 = det*w[0][4]*K_11*(1.0);
    const double G10_5_0 = det*w[0][5]*K_01*(1.0);
    const double G10_5_1 = det*w[0][5]*K_11*(1.0);
    const double G11_6_0 = det*w[0][6]*K_01*(1.0);
    const double G11_6_1 = det*w[0][6]*K_11*(1.0);
    const double G11_7_0 = det*w[0][7]*K_01*(1.0);
    const double G11_7_1 = det*w[0][7]*K_11*(1.0);
    const double G11_8_0 = det*w[0][8]*K_01*(1.0);
    const double G11_8_1 = det*w[0][8]*K_11*(1.0);
    const double G11_9_0 = det*w[0][9]*K_01*(1.0);
    const double G11_9_1 = det*w[0][9]*K_11*(1.0);
    const double G11_10_0 = det*w[0][10]*K_01*(1.0);
    const double G11_10_1 = det*w[0][10]*K_11*(1.0);
    const double G11_11_0 = det*w[0][11]*K_01*(1.0);
    const double G11_11_1 = det*w[0][11]*K_11*(1.0);
    const double G12_6_0 = det*w[0][6]*K_00*(1.0);
    const double G12_6_1 = det*w[0][6]*K_10*(1.0);
    const double G12_7_0 = det*w[0][7]*K_00*(1.0);
    const double G12_8_1 = det*w[0][8]*K_10*(1.0);
    const double G12_9_0 = det*w[0][9]*K_00*(1.0);
    const double G12_9_1 = det*w[0][9]*K_10*(1.0);
    const double G12_10_0 = det*w[0][10]*K_00*(1.0);
    const double G12_10_1 = det*w[0][10]*K_10*(1.0);
    const double G12_11_0 = det*w[0][11]*K_00*(1.0);
    const double G12_11_1 = det*w[0][11]*K_10*(1.0);
    const double G13_0_0 = det*w[0][0]*K_00*(1.0);
    const double G13_0_1 = det*w[0][0]*K_10*(1.0);
    const double G13_1_0 = det*w[0][1]*K_00*(1.0);
    const double G13_1_1 = det*w[0][1]*K_10*(1.0);
    const double G13_2_0 = det*w[0][2]*K_00*(1.0);
    const double G13_2_1 = det*w[0][2]*K_10*(1.0);
    const double G13_3_0 = det*w[0][3]*K_00*(1.0);
    const double G13_3_1 = det*w[0][3]*K_10*(1.0);
    const double G13_4_0 = det*w[0][4]*K_00*(1.0);
    const double G13_4_1 = det*w[0][4]*K_10*(1.0);
    const double G13_5_0 = det*w[0][5]*K_00*(1.0);
    const double G13_5_1 = det*w[0][5]*K_10*(1.0);
    const double G14_6_0 = det*w[0][6]*K_01*(1.0);
    const double G14_6_1 = det*w[0][6]*K_11*(1.0);
    const double G14_7_0 = det*w[0][7]*K_01*(1.0);
    const double G14_8_1 = det*w[0][8]*K_11*(1.0);
    const double G14_9_0 = det*w[0][9]*K_01*(1.0);
    const double G14_9_1 = det*w[0][9]*K_11*(1.0);
    const double G14_10_0 = det*w[0][10]*K_01*(1.0);
    const double G14_10_1 = det*w[0][10]*K_11*(1.0);
    const double G14_11_0 = det*w[0][11]*K_01*(1.0);
    const double G14_11_1 = det*w[0][11]*K_11*(1.0);
    const double G15_6_0 = det*w[0][6]*K_01*(1.0);
    const double G15_6_1 = det*w[0][6]*K_11*(1.0);
    const double G15_7_0 = det*w[0][7]*K_01*(1.0);
    const double G15_7_1 = det*w[0][7]*K_11*(1.0);
    const double G15_8_0 = det*w[0][8]*K_01*(1.0);
    const double G15_8_1 = det*w[0][8]*K_11*(1.0);
    const double G15_9_0 = det*w[0][9]*K_01*(1.0);
    const double G15_9_1 = det*w[0][9]*K_11*(1.0);
    const double G15_10_0 = det*w[0][10]*K_01*(1.0);
    const double G15_10_1 = det*w[0][10]*K_11*(1.0);
    const double G15_11_0 = det*w[0][11]*K_01*(1.0);
    const double G15_11_1 = det*w[0][11]*K_11*(1.0);
    
    // Compute element tensor
    A[0] = 0.5*G2_0_0_0 + 0.5*G2_0_0_1 + 0.5*G2_0_1_0 + 0.5*G2_0_1_1 + 0.5*G4_0_0_0 + 0.5*G4_0_0_1 + 0.5*G4_0_1_0 + 0.5*G4_0_1_1 - 0.030952380952381*G8_0_0 - 0.0309523809523809*G8_0_1 - 0.00714285714285714*G8_1_0 - 0.00714285714285714*G8_2_1 + 0.00952380952380952*G8_3_0 + 0.00952380952380952*G8_3_1 - 0.00952380952380952*G8_4_0 + 0.0380952380952381*G8_4_1 + 0.0380952380952381*G8_5_0 - 0.00952380952380953*G8_5_1 - 0.030952380952381*G9_0_0 - 0.0309523809523809*G9_0_1 + 0.00357142857142857*G9_1_0 + 0.00357142857142857*G9_1_1 + 0.00357142857142857*G9_2_0 + 0.00357142857142857*G9_2_1 - 0.00476190476190477*G9_3_0 - 0.00476190476190477*G9_3_1 - 0.0190476190476191*G9_4_0 - 0.0190476190476191*G9_4_1 - 0.019047619047619*G9_5_0 - 0.019047619047619*G9_5_1 - 0.030952380952381*G11_6_0 - 0.0309523809523809*G11_6_1 + 0.00357142857142857*G11_7_0 + 0.00357142857142857*G11_7_1 + 0.00357142857142857*G11_8_0 + 0.00357142857142857*G11_8_1 - 0.00476190476190477*G11_9_0 - 0.00476190476190477*G11_9_1 - 0.0190476190476191*G11_10_0 - 0.0190476190476191*G11_10_1 - 0.019047619047619*G11_11_0 - 0.019047619047619*G11_11_1;
    A[1] = 0.166666666666667*G2_0_0_0 + 0.166666666666667*G2_0_1_0 + 0.166666666666667*G4_0_0_0 + 0.166666666666667*G4_0_1_0 + 0.00357142857142857*G8_0_0 + 0.00357142857142857*G8_0_1 - 0.00357142857142857*G8_1_0 + 0.00436507936507937*G8_2_1 + 0.00158730158730159*G8_3_0 - 0.00634920634920635*G8_3_1 - 0.00158730158730159*G8_4_0 - 0.00793650793650794*G8_4_1 + 0.00634920634920635*G8_5_1 - 0.00714285714285714*G9_0_0 - 0.00357142857142857*G9_1_0 + 0.00436507936507937*G9_2_0 - 0.00793650793650794*G9_3_0 - 0.00634920634920635*G9_4_0 - 0.0126984126984127*G9_5_0 - 0.00714285714285714*G11_6_0 - 0.00357142857142857*G11_7_0 + 0.00436507936507937*G11_8_0 - 0.00793650793650794*G11_9_0 - 0.00634920634920635*G11_10_0 - 0.0126984126984127*G11_11_0;
    A[2] = 0.166666666666667*G2_0_0_1 + 0.166666666666667*G2_0_1_1 + 0.166666666666667*G4_0_0_1 + 0.166666666666667*G4_0_1_1 + 0.00357142857142857*G8_0_0 + 0.00357142857142857*G8_0_1 + 0.00436507936507937*G8_1_0 - 0.00357142857142857*G8_2_1 - 0.00634920634920634*G8_3_0 + 0.00158730158730159*G8_3_1 + 0.00634920634920634*G8_4_0 - 0.00793650793650794*G8_5_0 - 0.00158730158730159*G8_5_1 - 0.00714285714285714*G9_0_1 + 0.00436507936507937*G9_1_1 - 0.00357142857142857*G9_2_1 - 0.00793650793650794*G9_3_1 - 0.0126984126984127*G9_4_1 - 0.00634920634920635*G9_5_1 - 0.00714285714285714*G11_6_1 + 0.00436507936507937*G11_7_1 - 0.00357142857142857*G11_8_1 - 0.00793650793650794*G11_9_1 - 0.0126984126984127*G11_10_1 - 0.00634920634920635*G11_11_1;
    A[3] = -0.00476190476190477*G8_0_0 - 0.00476190476190477*G8_0_1 - 0.00793650793650794*G8_1_0 - 0.00793650793650794*G8_2_1 - 0.019047619047619*G8_3_0 - 0.019047619047619*G8_3_1 + 0.0190476190476191*G8_4_0 + 0.0126984126984127*G8_4_1 + 0.0126984126984127*G8_5_0 + 0.0190476190476191*G8_5_1 + 0.00952380952380952*G9_0_0 + 0.00952380952380952*G9_0_1 + 0.00158730158730159*G9_1_0 - 0.00634920634920635*G9_1_1 - 0.00634920634920634*G9_2_0 + 0.00158730158730159*G9_2_1 - 0.019047619047619*G9_3_0 - 0.019047619047619*G9_3_1 - 0.0126984126984127*G9_4_0 - 0.00634920634920635*G9_4_1 - 0.00634920634920636*G9_5_0 - 0.0126984126984127*G9_5_1 + 0.00952380952380952*G11_6_0 + 0.00952380952380952*G11_6_1 + 0.00158730158730159*G11_7_0 - 0.00634920634920635*G11_7_1 - 0.00634920634920634*G11_8_0 + 0.00158730158730159*G11_8_1 - 0.019047619047619*G11_9_0 - 0.019047619047619*G11_9_1 - 0.0126984126984127*G11_10_0 - 0.00634920634920635*G11_10_1 - 0.00634920634920636*G11_11_0 - 0.0126984126984127*G11_11_1;
    A[4] = -0.666666666666667*G2_0_0_1 - 0.666666666666667*G2_0_1_1 - 0.666666666666667*G4_0_0_1 - 0.666666666666667*G4_0_1_1 - 0.0190476190476191*G8_0_0 - 0.0190476190476191*G8_0_1 - 0.00634920634920635*G8_1_0 - 0.0126984126984127*G8_2_1 - 0.0126984126984127*G8_3_0 - 0.00634920634920635*G8_3_1 + 0.0126984126984127*G8_4_0 + 0.0317460317460318*G8_4_1 + 0.0253968253968254*G8_5_0 + 0.00634920634920635*G8_5_1 - 0.00952380952380952*G9_0_0 + 0.0380952380952381*G9_0_1 - 0.00158730158730159*G9_1_0 - 0.00793650793650794*G9_1_1 + 0.00634920634920634*G9_2_0 + 0.0190476190476191*G9_3_0 + 0.0126984126984127*G9_3_1 + 0.0126984126984127*G9_4_0 + 0.0317460317460318*G9_4_1 + 0.00634920634920636*G9_5_0 + 0.0253968253968254*G9_5_1 - 0.00952380952380952*G11_6_0 + 0.0380952380952381*G11_6_1 - 0.00158730158730159*G11_7_0 - 0.00793650793650794*G11_7_1 + 0.00634920634920634*G11_8_0 + 0.0190476190476191*G11_9_0 + 0.0126984126984127*G11_9_1 + 0.0126984126984127*G11_10_0 + 0.0317460317460318*G11_10_1 + 0.00634920634920636*G11_11_0 + 0.0253968253968254*G11_11_1;
    A[5] = -0.666666666666667*G2_0_0_0 - 0.666666666666667*G2_0_1_0 - 0.666666666666667*G4_0_0_0 - 0.666666666666667*G4_0_1_0 - 0.019047619047619*G8_0_0 - 0.019047619047619*G8_0_1 - 0.0126984126984127*G8_1_0 - 0.00634920634920635*G8_2_1 - 0.00634920634920636*G8_3_0 - 0.0126984126984127*G8_3_1 + 0.00634920634920636*G8_4_0 + 0.0253968253968254*G8_4_1 + 0.0317460317460317*G8_5_0 + 0.0126984126984127*G8_5_1 + 0.0380952380952381*G9_0_0 - 0.00952380952380953*G9_0_1 + 0.00634920634920635*G9_1_1 - 0.00793650793650794*G9_2_0 - 0.00158730158730159*G9_2_1 + 0.0126984126984127*G9_3_0 + 0.0190476190476191*G9_3_1 + 0.0253968253968254*G9_4_0 + 0.00634920634920635*G9_4_1 + 0.0317460317460317*G9_5_0 + 0.0126984126984127*G9_5_1 + 0.0380952380952381*G11_6_0 - 0.00952380952380953*G11_6_1 + 0.00634920634920635*G11_7_1 - 0.00793650793650794*G11_8_0 - 0.00158730158730159*G11_8_1 + 0.0126984126984127*G11_9_0 + 0.0190476190476191*G11_9_1 + 0.0253968253968254*G11_10_0 + 0.00634920634920635*G11_10_1 + 0.0317460317460317*G11_11_0 + 0.0126984126984127*G11_11_1;
    A[6] = -0.030952380952381*G10_0_0 - 0.0309523809523809*G10_0_1 - 0.00714285714285714*G10_1_0 - 0.00714285714285714*G10_2_1 + 0.00952380952380952*G10_3_0 + 0.00952380952380952*G10_3_1 - 0.00952380952380952*G10_4_0 + 0.0380952380952381*G10_4_1 + 0.0380952380952381*G10_5_0 - 0.00952380952380953*G10_5_1;
    A[7] = 0.00357142857142857*G10_0_0 + 0.00357142857142857*G10_0_1 - 0.00357142857142857*G10_1_0 + 0.00436507936507937*G10_2_1 + 0.00158730158730159*G10_3_0 - 0.00634920634920635*G10_3_1 - 0.00158730158730159*G10_4_0 - 0.00793650793650794*G10_4_1 + 0.00634920634920635*G10_5_1;
    A[8] = 0.00357142857142857*G10_0_0 + 0.00357142857142857*G10_0_1 + 0.00436507936507937*G10_1_0 - 0.00357142857142857*G10_2_1 - 0.00634920634920634*G10_3_0 + 0.00158730158730159*G10_3_1 + 0.00634920634920634*G10_4_0 - 0.00793650793650794*G10_5_0 - 0.00158730158730159*G10_5_1;
    A[9] = -0.00476190476190477*G10_0_0 - 0.00476190476190477*G10_0_1 - 0.00793650793650794*G10_1_0 - 0.00793650793650794*G10_2_1 - 0.019047619047619*G10_3_0 - 0.019047619047619*G10_3_1 + 0.0190476190476191*G10_4_0 + 0.0126984126984127*G10_4_1 + 0.0126984126984127*G10_5_0 + 0.0190476190476191*G10_5_1;
    A[10] = -0.0190476190476191*G10_0_0 - 0.0190476190476191*G10_0_1 - 0.00634920634920635*G10_1_0 - 0.0126984126984127*G10_2_1 - 0.0126984126984127*G10_3_0 - 0.00634920634920635*G10_3_1 + 0.0126984126984127*G10_4_0 + 0.0317460317460318*G10_4_1 + 0.0253968253968254*G10_5_0 + 0.00634920634920635*G10_5_1;
    A[11] = -0.019047619047619*G10_0_0 - 0.019047619047619*G10_0_1 - 0.0126984126984127*G10_1_0 - 0.00634920634920635*G10_2_1 - 0.00634920634920636*G10_3_0 - 0.0126984126984127*G10_3_1 + 0.00634920634920636*G10_4_0 + 0.0253968253968254*G10_4_1 + 0.0317460317460317*G10_5_0 + 0.0126984126984127*G10_5_1;
    A[12] = 0.166666666666667*G6_0 + 0.166666666666667*G6_1;
    A[13] = 0.0;
    A[14] = 0.0;
    A[15] = 0.166666666666667*G2_0_0_0 + 0.166666666666667*G2_0_0_1 + 0.166666666666667*G4_0_0_0 + 0.166666666666667*G4_0_0_1 + 0.00357142857142857*G8_0_0 + 0.00357142857142857*G8_0_1 - 0.00357142857142857*G8_1_0 + 0.00436507936507937*G8_2_1 + 0.00158730158730159*G8_3_0 - 0.00634920634920635*G8_3_1 - 0.00158730158730159*G8_4_0 - 0.00793650793650794*G8_4_1 + 0.00634920634920635*G8_5_1 + 0.00357142857142857*G9_0_0 + 0.00357142857142857*G9_0_1 + 0.00714285714285713*G9_1_0 + 0.00714285714285714*G9_1_1 - 0.00436507936507936*G9_2_0 - 0.00436507936507936*G9_2_1 + 0.00634920634920635*G9_3_0 + 0.00634920634920635*G9_3_1 + 0.00793650793650794*G9_4_0 + 0.00793650793650794*G9_4_1 + 0.0126984126984127*G9_5_0 + 0.0126984126984127*G9_5_1 + 0.00357142857142857*G11_6_0 + 0.00357142857142857*G11_6_1 + 0.00714285714285713*G11_7_0 + 0.00714285714285714*G11_7_1 - 0.00436507936507936*G11_8_0 - 0.00436507936507936*G11_8_1 + 0.00634920634920635*G11_9_0 + 0.00634920634920635*G11_9_1 + 0.00793650793650794*G11_10_0 + 0.00793650793650794*G11_10_1 + 0.0126984126984127*G11_11_0 + 0.0126984126984127*G11_11_1;
    A[16] = 0.5*G2_0_0_0 + 0.5*G4_0_0_0 + 0.00714285714285713*G8_0_0 + 0.00714285714285714*G8_0_1 + 0.0309523809523809*G8_1_0 - 0.00714285714285713*G8_2_1 + 0.00952380952380951*G8_3_0 + 0.0476190476190476*G8_3_1 - 0.00952380952380952*G8_4_0 - 0.0380952380952381*G8_5_0 - 0.0476190476190476*G8_5_1 - 0.00357142857142857*G9_0_0 + 0.0309523809523809*G9_1_0 - 0.00357142857142857*G9_2_0 + 0.019047619047619*G9_3_0 + 0.00476190476190476*G9_4_0 + 0.0190476190476191*G9_5_0 - 0.00357142857142857*G11_6_0 + 0.0309523809523809*G11_7_0 - 0.00357142857142857*G11_8_0 + 0.019047619047619*G11_9_0 + 0.00476190476190476*G11_10_0 + 0.0190476190476191*G11_11_0;
    A[17] = -0.166666666666667*G2_0_0_1 - 0.166666666666667*G4_0_0_1 - 0.00436507936507936*G8_0_0 - 0.00436507936507936*G8_0_1 - 0.00357142857142857*G8_1_0 - 0.00357142857142857*G8_2_1 - 0.00634920634920634*G8_3_0 - 0.00634920634920634*G8_3_1 + 0.00634920634920634*G8_4_0 + 0.00793650793650793*G8_4_1 + 0.00793650793650793*G8_5_0 + 0.00634920634920634*G8_5_1 + 0.00436507936507937*G9_0_1 - 0.00714285714285713*G9_1_1 - 0.00357142857142857*G9_2_1 - 0.0126984126984127*G9_3_1 - 0.00793650793650794*G9_4_1 - 0.00634920634920635*G9_5_1 + 0.00436507936507937*G11_6_1 - 0.00714285714285713*G11_7_1 - 0.00357142857142857*G11_8_1 - 0.0126984126984127*G11_9_1 - 0.00793650793650794*G11_10_1 - 0.00634920634920635*G11_11_1;
    A[18] = 0.666666666666666*G2_0_0_1 + 0.666666666666666*G4_0_0_1 + 0.00634920634920635*G8_0_0 + 0.00634920634920635*G8_0_1 + 0.019047619047619*G8_1_0 - 0.0126984126984127*G8_2_1 - 0.0126984126984127*G8_3_0 + 0.019047619047619*G8_3_1 + 0.0126984126984127*G8_4_0 + 0.00634920634920635*G8_4_1 - 0.0253968253968254*G8_5_0 - 0.019047619047619*G8_5_1 + 0.00158730158730159*G9_0_0 - 0.00634920634920635*G9_0_1 + 0.00952380952380951*G9_1_0 + 0.0476190476190476*G9_1_1 - 0.00634920634920634*G9_2_0 - 0.00634920634920634*G9_2_1 - 0.0126984126984127*G9_3_0 + 0.019047619047619*G9_3_1 - 0.019047619047619*G9_4_0 - 0.00634920634920635*G9_4_1 - 0.00634920634920636*G9_5_0 + 0.0190476190476191*G9_5_1 + 0.00158730158730159*G11_6_0 - 0.00634920634920635*G11_6_1 + 0.00952380952380951*G11_7_0 + 0.0476190476190476*G11_7_1 - 0.00634920634920634*G11_8_0 - 0.00634920634920634*G11_8_1 - 0.0126984126984127*G11_9_0 + 0.019047619047619*G11_9_1 - 0.019047619047619*G11_10_0 - 0.00634920634920635*G11_10_1 - 0.00634920634920636*G11_11_0 + 0.0190476190476191*G11_11_1;
    A[19] = 0.00793650793650794*G8_0_0 + 0.00793650793650794*G8_0_1 + 0.00476190476190476*G8_1_0 - 0.00793650793650794*G8_2_1 - 0.019047619047619*G8_3_0 - 0.00634920634920635*G8_3_1 + 0.0190476190476191*G8_4_0 - 0.0126984126984127*G8_5_0 + 0.00634920634920635*G8_5_1 - 0.00158730158730159*G9_0_0 - 0.00793650793650794*G9_0_1 - 0.00952380952380952*G9_1_0 + 0.00634920634920634*G9_2_0 + 0.00793650793650793*G9_2_1 + 0.0126984126984127*G9_3_0 + 0.00634920634920635*G9_3_1 + 0.0190476190476191*G9_4_0 + 0.00634920634920636*G9_5_0 - 0.00634920634920634*G9_5_1 - 0.00158730158730159*G11_6_0 - 0.00793650793650794*G11_6_1 - 0.00952380952380952*G11_7_0 + 0.00634920634920634*G11_8_0 + 0.00793650793650793*G11_8_1 + 0.0126984126984127*G11_9_0 + 0.00634920634920635*G11_9_1 + 0.0190476190476191*G11_10_0 + 0.00634920634920636*G11_11_0 - 0.00634920634920634*G11_11_1;
    A[20] = -0.666666666666667*G2_0_0_0 - 0.666666666666667*G2_0_0_1 - 0.666666666666667*G4_0_0_0 - 0.666666666666667*G4_0_0_1 + 0.0126984126984127*G8_0_0 + 0.0126984126984127*G8_0_1 + 0.0190476190476191*G8_1_0 - 0.00634920634920635*G8_2_1 - 0.00634920634920636*G8_3_0 + 0.0190476190476191*G8_3_1 + 0.00634920634920636*G8_4_0 - 0.00634920634920634*G8_4_1 - 0.0317460317460318*G8_5_0 - 0.0190476190476191*G8_5_1 + 0.00634920634920635*G9_0_1 - 0.0380952380952381*G9_1_0 - 0.0476190476190476*G9_1_1 + 0.00793650793650793*G9_2_0 + 0.00634920634920634*G9_2_1 - 0.0253968253968254*G9_3_0 - 0.019047619047619*G9_3_1 - 0.0126984126984127*G9_4_0 + 0.00634920634920635*G9_4_1 - 0.0317460317460318*G9_5_0 - 0.0190476190476191*G9_5_1 + 0.00634920634920635*G11_6_1 - 0.0380952380952381*G11_7_0 - 0.0476190476190476*G11_7_1 + 0.00793650793650793*G11_8_0 + 0.00634920634920634*G11_8_1 - 0.0253968253968254*G11_9_0 - 0.019047619047619*G11_9_1 - 0.0126984126984127*G11_10_0 + 0.00634920634920635*G11_10_1 - 0.0317460317460318*G11_11_0 - 0.0190476190476191*G11_11_1;
    A[21] = 0.00357142857142857*G10_0_0 + 0.00357142857142857*G10_0_1 - 0.00357142857142857*G10_1_0 + 0.00436507936507937*G10_2_1 + 0.00158730158730159*G10_3_0 - 0.00634920634920635*G10_3_1 - 0.00158730158730159*G10_4_0 - 0.00793650793650794*G10_4_1 + 0.00634920634920635*G10_5_1;
    A[22] = 0.00714285714285713*G10_0_0 + 0.00714285714285714*G10_0_1 + 0.0309523809523809*G10_1_0 - 0.00714285714285713*G10_2_1 + 0.00952380952380951*G10_3_0 + 0.0476190476190476*G10_3_1 - 0.00952380952380952*G10_4_0 - 0.0380952380952381*G10_5_0 - 0.0476190476190476*G10_5_1;
    A[23] = -0.00436507936507936*G10_0_0 - 0.00436507936507936*G10_0_1 - 0.00357142857142857*G10_1_0 - 0.00357142857142857*G10_2_1 - 0.00634920634920634*G10_3_0 - 0.00634920634920634*G10_3_1 + 0.00634920634920634*G10_4_0 + 0.00793650793650793*G10_4_1 + 0.00793650793650793*G10_5_0 + 0.00634920634920634*G10_5_1;
    A[24] = 0.00634920634920635*G10_0_0 + 0.00634920634920635*G10_0_1 + 0.019047619047619*G10_1_0 - 0.0126984126984127*G10_2_1 - 0.0126984126984127*G10_3_0 + 0.019047619047619*G10_3_1 + 0.0126984126984127*G10_4_0 + 0.00634920634920635*G10_4_1 - 0.0253968253968254*G10_5_0 - 0.019047619047619*G10_5_1;
    A[25] = 0.00793650793650794*G10_0_0 + 0.00793650793650794*G10_0_1 + 0.00476190476190476*G10_1_0 - 0.00793650793650794*G10_2_1 - 0.019047619047619*G10_3_0 - 0.00634920634920635*G10_3_1 + 0.0190476190476191*G10_4_0 - 0.0126984126984127*G10_5_0 + 0.00634920634920635*G10_5_1;
    A[26] = 0.0126984126984127*G10_0_0 + 0.0126984126984127*G10_0_1 + 0.0190476190476191*G10_1_0 - 0.00634920634920635*G10_2_1 - 0.00634920634920636*G10_3_0 + 0.0190476190476191*G10_3_1 + 0.00634920634920636*G10_4_0 - 0.00634920634920634*G10_4_1 - 0.0317460317460318*G10_5_0 - 0.0190476190476191*G10_5_1;
    A[27] = 0.0;
    A[28] = -0.166666666666667*G6_0;
    A[29] = 0.0;
    A[30] = 0.166666666666667*G2_0_1_0 + 0.166666666666667*G2_0_1_1 + 0.166666666666667*G4_0_1_0 + 0.166666666666667*G4_0_1_1 + 0.00357142857142857*G8_0_0 + 0.00357142857142857*G8_0_1 + 0.00436507936507937*G8_1_0 - 0.00357142857142857*G8_2_1 - 0.00634920634920634*G8_3_0 + 0.00158730158730159*G8_3_1 + 0.00634920634920634*G8_4_0 - 0.00793650793650794*G8_5_0 - 0.00158730158730159*G8_5_1 + 0.00357142857142857*G9_0_0 + 0.00357142857142857*G9_0_1 - 0.00436507936507936*G9_1_0 - 0.00436507936507936*G9_1_1 + 0.00714285714285713*G9_2_0 + 0.00714285714285712*G9_2_1 + 0.00634920634920634*G9_3_0 + 0.00634920634920634*G9_3_1 + 0.0126984126984127*G9_4_0 + 0.0126984126984127*G9_4_1 + 0.00793650793650794*G9_5_0 + 0.00793650793650794*G9_5_1 + 0.00357142857142857*G11_6_0 + 0.00357142857142857*G11_6_1 - 0.00436507936507936*G11_7_0 - 0.00436507936507936*G11_7_1 + 0.00714285714285713*G11_8_0 + 0.00714285714285712*G11_8_1 + 0.00634920634920634*G11_9_0 + 0.00634920634920634*G11_9_1 + 0.0126984126984127*G11_10_0 + 0.0126984126984127*G11_10_1 + 0.00793650793650794*G11_11_0 + 0.00793650793650794*G11_11_1;
    A[31] = -0.166666666666667*G2_0_1_0 - 0.166666666666667*G4_0_1_0 - 0.00436507936507936*G8_0_0 - 0.00436507936507936*G8_0_1 - 0.00357142857142857*G8_1_0 - 0.00357142857142857*G8_2_1 - 0.00634920634920634*G8_3_0 - 0.00634920634920634*G8_3_1 + 0.00634920634920634*G8_4_0 + 0.00793650793650793*G8_4_1 + 0.00793650793650793*G8_5_0 + 0.00634920634920634*G8_5_1 + 0.00436507936507937*G9_0_0 - 0.00357142857142857*G9_1_0 - 0.00714285714285714*G9_2_0 - 0.0126984126984127*G9_3_0 - 0.00634920634920635*G9_4_0 - 0.00793650793650794*G9_5_0 + 0.00436507936507937*G11_6_0 - 0.00357142857142857*G11_7_0 - 0.00714285714285714*G11_8_0 - 0.0126984126984127*G11_9_0 - 0.00634920634920635*G11_10_0 - 0.00793650793650794*G11_11_0;
    A[32] = 0.5*G2_0_1_1 + 0.5*G4_0_1_1 + 0.00714285714285713*G8_0_0 + 0.00714285714285712*G8_0_1 - 0.00714285714285714*G8_1_0 + 0.0309523809523809*G8_2_1 + 0.0476190476190475*G8_3_0 + 0.0095238095238095*G8_3_1 - 0.0476190476190476*G8_4_0 - 0.038095238095238*G8_4_1 - 0.00952380952380951*G8_5_1 - 0.00357142857142857*G9_0_1 - 0.00357142857142857*G9_1_1 + 0.0309523809523809*G9_2_1 + 0.019047619047619*G9_3_1 + 0.019047619047619*G9_4_1 + 0.00476190476190476*G9_5_1 - 0.00357142857142857*G11_6_1 - 0.00357142857142857*G11_7_1 + 0.0309523809523809*G11_8_1 + 0.019047619047619*G11_9_1 + 0.019047619047619*G11_10_1 + 0.00476190476190476*G11_11_1;
    A[33] = 0.666666666666666*G2_0_1_0 + 0.666666666666666*G4_0_1_0 + 0.00634920634920634*G8_0_0 + 0.00634920634920634*G8_0_1 - 0.0126984126984127*G8_1_0 + 0.019047619047619*G8_2_1 + 0.019047619047619*G8_3_0 - 0.0126984126984127*G8_3_1 - 0.019047619047619*G8_4_0 - 0.0253968253968254*G8_4_1 + 0.00634920634920635*G8_5_0 + 0.0126984126984127*G8_5_1 - 0.00634920634920634*G9_0_0 + 0.00158730158730159*G9_0_1 - 0.00634920634920634*G9_1_0 - 0.00634920634920634*G9_1_1 + 0.0476190476190475*G9_2_0 + 0.0095238095238095*G9_2_1 + 0.019047619047619*G9_3_0 - 0.0126984126984127*G9_3_1 + 0.019047619047619*G9_4_0 - 0.00634920634920636*G9_4_1 - 0.00634920634920634*G9_5_0 - 0.019047619047619*G9_5_1 - 0.00634920634920634*G11_6_0 + 0.00158730158730159*G11_6_1 - 0.00634920634920634*G11_7_0 - 0.00634920634920634*G11_7_1 + 0.0476190476190475*G11_8_0 + 0.0095238095238095*G11_8_1 + 0.019047619047619*G11_9_0 - 0.0126984126984127*G11_9_1 + 0.019047619047619*G11_10_0 - 0.00634920634920636*G11_10_1 - 0.00634920634920634*G11_11_0 - 0.019047619047619*G11_11_1;
    A[34] = -0.666666666666667*G2_0_1_0 - 0.666666666666667*G2_0_1_1 - 0.666666666666667*G4_0_1_0 - 0.666666666666667*G4_0_1_1 + 0.0126984126984127*G8_0_0 + 0.0126984126984127*G8_0_1 - 0.00634920634920635*G8_1_0 + 0.019047619047619*G8_2_1 + 0.019047619047619*G8_3_0 - 0.00634920634920636*G8_3_1 - 0.019047619047619*G8_4_0 - 0.0317460317460317*G8_4_1 - 0.00634920634920635*G8_5_0 + 0.00634920634920635*G8_5_1 + 0.00634920634920634*G9_0_0 + 0.00634920634920634*G9_1_0 + 0.00793650793650793*G9_1_1 - 0.0476190476190476*G9_2_0 - 0.038095238095238*G9_2_1 - 0.019047619047619*G9_3_0 - 0.0253968253968254*G9_3_1 - 0.019047619047619*G9_4_0 - 0.0317460317460317*G9_4_1 + 0.00634920634920635*G9_5_0 - 0.0126984126984127*G9_5_1 + 0.00634920634920634*G11_6_0 + 0.00634920634920634*G11_7_0 + 0.00793650793650793*G11_7_1 - 0.0476190476190476*G11_8_0 - 0.038095238095238*G11_8_1 - 0.019047619047619*G11_9_0 - 0.0253968253968254*G11_9_1 - 0.019047619047619*G11_10_0 - 0.0317460317460317*G11_10_1 + 0.00634920634920635*G11_11_0 - 0.0126984126984127*G11_11_1;
    A[35] = 0.00793650793650794*G8_0_0 + 0.00793650793650794*G8_0_1 - 0.00793650793650794*G8_1_0 + 0.00476190476190476*G8_2_1 - 0.00634920634920634*G8_3_0 - 0.019047619047619*G8_3_1 + 0.00634920634920635*G8_4_0 - 0.0126984126984127*G8_4_1 + 0.019047619047619*G8_5_1 - 0.00793650793650794*G9_0_0 - 0.00158730158730159*G9_0_1 + 0.00793650793650793*G9_1_0 + 0.00634920634920634*G9_1_1 - 0.00952380952380951*G9_2_1 + 0.00634920634920635*G9_3_0 + 0.0126984126984127*G9_3_1 - 0.00634920634920635*G9_4_0 + 0.00634920634920635*G9_4_1 + 0.019047619047619*G9_5_1 - 0.00793650793650794*G11_6_0 - 0.00158730158730159*G11_6_1 + 0.00793650793650793*G11_7_0 + 0.00634920634920634*G11_7_1 - 0.00952380952380951*G11_8_1 + 0.00634920634920635*G11_9_0 + 0.0126984126984127*G11_9_1 - 0.00634920634920635*G11_10_0 + 0.00634920634920635*G11_10_1 + 0.019047619047619*G11_11_1;
    A[36] = 0.00357142857142857*G10_0_0 + 0.00357142857142857*G10_0_1 + 0.00436507936507937*G10_1_0 - 0.00357142857142857*G10_2_1 - 0.00634920634920634*G10_3_0 + 0.00158730158730159*G10_3_1 + 0.00634920634920634*G10_4_0 - 0.00793650793650794*G10_5_0 - 0.00158730158730159*G10_5_1;
    A[37] = -0.00436507936507936*G10_0_0 - 0.00436507936507936*G10_0_1 - 0.00357142857142857*G10_1_0 - 0.00357142857142857*G10_2_1 - 0.00634920634920634*G10_3_0 - 0.00634920634920634*G10_3_1 + 0.00634920634920634*G10_4_0 + 0.00793650793650793*G10_4_1 + 0.00793650793650793*G10_5_0 + 0.00634920634920634*G10_5_1;
    A[38] = 0.00714285714285713*G10_0_0 + 0.00714285714285712*G10_0_1 - 0.00714285714285714*G10_1_0 + 0.0309523809523809*G10_2_1 + 0.0476190476190475*G10_3_0 + 0.0095238095238095*G10_3_1 - 0.0476190476190476*G10_4_0 - 0.038095238095238*G10_4_1 - 0.00952380952380951*G10_5_1;
    A[39] = 0.00634920634920634*G10_0_0 + 0.00634920634920634*G10_0_1 - 0.0126984126984127*G10_1_0 + 0.019047619047619*G10_2_1 + 0.019047619047619*G10_3_0 - 0.0126984126984127*G10_3_1 - 0.019047619047619*G10_4_0 - 0.0253968253968254*G10_4_1 + 0.00634920634920635*G10_5_0 + 0.0126984126984127*G10_5_1;
    A[40] = 0.0126984126984127*G10_0_0 + 0.0126984126984127*G10_0_1 - 0.00634920634920635*G10_1_0 + 0.019047619047619*G10_2_1 + 0.019047619047619*G10_3_0 - 0.00634920634920636*G10_3_1 - 0.019047619047619*G10_4_0 - 0.0317460317460317*G10_4_1 - 0.00634920634920635*G10_5_0 + 0.00634920634920635*G10_5_1;
    A[41] = 0.00793650793650794*G10_0_0 + 0.00793650793650794*G10_0_1 - 0.00793650793650794*G10_1_0 + 0.00476190476190476*G10_2_1 - 0.00634920634920634*G10_3_0 - 0.019047619047619*G10_3_1 + 0.00634920634920635*G10_4_0 - 0.0126984126984127*G10_4_1 + 0.019047619047619*G10_5_1;
    A[42] = 0.0;
    A[43] = 0.0;
    A[44] = -0.166666666666667*G6_1;
    A[45] = -0.00476190476190477*G8_0_0 - 0.00476190476190477*G8_0_1 - 0.00793650793650794*G8_1_0 - 0.00793650793650794*G8_2_1 - 0.019047619047619*G8_3_0 - 0.019047619047619*G8_3_1 + 0.0190476190476191*G8_4_0 + 0.0126984126984127*G8_4_1 + 0.0126984126984127*G8_5_0 + 0.0190476190476191*G8_5_1 - 0.00476190476190477*G9_0_0 - 0.00476190476190477*G9_0_1 + 0.00634920634920635*G9_1_0 + 0.00634920634920635*G9_1_1 + 0.00634920634920635*G9_2_0 + 0.00634920634920634*G9_2_1 + 0.0380952380952381*G9_3_0 + 0.0380952380952381*G9_3_1 - 0.00634920634920635*G9_4_0 - 0.00634920634920636*G9_4_1 - 0.00634920634920635*G9_5_0 - 0.00634920634920635*G9_5_1 - 0.00476190476190477*G11_6_0 - 0.00476190476190477*G11_6_1 + 0.00634920634920635*G11_7_0 + 0.00634920634920635*G11_7_1 + 0.00634920634920635*G11_8_0 + 0.00634920634920634*G11_8_1 + 0.0380952380952381*G11_9_0 + 0.0380952380952381*G11_9_1 - 0.00634920634920635*G11_10_0 - 0.00634920634920636*G11_10_1 - 0.00634920634920635*G11_11_0 - 0.00634920634920635*G11_11_1;
    A[46] = 0.666666666666666*G2_0_1_0 + 0.666666666666666*G4_0_1_0 + 0.00634920634920635*G8_0_0 + 0.00634920634920635*G8_0_1 + 0.019047619047619*G8_1_0 - 0.0126984126984127*G8_2_1 - 0.0126984126984127*G8_3_0 + 0.019047619047619*G8_3_1 + 0.0126984126984127*G8_4_0 + 0.00634920634920635*G8_4_1 - 0.0253968253968254*G8_5_0 - 0.019047619047619*G8_5_1 - 0.00793650793650794*G9_0_0 + 0.019047619047619*G9_1_0 - 0.0126984126984127*G9_2_0 + 0.0634920634920634*G9_3_0 + 0.00634920634920634*G9_4_0 + 0.0317460317460318*G9_5_0 - 0.00793650793650794*G11_6_0 + 0.019047619047619*G11_7_0 - 0.0126984126984127*G11_8_0 + 0.0634920634920634*G11_9_0 + 0.00634920634920634*G11_10_0 + 0.0317460317460318*G11_11_0;
    A[47] = 0.666666666666666*G2_0_0_1 + 0.666666666666666*G4_0_0_1 + 0.00634920634920635*G8_0_0 + 0.00634920634920634*G8_0_1 - 0.0126984126984127*G8_1_0 + 0.019047619047619*G8_2_1 + 0.019047619047619*G8_3_0 - 0.0126984126984127*G8_3_1 - 0.019047619047619*G8_4_0 - 0.0253968253968254*G8_4_1 + 0.00634920634920635*G8_5_0 + 0.0126984126984127*G8_5_1 - 0.00793650793650794*G9_0_1 - 0.0126984126984127*G9_1_1 + 0.019047619047619*G9_2_1 + 0.0634920634920635*G9_3_1 + 0.0317460317460318*G9_4_1 + 0.00634920634920637*G9_5_1 - 0.00793650793650794*G11_6_1 - 0.0126984126984127*G11_7_1 + 0.019047619047619*G11_8_1 + 0.0634920634920635*G11_9_1 + 0.0317460317460318*G11_10_1 + 0.00634920634920637*G11_11_1;
    A[48] = 1.33333333333333*G2_0_0_0 + 0.666666666666666*G2_0_0_1 + 0.666666666666666*G2_0_1_0 + 1.33333333333333*G2_0_1_1 + 1.33333333333333*G4_0_0_0 + 0.666666666666666*G4_0_0_1 + 0.666666666666666*G4_0_1_0 + 1.33333333333333*G4_0_1_1 + 0.0380952380952381*G8_0_0 + 0.0380952380952381*G8_0_1 + 0.0634920634920634*G8_1_0 + 0.0634920634920635*G8_2_1 + 0.152380952380952*G8_3_0 + 0.152380952380952*G8_3_1 - 0.152380952380952*G8_4_0 - 0.101587301587302*G8_4_1 - 0.101587301587302*G8_5_0 - 0.152380952380952*G8_5_1 - 0.019047619047619*G9_0_0 - 0.019047619047619*G9_0_1 - 0.0126984126984127*G9_1_0 + 0.019047619047619*G9_1_1 + 0.019047619047619*G9_2_0 - 0.0126984126984127*G9_2_1 + 0.152380952380952*G9_3_0 + 0.152380952380952*G9_3_1 + 0.0761904761904762*G9_4_0 + 0.0507936507936508*G9_4_1 + 0.0507936507936508*G9_5_0 + 0.0761904761904762*G9_5_1 - 0.019047619047619*G11_6_0 - 0.019047619047619*G11_6_1 - 0.0126984126984127*G11_7_0 + 0.019047619047619*G11_7_1 + 0.019047619047619*G11_8_0 - 0.0126984126984127*G11_8_1 + 0.152380952380952*G11_9_0 + 0.152380952380952*G11_9_1 + 0.0761904761904762*G11_10_0 + 0.0507936507936508*G11_10_1 + 0.0507936507936508*G11_11_0 + 0.0761904761904762*G11_11_1;
    A[49] = -1.33333333333333*G2_0_0_0 - 0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_0 - 1.33333333333333*G4_0_0_0 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_0 - 0.00634920634920635*G8_0_0 - 0.00634920634920636*G8_0_1 + 0.00634920634920634*G8_1_0 + 0.0317460317460318*G8_2_1 + 0.0761904761904762*G8_3_0 + 0.0507936507936508*G8_3_1 - 0.0761904761904762*G8_4_0 - 0.0253968253968254*G8_4_1 - 0.0507936507936508*G8_5_1 + 0.0190476190476191*G9_0_0 + 0.0126984126984127*G9_0_1 + 0.0126984126984127*G9_1_0 + 0.00634920634920635*G9_1_1 - 0.019047619047619*G9_2_0 - 0.0253968253968254*G9_2_1 - 0.152380952380952*G9_3_0 - 0.101587301587302*G9_3_1 - 0.0761904761904762*G9_4_0 - 0.0253968253968254*G9_4_1 - 0.0507936507936508*G9_5_0 + 0.0190476190476191*G11_6_0 + 0.0126984126984127*G11_6_1 + 0.0126984126984127*G11_7_0 + 0.00634920634920635*G11_7_1 - 0.019047619047619*G11_8_0 - 0.0253968253968254*G11_8_1 - 0.152380952380952*G11_9_0 - 0.101587301587302*G11_9_1 - 0.0761904761904762*G11_10_0 - 0.0253968253968254*G11_10_1 - 0.0507936507936508*G11_11_0;
    A[50] = -0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_0 - 1.33333333333333*G2_0_1_1 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_0 - 1.33333333333333*G4_0_1_1 - 0.00634920634920635*G8_0_0 - 0.00634920634920635*G8_0_1 + 0.0317460317460318*G8_1_0 + 0.00634920634920637*G8_2_1 + 0.0507936507936508*G8_3_0 + 0.0761904761904762*G8_3_1 - 0.0507936507936508*G8_4_0 - 0.0253968253968254*G8_5_0 - 0.0761904761904762*G8_5_1 + 0.0126984126984127*G9_0_0 + 0.0190476190476191*G9_0_1 - 0.0253968253968254*G9_1_0 - 0.019047619047619*G9_1_1 + 0.00634920634920635*G9_2_0 + 0.0126984126984127*G9_2_1 - 0.101587301587302*G9_3_0 - 0.152380952380952*G9_3_1 - 0.0507936507936508*G9_4_1 - 0.0253968253968254*G9_5_0 - 0.0761904761904762*G9_5_1 + 0.0126984126984127*G11_6_0 + 0.0190476190476191*G11_6_1 - 0.0253968253968254*G11_7_0 - 0.019047619047619*G11_7_1 + 0.00634920634920635*G11_8_0 + 0.0126984126984127*G11_8_1 - 0.101587301587302*G11_9_0 - 0.152380952380952*G11_9_1 - 0.0507936507936508*G11_10_1 - 0.0253968253968254*G11_11_0 - 0.0761904761904762*G11_11_1;
    A[51] = -0.00476190476190477*G10_0_0 - 0.00476190476190477*G10_0_1 - 0.00793650793650794*G10_1_0 - 0.00793650793650794*G10_2_1 - 0.019047619047619*G10_3_0 - 0.019047619047619*G10_3_1 + 0.0190476190476191*G10_4_0 + 0.0126984126984127*G10_4_1 + 0.0126984126984127*G10_5_0 + 0.0190476190476191*G10_5_1;
    A[52] = 0.00634920634920635*G10_0_0 + 0.00634920634920635*G10_0_1 + 0.019047619047619*G10_1_0 - 0.0126984126984127*G10_2_1 - 0.0126984126984127*G10_3_0 + 0.019047619047619*G10_3_1 + 0.0126984126984127*G10_4_0 + 0.00634920634920635*G10_4_1 - 0.0253968253968254*G10_5_0 - 0.019047619047619*G10_5_1;
    A[53] = 0.00634920634920635*G10_0_0 + 0.00634920634920634*G10_0_1 - 0.0126984126984127*G10_1_0 + 0.019047619047619*G10_2_1 + 0.019047619047619*G10_3_0 - 0.0126984126984127*G10_3_1 - 0.019047619047619*G10_4_0 - 0.0253968253968254*G10_4_1 + 0.00634920634920635*G10_5_0 + 0.0126984126984127*G10_5_1;
    A[54] = 0.0380952380952381*G10_0_0 + 0.0380952380952381*G10_0_1 + 0.0634920634920634*G10_1_0 + 0.0634920634920635*G10_2_1 + 0.152380952380952*G10_3_0 + 0.152380952380952*G10_3_1 - 0.152380952380952*G10_4_0 - 0.101587301587302*G10_4_1 - 0.101587301587302*G10_5_0 - 0.152380952380952*G10_5_1;
    A[55] = -0.00634920634920635*G10_0_0 - 0.00634920634920636*G10_0_1 + 0.00634920634920634*G10_1_0 + 0.0317460317460318*G10_2_1 + 0.0761904761904762*G10_3_0 + 0.0507936507936508*G10_3_1 - 0.0761904761904762*G10_4_0 - 0.0253968253968254*G10_4_1 - 0.0507936507936508*G10_5_1;
    A[56] = -0.00634920634920635*G10_0_0 - 0.00634920634920635*G10_0_1 + 0.0317460317460318*G10_1_0 + 0.00634920634920637*G10_2_1 + 0.0507936507936508*G10_3_0 + 0.0761904761904762*G10_3_1 - 0.0507936507936508*G10_4_0 - 0.0253968253968254*G10_5_0 - 0.0761904761904762*G10_5_1;
    A[57] = -0.166666666666667*G6_0 - 0.166666666666667*G6_1;
    A[58] = -0.166666666666667*G6_0 - 0.333333333333333*G6_1;
    A[59] = -0.333333333333333*G6_0 - 0.166666666666667*G6_1;
    A[60] = -0.666666666666667*G2_0_1_0 - 0.666666666666667*G2_0_1_1 - 0.666666666666667*G4_0_1_0 - 0.666666666666667*G4_0_1_1 - 0.0190476190476191*G8_0_0 - 0.0190476190476191*G8_0_1 - 0.00634920634920635*G8_1_0 - 0.0126984126984127*G8_2_1 - 0.0126984126984127*G8_3_0 - 0.00634920634920635*G8_3_1 + 0.0126984126984127*G8_4_0 + 0.0317460317460318*G8_4_1 + 0.0253968253968254*G8_5_0 + 0.00634920634920635*G8_5_1 - 0.0190476190476191*G9_0_0 - 0.0190476190476191*G9_0_1 + 0.00793650793650794*G9_1_0 + 0.00793650793650794*G9_1_1 + 0.0126984126984127*G9_2_0 + 0.0126984126984127*G9_2_1 - 0.00634920634920635*G9_3_0 - 0.00634920634920636*G9_3_1 - 0.0634920634920635*G9_4_0 - 0.0634920634920635*G9_4_1 - 0.0317460317460317*G9_5_0 - 0.0317460317460317*G9_5_1 - 0.0190476190476191*G11_6_0 - 0.0190476190476191*G11_6_1 + 0.00793650793650794*G11_7_0 + 0.00793650793650794*G11_7_1 + 0.0126984126984127*G11_8_0 + 0.0126984126984127*G11_8_1 - 0.00634920634920635*G11_9_0 - 0.00634920634920636*G11_9_1 - 0.0634920634920635*G11_10_0 - 0.0634920634920635*G11_10_1 - 0.0317460317460317*G11_11_0 - 0.0317460317460317*G11_11_1;
    A[61] = 0.00793650793650794*G8_0_0 + 0.00793650793650794*G8_0_1 + 0.00476190476190476*G8_1_0 - 0.00793650793650794*G8_2_1 - 0.019047619047619*G8_3_0 - 0.00634920634920635*G8_3_1 + 0.0190476190476191*G8_4_0 - 0.0126984126984127*G8_5_0 + 0.00634920634920635*G8_5_1 - 0.00634920634920635*G9_0_0 + 0.00476190476190476*G9_1_0 - 0.00634920634920635*G9_2_0 + 0.00634920634920634*G9_3_0 - 0.0380952380952381*G9_4_0 + 0.00634920634920634*G9_5_0 - 0.00634920634920635*G11_6_0 + 0.00476190476190476*G11_7_0 - 0.00634920634920635*G11_8_0 + 0.00634920634920634*G11_9_0 - 0.0380952380952381*G11_10_0 + 0.00634920634920634*G11_11_0;
    A[62] = -0.666666666666667*G2_0_0_1 - 0.666666666666667*G2_0_1_1 - 0.666666666666667*G4_0_0_1 - 0.666666666666667*G4_0_1_1 + 0.0126984126984127*G8_0_0 + 0.0126984126984127*G8_0_1 - 0.00634920634920635*G8_1_0 + 0.019047619047619*G8_2_1 + 0.019047619047619*G8_3_0 - 0.00634920634920636*G8_3_1 - 0.019047619047619*G8_4_0 - 0.0317460317460317*G8_4_1 - 0.00634920634920635*G8_5_0 + 0.00634920634920635*G8_5_1 - 0.0126984126984127*G9_0_1 - 0.00793650793650794*G9_1_1 + 0.019047619047619*G9_2_1 + 0.0317460317460318*G9_3_1 + 0.0634920634920635*G9_4_1 + 0.00634920634920636*G9_5_1 - 0.0126984126984127*G11_6_1 - 0.00793650793650794*G11_7_1 + 0.019047619047619*G11_8_1 + 0.0317460317460318*G11_9_1 + 0.0634920634920635*G11_10_1 + 0.00634920634920636*G11_11_1;
    A[63] = -1.33333333333333*G2_0_0_0 - 0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_0 - 1.33333333333333*G4_0_0_0 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_0 - 0.00634920634920635*G8_0_0 - 0.00634920634920636*G8_0_1 + 0.00634920634920634*G8_1_0 + 0.0317460317460318*G8_2_1 + 0.0761904761904762*G8_3_0 + 0.0507936507936508*G8_3_1 - 0.0761904761904763*G8_4_0 - 0.0253968253968254*G8_4_1 - 0.0507936507936508*G8_5_1 - 0.0126984126984127*G9_0_0 - 0.00634920634920635*G9_0_1 - 0.019047619047619*G9_1_0 - 0.00634920634920635*G9_1_1 + 0.019047619047619*G9_2_0 - 0.00634920634920636*G9_2_1 + 0.0761904761904762*G9_3_0 + 0.0507936507936508*G9_3_1 + 0.152380952380952*G9_4_0 + 0.0507936507936508*G9_4_1 + 0.0507936507936508*G9_5_0 + 0.0507936507936508*G9_5_1 - 0.0126984126984127*G11_6_0 - 0.00634920634920635*G11_6_1 - 0.019047619047619*G11_7_0 - 0.00634920634920635*G11_7_1 + 0.019047619047619*G11_8_0 - 0.00634920634920636*G11_8_1 + 0.0761904761904762*G11_9_0 + 0.0507936507936508*G11_9_1 + 0.152380952380952*G11_10_0 + 0.0507936507936508*G11_10_1 + 0.0507936507936508*G11_11_0 + 0.0507936507936508*G11_11_1;
    A[64] = 1.33333333333333*G2_0_0_0 + 0.666666666666666*G2_0_0_1 + 0.666666666666666*G2_0_1_0 + 1.33333333333333*G2_0_1_1 + 1.33333333333333*G4_0_0_0 + 0.666666666666666*G4_0_0_1 + 0.666666666666666*G4_0_1_0 + 1.33333333333333*G4_0_1_1 - 0.0634920634920635*G8_0_0 - 0.0634920634920635*G8_0_1 - 0.0380952380952381*G8_1_0 + 0.0634920634920635*G8_2_1 + 0.152380952380952*G8_3_0 + 0.0507936507936508*G8_3_1 - 0.152380952380953*G8_4_0 + 0.101587301587302*G8_5_0 - 0.0507936507936508*G8_5_1 + 0.0126984126984127*G9_0_0 + 0.0317460317460318*G9_0_1 + 0.0190476190476191*G9_1_0 - 0.019047619047619*G9_2_0 - 0.0317460317460317*G9_2_1 - 0.0761904761904763*G9_3_0 - 0.0253968253968254*G9_3_1 - 0.152380952380953*G9_4_0 - 0.0507936507936508*G9_5_0 + 0.0253968253968254*G9_5_1 + 0.0126984126984127*G11_6_0 + 0.0317460317460318*G11_6_1 + 0.0190476190476191*G11_7_0 - 0.019047619047619*G11_8_0 - 0.0317460317460317*G11_8_1 - 0.0761904761904763*G11_9_0 - 0.0253968253968254*G11_9_1 - 0.152380952380953*G11_10_0 - 0.0507936507936508*G11_11_0 + 0.0253968253968254*G11_11_1;
    A[65] = 0.666666666666667*G2_0_0_1 + 0.666666666666667*G2_0_1_0 + 0.666666666666667*G4_0_0_1 + 0.666666666666667*G4_0_1_0 - 0.0317460317460317*G8_0_0 - 0.0317460317460317*G8_0_1 + 0.00634920634920634*G8_1_0 + 0.00634920634920636*G8_2_1 + 0.0507936507936508*G8_3_0 + 0.0507936507936508*G8_3_1 - 0.0507936507936508*G8_4_0 + 0.0253968253968254*G8_4_1 + 0.0253968253968254*G8_5_0 - 0.0507936507936508*G8_5_1 + 0.0253968253968254*G9_0_0 + 0.00634920634920635*G9_0_1 - 0.0126984126984127*G9_1_0 + 0.00634920634920635*G9_1_1 - 0.00634920634920635*G9_2_0 + 0.00634920634920635*G9_2_1 - 0.0507936507936508*G9_3_1 + 0.101587301587302*G9_4_0 - 0.0507936507936508*G9_4_1 + 0.0253968253968254*G9_5_0 - 0.0507936507936508*G9_5_1 + 0.0253968253968254*G11_6_0 + 0.00634920634920635*G11_6_1 - 0.0126984126984127*G11_7_0 + 0.00634920634920635*G11_7_1 - 0.00634920634920635*G11_8_0 + 0.00634920634920635*G11_8_1 - 0.0507936507936508*G11_9_1 + 0.101587301587302*G11_10_0 - 0.0507936507936508*G11_10_1 + 0.0253968253968254*G11_11_0 - 0.0507936507936508*G11_11_1;
    A[66] = -0.0190476190476191*G10_0_0 - 0.0190476190476191*G10_0_1 - 0.00634920634920635*G10_1_0 - 0.0126984126984127*G10_2_1 - 0.0126984126984127*G10_3_0 - 0.00634920634920635*G10_3_1 + 0.0126984126984127*G10_4_0 + 0.0317460317460318*G10_4_1 + 0.0253968253968254*G10_5_0 + 0.00634920634920635*G10_5_1;
    A[67] = 0.00793650793650794*G10_0_0 + 0.00793650793650794*G10_0_1 + 0.00476190476190476*G10_1_0 - 0.00793650793650794*G10_2_1 - 0.019047619047619*G10_3_0 - 0.00634920634920635*G10_3_1 + 0.0190476190476191*G10_4_0 - 0.0126984126984127*G10_5_0 + 0.00634920634920635*G10_5_1;
    A[68] = 0.0126984126984127*G10_0_0 + 0.0126984126984127*G10_0_1 - 0.00634920634920635*G10_1_0 + 0.019047619047619*G10_2_1 + 0.019047619047619*G10_3_0 - 0.00634920634920636*G10_3_1 - 0.019047619047619*G10_4_0 - 0.0317460317460317*G10_4_1 - 0.00634920634920635*G10_5_0 + 0.00634920634920635*G10_5_1;
    A[69] = -0.00634920634920635*G10_0_0 - 0.00634920634920636*G10_0_1 + 0.00634920634920634*G10_1_0 + 0.0317460317460318*G10_2_1 + 0.0761904761904762*G10_3_0 + 0.0507936507936508*G10_3_1 - 0.0761904761904763*G10_4_0 - 0.0253968253968254*G10_4_1 - 0.0507936507936508*G10_5_1;
    A[70] = -0.0634920634920635*G10_0_0 - 0.0634920634920635*G10_0_1 - 0.0380952380952381*G10_1_0 + 0.0634920634920635*G10_2_1 + 0.152380952380952*G10_3_0 + 0.0507936507936508*G10_3_1 - 0.152380952380953*G10_4_0 + 0.101587301587302*G10_5_0 - 0.0507936507936508*G10_5_1;
    A[71] = -0.0317460317460317*G10_0_0 - 0.0317460317460317*G10_0_1 + 0.00634920634920634*G10_1_0 + 0.00634920634920636*G10_2_1 + 0.0507936507936508*G10_3_0 + 0.0507936507936508*G10_3_1 - 0.0507936507936508*G10_4_0 + 0.0253968253968254*G10_4_1 + 0.0253968253968254*G10_5_0 - 0.0507936507936508*G10_5_1;
    A[72] = 0.166666666666667*G6_0 - 0.166666666666667*G6_1;
    A[73] = 0.166666666666667*G6_0;
    A[74] = 0.333333333333333*G6_0 + 0.166666666666667*G6_1;
    A[75] = -0.666666666666667*G2_0_0_0 - 0.666666666666667*G2_0_0_1 - 0.666666666666667*G4_0_0_0 - 0.666666666666667*G4_0_0_1 - 0.019047619047619*G8_0_0 - 0.019047619047619*G8_0_1 - 0.0126984126984127*G8_1_0 - 0.00634920634920635*G8_2_1 - 0.00634920634920636*G8_3_0 - 0.0126984126984127*G8_3_1 + 0.00634920634920636*G8_4_0 + 0.0253968253968254*G8_4_1 + 0.0317460317460318*G8_5_0 + 0.0126984126984127*G8_5_1 - 0.019047619047619*G9_0_0 - 0.019047619047619*G9_0_1 + 0.0126984126984127*G9_1_0 + 0.0126984126984127*G9_1_1 + 0.00793650793650794*G9_2_0 + 0.00793650793650794*G9_2_1 - 0.00634920634920635*G9_3_0 - 0.00634920634920635*G9_3_1 - 0.0317460317460317*G9_4_0 - 0.0317460317460317*G9_4_1 - 0.0634920634920635*G9_5_0 - 0.0634920634920635*G9_5_1 - 0.019047619047619*G11_6_0 - 0.019047619047619*G11_6_1 + 0.0126984126984127*G11_7_0 + 0.0126984126984127*G11_7_1 + 0.00793650793650794*G11_8_0 + 0.00793650793650794*G11_8_1 - 0.00634920634920635*G11_9_0 - 0.00634920634920635*G11_9_1 - 0.0317460317460317*G11_10_0 - 0.0317460317460317*G11_10_1 - 0.0634920634920635*G11_11_0 - 0.0634920634920635*G11_11_1;
    A[76] = -0.666666666666667*G2_0_0_0 - 0.666666666666667*G2_0_1_0 - 0.666666666666667*G4_0_0_0 - 0.666666666666667*G4_0_1_0 + 0.0126984126984127*G8_0_0 + 0.0126984126984127*G8_0_1 + 0.0190476190476191*G8_1_0 - 0.00634920634920635*G8_2_1 - 0.00634920634920636*G8_3_0 + 0.0190476190476191*G8_3_1 + 0.00634920634920636*G8_4_0 - 0.00634920634920634*G8_4_1 - 0.0317460317460318*G8_5_0 - 0.0190476190476191*G8_5_1 - 0.0126984126984127*G9_0_0 + 0.0190476190476191*G9_1_0 - 0.00793650793650794*G9_2_0 + 0.0317460317460318*G9_3_0 + 0.00634920634920634*G9_4_0 + 0.0634920634920635*G9_5_0 - 0.0126984126984127*G11_6_0 + 0.0190476190476191*G11_7_0 - 0.00793650793650794*G11_8_0 + 0.0317460317460318*G11_9_0 + 0.00634920634920634*G11_10_0 + 0.0634920634920635*G11_11_0;
    A[77] = 0.00793650793650794*G8_0_0 + 0.00793650793650794*G8_0_1 - 0.00793650793650794*G8_1_0 + 0.00476190476190476*G8_2_1 - 0.00634920634920634*G8_3_0 - 0.019047619047619*G8_3_1 + 0.00634920634920635*G8_4_0 - 0.0126984126984127*G8_4_1 + 0.019047619047619*G8_5_1 - 0.00634920634920635*G9_0_1 - 0.00634920634920635*G9_1_1 + 0.00476190476190476*G9_2_1 + 0.00634920634920637*G9_3_1 + 0.00634920634920636*G9_4_1 - 0.0380952380952381*G9_5_1 - 0.00634920634920635*G11_6_1 - 0.00634920634920635*G11_7_1 + 0.00476190476190476*G11_8_1 + 0.00634920634920637*G11_9_1 + 0.00634920634920636*G11_10_1 - 0.0380952380952381*G11_11_1;
    A[78] = -0.666666666666666*G2_0_0_1 - 0.666666666666666*G2_0_1_0 - 1.33333333333333*G2_0_1_1 - 0.666666666666666*G4_0_0_1 - 0.666666666666666*G4_0_1_0 - 1.33333333333333*G4_0_1_1 - 0.00634920634920635*G8_0_0 - 0.00634920634920635*G8_0_1 + 0.0317460317460318*G8_1_0 + 0.00634920634920637*G8_2_1 + 0.0507936507936508*G8_3_0 + 0.0761904761904762*G8_3_1 - 0.0507936507936508*G8_4_0 - 0.0253968253968254*G8_5_0 - 0.0761904761904762*G8_5_1 - 0.00634920634920636*G9_0_0 - 0.0126984126984127*G9_0_1 - 0.00634920634920636*G9_1_0 + 0.0190476190476191*G9_1_1 - 0.00634920634920634*G9_2_0 - 0.019047619047619*G9_2_1 + 0.0507936507936508*G9_3_0 + 0.0761904761904762*G9_3_1 + 0.0507936507936508*G9_4_0 + 0.0507936507936508*G9_4_1 + 0.0507936507936508*G9_5_0 + 0.152380952380952*G9_5_1 - 0.00634920634920636*G11_6_0 - 0.0126984126984127*G11_6_1 - 0.00634920634920636*G11_7_0 + 0.0190476190476191*G11_7_1 - 0.00634920634920634*G11_8_0 - 0.019047619047619*G11_8_1 + 0.0507936507936508*G11_9_0 + 0.0761904761904762*G11_9_1 + 0.0507936507936508*G11_10_0 + 0.0507936507936508*G11_10_1 + 0.0507936507936508*G11_11_0 + 0.152380952380952*G11_11_1;
    A[79] = 0.666666666666667*G2_0_0_1 + 0.666666666666667*G2_0_1_0 + 0.666666666666667*G4_0_0_1 + 0.666666666666667*G4_0_1_0 - 0.0317460317460317*G8_0_0 - 0.0317460317460317*G8_0_1 + 0.00634920634920634*G8_1_0 + 0.00634920634920636*G8_2_1 + 0.0507936507936508*G8_3_0 + 0.0507936507936508*G8_3_1 - 0.0507936507936508*G8_4_0 + 0.0253968253968254*G8_4_1 + 0.0253968253968254*G8_5_0 - 0.0507936507936508*G8_5_1 + 0.00634920634920636*G9_0_0 + 0.0253968253968254*G9_0_1 + 0.00634920634920636*G9_1_0 - 0.00634920634920634*G9_1_1 + 0.00634920634920635*G9_2_0 - 0.0126984126984127*G9_2_1 - 0.0507936507936508*G9_3_0 - 0.0507936507936508*G9_4_0 + 0.0253968253968254*G9_4_1 - 0.0507936507936508*G9_5_0 + 0.101587301587302*G9_5_1 + 0.00634920634920636*G11_6_0 + 0.0253968253968254*G11_6_1 + 0.00634920634920636*G11_7_0 - 0.00634920634920634*G11_7_1 + 0.00634920634920635*G11_8_0 - 0.0126984126984127*G11_8_1 - 0.0507936507936508*G11_9_0 - 0.0507936507936508*G11_10_0 + 0.0253968253968254*G11_10_1 - 0.0507936507936508*G11_11_0 + 0.101587301587302*G11_11_1;
    A[80] = 1.33333333333333*G2_0_0_0 + 0.666666666666666*G2_0_0_1 + 0.666666666666666*G2_0_1_0 + 1.33333333333333*G2_0_1_1 + 1.33333333333333*G4_0_0_0 + 0.666666666666666*G4_0_0_1 + 0.666666666666666*G4_0_1_0 + 1.33333333333333*G4_0_1_1 - 0.0634920634920635*G8_0_0 - 0.0634920634920635*G8_0_1 + 0.0634920634920635*G8_1_0 - 0.0380952380952381*G8_2_1 + 0.0507936507936508*G8_3_0 + 0.152380952380952*G8_3_1 - 0.0507936507936508*G8_4_0 + 0.101587301587302*G8_4_1 - 0.152380952380952*G8_5_1 + 0.0317460317460318*G9_0_0 + 0.0126984126984127*G9_0_1 - 0.0317460317460318*G9_1_0 - 0.0190476190476191*G9_1_1 + 0.019047619047619*G9_2_1 - 0.0253968253968254*G9_3_0 - 0.0761904761904762*G9_3_1 + 0.0253968253968254*G9_4_0 - 0.0507936507936508*G9_4_1 - 0.152380952380952*G9_5_1 + 0.0317460317460318*G11_6_0 + 0.0126984126984127*G11_6_1 - 0.0317460317460318*G11_7_0 - 0.0190476190476191*G11_7_1 + 0.019047619047619*G11_8_1 - 0.0253968253968254*G11_9_0 - 0.0761904761904762*G11_9_1 + 0.0253968253968254*G11_10_0 - 0.0507936507936508*G11_10_1 - 0.152380952380952*G11_11_1;
    A[81] = -0.019047619047619*G10_0_0 - 0.019047619047619*G10_0_1 - 0.0126984126984127*G10_1_0 - 0.00634920634920635*G10_2_1 - 0.00634920634920636*G10_3_0 - 0.0126984126984127*G10_3_1 + 0.00634920634920636*G10_4_0 + 0.0253968253968254*G10_4_1 + 0.0317460317460318*G10_5_0 + 0.0126984126984127*G10_5_1;
    A[82] = 0.0126984126984127*G10_0_0 + 0.0126984126984127*G10_0_1 + 0.0190476190476191*G10_1_0 - 0.00634920634920635*G10_2_1 - 0.00634920634920636*G10_3_0 + 0.0190476190476191*G10_3_1 + 0.00634920634920636*G10_4_0 - 0.00634920634920634*G10_4_1 - 0.0317460317460318*G10_5_0 - 0.0190476190476191*G10_5_1;
    A[83] = 0.00793650793650794*G10_0_0 + 0.00793650793650794*G10_0_1 - 0.00793650793650794*G10_1_0 + 0.00476190476190476*G10_2_1 - 0.00634920634920634*G10_3_0 - 0.019047619047619*G10_3_1 + 0.00634920634920635*G10_4_0 - 0.0126984126984127*G10_4_1 + 0.019047619047619*G10_5_1;
    A[84] = -0.00634920634920635*G10_0_0 - 0.00634920634920635*G10_0_1 + 0.0317460317460318*G10_1_0 + 0.00634920634920637*G10_2_1 + 0.0507936507936508*G10_3_0 + 0.0761904761904762*G10_3_1 - 0.0507936507936508*G10_4_0 - 0.0253968253968254*G10_5_0 - 0.0761904761904762*G10_5_1;
    A[85] = -0.0317460317460317*G10_0_0 - 0.0317460317460317*G10_0_1 + 0.00634920634920634*G10_1_0 + 0.00634920634920636*G10_2_1 + 0.0507936507936508*G10_3_0 + 0.0507936507936508*G10_3_1 - 0.0507936507936508*G10_4_0 + 0.0253968253968254*G10_4_1 + 0.0253968253968254*G10_5_0 - 0.0507936507936508*G10_5_1;
    A[86] = -0.0634920634920635*G10_0_0 - 0.0634920634920635*G10_0_1 + 0.0634920634920635*G10_1_0 - 0.0380952380952381*G10_2_1 + 0.0507936507936508*G10_3_0 + 0.152380952380952*G10_3_1 - 0.0507936507936508*G10_4_0 + 0.101587301587302*G10_4_1 - 0.152380952380952*G10_5_1;
    A[87] = -0.166666666666667*G6_0 + 0.166666666666667*G6_1;
    A[88] = 0.166666666666667*G6_0 + 0.333333333333333*G6_1;
    A[89] = 0.166666666666667*G6_1;
    A[90] = -0.030952380952381*G12_6_0 - 0.0309523809523809*G12_6_1 - 0.00714285714285714*G12_7_0 - 0.00714285714285714*G12_8_1 + 0.00952380952380952*G12_9_0 + 0.00952380952380952*G12_9_1 - 0.00952380952380952*G12_10_0 + 0.0380952380952381*G12_10_1 + 0.0380952380952381*G12_11_0 - 0.00952380952380953*G12_11_1;
    A[91] = 0.00357142857142857*G12_6_0 + 0.00357142857142857*G12_6_1 - 0.00357142857142857*G12_7_0 + 0.00436507936507937*G12_8_1 + 0.00158730158730159*G12_9_0 - 0.00634920634920635*G12_9_1 - 0.00158730158730159*G12_10_0 - 0.00793650793650794*G12_10_1 + 0.00634920634920635*G12_11_1;
    A[92] = 0.00357142857142857*G12_6_0 + 0.00357142857142857*G12_6_1 + 0.00436507936507937*G12_7_0 - 0.00357142857142857*G12_8_1 - 0.00634920634920634*G12_9_0 + 0.00158730158730159*G12_9_1 + 0.00634920634920634*G12_10_0 - 0.00793650793650794*G12_11_0 - 0.00158730158730159*G12_11_1;
    A[93] = -0.00476190476190477*G12_6_0 - 0.00476190476190477*G12_6_1 - 0.00793650793650794*G12_7_0 - 0.00793650793650794*G12_8_1 - 0.019047619047619*G12_9_0 - 0.019047619047619*G12_9_1 + 0.0190476190476191*G12_10_0 + 0.0126984126984127*G12_10_1 + 0.0126984126984127*G12_11_0 + 0.0190476190476191*G12_11_1;
    A[94] = -0.0190476190476191*G12_6_0 - 0.0190476190476191*G12_6_1 - 0.00634920634920635*G12_7_0 - 0.0126984126984127*G12_8_1 - 0.0126984126984127*G12_9_0 - 0.00634920634920635*G12_9_1 + 0.0126984126984127*G12_10_0 + 0.0317460317460318*G12_10_1 + 0.0253968253968254*G12_11_0 + 0.00634920634920635*G12_11_1;
    A[95] = -0.019047619047619*G12_6_0 - 0.019047619047619*G12_6_1 - 0.0126984126984127*G12_7_0 - 0.00634920634920635*G12_8_1 - 0.00634920634920636*G12_9_0 - 0.0126984126984127*G12_9_1 + 0.00634920634920636*G12_10_0 + 0.0253968253968254*G12_10_1 + 0.0317460317460317*G12_11_0 + 0.0126984126984127*G12_11_1;
    A[96] = 0.5*G3_0_0_0 + 0.5*G3_0_0_1 + 0.5*G3_0_1_0 + 0.5*G3_0_1_1 + 0.5*G5_0_0_0 + 0.5*G5_0_0_1 + 0.5*G5_0_1_0 + 0.5*G5_0_1_1 - 0.030952380952381*G13_0_0 - 0.0309523809523809*G13_0_1 + 0.00357142857142857*G13_1_0 + 0.00357142857142857*G13_1_1 + 0.00357142857142857*G13_2_0 + 0.00357142857142857*G13_2_1 - 0.00476190476190477*G13_3_0 - 0.00476190476190477*G13_3_1 - 0.0190476190476191*G13_4_0 - 0.0190476190476191*G13_4_1 - 0.019047619047619*G13_5_0 - 0.019047619047619*G13_5_1 - 0.030952380952381*G14_6_0 - 0.0309523809523809*G14_6_1 - 0.00714285714285714*G14_7_0 - 0.00714285714285714*G14_8_1 + 0.00952380952380952*G14_9_0 + 0.00952380952380952*G14_9_1 - 0.00952380952380952*G14_10_0 + 0.0380952380952381*G14_10_1 + 0.0380952380952381*G14_11_0 - 0.00952380952380953*G14_11_1 - 0.030952380952381*G15_6_0 - 0.0309523809523809*G15_6_1 + 0.00357142857142857*G15_7_0 + 0.00357142857142857*G15_7_1 + 0.00357142857142857*G15_8_0 + 0.00357142857142857*G15_8_1 - 0.00476190476190477*G15_9_0 - 0.00476190476190477*G15_9_1 - 0.0190476190476191*G15_10_0 - 0.0190476190476191*G15_10_1 - 0.019047619047619*G15_11_0 - 0.019047619047619*G15_11_1;
    A[97] = 0.166666666666667*G3_0_0_0 + 0.166666666666667*G3_0_1_0 + 0.166666666666667*G5_0_0_0 + 0.166666666666667*G5_0_1_0 - 0.00714285714285714*G13_0_0 - 0.00357142857142857*G13_1_0 + 0.00436507936507937*G13_2_0 - 0.00793650793650794*G13_3_0 - 0.00634920634920635*G13_4_0 - 0.0126984126984127*G13_5_0 + 0.00357142857142857*G14_6_0 + 0.00357142857142857*G14_6_1 - 0.00357142857142857*G14_7_0 + 0.00436507936507937*G14_8_1 + 0.00158730158730159*G14_9_0 - 0.00634920634920635*G14_9_1 - 0.00158730158730159*G14_10_0 - 0.00793650793650794*G14_10_1 + 0.00634920634920635*G14_11_1 - 0.00714285714285714*G15_6_0 - 0.00357142857142857*G15_7_0 + 0.00436507936507937*G15_8_0 - 0.00793650793650794*G15_9_0 - 0.00634920634920635*G15_10_0 - 0.0126984126984127*G15_11_0;
    A[98] = 0.166666666666667*G3_0_0_1 + 0.166666666666667*G3_0_1_1 + 0.166666666666667*G5_0_0_1 + 0.166666666666667*G5_0_1_1 - 0.00714285714285714*G13_0_1 + 0.00436507936507937*G13_1_1 - 0.00357142857142857*G13_2_1 - 0.00793650793650794*G13_3_1 - 0.0126984126984127*G13_4_1 - 0.00634920634920635*G13_5_1 + 0.00357142857142857*G14_6_0 + 0.00357142857142857*G14_6_1 + 0.00436507936507937*G14_7_0 - 0.00357142857142857*G14_8_1 - 0.00634920634920634*G14_9_0 + 0.00158730158730159*G14_9_1 + 0.00634920634920634*G14_10_0 - 0.00793650793650794*G14_11_0 - 0.00158730158730159*G14_11_1 - 0.00714285714285714*G15_6_1 + 0.00436507936507937*G15_7_1 - 0.00357142857142857*G15_8_1 - 0.00793650793650794*G15_9_1 - 0.0126984126984127*G15_10_1 - 0.00634920634920635*G15_11_1;
    A[99] = 0.00952380952380952*G13_0_0 + 0.00952380952380952*G13_0_1 + 0.00158730158730159*G13_1_0 - 0.00634920634920635*G13_1_1 - 0.00634920634920634*G13_2_0 + 0.00158730158730159*G13_2_1 - 0.019047619047619*G13_3_0 - 0.019047619047619*G13_3_1 - 0.0126984126984127*G13_4_0 - 0.00634920634920635*G13_4_1 - 0.00634920634920636*G13_5_0 - 0.0126984126984127*G13_5_1 - 0.00476190476190477*G14_6_0 - 0.00476190476190477*G14_6_1 - 0.00793650793650794*G14_7_0 - 0.00793650793650794*G14_8_1 - 0.019047619047619*G14_9_0 - 0.019047619047619*G14_9_1 + 0.0190476190476191*G14_10_0 + 0.0126984126984127*G14_10_1 + 0.0126984126984127*G14_11_0 + 0.0190476190476191*G14_11_1 + 0.00952380952380952*G15_6_0 + 0.00952380952380952*G15_6_1 + 0.00158730158730159*G15_7_0 - 0.00634920634920635*G15_7_1 - 0.00634920634920634*G15_8_0 + 0.00158730158730159*G15_8_1 - 0.019047619047619*G15_9_0 - 0.019047619047619*G15_9_1 - 0.0126984126984127*G15_10_0 - 0.00634920634920635*G15_10_1 - 0.00634920634920636*G15_11_0 - 0.0126984126984127*G15_11_1;
    A[100] = -0.666666666666667*G3_0_0_1 - 0.666666666666667*G3_0_1_1 - 0.666666666666667*G5_0_0_1 - 0.666666666666667*G5_0_1_1 - 0.00952380952380952*G13_0_0 + 0.0380952380952381*G13_0_1 - 0.00158730158730159*G13_1_0 - 0.00793650793650794*G13_1_1 + 0.00634920634920634*G13_2_0 + 0.0190476190476191*G13_3_0 + 0.0126984126984127*G13_3_1 + 0.0126984126984127*G13_4_0 + 0.0317460317460318*G13_4_1 + 0.00634920634920636*G13_5_0 + 0.0253968253968254*G13_5_1 - 0.0190476190476191*G14_6_0 - 0.0190476190476191*G14_6_1 - 0.00634920634920635*G14_7_0 - 0.0126984126984127*G14_8_1 - 0.0126984126984127*G14_9_0 - 0.00634920634920635*G14_9_1 + 0.0126984126984127*G14_10_0 + 0.0317460317460318*G14_10_1 + 0.0253968253968254*G14_11_0 + 0.00634920634920635*G14_11_1 - 0.00952380952380952*G15_6_0 + 0.0380952380952381*G15_6_1 - 0.00158730158730159*G15_7_0 - 0.00793650793650794*G15_7_1 + 0.00634920634920634*G15_8_0 + 0.0190476190476191*G15_9_0 + 0.0126984126984127*G15_9_1 + 0.0126984126984127*G15_10_0 + 0.0317460317460318*G15_10_1 + 0.00634920634920636*G15_11_0 + 0.0253968253968254*G15_11_1;
    A[101] = -0.666666666666667*G3_0_0_0 - 0.666666666666667*G3_0_1_0 - 0.666666666666667*G5_0_0_0 - 0.666666666666667*G5_0_1_0 + 0.0380952380952381*G13_0_0 - 0.00952380952380953*G13_0_1 + 0.00634920634920635*G13_1_1 - 0.00793650793650794*G13_2_0 - 0.00158730158730159*G13_2_1 + 0.0126984126984127*G13_3_0 + 0.0190476190476191*G13_3_1 + 0.0253968253968254*G13_4_0 + 0.00634920634920635*G13_4_1 + 0.0317460317460317*G13_5_0 + 0.0126984126984127*G13_5_1 - 0.019047619047619*G14_6_0 - 0.019047619047619*G14_6_1 - 0.0126984126984127*G14_7_0 - 0.00634920634920635*G14_8_1 - 0.00634920634920636*G14_9_0 - 0.0126984126984127*G14_9_1 + 0.00634920634920636*G14_10_0 + 0.0253968253968254*G14_10_1 + 0.0317460317460317*G14_11_0 + 0.0126984126984127*G14_11_1 + 0.0380952380952381*G15_6_0 - 0.00952380952380953*G15_6_1 + 0.00634920634920635*G15_7_1 - 0.00793650793650794*G15_8_0 - 0.00158730158730159*G15_8_1 + 0.0126984126984127*G15_9_0 + 0.0190476190476191*G15_9_1 + 0.0253968253968254*G15_10_0 + 0.00634920634920635*G15_10_1 + 0.0317460317460317*G15_11_0 + 0.0126984126984127*G15_11_1;
    A[102] = 0.166666666666667*G7_0 + 0.166666666666667*G7_1;
    A[103] = 0.0;
    A[104] = 0.0;
    A[105] = 0.00357142857142857*G12_6_0 + 0.00357142857142857*G12_6_1 - 0.00357142857142857*G12_7_0 + 0.00436507936507937*G12_8_1 + 0.00158730158730159*G12_9_0 - 0.00634920634920635*G12_9_1 - 0.00158730158730159*G12_10_0 - 0.00793650793650794*G12_10_1 + 0.00634920634920635*G12_11_1;
    A[106] = 0.00714285714285713*G12_6_0 + 0.00714285714285714*G12_6_1 + 0.0309523809523809*G12_7_0 - 0.00714285714285713*G12_8_1 + 0.00952380952380951*G12_9_0 + 0.0476190476190476*G12_9_1 - 0.00952380952380952*G12_10_0 - 0.0380952380952381*G12_11_0 - 0.0476190476190476*G12_11_1;
    A[107] = -0.00436507936507936*G12_6_0 - 0.00436507936507936*G12_6_1 - 0.00357142857142857*G12_7_0 - 0.00357142857142857*G12_8_1 - 0.00634920634920634*G12_9_0 - 0.00634920634920634*G12_9_1 + 0.00634920634920634*G12_10_0 + 0.00793650793650793*G12_10_1 + 0.00793650793650793*G12_11_0 + 0.00634920634920634*G12_11_1;
    A[108] = 0.00634920634920635*G12_6_0 + 0.00634920634920635*G12_6_1 + 0.019047619047619*G12_7_0 - 0.0126984126984127*G12_8_1 - 0.0126984126984127*G12_9_0 + 0.019047619047619*G12_9_1 + 0.0126984126984127*G12_10_0 + 0.00634920634920635*G12_10_1 - 0.0253968253968254*G12_11_0 - 0.019047619047619*G12_11_1;
    A[109] = 0.00793650793650794*G12_6_0 + 0.00793650793650794*G12_6_1 + 0.00476190476190476*G12_7_0 - 0.00793650793650794*G12_8_1 - 0.019047619047619*G12_9_0 - 0.00634920634920635*G12_9_1 + 0.0190476190476191*G12_10_0 - 0.0126984126984127*G12_11_0 + 0.00634920634920635*G12_11_1;
    A[110] = 0.0126984126984127*G12_6_0 + 0.0126984126984127*G12_6_1 + 0.0190476190476191*G12_7_0 - 0.00634920634920635*G12_8_1 - 0.00634920634920636*G12_9_0 + 0.0190476190476191*G12_9_1 + 0.00634920634920636*G12_10_0 - 0.00634920634920634*G12_10_1 - 0.0317460317460318*G12_11_0 - 0.0190476190476191*G12_11_1;
    A[111] = 0.166666666666667*G3_0_0_0 + 0.166666666666667*G3_0_0_1 + 0.166666666666667*G5_0_0_0 + 0.166666666666667*G5_0_0_1 + 0.00357142857142857*G13_0_0 + 0.00357142857142857*G13_0_1 + 0.00714285714285713*G13_1_0 + 0.00714285714285714*G13_1_1 - 0.00436507936507936*G13_2_0 - 0.00436507936507936*G13_2_1 + 0.00634920634920635*G13_3_0 + 0.00634920634920635*G13_3_1 + 0.00793650793650794*G13_4_0 + 0.00793650793650794*G13_4_1 + 0.0126984126984127*G13_5_0 + 0.0126984126984127*G13_5_1 + 0.00357142857142857*G14_6_0 + 0.00357142857142857*G14_6_1 - 0.00357142857142857*G14_7_0 + 0.00436507936507937*G14_8_1 + 0.00158730158730159*G14_9_0 - 0.00634920634920635*G14_9_1 - 0.00158730158730159*G14_10_0 - 0.00793650793650794*G14_10_1 + 0.00634920634920635*G14_11_1 + 0.00357142857142857*G15_6_0 + 0.00357142857142857*G15_6_1 + 0.00714285714285713*G15_7_0 + 0.00714285714285714*G15_7_1 - 0.00436507936507936*G15_8_0 - 0.00436507936507936*G15_8_1 + 0.00634920634920635*G15_9_0 + 0.00634920634920635*G15_9_1 + 0.00793650793650794*G15_10_0 + 0.00793650793650794*G15_10_1 + 0.0126984126984127*G15_11_0 + 0.0126984126984127*G15_11_1;
    A[112] = 0.5*G3_0_0_0 + 0.5*G5_0_0_0 - 0.00357142857142857*G13_0_0 + 0.0309523809523809*G13_1_0 - 0.00357142857142857*G13_2_0 + 0.019047619047619*G13_3_0 + 0.00476190476190476*G13_4_0 + 0.0190476190476191*G13_5_0 + 0.00714285714285713*G14_6_0 + 0.00714285714285714*G14_6_1 + 0.0309523809523809*G14_7_0 - 0.00714285714285713*G14_8_1 + 0.00952380952380951*G14_9_0 + 0.0476190476190476*G14_9_1 - 0.00952380952380952*G14_10_0 - 0.0380952380952381*G14_11_0 - 0.0476190476190476*G14_11_1 - 0.00357142857142857*G15_6_0 + 0.0309523809523809*G15_7_0 - 0.00357142857142857*G15_8_0 + 0.019047619047619*G15_9_0 + 0.00476190476190476*G15_10_0 + 0.0190476190476191*G15_11_0;
    A[113] = -0.166666666666667*G3_0_0_1 - 0.166666666666667*G5_0_0_1 + 0.00436507936507937*G13_0_1 - 0.00714285714285713*G13_1_1 - 0.00357142857142857*G13_2_1 - 0.0126984126984127*G13_3_1 - 0.00793650793650794*G13_4_1 - 0.00634920634920635*G13_5_1 - 0.00436507936507936*G14_6_0 - 0.00436507936507936*G14_6_1 - 0.00357142857142857*G14_7_0 - 0.00357142857142857*G14_8_1 - 0.00634920634920634*G14_9_0 - 0.00634920634920634*G14_9_1 + 0.00634920634920634*G14_10_0 + 0.00793650793650793*G14_10_1 + 0.00793650793650793*G14_11_0 + 0.00634920634920634*G14_11_1 + 0.00436507936507937*G15_6_1 - 0.00714285714285713*G15_7_1 - 0.00357142857142857*G15_8_1 - 0.0126984126984127*G15_9_1 - 0.00793650793650794*G15_10_1 - 0.00634920634920635*G15_11_1;
    A[114] = 0.666666666666666*G3_0_0_1 + 0.666666666666666*G5_0_0_1 + 0.00158730158730159*G13_0_0 - 0.00634920634920635*G13_0_1 + 0.00952380952380951*G13_1_0 + 0.0476190476190476*G13_1_1 - 0.00634920634920634*G13_2_0 - 0.00634920634920634*G13_2_1 - 0.0126984126984127*G13_3_0 + 0.019047619047619*G13_3_1 - 0.019047619047619*G13_4_0 - 0.00634920634920635*G13_4_1 - 0.00634920634920636*G13_5_0 + 0.0190476190476191*G13_5_1 + 0.00634920634920635*G14_6_0 + 0.00634920634920635*G14_6_1 + 0.019047619047619*G14_7_0 - 0.0126984126984127*G14_8_1 - 0.0126984126984127*G14_9_0 + 0.019047619047619*G14_9_1 + 0.0126984126984127*G14_10_0 + 0.00634920634920635*G14_10_1 - 0.0253968253968254*G14_11_0 - 0.019047619047619*G14_11_1 + 0.00158730158730159*G15_6_0 - 0.00634920634920635*G15_6_1 + 0.00952380952380951*G15_7_0 + 0.0476190476190476*G15_7_1 - 0.00634920634920634*G15_8_0 - 0.00634920634920634*G15_8_1 - 0.0126984126984127*G15_9_0 + 0.019047619047619*G15_9_1 - 0.019047619047619*G15_10_0 - 0.00634920634920635*G15_10_1 - 0.00634920634920636*G15_11_0 + 0.0190476190476191*G15_11_1;
    A[115] = -0.00158730158730159*G13_0_0 - 0.00793650793650794*G13_0_1 - 0.00952380952380952*G13_1_0 + 0.00634920634920634*G13_2_0 + 0.00793650793650793*G13_2_1 + 0.0126984126984127*G13_3_0 + 0.00634920634920635*G13_3_1 + 0.0190476190476191*G13_4_0 + 0.00634920634920636*G13_5_0 - 0.00634920634920634*G13_5_1 + 0.00793650793650794*G14_6_0 + 0.00793650793650794*G14_6_1 + 0.00476190476190476*G14_7_0 - 0.00793650793650794*G14_8_1 - 0.019047619047619*G14_9_0 - 0.00634920634920635*G14_9_1 + 0.0190476190476191*G14_10_0 - 0.0126984126984127*G14_11_0 + 0.00634920634920635*G14_11_1 - 0.00158730158730159*G15_6_0 - 0.00793650793650794*G15_6_1 - 0.00952380952380952*G15_7_0 + 0.00634920634920634*G15_8_0 + 0.00793650793650793*G15_8_1 + 0.0126984126984127*G15_9_0 + 0.00634920634920635*G15_9_1 + 0.0190476190476191*G15_10_0 + 0.00634920634920636*G15_11_0 - 0.00634920634920634*G15_11_1;
    A[116] = -0.666666666666667*G3_0_0_0 - 0.666666666666667*G3_0_0_1 - 0.666666666666667*G5_0_0_0 - 0.666666666666667*G5_0_0_1 + 0.00634920634920635*G13_0_1 - 0.0380952380952381*G13_1_0 - 0.0476190476190476*G13_1_1 + 0.00793650793650793*G13_2_0 + 0.00634920634920634*G13_2_1 - 0.0253968253968254*G13_3_0 - 0.019047619047619*G13_3_1 - 0.0126984126984127*G13_4_0 + 0.00634920634920635*G13_4_1 - 0.0317460317460318*G13_5_0 - 0.0190476190476191*G13_5_1 + 0.0126984126984127*G14_6_0 + 0.0126984126984127*G14_6_1 + 0.0190476190476191*G14_7_0 - 0.00634920634920635*G14_8_1 - 0.00634920634920636*G14_9_0 + 0.0190476190476191*G14_9_1 + 0.00634920634920636*G14_10_0 - 0.00634920634920634*G14_10_1 - 0.0317460317460318*G14_11_0 - 0.0190476190476191*G14_11_1 + 0.00634920634920635*G15_6_1 - 0.0380952380952381*G15_7_0 - 0.0476190476190476*G15_7_1 + 0.00793650793650793*G15_8_0 + 0.00634920634920634*G15_8_1 - 0.0253968253968254*G15_9_0 - 0.019047619047619*G15_9_1 - 0.0126984126984127*G15_10_0 + 0.00634920634920635*G15_10_1 - 0.0317460317460318*G15_11_0 - 0.0190476190476191*G15_11_1;
    A[117] = 0.0;
    A[118] = -0.166666666666667*G7_0;
    A[119] = 0.0;
    A[120] = 0.00357142857142857*G12_6_0 + 0.00357142857142857*G12_6_1 + 0.00436507936507937*G12_7_0 - 0.00357142857142857*G12_8_1 - 0.00634920634920634*G12_9_0 + 0.00158730158730159*G12_9_1 + 0.00634920634920634*G12_10_0 - 0.00793650793650794*G12_11_0 - 0.00158730158730159*G12_11_1;
    A[121] = -0.00436507936507936*G12_6_0 - 0.00436507936507936*G12_6_1 - 0.00357142857142857*G12_7_0 - 0.00357142857142857*G12_8_1 - 0.00634920634920634*G12_9_0 - 0.00634920634920634*G12_9_1 + 0.00634920634920634*G12_10_0 + 0.00793650793650793*G12_10_1 + 0.00793650793650793*G12_11_0 + 0.00634920634920634*G12_11_1;
    A[122] = 0.00714285714285713*G12_6_0 + 0.00714285714285712*G12_6_1 - 0.00714285714285714*G12_7_0 + 0.0309523809523809*G12_8_1 + 0.0476190476190475*G12_9_0 + 0.0095238095238095*G12_9_1 - 0.0476190476190476*G12_10_0 - 0.038095238095238*G12_10_1 - 0.00952380952380951*G12_11_1;
    A[123] = 0.00634920634920634*G12_6_0 + 0.00634920634920634*G12_6_1 - 0.0126984126984127*G12_7_0 + 0.019047619047619*G12_8_1 + 0.019047619047619*G12_9_0 - 0.0126984126984127*G12_9_1 - 0.019047619047619*G12_10_0 - 0.0253968253968254*G12_10_1 + 0.00634920634920635*G12_11_0 + 0.0126984126984127*G12_11_1;
    A[124] = 0.0126984126984127*G12_6_0 + 0.0126984126984127*G12_6_1 - 0.00634920634920635*G12_7_0 + 0.019047619047619*G12_8_1 + 0.019047619047619*G12_9_0 - 0.00634920634920636*G12_9_1 - 0.019047619047619*G12_10_0 - 0.0317460317460317*G12_10_1 - 0.00634920634920635*G12_11_0 + 0.00634920634920635*G12_11_1;
    A[125] = 0.00793650793650794*G12_6_0 + 0.00793650793650794*G12_6_1 - 0.00793650793650794*G12_7_0 + 0.00476190476190476*G12_8_1 - 0.00634920634920634*G12_9_0 - 0.019047619047619*G12_9_1 + 0.00634920634920635*G12_10_0 - 0.0126984126984127*G12_10_1 + 0.019047619047619*G12_11_1;
    A[126] = 0.166666666666667*G3_0_1_0 + 0.166666666666667*G3_0_1_1 + 0.166666666666667*G5_0_1_0 + 0.166666666666667*G5_0_1_1 + 0.00357142857142857*G13_0_0 + 0.00357142857142857*G13_0_1 - 0.00436507936507936*G13_1_0 - 0.00436507936507936*G13_1_1 + 0.00714285714285713*G13_2_0 + 0.00714285714285712*G13_2_1 + 0.00634920634920634*G13_3_0 + 0.00634920634920634*G13_3_1 + 0.0126984126984127*G13_4_0 + 0.0126984126984127*G13_4_1 + 0.00793650793650794*G13_5_0 + 0.00793650793650794*G13_5_1 + 0.00357142857142857*G14_6_0 + 0.00357142857142857*G14_6_1 + 0.00436507936507937*G14_7_0 - 0.00357142857142857*G14_8_1 - 0.00634920634920634*G14_9_0 + 0.00158730158730159*G14_9_1 + 0.00634920634920634*G14_10_0 - 0.00793650793650794*G14_11_0 - 0.00158730158730159*G14_11_1 + 0.00357142857142857*G15_6_0 + 0.00357142857142857*G15_6_1 - 0.00436507936507936*G15_7_0 - 0.00436507936507936*G15_7_1 + 0.00714285714285713*G15_8_0 + 0.00714285714285712*G15_8_1 + 0.00634920634920634*G15_9_0 + 0.00634920634920634*G15_9_1 + 0.0126984126984127*G15_10_0 + 0.0126984126984127*G15_10_1 + 0.00793650793650794*G15_11_0 + 0.00793650793650794*G15_11_1;
    A[127] = -0.166666666666667*G3_0_1_0 - 0.166666666666667*G5_0_1_0 + 0.00436507936507937*G13_0_0 - 0.00357142857142857*G13_1_0 - 0.00714285714285714*G13_2_0 - 0.0126984126984127*G13_3_0 - 0.00634920634920635*G13_4_0 - 0.00793650793650794*G13_5_0 - 0.00436507936507936*G14_6_0 - 0.00436507936507936*G14_6_1 - 0.00357142857142857*G14_7_0 - 0.00357142857142857*G14_8_1 - 0.00634920634920634*G14_9_0 - 0.00634920634920634*G14_9_1 + 0.00634920634920634*G14_10_0 + 0.00793650793650793*G14_10_1 + 0.00793650793650793*G14_11_0 + 0.00634920634920634*G14_11_1 + 0.00436507936507937*G15_6_0 - 0.00357142857142857*G15_7_0 - 0.00714285714285714*G15_8_0 - 0.0126984126984127*G15_9_0 - 0.00634920634920635*G15_10_0 - 0.00793650793650794*G15_11_0;
    A[128] = 0.5*G3_0_1_1 + 0.5*G5_0_1_1 - 0.00357142857142857*G13_0_1 - 0.00357142857142857*G13_1_1 + 0.0309523809523809*G13_2_1 + 0.019047619047619*G13_3_1 + 0.019047619047619*G13_4_1 + 0.00476190476190476*G13_5_1 + 0.00714285714285713*G14_6_0 + 0.00714285714285712*G14_6_1 - 0.00714285714285714*G14_7_0 + 0.0309523809523809*G14_8_1 + 0.0476190476190475*G14_9_0 + 0.0095238095238095*G14_9_1 - 0.0476190476190476*G14_10_0 - 0.038095238095238*G14_10_1 - 0.00952380952380951*G14_11_1 - 0.00357142857142857*G15_6_1 - 0.00357142857142857*G15_7_1 + 0.0309523809523809*G15_8_1 + 0.019047619047619*G15_9_1 + 0.019047619047619*G15_10_1 + 0.00476190476190476*G15_11_1;
    A[129] = 0.666666666666666*G3_0_1_0 + 0.666666666666666*G5_0_1_0 - 0.00634920634920634*G13_0_0 + 0.00158730158730159*G13_0_1 - 0.00634920634920634*G13_1_0 - 0.00634920634920634*G13_1_1 + 0.0476190476190475*G13_2_0 + 0.0095238095238095*G13_2_1 + 0.019047619047619*G13_3_0 - 0.0126984126984127*G13_3_1 + 0.019047619047619*G13_4_0 - 0.00634920634920636*G13_4_1 - 0.00634920634920634*G13_5_0 - 0.019047619047619*G13_5_1 + 0.00634920634920634*G14_6_0 + 0.00634920634920634*G14_6_1 - 0.0126984126984127*G14_7_0 + 0.019047619047619*G14_8_1 + 0.019047619047619*G14_9_0 - 0.0126984126984127*G14_9_1 - 0.019047619047619*G14_10_0 - 0.0253968253968254*G14_10_1 + 0.00634920634920635*G14_11_0 + 0.0126984126984127*G14_11_1 - 0.00634920634920634*G15_6_0 + 0.00158730158730159*G15_6_1 - 0.00634920634920634*G15_7_0 - 0.00634920634920634*G15_7_1 + 0.0476190476190475*G15_8_0 + 0.0095238095238095*G15_8_1 + 0.019047619047619*G15_9_0 - 0.0126984126984127*G15_9_1 + 0.019047619047619*G15_10_0 - 0.00634920634920636*G15_10_1 - 0.00634920634920634*G15_11_0 - 0.019047619047619*G15_11_1;
    A[130] = -0.666666666666667*G3_0_1_0 - 0.666666666666667*G3_0_1_1 - 0.666666666666667*G5_0_1_0 - 0.666666666666667*G5_0_1_1 + 0.00634920634920634*G13_0_0 + 0.00634920634920634*G13_1_0 + 0.00793650793650793*G13_1_1 - 0.0476190476190476*G13_2_0 - 0.038095238095238*G13_2_1 - 0.019047619047619*G13_3_0 - 0.0253968253968254*G13_3_1 - 0.019047619047619*G13_4_0 - 0.0317460317460317*G13_4_1 + 0.00634920634920635*G13_5_0 - 0.0126984126984127*G13_5_1 + 0.0126984126984127*G14_6_0 + 0.0126984126984127*G14_6_1 - 0.00634920634920635*G14_7_0 + 0.019047619047619*G14_8_1 + 0.019047619047619*G14_9_0 - 0.00634920634920636*G14_9_1 - 0.019047619047619*G14_10_0 - 0.0317460317460317*G14_10_1 - 0.00634920634920635*G14_11_0 + 0.00634920634920635*G14_11_1 + 0.00634920634920634*G15_6_0 + 0.00634920634920634*G15_7_0 + 0.00793650793650793*G15_7_1 - 0.0476190476190476*G15_8_0 - 0.038095238095238*G15_8_1 - 0.019047619047619*G15_9_0 - 0.0253968253968254*G15_9_1 - 0.019047619047619*G15_10_0 - 0.0317460317460317*G15_10_1 + 0.00634920634920635*G15_11_0 - 0.0126984126984127*G15_11_1;
    A[131] = -0.00793650793650794*G13_0_0 - 0.00158730158730159*G13_0_1 + 0.00793650793650793*G13_1_0 + 0.00634920634920634*G13_1_1 - 0.00952380952380951*G13_2_1 + 0.00634920634920635*G13_3_0 + 0.0126984126984127*G13_3_1 - 0.00634920634920635*G13_4_0 + 0.00634920634920635*G13_4_1 + 0.019047619047619*G13_5_1 + 0.00793650793650794*G14_6_0 + 0.00793650793650794*G14_6_1 - 0.00793650793650794*G14_7_0 + 0.00476190476190476*G14_8_1 - 0.00634920634920634*G14_9_0 - 0.019047619047619*G14_9_1 + 0.00634920634920635*G14_10_0 - 0.0126984126984127*G14_10_1 + 0.019047619047619*G14_11_1 - 0.00793650793650794*G15_6_0 - 0.00158730158730159*G15_6_1 + 0.00793650793650793*G15_7_0 + 0.00634920634920634*G15_7_1 - 0.00952380952380951*G15_8_1 + 0.00634920634920635*G15_9_0 + 0.0126984126984127*G15_9_1 - 0.00634920634920635*G15_10_0 + 0.00634920634920635*G15_10_1 + 0.019047619047619*G15_11_1;
    A[132] = 0.0;
    A[133] = 0.0;
    A[134] = -0.166666666666667*G7_1;
    A[135] = -0.00476190476190477*G12_6_0 - 0.00476190476190477*G12_6_1 - 0.00793650793650794*G12_7_0 - 0.00793650793650794*G12_8_1 - 0.019047619047619*G12_9_0 - 0.019047619047619*G12_9_1 + 0.0190476190476191*G12_10_0 + 0.0126984126984127*G12_10_1 + 0.0126984126984127*G12_11_0 + 0.0190476190476191*G12_11_1;
    A[136] = 0.00634920634920635*G12_6_0 + 0.00634920634920635*G12_6_1 + 0.019047619047619*G12_7_0 - 0.0126984126984127*G12_8_1 - 0.0126984126984127*G12_9_0 + 0.019047619047619*G12_9_1 + 0.0126984126984127*G12_10_0 + 0.00634920634920635*G12_10_1 - 0.0253968253968254*G12_11_0 - 0.019047619047619*G12_11_1;
    A[137] = 0.00634920634920635*G12_6_0 + 0.00634920634920634*G12_6_1 - 0.0126984126984127*G12_7_0 + 0.019047619047619*G12_8_1 + 0.019047619047619*G12_9_0 - 0.0126984126984127*G12_9_1 - 0.019047619047619*G12_10_0 - 0.0253968253968254*G12_10_1 + 0.00634920634920635*G12_11_0 + 0.0126984126984127*G12_11_1;
    A[138] = 0.0380952380952381*G12_6_0 + 0.0380952380952381*G12_6_1 + 0.0634920634920634*G12_7_0 + 0.0634920634920635*G12_8_1 + 0.152380952380952*G12_9_0 + 0.152380952380952*G12_9_1 - 0.152380952380952*G12_10_0 - 0.101587301587302*G12_10_1 - 0.101587301587302*G12_11_0 - 0.152380952380952*G12_11_1;
    A[139] = -0.00634920634920635*G12_6_0 - 0.00634920634920636*G12_6_1 + 0.00634920634920634*G12_7_0 + 0.0317460317460318*G12_8_1 + 0.0761904761904762*G12_9_0 + 0.0507936507936508*G12_9_1 - 0.0761904761904762*G12_10_0 - 0.0253968253968254*G12_10_1 - 0.0507936507936508*G12_11_1;
    A[140] = -0.00634920634920635*G12_6_0 - 0.00634920634920635*G12_6_1 + 0.0317460317460318*G12_7_0 + 0.00634920634920637*G12_8_1 + 0.0507936507936508*G12_9_0 + 0.0761904761904762*G12_9_1 - 0.0507936507936508*G12_10_0 - 0.0253968253968254*G12_11_0 - 0.0761904761904762*G12_11_1;
    A[141] = -0.00476190476190477*G13_0_0 - 0.00476190476190477*G13_0_1 + 0.00634920634920635*G13_1_0 + 0.00634920634920635*G13_1_1 + 0.00634920634920635*G13_2_0 + 0.00634920634920634*G13_2_1 + 0.0380952380952381*G13_3_0 + 0.0380952380952381*G13_3_1 - 0.00634920634920635*G13_4_0 - 0.00634920634920636*G13_4_1 - 0.00634920634920635*G13_5_0 - 0.00634920634920635*G13_5_1 - 0.00476190476190477*G14_6_0 - 0.00476190476190477*G14_6_1 - 0.00793650793650794*G14_7_0 - 0.00793650793650794*G14_8_1 - 0.019047619047619*G14_9_0 - 0.019047619047619*G14_9_1 + 0.0190476190476191*G14_10_0 + 0.0126984126984127*G14_10_1 + 0.0126984126984127*G14_11_0 + 0.0190476190476191*G14_11_1 - 0.00476190476190477*G15_6_0 - 0.00476190476190477*G15_6_1 + 0.00634920634920635*G15_7_0 + 0.00634920634920635*G15_7_1 + 0.00634920634920635*G15_8_0 + 0.00634920634920634*G15_8_1 + 0.0380952380952381*G15_9_0 + 0.0380952380952381*G15_9_1 - 0.00634920634920635*G15_10_0 - 0.00634920634920636*G15_10_1 - 0.00634920634920635*G15_11_0 - 0.00634920634920635*G15_11_1;
    A[142] = 0.666666666666666*G3_0_1_0 + 0.666666666666666*G5_0_1_0 - 0.00793650793650794*G13_0_0 + 0.019047619047619*G13_1_0 - 0.0126984126984127*G13_2_0 + 0.0634920634920634*G13_3_0 + 0.00634920634920634*G13_4_0 + 0.0317460317460318*G13_5_0 + 0.00634920634920635*G14_6_0 + 0.00634920634920635*G14_6_1 + 0.019047619047619*G14_7_0 - 0.0126984126984127*G14_8_1 - 0.0126984126984127*G14_9_0 + 0.019047619047619*G14_9_1 + 0.0126984126984127*G14_10_0 + 0.00634920634920635*G14_10_1 - 0.0253968253968254*G14_11_0 - 0.019047619047619*G14_11_1 - 0.00793650793650794*G15_6_0 + 0.019047619047619*G15_7_0 - 0.0126984126984127*G15_8_0 + 0.0634920634920634*G15_9_0 + 0.00634920634920634*G15_10_0 + 0.0317460317460318*G15_11_0;
    A[143] = 0.666666666666666*G3_0_0_1 + 0.666666666666666*G5_0_0_1 - 0.00793650793650794*G13_0_1 - 0.0126984126984127*G13_1_1 + 0.019047619047619*G13_2_1 + 0.0634920634920635*G13_3_1 + 0.0317460317460318*G13_4_1 + 0.00634920634920637*G13_5_1 + 0.00634920634920635*G14_6_0 + 0.00634920634920634*G14_6_1 - 0.0126984126984127*G14_7_0 + 0.019047619047619*G14_8_1 + 0.019047619047619*G14_9_0 - 0.0126984126984127*G14_9_1 - 0.019047619047619*G14_10_0 - 0.0253968253968254*G14_10_1 + 0.00634920634920635*G14_11_0 + 0.0126984126984127*G14_11_1 - 0.00793650793650794*G15_6_1 - 0.0126984126984127*G15_7_1 + 0.019047619047619*G15_8_1 + 0.0634920634920635*G15_9_1 + 0.0317460317460318*G15_10_1 + 0.00634920634920637*G15_11_1;
    A[144] = 1.33333333333333*G3_0_0_0 + 0.666666666666666*G3_0_0_1 + 0.666666666666666*G3_0_1_0 + 1.33333333333333*G3_0_1_1 + 1.33333333333333*G5_0_0_0 + 0.666666666666666*G5_0_0_1 + 0.666666666666666*G5_0_1_0 + 1.33333333333333*G5_0_1_1 - 0.019047619047619*G13_0_0 - 0.019047619047619*G13_0_1 - 0.0126984126984127*G13_1_0 + 0.019047619047619*G13_1_1 + 0.019047619047619*G13_2_0 - 0.0126984126984127*G13_2_1 + 0.152380952380952*G13_3_0 + 0.152380952380952*G13_3_1 + 0.0761904761904762*G13_4_0 + 0.0507936507936508*G13_4_1 + 0.0507936507936508*G13_5_0 + 0.0761904761904762*G13_5_1 + 0.0380952380952381*G14_6_0 + 0.0380952380952381*G14_6_1 + 0.0634920634920634*G14_7_0 + 0.0634920634920635*G14_8_1 + 0.152380952380952*G14_9_0 + 0.152380952380952*G14_9_1 - 0.152380952380952*G14_10_0 - 0.101587301587302*G14_10_1 - 0.101587301587302*G14_11_0 - 0.152380952380952*G14_11_1 - 0.019047619047619*G15_6_0 - 0.019047619047619*G15_6_1 - 0.0126984126984127*G15_7_0 + 0.019047619047619*G15_7_1 + 0.019047619047619*G15_8_0 - 0.0126984126984127*G15_8_1 + 0.152380952380952*G15_9_0 + 0.152380952380952*G15_9_1 + 0.0761904761904762*G15_10_0 + 0.0507936507936508*G15_10_1 + 0.0507936507936508*G15_11_0 + 0.0761904761904762*G15_11_1;
    A[145] = -1.33333333333333*G3_0_0_0 - 0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_0 - 1.33333333333333*G5_0_0_0 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_0 + 0.0190476190476191*G13_0_0 + 0.0126984126984127*G13_0_1 + 0.0126984126984127*G13_1_0 + 0.00634920634920635*G13_1_1 - 0.019047619047619*G13_2_0 - 0.0253968253968254*G13_2_1 - 0.152380952380952*G13_3_0 - 0.101587301587302*G13_3_1 - 0.0761904761904762*G13_4_0 - 0.0253968253968254*G13_4_1 - 0.0507936507936508*G13_5_0 - 0.00634920634920635*G14_6_0 - 0.00634920634920636*G14_6_1 + 0.00634920634920634*G14_7_0 + 0.0317460317460318*G14_8_1 + 0.0761904761904762*G14_9_0 + 0.0507936507936508*G14_9_1 - 0.0761904761904762*G14_10_0 - 0.0253968253968254*G14_10_1 - 0.0507936507936508*G14_11_1 + 0.0190476190476191*G15_6_0 + 0.0126984126984127*G15_6_1 + 0.0126984126984127*G15_7_0 + 0.00634920634920635*G15_7_1 - 0.019047619047619*G15_8_0 - 0.0253968253968254*G15_8_1 - 0.152380952380952*G15_9_0 - 0.101587301587302*G15_9_1 - 0.0761904761904762*G15_10_0 - 0.0253968253968254*G15_10_1 - 0.0507936507936508*G15_11_0;
    A[146] = -0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_0 - 1.33333333333333*G3_0_1_1 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_0 - 1.33333333333333*G5_0_1_1 + 0.0126984126984127*G13_0_0 + 0.0190476190476191*G13_0_1 - 0.0253968253968254*G13_1_0 - 0.019047619047619*G13_1_1 + 0.00634920634920635*G13_2_0 + 0.0126984126984127*G13_2_1 - 0.101587301587302*G13_3_0 - 0.152380952380952*G13_3_1 - 0.0507936507936508*G13_4_1 - 0.0253968253968254*G13_5_0 - 0.0761904761904762*G13_5_1 - 0.00634920634920635*G14_6_0 - 0.00634920634920635*G14_6_1 + 0.0317460317460318*G14_7_0 + 0.00634920634920637*G14_8_1 + 0.0507936507936508*G14_9_0 + 0.0761904761904762*G14_9_1 - 0.0507936507936508*G14_10_0 - 0.0253968253968254*G14_11_0 - 0.0761904761904762*G14_11_1 + 0.0126984126984127*G15_6_0 + 0.0190476190476191*G15_6_1 - 0.0253968253968254*G15_7_0 - 0.019047619047619*G15_7_1 + 0.00634920634920635*G15_8_0 + 0.0126984126984127*G15_8_1 - 0.101587301587302*G15_9_0 - 0.152380952380952*G15_9_1 - 0.0507936507936508*G15_10_1 - 0.0253968253968254*G15_11_0 - 0.0761904761904762*G15_11_1;
    A[147] = -0.166666666666667*G7_0 - 0.166666666666667*G7_1;
    A[148] = -0.166666666666667*G7_0 - 0.333333333333333*G7_1;
    A[149] = -0.333333333333333*G7_0 - 0.166666666666667*G7_1;
    A[150] = -0.0190476190476191*G12_6_0 - 0.0190476190476191*G12_6_1 - 0.00634920634920635*G12_7_0 - 0.0126984126984127*G12_8_1 - 0.0126984126984127*G12_9_0 - 0.00634920634920635*G12_9_1 + 0.0126984126984127*G12_10_0 + 0.0317460317460318*G12_10_1 + 0.0253968253968254*G12_11_0 + 0.00634920634920635*G12_11_1;
    A[151] = 0.00793650793650794*G12_6_0 + 0.00793650793650794*G12_6_1 + 0.00476190476190476*G12_7_0 - 0.00793650793650794*G12_8_1 - 0.019047619047619*G12_9_0 - 0.00634920634920635*G12_9_1 + 0.0190476190476191*G12_10_0 - 0.0126984126984127*G12_11_0 + 0.00634920634920635*G12_11_1;
    A[152] = 0.0126984126984127*G12_6_0 + 0.0126984126984127*G12_6_1 - 0.00634920634920635*G12_7_0 + 0.019047619047619*G12_8_1 + 0.019047619047619*G12_9_0 - 0.00634920634920636*G12_9_1 - 0.019047619047619*G12_10_0 - 0.0317460317460317*G12_10_1 - 0.00634920634920635*G12_11_0 + 0.00634920634920635*G12_11_1;
    A[153] = -0.00634920634920635*G12_6_0 - 0.00634920634920636*G12_6_1 + 0.00634920634920634*G12_7_0 + 0.0317460317460318*G12_8_1 + 0.0761904761904762*G12_9_0 + 0.0507936507936508*G12_9_1 - 0.0761904761904763*G12_10_0 - 0.0253968253968254*G12_10_1 - 0.0507936507936508*G12_11_1;
    A[154] = -0.0634920634920635*G12_6_0 - 0.0634920634920635*G12_6_1 - 0.0380952380952381*G12_7_0 + 0.0634920634920635*G12_8_1 + 0.152380952380952*G12_9_0 + 0.0507936507936508*G12_9_1 - 0.152380952380953*G12_10_0 + 0.101587301587302*G12_11_0 - 0.0507936507936508*G12_11_1;
    A[155] = -0.0317460317460317*G12_6_0 - 0.0317460317460317*G12_6_1 + 0.00634920634920634*G12_7_0 + 0.00634920634920636*G12_8_1 + 0.0507936507936508*G12_9_0 + 0.0507936507936508*G12_9_1 - 0.0507936507936508*G12_10_0 + 0.0253968253968254*G12_10_1 + 0.0253968253968254*G12_11_0 - 0.0507936507936508*G12_11_1;
    A[156] = -0.666666666666667*G3_0_1_0 - 0.666666666666667*G3_0_1_1 - 0.666666666666667*G5_0_1_0 - 0.666666666666667*G5_0_1_1 - 0.0190476190476191*G13_0_0 - 0.0190476190476191*G13_0_1 + 0.00793650793650794*G13_1_0 + 0.00793650793650794*G13_1_1 + 0.0126984126984127*G13_2_0 + 0.0126984126984127*G13_2_1 - 0.00634920634920635*G13_3_0 - 0.00634920634920636*G13_3_1 - 0.0634920634920635*G13_4_0 - 0.0634920634920635*G13_4_1 - 0.0317460317460317*G13_5_0 - 0.0317460317460317*G13_5_1 - 0.0190476190476191*G14_6_0 - 0.0190476190476191*G14_6_1 - 0.00634920634920635*G14_7_0 - 0.0126984126984127*G14_8_1 - 0.0126984126984127*G14_9_0 - 0.00634920634920635*G14_9_1 + 0.0126984126984127*G14_10_0 + 0.0317460317460318*G14_10_1 + 0.0253968253968254*G14_11_0 + 0.00634920634920635*G14_11_1 - 0.0190476190476191*G15_6_0 - 0.0190476190476191*G15_6_1 + 0.00793650793650794*G15_7_0 + 0.00793650793650794*G15_7_1 + 0.0126984126984127*G15_8_0 + 0.0126984126984127*G15_8_1 - 0.00634920634920635*G15_9_0 - 0.00634920634920636*G15_9_1 - 0.0634920634920635*G15_10_0 - 0.0634920634920635*G15_10_1 - 0.0317460317460317*G15_11_0 - 0.0317460317460317*G15_11_1;
    A[157] = -0.00634920634920635*G13_0_0 + 0.00476190476190476*G13_1_0 - 0.00634920634920635*G13_2_0 + 0.00634920634920634*G13_3_0 - 0.0380952380952381*G13_4_0 + 0.00634920634920634*G13_5_0 + 0.00793650793650794*G14_6_0 + 0.00793650793650794*G14_6_1 + 0.00476190476190476*G14_7_0 - 0.00793650793650794*G14_8_1 - 0.019047619047619*G14_9_0 - 0.00634920634920635*G14_9_1 + 0.0190476190476191*G14_10_0 - 0.0126984126984127*G14_11_0 + 0.00634920634920635*G14_11_1 - 0.00634920634920635*G15_6_0 + 0.00476190476190476*G15_7_0 - 0.00634920634920635*G15_8_0 + 0.00634920634920634*G15_9_0 - 0.0380952380952381*G15_10_0 + 0.00634920634920634*G15_11_0;
    A[158] = -0.666666666666667*G3_0_0_1 - 0.666666666666667*G3_0_1_1 - 0.666666666666667*G5_0_0_1 - 0.666666666666667*G5_0_1_1 - 0.0126984126984127*G13_0_1 - 0.00793650793650794*G13_1_1 + 0.019047619047619*G13_2_1 + 0.0317460317460318*G13_3_1 + 0.0634920634920635*G13_4_1 + 0.00634920634920636*G13_5_1 + 0.0126984126984127*G14_6_0 + 0.0126984126984127*G14_6_1 - 0.00634920634920635*G14_7_0 + 0.019047619047619*G14_8_1 + 0.019047619047619*G14_9_0 - 0.00634920634920636*G14_9_1 - 0.019047619047619*G14_10_0 - 0.0317460317460317*G14_10_1 - 0.00634920634920635*G14_11_0 + 0.00634920634920635*G14_11_1 - 0.0126984126984127*G15_6_1 - 0.00793650793650794*G15_7_1 + 0.019047619047619*G15_8_1 + 0.0317460317460318*G15_9_1 + 0.0634920634920635*G15_10_1 + 0.00634920634920636*G15_11_1;
    A[159] = -1.33333333333333*G3_0_0_0 - 0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_0 - 1.33333333333333*G5_0_0_0 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_0 - 0.0126984126984127*G13_0_0 - 0.00634920634920635*G13_0_1 - 0.019047619047619*G13_1_0 - 0.00634920634920635*G13_1_1 + 0.019047619047619*G13_2_0 - 0.00634920634920636*G13_2_1 + 0.0761904761904762*G13_3_0 + 0.0507936507936508*G13_3_1 + 0.152380952380952*G13_4_0 + 0.0507936507936508*G13_4_1 + 0.0507936507936508*G13_5_0 + 0.0507936507936508*G13_5_1 - 0.00634920634920635*G14_6_0 - 0.00634920634920636*G14_6_1 + 0.00634920634920634*G14_7_0 + 0.0317460317460318*G14_8_1 + 0.0761904761904762*G14_9_0 + 0.0507936507936508*G14_9_1 - 0.0761904761904763*G14_10_0 - 0.0253968253968254*G14_10_1 - 0.0507936507936508*G14_11_1 - 0.0126984126984127*G15_6_0 - 0.00634920634920635*G15_6_1 - 0.019047619047619*G15_7_0 - 0.00634920634920635*G15_7_1 + 0.019047619047619*G15_8_0 - 0.00634920634920636*G15_8_1 + 0.0761904761904762*G15_9_0 + 0.0507936507936508*G15_9_1 + 0.152380952380952*G15_10_0 + 0.0507936507936508*G15_10_1 + 0.0507936507936508*G15_11_0 + 0.0507936507936508*G15_11_1;
    A[160] = 1.33333333333333*G3_0_0_0 + 0.666666666666666*G3_0_0_1 + 0.666666666666666*G3_0_1_0 + 1.33333333333333*G3_0_1_1 + 1.33333333333333*G5_0_0_0 + 0.666666666666666*G5_0_0_1 + 0.666666666666666*G5_0_1_0 + 1.33333333333333*G5_0_1_1 + 0.0126984126984127*G13_0_0 + 0.0317460317460318*G13_0_1 + 0.0190476190476191*G13_1_0 - 0.019047619047619*G13_2_0 - 0.0317460317460317*G13_2_1 - 0.0761904761904763*G13_3_0 - 0.0253968253968254*G13_3_1 - 0.152380952380953*G13_4_0 - 0.0507936507936508*G13_5_0 + 0.0253968253968254*G13_5_1 - 0.0634920634920635*G14_6_0 - 0.0634920634920635*G14_6_1 - 0.0380952380952381*G14_7_0 + 0.0634920634920635*G14_8_1 + 0.152380952380952*G14_9_0 + 0.0507936507936508*G14_9_1 - 0.152380952380953*G14_10_0 + 0.101587301587302*G14_11_0 - 0.0507936507936508*G14_11_1 + 0.0126984126984127*G15_6_0 + 0.0317460317460318*G15_6_1 + 0.0190476190476191*G15_7_0 - 0.019047619047619*G15_8_0 - 0.0317460317460317*G15_8_1 - 0.0761904761904763*G15_9_0 - 0.0253968253968254*G15_9_1 - 0.152380952380953*G15_10_0 - 0.0507936507936508*G15_11_0 + 0.0253968253968254*G15_11_1;
    A[161] = 0.666666666666667*G3_0_0_1 + 0.666666666666667*G3_0_1_0 + 0.666666666666667*G5_0_0_1 + 0.666666666666667*G5_0_1_0 + 0.0253968253968254*G13_0_0 + 0.00634920634920635*G13_0_1 - 0.0126984126984127*G13_1_0 + 0.00634920634920635*G13_1_1 - 0.00634920634920635*G13_2_0 + 0.00634920634920635*G13_2_1 - 0.0507936507936508*G13_3_1 + 0.101587301587302*G13_4_0 - 0.0507936507936508*G13_4_1 + 0.0253968253968254*G13_5_0 - 0.0507936507936508*G13_5_1 - 0.0317460317460317*G14_6_0 - 0.0317460317460317*G14_6_1 + 0.00634920634920634*G14_7_0 + 0.00634920634920636*G14_8_1 + 0.0507936507936508*G14_9_0 + 0.0507936507936508*G14_9_1 - 0.0507936507936508*G14_10_0 + 0.0253968253968254*G14_10_1 + 0.0253968253968254*G14_11_0 - 0.0507936507936508*G14_11_1 + 0.0253968253968254*G15_6_0 + 0.00634920634920635*G15_6_1 - 0.0126984126984127*G15_7_0 + 0.00634920634920635*G15_7_1 - 0.00634920634920635*G15_8_0 + 0.00634920634920635*G15_8_1 - 0.0507936507936508*G15_9_1 + 0.101587301587302*G15_10_0 - 0.0507936507936508*G15_10_1 + 0.0253968253968254*G15_11_0 - 0.0507936507936508*G15_11_1;
    A[162] = 0.166666666666667*G7_0 - 0.166666666666667*G7_1;
    A[163] = 0.166666666666667*G7_0;
    A[164] = 0.333333333333333*G7_0 + 0.166666666666667*G7_1;
    A[165] = -0.019047619047619*G12_6_0 - 0.019047619047619*G12_6_1 - 0.0126984126984127*G12_7_0 - 0.00634920634920635*G12_8_1 - 0.00634920634920636*G12_9_0 - 0.0126984126984127*G12_9_1 + 0.00634920634920636*G12_10_0 + 0.0253968253968254*G12_10_1 + 0.0317460317460318*G12_11_0 + 0.0126984126984127*G12_11_1;
    A[166] = 0.0126984126984127*G12_6_0 + 0.0126984126984127*G12_6_1 + 0.0190476190476191*G12_7_0 - 0.00634920634920635*G12_8_1 - 0.00634920634920636*G12_9_0 + 0.0190476190476191*G12_9_1 + 0.00634920634920636*G12_10_0 - 0.00634920634920634*G12_10_1 - 0.0317460317460318*G12_11_0 - 0.0190476190476191*G12_11_1;
    A[167] = 0.00793650793650794*G12_6_0 + 0.00793650793650794*G12_6_1 - 0.00793650793650794*G12_7_0 + 0.00476190476190476*G12_8_1 - 0.00634920634920634*G12_9_0 - 0.019047619047619*G12_9_1 + 0.00634920634920635*G12_10_0 - 0.0126984126984127*G12_10_1 + 0.019047619047619*G12_11_1;
    A[168] = -0.00634920634920635*G12_6_0 - 0.00634920634920635*G12_6_1 + 0.0317460317460318*G12_7_0 + 0.00634920634920637*G12_8_1 + 0.0507936507936508*G12_9_0 + 0.0761904761904762*G12_9_1 - 0.0507936507936508*G12_10_0 - 0.0253968253968254*G12_11_0 - 0.0761904761904762*G12_11_1;
    A[169] = -0.0317460317460317*G12_6_0 - 0.0317460317460317*G12_6_1 + 0.00634920634920634*G12_7_0 + 0.00634920634920636*G12_8_1 + 0.0507936507936508*G12_9_0 + 0.0507936507936508*G12_9_1 - 0.0507936507936508*G12_10_0 + 0.0253968253968254*G12_10_1 + 0.0253968253968254*G12_11_0 - 0.0507936507936508*G12_11_1;
    A[170] = -0.0634920634920635*G12_6_0 - 0.0634920634920635*G12_6_1 + 0.0634920634920635*G12_7_0 - 0.0380952380952381*G12_8_1 + 0.0507936507936508*G12_9_0 + 0.152380952380952*G12_9_1 - 0.0507936507936508*G12_10_0 + 0.101587301587302*G12_10_1 - 0.152380952380952*G12_11_1;
    A[171] = -0.666666666666667*G3_0_0_0 - 0.666666666666667*G3_0_0_1 - 0.666666666666667*G5_0_0_0 - 0.666666666666667*G5_0_0_1 - 0.019047619047619*G13_0_0 - 0.019047619047619*G13_0_1 + 0.0126984126984127*G13_1_0 + 0.0126984126984127*G13_1_1 + 0.00793650793650794*G13_2_0 + 0.00793650793650794*G13_2_1 - 0.00634920634920635*G13_3_0 - 0.00634920634920635*G13_3_1 - 0.0317460317460317*G13_4_0 - 0.0317460317460317*G13_4_1 - 0.0634920634920635*G13_5_0 - 0.0634920634920635*G13_5_1 - 0.019047619047619*G14_6_0 - 0.019047619047619*G14_6_1 - 0.0126984126984127*G14_7_0 - 0.00634920634920635*G14_8_1 - 0.00634920634920636*G14_9_0 - 0.0126984126984127*G14_9_1 + 0.00634920634920636*G14_10_0 + 0.0253968253968254*G14_10_1 + 0.0317460317460318*G14_11_0 + 0.0126984126984127*G14_11_1 - 0.019047619047619*G15_6_0 - 0.019047619047619*G15_6_1 + 0.0126984126984127*G15_7_0 + 0.0126984126984127*G15_7_1 + 0.00793650793650794*G15_8_0 + 0.00793650793650794*G15_8_1 - 0.00634920634920635*G15_9_0 - 0.00634920634920635*G15_9_1 - 0.0317460317460317*G15_10_0 - 0.0317460317460317*G15_10_1 - 0.0634920634920635*G15_11_0 - 0.0634920634920635*G15_11_1;
    A[172] = -0.666666666666667*G3_0_0_0 - 0.666666666666667*G3_0_1_0 - 0.666666666666667*G5_0_0_0 - 0.666666666666667*G5_0_1_0 - 0.0126984126984127*G13_0_0 + 0.0190476190476191*G13_1_0 - 0.00793650793650794*G13_2_0 + 0.0317460317460318*G13_3_0 + 0.00634920634920634*G13_4_0 + 0.0634920634920635*G13_5_0 + 0.0126984126984127*G14_6_0 + 0.0126984126984127*G14_6_1 + 0.0190476190476191*G14_7_0 - 0.00634920634920635*G14_8_1 - 0.00634920634920636*G14_9_0 + 0.0190476190476191*G14_9_1 + 0.00634920634920636*G14_10_0 - 0.00634920634920634*G14_10_1 - 0.0317460317460318*G14_11_0 - 0.0190476190476191*G14_11_1 - 0.0126984126984127*G15_6_0 + 0.0190476190476191*G15_7_0 - 0.00793650793650794*G15_8_0 + 0.0317460317460318*G15_9_0 + 0.00634920634920634*G15_10_0 + 0.0634920634920635*G15_11_0;
    A[173] = -0.00634920634920635*G13_0_1 - 0.00634920634920635*G13_1_1 + 0.00476190476190476*G13_2_1 + 0.00634920634920637*G13_3_1 + 0.00634920634920636*G13_4_1 - 0.0380952380952381*G13_5_1 + 0.00793650793650794*G14_6_0 + 0.00793650793650794*G14_6_1 - 0.00793650793650794*G14_7_0 + 0.00476190476190476*G14_8_1 - 0.00634920634920634*G14_9_0 - 0.019047619047619*G14_9_1 + 0.00634920634920635*G14_10_0 - 0.0126984126984127*G14_10_1 + 0.019047619047619*G14_11_1 - 0.00634920634920635*G15_6_1 - 0.00634920634920635*G15_7_1 + 0.00476190476190476*G15_8_1 + 0.00634920634920637*G15_9_1 + 0.00634920634920636*G15_10_1 - 0.0380952380952381*G15_11_1;
    A[174] = -0.666666666666666*G3_0_0_1 - 0.666666666666666*G3_0_1_0 - 1.33333333333333*G3_0_1_1 - 0.666666666666666*G5_0_0_1 - 0.666666666666666*G5_0_1_0 - 1.33333333333333*G5_0_1_1 - 0.00634920634920636*G13_0_0 - 0.0126984126984127*G13_0_1 - 0.00634920634920636*G13_1_0 + 0.0190476190476191*G13_1_1 - 0.00634920634920634*G13_2_0 - 0.019047619047619*G13_2_1 + 0.0507936507936508*G13_3_0 + 0.0761904761904762*G13_3_1 + 0.0507936507936508*G13_4_0 + 0.0507936507936508*G13_4_1 + 0.0507936507936508*G13_5_0 + 0.152380952380952*G13_5_1 - 0.00634920634920635*G14_6_0 - 0.00634920634920635*G14_6_1 + 0.0317460317460318*G14_7_0 + 0.00634920634920637*G14_8_1 + 0.0507936507936508*G14_9_0 + 0.0761904761904762*G14_9_1 - 0.0507936507936508*G14_10_0 - 0.0253968253968254*G14_11_0 - 0.0761904761904762*G14_11_1 - 0.00634920634920636*G15_6_0 - 0.0126984126984127*G15_6_1 - 0.00634920634920636*G15_7_0 + 0.0190476190476191*G15_7_1 - 0.00634920634920634*G15_8_0 - 0.019047619047619*G15_8_1 + 0.0507936507936508*G15_9_0 + 0.0761904761904762*G15_9_1 + 0.0507936507936508*G15_10_0 + 0.0507936507936508*G15_10_1 + 0.0507936507936508*G15_11_0 + 0.152380952380952*G15_11_1;
    A[175] = 0.666666666666667*G3_0_0_1 + 0.666666666666667*G3_0_1_0 + 0.666666666666667*G5_0_0_1 + 0.666666666666667*G5_0_1_0 + 0.00634920634920636*G13_0_0 + 0.0253968253968254*G13_0_1 + 0.00634920634920636*G13_1_0 - 0.00634920634920634*G13_1_1 + 0.00634920634920635*G13_2_0 - 0.0126984126984127*G13_2_1 - 0.0507936507936508*G13_3_0 - 0.0507936507936508*G13_4_0 + 0.0253968253968254*G13_4_1 - 0.0507936507936508*G13_5_0 + 0.101587301587302*G13_5_1 - 0.0317460317460317*G14_6_0 - 0.0317460317460317*G14_6_1 + 0.00634920634920634*G14_7_0 + 0.00634920634920636*G14_8_1 + 0.0507936507936508*G14_9_0 + 0.0507936507936508*G14_9_1 - 0.0507936507936508*G14_10_0 + 0.0253968253968254*G14_10_1 + 0.0253968253968254*G14_11_0 - 0.0507936507936508*G14_11_1 + 0.00634920634920636*G15_6_0 + 0.0253968253968254*G15_6_1 + 0.00634920634920636*G15_7_0 - 0.00634920634920634*G15_7_1 + 0.00634920634920635*G15_8_0 - 0.0126984126984127*G15_8_1 - 0.0507936507936508*G15_9_0 - 0.0507936507936508*G15_10_0 + 0.0253968253968254*G15_10_1 - 0.0507936507936508*G15_11_0 + 0.101587301587302*G15_11_1;
    A[176] = 1.33333333333333*G3_0_0_0 + 0.666666666666666*G3_0_0_1 + 0.666666666666666*G3_0_1_0 + 1.33333333333333*G3_0_1_1 + 1.33333333333333*G5_0_0_0 + 0.666666666666666*G5_0_0_1 + 0.666666666666666*G5_0_1_0 + 1.33333333333333*G5_0_1_1 + 0.0317460317460318*G13_0_0 + 0.0126984126984127*G13_0_1 - 0.0317460317460318*G13_1_0 - 0.0190476190476191*G13_1_1 + 0.019047619047619*G13_2_1 - 0.0253968253968254*G13_3_0 - 0.0761904761904762*G13_3_1 + 0.0253968253968254*G13_4_0 - 0.0507936507936508*G13_4_1 - 0.152380952380952*G13_5_1 - 0.0634920634920635*G14_6_0 - 0.0634920634920635*G14_6_1 + 0.0634920634920635*G14_7_0 - 0.0380952380952381*G14_8_1 + 0.0507936507936508*G14_9_0 + 0.152380952380952*G14_9_1 - 0.0507936507936508*G14_10_0 + 0.101587301587302*G14_10_1 - 0.152380952380952*G14_11_1 + 0.0317460317460318*G15_6_0 + 0.0126984126984127*G15_6_1 - 0.0317460317460318*G15_7_0 - 0.0190476190476191*G15_7_1 + 0.019047619047619*G15_8_1 - 0.0253968253968254*G15_9_0 - 0.0761904761904762*G15_9_1 + 0.0253968253968254*G15_10_0 - 0.0507936507936508*G15_10_1 - 0.152380952380952*G15_11_1;
    A[177] = -0.166666666666667*G7_0 + 0.166666666666667*G7_1;
    A[178] = 0.166666666666667*G7_0 + 0.333333333333333*G7_1;
    A[179] = 0.166666666666667*G7_1;
    A[180] = -0.166666666666667*G0_0 - 0.166666666666667*G0_1;
    A[181] = 0.0;
    A[182] = 0.0;
    A[183] = 0.166666666666667*G0_0 + 0.166666666666667*G0_1;
    A[184] = -0.166666666666667*G0_0 + 0.166666666666667*G0_1;
    A[185] = 0.166666666666667*G0_0 - 0.166666666666667*G0_1;
    A[186] = -0.166666666666667*G1_0 - 0.166666666666667*G1_1;
    A[187] = 0.0;
    A[188] = 0.0;
    A[189] = 0.166666666666667*G1_0 + 0.166666666666667*G1_1;
    A[190] = -0.166666666666667*G1_0 + 0.166666666666667*G1_1;
    A[191] = 0.166666666666667*G1_0 - 0.166666666666667*G1_1;
    A[192] = 0.0;
    A[193] = 0.0;
    A[194] = 0.0;
    A[195] = 0.0;
    A[196] = 0.166666666666667*G0_0;
    A[197] = 0.0;
    A[198] = 0.166666666666667*G0_0 + 0.333333333333333*G0_1;
    A[199] = -0.166666666666667*G0_0;
    A[200] = -0.166666666666667*G0_0 - 0.333333333333333*G0_1;
    A[201] = 0.0;
    A[202] = 0.166666666666667*G1_0;
    A[203] = 0.0;
    A[204] = 0.166666666666667*G1_0 + 0.333333333333333*G1_1;
    A[205] = -0.166666666666667*G1_0;
    A[206] = -0.166666666666667*G1_0 - 0.333333333333333*G1_1;
    A[207] = 0.0;
    A[208] = 0.0;
    A[209] = 0.0;
    A[210] = 0.0;
    A[211] = 0.0;
    A[212] = 0.166666666666667*G0_1;
    A[213] = 0.333333333333333*G0_0 + 0.166666666666667*G0_1;
    A[214] = -0.333333333333333*G0_0 - 0.166666666666667*G0_1;
    A[215] = -0.166666666666667*G0_1;
    A[216] = 0.0;
    A[217] = 0.0;
    A[218] = 0.166666666666667*G1_1;
    A[219] = 0.333333333333333*G1_0 + 0.166666666666667*G1_1;
    A[220] = -0.333333333333333*G1_0 - 0.166666666666667*G1_1;
    A[221] = -0.166666666666667*G1_1;
    A[222] = 0.0;
    A[223] = 0.0;
    A[224] = 0.0;
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the tabulation of the cell
/// tensor corresponding to the local contribution to a form from
/// the integral over a cell.

class adaptivenavierstokes_cell_integral_9_0: public ufc::cell_integral
{
public:

  /// Constructor
  adaptivenavierstokes_cell_integral_9_0() : ufc::cell_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_cell_integral_9_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local cell
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    const double J_00 = x[1][0] - x[0][0];
    const double J_01 = x[2][0] - x[0][0];
    const double J_10 = x[1][1] - x[0][1];
    const double J_11 = x[2][1] - x[0][1];
    
    // Compute determinant of Jacobian
    double detJ = J_00*J_11 - J_01*J_10;
    
    // Compute inverse of Jacobian
    const double K_00 =  J_11 / detJ;
    const double K_01 = -J_01 / detJ;
    const double K_10 = -J_10 / detJ;
    const double K_11 =  J_00 / detJ;
    
    // Set scale factor
    const double det = std::abs(detJ);
    
    // Cell Volume.
    
    // Compute circumradius, assuming triangle is embedded in 2D.
    
    
    // Facet Area.
    
    // Array of quadrature weights.
    static const double W7[7] = {0.1125, 0.0629695902724136, 0.0629695902724136, 0.0629695902724136, 0.0661970763942531, 0.0661970763942531, 0.0661970763942531};
    // Quadrature points on the UFC reference element: (0.333333333333333, 0.333333333333333), (0.797426985353087, 0.101286507323456), (0.101286507323456, 0.797426985353087), (0.101286507323456, 0.101286507323456), (0.0597158717897698, 0.470142064105115), (0.470142064105115, 0.0597158717897698), (0.470142064105115, 0.470142064105115)
    
    // Value of basis functions at quadrature points.
    static const double FE0_C0[7][6] = \
    {{-0.111111111111111, -0.111111111111111, -0.111111111111111, 0.444444444444444, 0.444444444444445, 0.444444444444445},
    {-0.0807685941918873, 0.474352608585538, -0.0807685941918872, 0.323074376767549, 0.0410358262631383, 0.323074376767549},
    {-0.0807685941918872, -0.0807685941918872, 0.474352608585538, 0.323074376767549, 0.323074376767549, 0.0410358262631384},
    {0.474352608585539, -0.0807685941918872, -0.0807685941918872, 0.0410358262631384, 0.323074376767549, 0.323074376767549},
    {-0.0280749432230787, -0.0525839011025453, -0.0280749432230789, 0.112299772892315, 0.884134241764073, 0.112299772892315},
    {-0.0280749432230787, -0.0280749432230788, -0.0525839011025453, 0.112299772892315, 0.112299772892315, 0.884134241764073},
    {-0.0525839011025454, -0.0280749432230788, -0.0280749432230788, 0.884134241764072, 0.112299772892315, 0.112299772892315}};
    
    // Array of non-zero columns
    static const unsigned int nzc3[6] = {6, 7, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc0[6] = {0, 1, 2, 3, 4, 5};
    
    static const double FE0_C0_D01[7][5] = \
    {{-0.333333333333333, 0.333333333333333, 1.33333333333333, 0.0, -1.33333333333333},
    {0.594853970706175, -0.594853970706174, 3.18970794141235, 0.0, -3.18970794141235},
    {0.594853970706174, 2.18970794141235, 0.405146029293824, -2.78456191211852, -0.405146029293825},
    {-2.18970794141235, -0.594853970706175, 0.405146029293825, 2.78456191211852, -0.405146029293825},
    {-0.880568256420461, 0.88056825642046, 0.238863487159079, 0.0, -0.238863487159079},
    {-0.880568256420461, -0.761136512840921, 1.88056825642046, 1.64170476926138, -1.88056825642046},
    {0.761136512840921, 0.88056825642046, 1.88056825642046, -1.64170476926138, -1.88056825642046}};
    
    // Array of non-zero columns
    static const unsigned int nzc4[5] = {6, 8, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc1[5] = {0, 2, 3, 4, 5};
    
    static const double FE0_C0_D10[7][5] = \
    {{-0.333333333333333, 0.333333333333333, 1.33333333333333, -1.33333333333333, 0.0},
    {0.594853970706174, 2.18970794141235, 0.405146029293825, -0.405146029293825, -2.78456191211852},
    {0.594853970706174, -0.594853970706175, 3.18970794141235, -3.18970794141235, 0.0},
    {-2.18970794141235, -0.594853970706175, 0.405146029293825, -0.405146029293825, 2.78456191211852},
    {-0.880568256420461, -0.761136512840921, 1.88056825642046, -1.88056825642046, 1.64170476926138},
    {-0.880568256420461, 0.88056825642046, 0.238863487159078, -0.238863487159079, 0.0},
    {0.761136512840921, 0.88056825642046, 1.88056825642046, -1.88056825642046, -1.64170476926138}};
    
    // Array of non-zero columns
    static const unsigned int nzc5[5] = {6, 7, 9, 10, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc2[5] = {0, 1, 3, 4, 5};
    
    static const double FE0_C2[7][3] = \
    {{0.333333333333333, 0.333333333333333, 0.333333333333333},
    {0.101286507323456, 0.797426985353087, 0.101286507323456},
    {0.101286507323456, 0.101286507323456, 0.797426985353087},
    {0.797426985353087, 0.101286507323456, 0.101286507323456},
    {0.470142064105115, 0.0597158717897698, 0.470142064105115},
    {0.470142064105115, 0.470142064105115, 0.0597158717897697},
    {0.0597158717897699, 0.470142064105115, 0.470142064105115}};
    
    // Array of non-zero columns
    static const unsigned int nzc6[3] = {12, 13, 14};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.0;
    }// end loop over 'r'
    // Number of operations to compute geometry constants: 23.
    double G[11];
    G[0] = K_00*det;
    G[1] = K_10*det;
    G[2] = K_01*det;
    G[3] = K_11*det;
    G[4] = det*w[2][0]*(K_00*K_10 + K_01*K_11);
    G[5] = det*w[2][0]*(K_10*K_10 + K_11*K_11);
    G[6] =  - K_10*det;
    G[7] = det*w[2][0]*(K_00*K_00 + K_01*K_01);
    G[8] =  - K_00*det;
    G[9] =  - K_11*det;
    G[10] =  - K_01*det;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    
    // Loop quadrature points for integral.
    // Number of operations to compute element tensor for following IP loop = 1344
    for (unsigned int ip = 0; ip < 7; ip++)
    {
      
      // Coefficient declarations.
      double F0 = 0.0;
      double F1 = 0.0;
      double F2 = 0.0;
      double F3 = 0.0;
      double F4 = 0.0;
      double F5 = 0.0;
      double F6 = 0.0;
      
      // Total number of operations to compute function values = 6
      for (unsigned int r = 0; r < 3; r++)
      {
        F6 += FE0_C2[ip][r]*w[0][nzc6[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 40
      for (unsigned int r = 0; r < 5; r++)
      {
        F0 += FE0_C0_D10[ip][r]*w[0][nzc2[r]];
        F1 += FE0_C0_D01[ip][r]*w[0][nzc1[r]];
        F4 += FE0_C0_D10[ip][r]*w[0][nzc5[r]];
        F5 += FE0_C0_D01[ip][r]*w[0][nzc4[r]];
      }// end loop over 'r'
      
      // Total number of operations to compute function values = 24
      for (unsigned int r = 0; r < 6; r++)
      {
        F2 += FE0_C0[ip][r]*w[0][nzc0[r]];
        F3 += FE0_C0[ip][r]*w[0][nzc3[r]];
      }// end loop over 'r'
      
      // Number of operations to compute ip constants: 52
      double I[7];
      // Number of operations: 8
      I[0] = W7[ip]*(F0*G[0] + F1*G[1] + F4*G[2] + F5*G[3]);
      
      // Number of operations: 6
      I[1] = W7[ip]*(F0*G[4] + F1*G[5] + F6*G[6]);
      
      // Number of operations: 6
      I[2] = W7[ip]*(F0*G[7] + F1*G[4] + F6*G[8]);
      
      // Number of operations: 6
      I[3] = W7[ip]*(F4*G[4] + F5*G[5] + F6*G[9]);
      
      // Number of operations: 6
      I[4] = W7[ip]*(F4*G[7] + F5*G[4] + F6*G[10]);
      
      // Number of operations: 10
      I[5] = W7[ip]*(F2*(F0*G[0] + F1*G[1]) + F3*(F0*G[2] + F1*G[3]));
      
      // Number of operations: 10
      I[6] = W7[ip]*(F4*(F2*G[0] + F3*G[2]) + F5*(F2*G[1] + F3*G[3]));
      
      
      // Number of operations for primary indices: 6
      for (unsigned int j = 0; j < 3; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc6[j]] += FE0_C2[ip][j]*I[0];
      }// end loop over 'j'
      
      // Number of operations for primary indices: 40
      for (unsigned int j = 0; j < 5; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc1[j]] += FE0_C0_D01[ip][j]*I[1];
        // Number of operations to compute entry: 2
        A[nzc2[j]] += FE0_C0_D10[ip][j]*I[2];
        // Number of operations to compute entry: 2
        A[nzc4[j]] += FE0_C0_D01[ip][j]*I[3];
        // Number of operations to compute entry: 2
        A[nzc5[j]] += FE0_C0_D10[ip][j]*I[4];
      }// end loop over 'j'
      
      // Number of operations for primary indices: 24
      for (unsigned int j = 0; j < 6; j++)
      {
        // Number of operations to compute entry: 2
        A[nzc0[j]] += FE0_C0[ip][j]*I[5];
        // Number of operations to compute entry: 2
        A[nzc3[j]] += FE0_C0[ip][j]*I[6];
      }// end loop over 'j'
    }// end loop over 'ip'
  }

  /// Tabulate the tensor for the contribution from a local cell
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not yet implemented (introduced in UFC 2.0).");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_9_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_9_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_9_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x[v1][0] - x[v0][0];
    const double dx1 = x[v1][1] - x[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    const bool direction = dx1*(x[facet][0] - x[v0][0]) - dx0*(x[facet][1] - x[v0][1]) < 0;// Compute facet normals from the facet scale factor constants
    const double n0 = direction ? dx1 / det : -dx1 / det;
    const double n1 = direction ? -dx0 / det : dx0 / det;
    
    // Cell Volume.
    
    // Compute circumradius, assuming triangle is embedded in 2D.
    
    
    // Facet Area.
    
    // Array of quadrature weights.
    static const double W2[2] = {0.5, 0.5};
    // Quadrature points on the UFC reference element: (0.211324865405187), (0.788675134594813)
    
    // Value of basis functions at quadrature points.
    static const double FE0_f0[2][2] = \
    {{0.788675134594813, 0.211324865405187},
    {0.211324865405187, 0.788675134594813}};
    
    // Array of non-zero columns
    static const unsigned int nzc0[2] = {1, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc1[2] = {0, 2};
    
    // Array of non-zero columns
    static const unsigned int nzc2[2] = {0, 1};
    
    static const double FE1_f0_C0[2][3] = \
    {{0.455341801261479, -0.122008467928146, 0.666666666666667},
    {-0.122008467928146, 0.455341801261479, 0.666666666666667}};
    
    // Array of non-zero columns
    static const unsigned int nzc3[3] = {1, 2, 3};
    
    // Array of non-zero columns
    static const unsigned int nzc4[3] = {7, 8, 9};
    
    // Array of non-zero columns
    static const unsigned int nzc9[3] = {0, 1, 5};
    
    // Array of non-zero columns
    static const unsigned int nzc10[3] = {6, 7, 11};
    
    // Array of non-zero columns
    static const unsigned int nzc7[3] = {6, 8, 10};
    
    // Array of non-zero columns
    static const unsigned int nzc6[3] = {0, 2, 4};
    
    // Reset values in the element tensor.
    for (unsigned int r = 0; r < 15; r++)
    {
      A[r] = 0.0;
    }// end loop over 'r'
    // Number of operations to compute geometry constants: 2.
    double G[2];
    G[0] = det*n0;
    G[1] = det*n1;
    
    // Compute element tensor using UFL quadrature representation
    // Optimisations: ('eliminate zeros', True), ('ignore ones', True), ('ignore zero tables', True), ('optimisation', 'simplify_expressions'), ('remove zero terms', True)
    switch (facet)
    {
    case 0:
      {
        // Total number of operations to compute element tensor (from this point): 40
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 40
      for (unsigned int ip = 0; ip < 2; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc0[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 4
        double I[2];
        // Number of operations: 2
        I[0] = F0*G[0]*W2[ip];
        
        // Number of operations: 2
        I[1] = F0*G[1]*W2[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc3[j]] += FE1_f0_C0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc4[j]] += FE1_f0_C0[ip][j]*I[1];
        }// end loop over 'j'
      }// end loop over 'ip'
        break;
      }
    case 1:
      {
        // Total number of operations to compute element tensor (from this point): 40
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 40
      for (unsigned int ip = 0; ip < 2; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc1[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 4
        double I[2];
        // Number of operations: 2
        I[0] = F0*G[0]*W2[ip];
        
        // Number of operations: 2
        I[1] = F0*G[1]*W2[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc6[j]] += FE1_f0_C0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc7[j]] += FE1_f0_C0[ip][j]*I[1];
        }// end loop over 'j'
      }// end loop over 'ip'
        break;
      }
    case 2:
      {
        // Total number of operations to compute element tensor (from this point): 40
      
      // Loop quadrature points for integral.
      // Number of operations to compute element tensor for following IP loop = 40
      for (unsigned int ip = 0; ip < 2; ip++)
      {
        
        // Coefficient declarations.
        double F0 = 0.0;
        
        // Total number of operations to compute function values = 4
        for (unsigned int r = 0; r < 2; r++)
        {
          F0 += FE0_f0[ip][r]*w[1][nzc2[r]];
        }// end loop over 'r'
        
        // Number of operations to compute ip constants: 4
        double I[2];
        // Number of operations: 2
        I[0] = F0*G[1]*W2[ip];
        
        // Number of operations: 2
        I[1] = F0*G[0]*W2[ip];
        
        
        // Number of operations for primary indices: 12
        for (unsigned int j = 0; j < 3; j++)
        {
          // Number of operations to compute entry: 2
          A[nzc10[j]] += FE1_f0_C0[ip][j]*I[0];
          // Number of operations to compute entry: 2
          A[nzc9[j]] += FE1_f0_C0[ip][j]*I[1];
        }// end loop over 'j'
      }// end loop over 'ip'
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not yet implemented (introduced in UFC 2.0).");
  }

};

/// This class defines the interface for the tabulation of the
/// exterior facet tensor corresponding to the local contribution to
/// a form from the integral over an exterior facet.

class adaptivenavierstokes_exterior_facet_integral_10_0: public ufc::exterior_facet_integral
{
public:

  /// Constructor
  adaptivenavierstokes_exterior_facet_integral_10_0() : ufc::exterior_facet_integral()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_exterior_facet_integral_10_0()
  {
    // Do nothing
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int facet) const
  {
    // Number of operations (multiply-add pairs) for Jacobian data:      9
    // Number of operations (multiply-add pairs) for geometry tensor:    6
    // Number of operations (multiply-add pairs) for tensor contraction: 7
    // Total number of operations (multiply-add pairs):                  22
    
    // Extract vertex coordinates
    const double * const * x = c.coordinates;
    
    // Compute Jacobian of affine map from reference cell
    
    // Compute determinant of Jacobian
    
    // Compute inverse of Jacobian
    
    // Get vertices on edge
    static unsigned int edge_vertices[3][2] = {{1, 2}, {0, 2}, {0, 1}};
    const unsigned int v0 = edge_vertices[facet][0];
    const unsigned int v1 = edge_vertices[facet][1];
    
    // Compute scale factor (length of edge scaled by length of reference interval)
    const double dx0 = x[v1][0] - x[v0][0];
    const double dx1 = x[v1][1] - x[v0][1];
    const double det = std::sqrt(dx0*dx0 + dx1*dx1);
    
    // Compute geometry tensor
    const double G0_0 = det*w[0][0]*(1.0);
    const double G0_1 = det*w[0][1]*(1.0);
    const double G0_2 = det*w[0][2]*(1.0);
    const double G0_3 = det*w[0][3]*(1.0);
    const double G0_4 = det*w[0][4]*(1.0);
    const double G0_5 = det*w[0][5]*(1.0);
    
    // Compute element tensor
    switch (facet)
    {
    case 0:
      {
        A[0] = 0.166666666666667*G0_1 + 0.166666666666667*G0_2 + 0.666666666666666*G0_3;
        break;
      }
    case 1:
      {
        A[0] = 0.166666666666667*G0_0 + 0.166666666666666*G0_2 + 0.666666666666666*G0_4;
        break;
      }
    case 2:
      {
        A[0] = 0.166666666666666*G0_0 + 0.166666666666667*G0_1 + 0.666666666666666*G0_5;
        break;
      }
    }
    
  }

  /// Tabulate the tensor for the contribution from a local exterior facet
  /// using the specified reference cell quadrature points/weights
  virtual void tabulate_tensor(double* A,
                               const double * const * w,
                               const ufc::cell& c,
                               unsigned int num_quadrature_points,
                               const double * const * quadrature_points,
                               const double* quadrature_weights) const
  {
    throw std::runtime_error("Quadrature version of tabulate_tensor not available when using the FFC tensor representation.");
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_0: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_0() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_0()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Sum(IndexSum(Product(Indexed(ComponentTensor(IndexSum(Sum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((Index(1), Index(0)), {Index(0): 2, Index(1): 2})), MultiIndex((Index(2), Index(3)), {Index(2): 2, Index(3): 2})), Indexed(ListTensor(Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(3),), {Index(3): 2}))), Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((Index(1), Index(0)), {Index(0): 2, Index(1): 2})), MultiIndex((Index(2), Index(3)), {Index(2): 2, Index(3): 2})), Indexed(ListTensor(Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(3),), {Index(3): 2})))), MultiIndex((Index(3),), {Index(3): 2})), MultiIndex((Index(2),), {Index(2): 2})), MultiIndex((Index(4),), {Index(4): 2})), Indexed(ListTensor(Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((FixedIndex(0),), {})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(4),), {Index(4): 2}))), MultiIndex((Index(4),), {Index(4): 2})), Sum(Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((Index(5),), {Index(5): 2})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((FixedIndex(2),), {}))), Sum(Product(Constant(Cell('triangle', Space(2)), 1), IndexSum(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((Index(7), Index(6)), {Index(7): 2, Index(6): 2})), MultiIndex((Index(8), Index(9)), {Index(8): 2, Index(9): 2})), Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(11),), {Index(11): 2})), MultiIndex((Index(11), Index(10)), {Index(11): 2, Index(10): 2})), MultiIndex((Index(8), Index(9)), {Index(8): 2, Index(9): 2}))), MultiIndex((Index(8),), {Index(8): 2})), MultiIndex((Index(9),), {Index(9): 2}))), Product(IntValue(-1, (), (), {}), Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((Index(12),), {Index(12): 2})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(2),), {}))))))), Measure('cell', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 2;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_10();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_10();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_cell_integral_0_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_1: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_1() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_1()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {})), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 0;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_1_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_2: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_2() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_2()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Product(IntValue(-1, (), (), {}), Sum(IndexSum(Product(Indexed(ComponentTensor(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((Index(1), Index(0)), {Index(0): 2, Index(1): 2})), MultiIndex((Index(2), Index(3)), {Index(2): 2, Index(3): 2})), Indexed(ListTensor(Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(3),), {Index(3): 2}))), MultiIndex((Index(3),), {Index(3): 2})), MultiIndex((Index(2),), {Index(2): 2})), MultiIndex((Index(4),), {Index(4): 2})), Indexed(ListTensor(Indexed(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((FixedIndex(0),), {})), Indexed(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(4),), {Index(4): 2}))), MultiIndex((Index(4),), {Index(4): 2})), Sum(Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((Index(5),), {Index(5): 2})), Indexed(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((FixedIndex(2),), {}))), Sum(Product(Constant(Cell('triangle', Space(2)), 2), IndexSum(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((Index(7), Index(6)), {Index(7): 2, Index(6): 2})), MultiIndex((Index(8), Index(9)), {Index(8): 2, Index(9): 2})), Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(11),), {Index(11): 2})), MultiIndex((Index(11), Index(10)), {Index(11): 2, Index(10): 2})), MultiIndex((Index(8), Index(9)), {Index(8): 2, Index(9): 2}))), MultiIndex((Index(8),), {Index(8): 2})), MultiIndex((Index(9),), {Index(9): 2}))), Product(IntValue(-1, (), (), {}), Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((Index(12),), {Index(12): 2})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(2),), {})))))))), Measure('cell', 0, None)), Integral(Product(IntValue(-1, (), (), {}), Product(Coefficient(FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), 1), IndexSum(Product(Indexed(FacetNormal(Cell('triangle', Space(2))), MultiIndex((Index(13),), {Index(13): 2})), Indexed(ListTensor(Indexed(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((FixedIndex(0),), {})), Indexed(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 3), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(13),), {Index(13): 2}))), MultiIndex((Index(13),), {Index(13): 2})))), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 0;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 4;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_10();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_9();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_10();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_9();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_cell_integral_2_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_2_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_3: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_3() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_3()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(IndexSum(Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(0),), {Index(0): 3})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 0), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((Index(0),), {Index(0): 3}))), MultiIndex((Index(0),), {Index(0): 3})), Measure('cell', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 1;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_1();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_1();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_cell_integral_3_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_4: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_4() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_4()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Product(IntValue(-1, (), (), {}), Sum(IndexSum(Product(Indexed(ComponentTensor(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((Index(1), Index(0)), {Index(0): 2, Index(1): 2})), MultiIndex((Index(2), Index(3)), {Index(2): 2, Index(3): 2})), Indexed(ListTensor(Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(3),), {Index(3): 2}))), MultiIndex((Index(3),), {Index(3): 2})), MultiIndex((Index(2),), {Index(2): 2})), MultiIndex((Index(4),), {Index(4): 2})), Indexed(ListTensor(Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3}))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(0),), {})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3}))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(4),), {Index(4): 2}))), MultiIndex((Index(4),), {Index(4): 2})), Sum(Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((Index(6),), {Index(6): 2})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3}))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(2),), {}))), Sum(Product(Constant(Cell('triangle', Space(2)), 2), IndexSum(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(ComponentTensor(Sum(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(SpatialDerivative(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((Index(5),), {Index(5): 3}))), Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3})), SpatialDerivative(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), MultiIndex((Index(7),), {Index(7): 2})))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(0),), {})), Indexed(ComponentTensor(Sum(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(SpatialDerivative(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((Index(5),), {Index(5): 3}))), Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3})), SpatialDerivative(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), MultiIndex((Index(7),), {Index(7): 2})))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(8),), {Index(8): 2})), MultiIndex((Index(8), Index(7)), {Index(7): 2, Index(8): 2})), MultiIndex((Index(9), Index(10)), {Index(10): 2, Index(9): 2})), Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(11),), {Index(11): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(11),), {Index(11): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((Index(12), Index(11)), {Index(11): 2, Index(12): 2})), MultiIndex((Index(9), Index(10)), {Index(10): 2, Index(9): 2}))), MultiIndex((Index(9),), {Index(9): 2})), MultiIndex((Index(10),), {Index(10): 2}))), Product(IntValue(-1, (), (), {}), Product(IndexSum(Indexed(ListTensor(Indexed(ComponentTensor(Sum(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(SpatialDerivative(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(13),), {Index(13): 2})), MultiIndex((Index(5),), {Index(5): 3}))), Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3})), SpatialDerivative(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), MultiIndex((Index(13),), {Index(13): 2})))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(0),), {})), Indexed(ComponentTensor(Sum(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(SpatialDerivative(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(13),), {Index(13): 2})), MultiIndex((Index(5),), {Index(5): 3}))), Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3})), SpatialDerivative(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), MultiIndex((Index(13),), {Index(13): 2})))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(13),), {Index(13): 2})), MultiIndex((Index(13),), {Index(13): 2})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(2),), {})))))))), Measure('cell', 0, None)), Integral(Product(IntValue(-1, (), (), {}), Product(Coefficient(FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), 1), IndexSum(Product(Indexed(FacetNormal(Cell('triangle', Space(2))), MultiIndex((Index(14),), {Index(14): 2})), Indexed(ListTensor(Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3}))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(0),), {})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Bubble', Cell('triangle', Space(2)), 3, None), 3), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 3}))), MultiIndex((Index(5),), {Index(5): 3})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(14),), {Index(14): 2}))), MultiIndex((Index(14),), {Index(14): 2})))), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 4;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_10();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_finite_element_1();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_10();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_dofmap_1();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_cell_integral_4_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_4_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_5: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_5() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_5()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Sum(IndexSum(Product(Indexed(NegativeRestricted(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1)), MultiIndex((Index(0),), {Index(0): 3})), Indexed(NegativeRestricted(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 0), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(0),), {Index(0): 3}))), MultiIndex((Index(0),), {Index(0): 3})), IndexSum(Product(Indexed(PositiveRestricted(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1)), MultiIndex((Index(2),), {Index(2): 3})), Indexed(PositiveRestricted(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 0), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(2),), {Index(2): 3}))), MultiIndex((Index(2),), {Index(2): 3}))), Measure('interior_facet', 0, None)), Integral(IndexSum(Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(3),), {Index(3): 3})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 0), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((Index(3),), {Index(3): 3}))), MultiIndex((Index(3),), {Index(3): 3})), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 1;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 1;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_5_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_interior_facet_integral_5_0();
        break;
      }
    }
    
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_6: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_6() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_6()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Sum(Product(IntValue(-1, (), (), {}), IndexSum(Product(Indexed(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(0),), {Index(0): 3})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((Index(0),), {Index(0): 3}))), MultiIndex((Index(0),), {Index(0): 3}))), Product(IntValue(-1, (), (), {}), Sum(IndexSum(Product(Indexed(ComponentTensor(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(2),), {Index(2): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(2),), {Index(2): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(3),), {Index(3): 2})), MultiIndex((Index(3), Index(2)), {Index(2): 2, Index(3): 2})), MultiIndex((Index(4), Index(5)), {Index(4): 2, Index(5): 2})), Indexed(ListTensor(Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(5),), {Index(5): 2}))), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((Index(4),), {Index(4): 2})), MultiIndex((Index(6),), {Index(6): 2})), Indexed(ListTensor(Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(0),), {})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(6),), {Index(6): 2}))), MultiIndex((Index(6),), {Index(6): 2})), Sum(Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((Index(7),), {Index(7): 2})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(2),), {}))), Sum(Product(Constant(Cell('triangle', Space(2)), 2), IndexSum(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(ComponentTensor(Sum(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(SpatialDerivative(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(8),), {Index(8): 2})), MultiIndex((Index(1),), {Index(1): 3}))), Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3})), SpatialDerivative(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), MultiIndex((Index(8),), {Index(8): 2})))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(0),), {})), Indexed(ComponentTensor(Sum(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(SpatialDerivative(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(8),), {Index(8): 2})), MultiIndex((Index(1),), {Index(1): 3}))), Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3})), SpatialDerivative(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), MultiIndex((Index(8),), {Index(8): 2})))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(9),), {Index(9): 2})), MultiIndex((Index(9), Index(8)), {Index(8): 2, Index(9): 2})), MultiIndex((Index(10), Index(11)), {Index(11): 2, Index(10): 2})), Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(13),), {Index(13): 2})), MultiIndex((Index(13), Index(12)), {Index(13): 2, Index(12): 2})), MultiIndex((Index(10), Index(11)), {Index(11): 2, Index(10): 2}))), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((Index(11),), {Index(11): 2}))), Product(IntValue(-1, (), (), {}), Product(IndexSum(Indexed(ListTensor(Indexed(ComponentTensor(Sum(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(SpatialDerivative(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(14),), {Index(14): 2})), MultiIndex((Index(1),), {Index(1): 3}))), Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3})), SpatialDerivative(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), MultiIndex((Index(14),), {Index(14): 2})))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(0),), {})), Indexed(ComponentTensor(Sum(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(SpatialDerivative(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(14),), {Index(14): 2})), MultiIndex((Index(1),), {Index(1): 3}))), Product(Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3})), SpatialDerivative(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), MultiIndex((Index(14),), {Index(14): 2})))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(14),), {Index(14): 2})), MultiIndex((Index(14),), {Index(14): 2})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(2),), {}))))))))), Measure('cell', 0, None)), Integral(Product(IntValue(-1, (), (), {}), Product(Coefficient(FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), 1), IndexSum(Product(Indexed(FacetNormal(Cell('triangle', Space(2))), MultiIndex((Index(15),), {Index(15): 2})), Indexed(ListTensor(Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(0),), {})), Indexed(ComponentTensor(Product(Coefficient(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), 4), Indexed(Argument(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(15),), {Index(15): 2}))), MultiIndex((Index(15),), {Index(15): 2})))), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 5;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_10();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 5:
      {
        return new adaptivenavierstokes_finite_element_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_10();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 5:
      {
        return new adaptivenavierstokes_dofmap_2();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_cell_integral_6_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_6_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_7: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_7() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_7()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Product(Argument(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 0, None), 0), IndexSum(Product(Indexed(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(0),), {Index(0): 3})), Indexed(Sum(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 0), ComponentTensor(Product(IntValue(-1, (), (), {}), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(1),), {Index(1): 3}))), MultiIndex((Index(0),), {Index(0): 3}))), MultiIndex((Index(0),), {Index(0): 3}))), Measure('cell', 0, None)), Integral(Product(Product(FloatValue(0.5, (), (), {}), Sum(NegativeRestricted(Argument(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 0, None), 0)), PositiveRestricted(Argument(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 0, None), 0)))), Sum(IndexSum(Product(Indexed(NegativeRestricted(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 2)), MultiIndex((Index(2),), {Index(2): 3})), Indexed(NegativeRestricted(Sum(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 0), ComponentTensor(Product(IntValue(-1, (), (), {}), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(3),), {Index(3): 3}))), MultiIndex((Index(3),), {Index(3): 3})))), MultiIndex((Index(2),), {Index(2): 3}))), MultiIndex((Index(2),), {Index(2): 3})), IndexSum(Product(Indexed(PositiveRestricted(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 2)), MultiIndex((Index(4),), {Index(4): 3})), Indexed(PositiveRestricted(Sum(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 0), ComponentTensor(Product(IntValue(-1, (), (), {}), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(5),), {Index(5): 3}))), MultiIndex((Index(5),), {Index(5): 3})))), MultiIndex((Index(4),), {Index(4): 3}))), MultiIndex((Index(4),), {Index(4): 3})))), Measure('interior_facet', 0, None)), Integral(Product(Argument(FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 0, None), 0), IndexSum(Product(Indexed(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (2,) }), FiniteElement('Discontinuous Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 2), MultiIndex((Index(6),), {Index(6): 3})), Indexed(Sum(Coefficient(MixedElement(*[MixedElement(*[FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 3, None)], **{'value_shape': (2,) }), FiniteElement('Lagrange', Cell('triangle', Space(2)), 2, None)], **{'value_shape': (3,) }), 0), ComponentTensor(Product(IntValue(-1, (), (), {}), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 3), MultiIndex((Index(7),), {Index(7): 3}))), MultiIndex((Index(7),), {Index(7): 3}))), MultiIndex((Index(6),), {Index(6): 3}))), MultiIndex((Index(6),), {Index(6): 3}))), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 4;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 1;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_0();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_9();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_5();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_0();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_9();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_5();
        break;
      }
    case 4:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_cell_integral_7_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_7_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_interior_facet_integral_7_0();
        break;
      }
    }
    
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_8: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_8() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_8()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Sum(IndexSum(Product(Indexed(ComponentTensor(IndexSum(Sum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((Index(1), Index(0)), {Index(0): 2, Index(1): 2})), MultiIndex((Index(2), Index(3)), {Index(2): 2, Index(3): 2})), Indexed(ListTensor(Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(3),), {Index(3): 2}))), Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((Index(1), Index(0)), {Index(0): 2, Index(1): 2})), MultiIndex((Index(2), Index(3)), {Index(2): 2, Index(3): 2})), Indexed(ListTensor(Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((FixedIndex(0),), {})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(3),), {Index(3): 2})))), MultiIndex((Index(3),), {Index(3): 2})), MultiIndex((Index(2),), {Index(2): 2})), MultiIndex((Index(4),), {Index(4): 2})), Indexed(ListTensor(Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(4),), {Index(4): 2}))), MultiIndex((Index(4),), {Index(4): 2})), Sum(Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((Index(5),), {Index(5): 2})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(2),), {}))), Sum(Product(Constant(Cell('triangle', Space(2)), 1), IndexSum(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((Index(7), Index(6)), {Index(7): 2, Index(6): 2})), MultiIndex((Index(8), Index(9)), {Index(8): 2, Index(9): 2})), Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(11),), {Index(11): 2})), MultiIndex((Index(11), Index(10)), {Index(11): 2, Index(10): 2})), MultiIndex((Index(8), Index(9)), {Index(8): 2, Index(9): 2}))), MultiIndex((Index(8),), {Index(8): 2})), MultiIndex((Index(9),), {Index(9): 2}))), Product(IntValue(-1, (), (), {}), Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((Index(12),), {Index(12): 2})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 1), MultiIndex((FixedIndex(2),), {}))))))), Measure('cell', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 2;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 2;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 0;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_10();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_10();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_cell_integral_8_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_9: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_9() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_9()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Sum(IndexSum(Product(Indexed(ComponentTensor(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(0),), {Index(0): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(1),), {Index(1): 2})), MultiIndex((Index(1), Index(0)), {Index(0): 2, Index(1): 2})), MultiIndex((Index(2), Index(3)), {Index(2): 2, Index(3): 2})), Indexed(ListTensor(Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(3),), {Index(3): 2}))), MultiIndex((Index(3),), {Index(3): 2})), MultiIndex((Index(2),), {Index(2): 2})), MultiIndex((Index(4),), {Index(4): 2})), Indexed(ListTensor(Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(4),), {Index(4): 2}))), MultiIndex((Index(4),), {Index(4): 2})), Sum(Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(5),), {Index(5): 2})), MultiIndex((Index(5),), {Index(5): 2})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(2),), {}))), Sum(Product(Constant(Cell('triangle', Space(2)), 2), IndexSum(IndexSum(Product(Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(6),), {Index(6): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(7),), {Index(7): 2})), MultiIndex((Index(7), Index(6)), {Index(7): 2, Index(6): 2})), MultiIndex((Index(8), Index(9)), {Index(8): 2, Index(9): 2})), Indexed(ComponentTensor(Indexed(ListTensor(Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(10),), {Index(10): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(11),), {Index(11): 2})), MultiIndex((Index(11), Index(10)), {Index(11): 2, Index(10): 2})), MultiIndex((Index(8), Index(9)), {Index(8): 2, Index(9): 2}))), MultiIndex((Index(8),), {Index(8): 2})), MultiIndex((Index(9),), {Index(9): 2}))), Product(IntValue(-1, (), (), {}), Product(IndexSum(Indexed(ListTensor(Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(0),), {})), Indexed(SpatialDerivative(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(12),), {Index(12): 2})), MultiIndex((Index(12),), {Index(12): 2})), Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(2),), {}))))))), Measure('cell', 0, None)), Integral(Product(Coefficient(FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None), 1), IndexSum(Product(Indexed(FacetNormal(Cell('triangle', Space(2))), MultiIndex((Index(13),), {Index(13): 2})), Indexed(ListTensor(Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {})), Indexed(Argument(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(1),), {}))), MultiIndex((Index(13),), {Index(13): 2}))), MultiIndex((Index(13),), {Index(13): 2}))), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 1;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 3;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 1;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_finite_element_12();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_finite_element_10();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 1:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    case 2:
      {
        return new adaptivenavierstokes_dofmap_12();
        break;
      }
    case 3:
      {
        return new adaptivenavierstokes_dofmap_10();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_cell_integral_9_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_9_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

/// This class defines the interface for the assembly of the global
/// tensor corresponding to a form with r + n arguments, that is, a
/// mapping
///
///     a : V1 x V2 x ... Vr x W1 x W2 x ... x Wn -> R
///
/// with arguments v1, v2, ..., vr, w1, w2, ..., wn. The rank r
/// global tensor A is defined by
///
///     A = a(V1, V2, ..., Vr, w1, w2, ..., wn),
///
/// where each argument Vj represents the application to the
/// sequence of basis functions of Vj and w1, w2, ..., wn are given
/// fixed functions (coefficients).

class adaptivenavierstokes_form_10: public ufc::form
{
public:

  /// Constructor
  adaptivenavierstokes_form_10() : ufc::form()
  {
    // Do nothing
  }

  /// Destructor
  virtual ~adaptivenavierstokes_form_10()
  {
    // Do nothing
  }

  /// Return a string identifying the form
  virtual const char* signature() const
  {
    return "Form([Integral(Indexed(Coefficient(MixedElement(*[VectorElement('Lagrange', Cell('triangle', Space(2)), 2, 2, None), FiniteElement('Lagrange', Cell('triangle', Space(2)), 1, None)], **{'value_shape': (3,) }), 0), MultiIndex((FixedIndex(0),), {})), Measure('exterior_facet', 0, None))])";
  }

  /// Return the rank of the global tensor (r)
  virtual unsigned int rank() const
  {
    return 0;
  }

  /// Return the number of coefficients (n)
  virtual unsigned int num_coefficients() const
  {
    return 1;
  }

  /// Return the number of cell domains
  virtual unsigned int num_cell_domains() const
  {
    return 0;
  }

  /// Return the number of exterior facet domains
  virtual unsigned int num_exterior_facet_domains() const
  {
    return 1;
  }

  /// Return the number of interior facet domains
  virtual unsigned int num_interior_facet_domains() const
  {
    return 0;
  }

  /// Create a new finite element for argument function i
  virtual ufc::finite_element* create_finite_element(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_finite_element_13();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new dofmap for argument function i
  virtual ufc::dofmap* create_dofmap(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_dofmap_13();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new cell integral on sub domain i
  virtual ufc::cell_integral* create_cell_integral(unsigned int i) const
  {
    return 0;
  }

  /// Create a new exterior facet integral on sub domain i
  virtual ufc::exterior_facet_integral* create_exterior_facet_integral(unsigned int i) const
  {
    switch (i)
    {
    case 0:
      {
        return new adaptivenavierstokes_exterior_facet_integral_10_0();
        break;
      }
    }
    
    return 0;
  }

  /// Create a new interior facet integral on sub domain i
  virtual ufc::interior_facet_integral* create_interior_facet_integral(unsigned int i) const
  {
    return 0;
  }

};

// DOLFIN wrappers

// Standard library includes
#include <string>

// DOLFIN includes
#include <dolfin/common/NoDeleter.h>
#include <dolfin/fem/FiniteElement.h>
#include <dolfin/fem/DofMap.h>
#include <dolfin/fem/Form.h>
#include <dolfin/function/FunctionSpace.h>
#include <dolfin/function/GenericFunction.h>
#include <dolfin/function/CoefficientAssigner.h>
#include <dolfin/adaptivity/ErrorControl.h>
#include <dolfin/adaptivity/GoalFunctional.h>

namespace AdaptiveNavierStokes
{

class CoefficientSpace___cell_bubble: public dolfin::FunctionSpace
{
public:

  CoefficientSpace___cell_bubble(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_1()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_1()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___cell_bubble(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_1()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_1()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___cell_bubble(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_1()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_1()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace___cell_bubble(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_1()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_1()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace___cell_bubble()
  {
  }

};

class CoefficientSpace___cell_cone: public dolfin::FunctionSpace
{
public:

  CoefficientSpace___cell_cone(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_2()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___cell_cone(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_2()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___cell_cone(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_2()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace___cell_cone(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_2()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_2()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace___cell_cone()
  {
  }

};

class CoefficientSpace___cell_residual: public dolfin::FunctionSpace
{
public:

  CoefficientSpace___cell_residual(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___cell_residual(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___cell_residual(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace___cell_residual(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace___cell_residual()
  {
  }

};

class CoefficientSpace___discrete_dual_solution: public dolfin::FunctionSpace
{
public:

  CoefficientSpace___discrete_dual_solution(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___discrete_dual_solution(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___discrete_dual_solution(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace___discrete_dual_solution(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace___discrete_dual_solution()
  {
  }

};

class CoefficientSpace___facet_residual: public dolfin::FunctionSpace
{
public:

  CoefficientSpace___facet_residual(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___facet_residual(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___facet_residual(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace___facet_residual(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace___facet_residual()
  {
  }

};

class CoefficientSpace___improved_dual: public dolfin::FunctionSpace
{
public:

  CoefficientSpace___improved_dual(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___improved_dual(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace___improved_dual(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace___improved_dual(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_9()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_9()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace___improved_dual()
  {
  }

};

class CoefficientSpace_nu: public dolfin::FunctionSpace
{
public:

  CoefficientSpace_nu(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_10()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_10()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_nu(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_10()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_10()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_nu(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_10()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_10()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace_nu(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_10()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_10()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace_nu()
  {
  }

};

class CoefficientSpace_p0: public dolfin::FunctionSpace
{
public:

  CoefficientSpace_p0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_p0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_p0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace_p0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_12()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_12()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace_p0()
  {
  }

};

class CoefficientSpace_w: public dolfin::FunctionSpace
{
public:

  CoefficientSpace_w(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_w(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  CoefficientSpace_w(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
      // Do nothing
  }

  CoefficientSpace_w(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
      // Do nothing
  }

  ~CoefficientSpace_w()
  {
  }

};

class Form_0_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_0_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
      // Do nothing
  }

  Form_0_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
      // Do nothing
  }

  ~Form_0_FunctionSpace_0()
  {
  }

};

class Form_0_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  Form_0_FunctionSpace_1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_1(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  Form_0_FunctionSpace_1(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
      // Do nothing
  }

  Form_0_FunctionSpace_1(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
      // Do nothing
  }

  ~Form_0_FunctionSpace_1()
  {
  }

};

typedef CoefficientSpace_w Form_0_FunctionSpace_2;

typedef CoefficientSpace_nu Form_0_FunctionSpace_3;

class Form_0: public dolfin::Form
{
public:

  // Constructor
  Form_0(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Constructor
  Form_0(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->w = w;
    this->nu = nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Constructor
  Form_0(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->w = *w;
    this->nu = *nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Constructor
  Form_0(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Constructor
  Form_0(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->w = w;
    this->nu = nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Constructor
  Form_0(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->w = *w;
    this->nu = *nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_0());
  }

  // Destructor
  ~Form_0()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "nu")
      return 1;

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "nu";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_0_FunctionSpace_0 TestSpace;
  typedef Form_0_FunctionSpace_1 TrialSpace;
  typedef Form_0_FunctionSpace_2 CoefficientSpace_w;
  typedef Form_0_FunctionSpace_3 CoefficientSpace_nu;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner nu;
};

class Form_1_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_1_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  Form_1_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  Form_1_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
      // Do nothing
  }

  Form_1_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
      // Do nothing
  }

  ~Form_1_FunctionSpace_0()
  {
  }

};

class Form_1: public dolfin::Form
{
public:

  // Constructor
  Form_1(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_1());
  }

  // Constructor
  Form_1(boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 0)
  {
    _function_spaces[0] = V0;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_1());
  }

  // Destructor
  ~Form_1()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "There are no coefficients");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "There are no coefficients");
    return "unnamed";
  }

  // Typedefs
  typedef Form_1_FunctionSpace_0 TestSpace;

  // Coefficients
};

typedef CoefficientSpace_w Form_2_FunctionSpace_0;

typedef CoefficientSpace_p0 Form_2_FunctionSpace_1;

typedef CoefficientSpace_nu Form_2_FunctionSpace_2;

typedef CoefficientSpace___improved_dual Form_2_FunctionSpace_3;

class Form_2: public dolfin::Form
{
public:

  // Constructor
  Form_2(const dolfin::Mesh& mesh):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Constructor
  Form_2(const dolfin::Mesh& mesh, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __improved_dual):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__improved_dual = __improved_dual;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Constructor
  Form_2(const dolfin::Mesh& mesh, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> p0, boost::shared_ptr<const dolfin::GenericFunction> nu, boost::shared_ptr<const dolfin::GenericFunction> __improved_dual):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__improved_dual = *__improved_dual;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Constructor
  Form_2(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = mesh;
    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Constructor
  Form_2(boost::shared_ptr<const dolfin::Mesh> mesh, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __improved_dual):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = mesh;
    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__improved_dual = __improved_dual;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Constructor
  Form_2(boost::shared_ptr<const dolfin::Mesh> mesh, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> p0, boost::shared_ptr<const dolfin::GenericFunction> nu, boost::shared_ptr<const dolfin::GenericFunction> __improved_dual):
    dolfin::Form(0, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __improved_dual(*this, 3)
  {
    _mesh = mesh;
    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__improved_dual = *__improved_dual;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_2());
  }

  // Destructor
  ~Form_2()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "p0")
      return 1;
    else if (name == "nu")
      return 2;
    else if (name == "__improved_dual")
      return 3;

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "p0";
    case 2:
      return "nu";
    case 3:
      return "__improved_dual";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_2_FunctionSpace_0 CoefficientSpace_w;
  typedef Form_2_FunctionSpace_1 CoefficientSpace_p0;
  typedef Form_2_FunctionSpace_2 CoefficientSpace_nu;
  typedef Form_2_FunctionSpace_3 CoefficientSpace___improved_dual;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner p0;
  dolfin::CoefficientAssigner nu;
  dolfin::CoefficientAssigner __improved_dual;
};

class Form_3_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_3_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  Form_3_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  Form_3_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  Form_3_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  ~Form_3_FunctionSpace_0()
  {
  }

};

class Form_3_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  Form_3_FunctionSpace_1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  Form_3_FunctionSpace_1(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  Form_3_FunctionSpace_1(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  Form_3_FunctionSpace_1(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  ~Form_3_FunctionSpace_1()
  {
  }

};

typedef CoefficientSpace___cell_bubble Form_3_FunctionSpace_2;

class Form_3: public dolfin::Form
{
public:

  // Constructor
  Form_3(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Constructor
  Form_3(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& __cell_bubble):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->__cell_bubble = __cell_bubble;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Constructor
  Form_3(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> __cell_bubble):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->__cell_bubble = *__cell_bubble;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Constructor
  Form_3(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Constructor
  Form_3(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& __cell_bubble):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->__cell_bubble = __cell_bubble;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Constructor
  Form_3(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> __cell_bubble):
    dolfin::Form(2, 1), __cell_bubble(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->__cell_bubble = *__cell_bubble;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_3());
  }

  // Destructor
  ~Form_3()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "__cell_bubble")
      return 0;

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "__cell_bubble";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_3_FunctionSpace_0 TestSpace;
  typedef Form_3_FunctionSpace_1 TrialSpace;
  typedef Form_3_FunctionSpace_2 CoefficientSpace___cell_bubble;

  // Coefficients
  dolfin::CoefficientAssigner __cell_bubble;
};

class Form_4_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_4_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  Form_4_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  Form_4_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  Form_4_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  ~Form_4_FunctionSpace_0()
  {
  }

};

typedef CoefficientSpace_w Form_4_FunctionSpace_1;

typedef CoefficientSpace_p0 Form_4_FunctionSpace_2;

typedef CoefficientSpace_nu Form_4_FunctionSpace_3;

typedef CoefficientSpace___cell_bubble Form_4_FunctionSpace_4;

class Form_4: public dolfin::Form
{
public:

  // Constructor
  Form_4(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Constructor
  Form_4(const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __cell_bubble):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__cell_bubble = __cell_bubble;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Constructor
  Form_4(const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> p0, boost::shared_ptr<const dolfin::GenericFunction> nu, boost::shared_ptr<const dolfin::GenericFunction> __cell_bubble):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__cell_bubble = *__cell_bubble;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Constructor
  Form_4(boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = V0;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Constructor
  Form_4(boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __cell_bubble):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = V0;

    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__cell_bubble = __cell_bubble;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Constructor
  Form_4(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> p0, boost::shared_ptr<const dolfin::GenericFunction> nu, boost::shared_ptr<const dolfin::GenericFunction> __cell_bubble):
    dolfin::Form(1, 4), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_bubble(*this, 3)
  {
    _function_spaces[0] = V0;

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__cell_bubble = *__cell_bubble;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_4());
  }

  // Destructor
  ~Form_4()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "p0")
      return 1;
    else if (name == "nu")
      return 2;
    else if (name == "__cell_bubble")
      return 3;

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "p0";
    case 2:
      return "nu";
    case 3:
      return "__cell_bubble";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_4_FunctionSpace_0 TestSpace;
  typedef Form_4_FunctionSpace_1 CoefficientSpace_w;
  typedef Form_4_FunctionSpace_2 CoefficientSpace_p0;
  typedef Form_4_FunctionSpace_3 CoefficientSpace_nu;
  typedef Form_4_FunctionSpace_4 CoefficientSpace___cell_bubble;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner p0;
  dolfin::CoefficientAssigner nu;
  dolfin::CoefficientAssigner __cell_bubble;
};

class Form_5_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_5_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  Form_5_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  Form_5_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  Form_5_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  ~Form_5_FunctionSpace_0()
  {
  }

};

class Form_5_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  Form_5_FunctionSpace_1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  Form_5_FunctionSpace_1(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  Form_5_FunctionSpace_1(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  Form_5_FunctionSpace_1(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  ~Form_5_FunctionSpace_1()
  {
  }

};

typedef CoefficientSpace___cell_cone Form_5_FunctionSpace_2;

class Form_5: public dolfin::Form
{
public:

  // Constructor
  Form_5(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Constructor
  Form_5(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& __cell_cone):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->__cell_cone = __cell_cone;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Constructor
  Form_5(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> __cell_cone):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->__cell_cone = *__cell_cone;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Constructor
  Form_5(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Constructor
  Form_5(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& __cell_cone):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->__cell_cone = __cell_cone;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Constructor
  Form_5(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> __cell_cone):
    dolfin::Form(2, 1), __cell_cone(*this, 0)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->__cell_cone = *__cell_cone;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_5());
  }

  // Destructor
  ~Form_5()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "__cell_cone")
      return 0;

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "__cell_cone";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_5_FunctionSpace_0 TestSpace;
  typedef Form_5_FunctionSpace_1 TrialSpace;
  typedef Form_5_FunctionSpace_2 CoefficientSpace___cell_cone;

  // Coefficients
  dolfin::CoefficientAssigner __cell_cone;
};

class Form_6_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_6_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  Form_6_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), mesh)))
  {
    // Do nothing
  }

  Form_6_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  Form_6_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_5()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_5()), *mesh)))
  {
      // Do nothing
  }

  ~Form_6_FunctionSpace_0()
  {
  }

};

typedef CoefficientSpace_w Form_6_FunctionSpace_1;

typedef CoefficientSpace_p0 Form_6_FunctionSpace_2;

typedef CoefficientSpace_nu Form_6_FunctionSpace_3;

typedef CoefficientSpace___cell_residual Form_6_FunctionSpace_4;

typedef CoefficientSpace___cell_cone Form_6_FunctionSpace_5;

class Form_6: public dolfin::Form
{
public:

  // Constructor
  Form_6(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Constructor
  Form_6(const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __cell_residual, const dolfin::GenericFunction& __cell_cone):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__cell_residual = __cell_residual;
    this->__cell_cone = __cell_cone;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Constructor
  Form_6(const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> p0, boost::shared_ptr<const dolfin::GenericFunction> nu, boost::shared_ptr<const dolfin::GenericFunction> __cell_residual, boost::shared_ptr<const dolfin::GenericFunction> __cell_cone):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__cell_residual = *__cell_residual;
    this->__cell_cone = *__cell_cone;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Constructor
  Form_6(boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = V0;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Constructor
  Form_6(boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu, const dolfin::GenericFunction& __cell_residual, const dolfin::GenericFunction& __cell_cone):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = V0;

    this->w = w;
    this->p0 = p0;
    this->nu = nu;
    this->__cell_residual = __cell_residual;
    this->__cell_cone = __cell_cone;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Constructor
  Form_6(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> p0, boost::shared_ptr<const dolfin::GenericFunction> nu, boost::shared_ptr<const dolfin::GenericFunction> __cell_residual, boost::shared_ptr<const dolfin::GenericFunction> __cell_cone):
    dolfin::Form(1, 5), w(*this, 0), p0(*this, 1), nu(*this, 2), __cell_residual(*this, 3), __cell_cone(*this, 4)
  {
    _function_spaces[0] = V0;

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;
    this->__cell_residual = *__cell_residual;
    this->__cell_cone = *__cell_cone;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_6());
  }

  // Destructor
  ~Form_6()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "p0")
      return 1;
    else if (name == "nu")
      return 2;
    else if (name == "__cell_residual")
      return 3;
    else if (name == "__cell_cone")
      return 4;

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "p0";
    case 2:
      return "nu";
    case 3:
      return "__cell_residual";
    case 4:
      return "__cell_cone";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_6_FunctionSpace_0 TestSpace;
  typedef Form_6_FunctionSpace_1 CoefficientSpace_w;
  typedef Form_6_FunctionSpace_2 CoefficientSpace_p0;
  typedef Form_6_FunctionSpace_3 CoefficientSpace_nu;
  typedef Form_6_FunctionSpace_4 CoefficientSpace___cell_residual;
  typedef Form_6_FunctionSpace_5 CoefficientSpace___cell_cone;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner p0;
  dolfin::CoefficientAssigner nu;
  dolfin::CoefficientAssigner __cell_residual;
  dolfin::CoefficientAssigner __cell_cone;
};

class Form_7_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_7_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_0()), mesh)))
  {
    // Do nothing
  }

  Form_7_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_0()), mesh)))
  {
    // Do nothing
  }

  Form_7_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_0()), *mesh)))
  {
      // Do nothing
  }

  Form_7_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_0()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_0()), *mesh)))
  {
      // Do nothing
  }

  ~Form_7_FunctionSpace_0()
  {
  }

};

typedef CoefficientSpace___improved_dual Form_7_FunctionSpace_1;

typedef CoefficientSpace___cell_residual Form_7_FunctionSpace_2;

typedef CoefficientSpace___facet_residual Form_7_FunctionSpace_3;

typedef CoefficientSpace___discrete_dual_solution Form_7_FunctionSpace_4;

class Form_7: public dolfin::Form
{
public:

  // Constructor
  Form_7(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Constructor
  Form_7(const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& __improved_dual, const dolfin::GenericFunction& __cell_residual, const dolfin::GenericFunction& __facet_residual, const dolfin::GenericFunction& __discrete_dual_solution):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->__improved_dual = __improved_dual;
    this->__cell_residual = __cell_residual;
    this->__facet_residual = __facet_residual;
    this->__discrete_dual_solution = __discrete_dual_solution;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Constructor
  Form_7(const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> __improved_dual, boost::shared_ptr<const dolfin::GenericFunction> __cell_residual, boost::shared_ptr<const dolfin::GenericFunction> __facet_residual, boost::shared_ptr<const dolfin::GenericFunction> __discrete_dual_solution):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->__improved_dual = *__improved_dual;
    this->__cell_residual = *__cell_residual;
    this->__facet_residual = *__facet_residual;
    this->__discrete_dual_solution = *__discrete_dual_solution;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Constructor
  Form_7(boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = V0;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Constructor
  Form_7(boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& __improved_dual, const dolfin::GenericFunction& __cell_residual, const dolfin::GenericFunction& __facet_residual, const dolfin::GenericFunction& __discrete_dual_solution):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = V0;

    this->__improved_dual = __improved_dual;
    this->__cell_residual = __cell_residual;
    this->__facet_residual = __facet_residual;
    this->__discrete_dual_solution = __discrete_dual_solution;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Constructor
  Form_7(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> __improved_dual, boost::shared_ptr<const dolfin::GenericFunction> __cell_residual, boost::shared_ptr<const dolfin::GenericFunction> __facet_residual, boost::shared_ptr<const dolfin::GenericFunction> __discrete_dual_solution):
    dolfin::Form(1, 4), __improved_dual(*this, 0), __cell_residual(*this, 1), __facet_residual(*this, 2), __discrete_dual_solution(*this, 3)
  {
    _function_spaces[0] = V0;

    this->__improved_dual = *__improved_dual;
    this->__cell_residual = *__cell_residual;
    this->__facet_residual = *__facet_residual;
    this->__discrete_dual_solution = *__discrete_dual_solution;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_7());
  }

  // Destructor
  ~Form_7()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "__improved_dual")
      return 0;
    else if (name == "__cell_residual")
      return 1;
    else if (name == "__facet_residual")
      return 2;
    else if (name == "__discrete_dual_solution")
      return 3;

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "__improved_dual";
    case 1:
      return "__cell_residual";
    case 2:
      return "__facet_residual";
    case 3:
      return "__discrete_dual_solution";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_7_FunctionSpace_0 TestSpace;
  typedef Form_7_FunctionSpace_1 CoefficientSpace___improved_dual;
  typedef Form_7_FunctionSpace_2 CoefficientSpace___cell_residual;
  typedef Form_7_FunctionSpace_3 CoefficientSpace___facet_residual;
  typedef Form_7_FunctionSpace_4 CoefficientSpace___discrete_dual_solution;

  // Coefficients
  dolfin::CoefficientAssigner __improved_dual;
  dolfin::CoefficientAssigner __cell_residual;
  dolfin::CoefficientAssigner __facet_residual;
  dolfin::CoefficientAssigner __discrete_dual_solution;
};

class Form_8_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_8_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  Form_8_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  Form_8_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
      // Do nothing
  }

  Form_8_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
      // Do nothing
  }

  ~Form_8_FunctionSpace_0()
  {
  }

};

class Form_8_FunctionSpace_1: public dolfin::FunctionSpace
{
public:

  Form_8_FunctionSpace_1(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  Form_8_FunctionSpace_1(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  Form_8_FunctionSpace_1(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
      // Do nothing
  }

  Form_8_FunctionSpace_1(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
      // Do nothing
  }

  ~Form_8_FunctionSpace_1()
  {
  }

};

typedef CoefficientSpace_w Form_8_FunctionSpace_2;

typedef CoefficientSpace_nu Form_8_FunctionSpace_3;

class Form_8: public dolfin::Form
{
public:

  // Constructor
  Form_8(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Constructor
  Form_8(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->w = w;
    this->nu = nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Constructor
  Form_8(const dolfin::FunctionSpace& V1, const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);
    _function_spaces[1] = reference_to_no_delete_pointer(V1);

    this->w = *w;
    this->nu = *nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Constructor
  Form_8(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Constructor
  Form_8(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->w = w;
    this->nu = nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Constructor
  Form_8(boost::shared_ptr<const dolfin::FunctionSpace> V1, boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(2, 2), w(*this, 0), nu(*this, 1)
  {
    _function_spaces[0] = V0;
    _function_spaces[1] = V1;

    this->w = *w;
    this->nu = *nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_8());
  }

  // Destructor
  ~Form_8()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "nu")
      return 1;

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "nu";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_8_FunctionSpace_0 TestSpace;
  typedef Form_8_FunctionSpace_1 TrialSpace;
  typedef Form_8_FunctionSpace_2 CoefficientSpace_w;
  typedef Form_8_FunctionSpace_3 CoefficientSpace_nu;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner nu;
};

class Form_9_FunctionSpace_0: public dolfin::FunctionSpace
{
public:

  Form_9_FunctionSpace_0(const dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  Form_9_FunctionSpace_0(dolfin::Mesh& mesh):
    dolfin::FunctionSpace(dolfin::reference_to_no_delete_pointer(mesh),
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), mesh)))
  {
    // Do nothing
  }

  Form_9_FunctionSpace_0(boost::shared_ptr<dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
      // Do nothing
  }

  Form_9_FunctionSpace_0(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::FunctionSpace(mesh,
                          boost::shared_ptr<const dolfin::FiniteElement>(new dolfin::FiniteElement(boost::shared_ptr<ufc::finite_element>(new adaptivenavierstokes_finite_element_13()))),
                          boost::shared_ptr<const dolfin::DofMap>(new dolfin::DofMap(boost::shared_ptr<ufc::dofmap>(new adaptivenavierstokes_dofmap_13()), *mesh)))
  {
      // Do nothing
  }

  ~Form_9_FunctionSpace_0()
  {
  }

};

typedef CoefficientSpace_w Form_9_FunctionSpace_1;

typedef CoefficientSpace_p0 Form_9_FunctionSpace_2;

typedef CoefficientSpace_nu Form_9_FunctionSpace_3;

class Form_9: public dolfin::Form
{
public:

  // Constructor
  Form_9(const dolfin::FunctionSpace& V0):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Constructor
  Form_9(const dolfin::FunctionSpace& V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = w;
    this->p0 = p0;
    this->nu = nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Constructor
  Form_9(const dolfin::FunctionSpace& V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> p0, boost::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = reference_to_no_delete_pointer(V0);

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Constructor
  Form_9(boost::shared_ptr<const dolfin::FunctionSpace> V0):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = V0;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Constructor
  Form_9(boost::shared_ptr<const dolfin::FunctionSpace> V0, const dolfin::GenericFunction& w, const dolfin::GenericFunction& p0, const dolfin::GenericFunction& nu):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = V0;

    this->w = w;
    this->p0 = p0;
    this->nu = nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Constructor
  Form_9(boost::shared_ptr<const dolfin::FunctionSpace> V0, boost::shared_ptr<const dolfin::GenericFunction> w, boost::shared_ptr<const dolfin::GenericFunction> p0, boost::shared_ptr<const dolfin::GenericFunction> nu):
    dolfin::Form(1, 3), w(*this, 0), p0(*this, 1), nu(*this, 2)
  {
    _function_spaces[0] = V0;

    this->w = *w;
    this->p0 = *p0;
    this->nu = *nu;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_9());
  }

  // Destructor
  ~Form_9()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;
    else if (name == "p0")
      return 1;
    else if (name == "nu")
      return 2;

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    case 1:
      return "p0";
    case 2:
      return "nu";
    }

    dolfin::dolfin_error("generated code for class Form",
                         "access coeficient data",
                         "Invalid coeficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_9_FunctionSpace_0 TestSpace;
  typedef Form_9_FunctionSpace_1 CoefficientSpace_w;
  typedef Form_9_FunctionSpace_2 CoefficientSpace_p0;
  typedef Form_9_FunctionSpace_3 CoefficientSpace_nu;

  // Coefficients
  dolfin::CoefficientAssigner w;
  dolfin::CoefficientAssigner p0;
  dolfin::CoefficientAssigner nu;
};

typedef CoefficientSpace_w Form_10_FunctionSpace_0;

class Form_10: public dolfin::GoalFunctional
{
public:

  // Constructor
  Form_10(const dolfin::Mesh& mesh):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Constructor
  Form_10(const dolfin::Mesh& mesh, const dolfin::GenericFunction& w):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    this->w = w;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Constructor
  Form_10(const dolfin::Mesh& mesh, boost::shared_ptr<const dolfin::GenericFunction> w):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = reference_to_no_delete_pointer(mesh);
    this->w = *w;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Constructor
  Form_10(boost::shared_ptr<const dolfin::Mesh> mesh):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = mesh;
    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Constructor
  Form_10(boost::shared_ptr<const dolfin::Mesh> mesh, const dolfin::GenericFunction& w):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = mesh;
    this->w = w;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Constructor
  Form_10(boost::shared_ptr<const dolfin::Mesh> mesh, boost::shared_ptr<const dolfin::GenericFunction> w):
    dolfin::GoalFunctional(0, 1), w(*this, 0)
  {
    _mesh = mesh;
    this->w = *w;

    _ufc_form = boost::shared_ptr<const ufc::form>(new adaptivenavierstokes_form_10());
  }

  // Destructor
  ~Form_10()
  {}

  /// Return the number of the coefficient with this name
  virtual dolfin::uint coefficient_number(const std::string& name) const
  {
    if (name == "w")
      return 0;

    dolfin::dolfin_error("generated code for class GoalFunctional",
                         "access coeficient data",
                         "Invalid coeficient");
    return 0;
  }

  /// Return the name of the coefficient with this number
  virtual std::string coefficient_name(dolfin::uint i) const
  {
    switch (i)
    {
    case 0:
      return "w";
    }

    dolfin::dolfin_error("generated code for class GoalFunctional",
                         "access coeficient data",
                         "Invalid coeficient");
    return "unnamed";
  }

  // Typedefs
  typedef Form_10_FunctionSpace_0 CoefficientSpace_w;

  // Coefficients
  dolfin::CoefficientAssigner w;

  /// Initialize all error control forms, attach coefficients and
  /// (re-)set error control
  virtual void update_ec(const dolfin::Form& a, const dolfin::Form& L)
  {
    // This stuff is created here and shipped elsewhere
    boost::shared_ptr<dolfin::Form> a_star;           // Dual lhs
    boost::shared_ptr<dolfin::Form> L_star;           // Dual rhs
    boost::shared_ptr<dolfin::FunctionSpace> V_Ez_h;  // Extrapolation space
    boost::shared_ptr<dolfin::Function> Ez_h;         // Extrapolated dual
    boost::shared_ptr<dolfin::Form> residual;         // Residual (as functional)
    boost::shared_ptr<dolfin::FunctionSpace> V_R_T;   // Trial space for cell residual
    boost::shared_ptr<dolfin::Form> a_R_T;            // Cell residual lhs
    boost::shared_ptr<dolfin::Form> L_R_T;            // Cell residual rhs
    boost::shared_ptr<dolfin::FunctionSpace> V_b_T;   // Function space for cell bubble
    boost::shared_ptr<dolfin::Function> b_T;          // Cell bubble
    boost::shared_ptr<dolfin::FunctionSpace> V_R_dT;  // Trial space for facet residual
    boost::shared_ptr<dolfin::Form> a_R_dT;           // Facet residual lhs
    boost::shared_ptr<dolfin::Form> L_R_dT;           // Facet residual rhs
    boost::shared_ptr<dolfin::FunctionSpace> V_b_e;   // Function space for cell cone
    boost::shared_ptr<dolfin::Function> b_e;          // Cell cone
    boost::shared_ptr<dolfin::FunctionSpace> V_eta_T; // Function space for indicators
    boost::shared_ptr<dolfin::Form> eta_T;            // Indicator form

    // Some handy views
    const dolfin::FunctionSpace& Vhat(*(a.function_space(0))); // Primal test
    const dolfin::FunctionSpace& V(*(a.function_space(1)));    // Primal trial
    assert(V.mesh());
    const dolfin::Mesh& mesh(*V.mesh());
    std::string name;

    // Initialize dual forms
    a_star.reset(new Form_0(V, Vhat));
    L_star.reset(new Form_1(V));

    
    // Attach coefficients from a to a_star
    for (dolfin::uint i = 0; i < a.num_coefficients(); i++)
    {
      name = a.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed).
      if (name == "__discrete_primal_solution")
        continue;

      // Test whether a_star has coefficient named 'name'
      try {
        a_star->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to a_star";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      a_star->set_coefficient(name, a.coefficient(i));
    }
    
    // Attach subdomains from a to a_star
    a_star->dx = a.cell_domains_shared_ptr();
    a_star->ds = a.exterior_facet_domains_shared_ptr();
    a_star->dS = a.interior_facet_domains_shared_ptr();

    
    // Attach coefficients from (*this) to L_star
    for (dolfin::uint i = 0; i < (*this).num_coefficients(); i++)
    {
      name = (*this).coefficient_name(i);
      // Don't attach discrete primal solution here (not computed).
      if (name == "__discrete_primal_solution")
        continue;

      // Test whether L_star has coefficient named 'name'
      try {
        L_star->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to L_star";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      L_star->set_coefficient(name, (*this).coefficient(i));
    }
    
    // Attach subdomains from (*this) to L_star
    L_star->dx = (*this).cell_domains_shared_ptr();
    L_star->ds = (*this).exterior_facet_domains_shared_ptr();
    L_star->dS = (*this).interior_facet_domains_shared_ptr();


    // Initialize residual
    residual.reset(new Form_2(mesh));
    
    // Attach coefficients from a to residual
    for (dolfin::uint i = 0; i < a.num_coefficients(); i++)
    {
      name = a.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed).
      if (name == "__discrete_primal_solution")
        continue;

      // Test whether residual has coefficient named 'name'
      try {
        residual->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to residual";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      residual->set_coefficient(name, a.coefficient(i));
    }
    

    // Attach coefficients from L to residual
    for (dolfin::uint i = 0; i < L.num_coefficients(); i++)
    {
      name = L.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed).
      if (name == "__discrete_primal_solution")
        continue;

      // Test whether residual has coefficient named 'name'
      try {
        residual->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to residual";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      residual->set_coefficient(name, L.coefficient(i));
    }
    
    // Attach subdomains from L to residual
    residual->dx = L.cell_domains_shared_ptr();
    residual->ds = L.exterior_facet_domains_shared_ptr();
    residual->dS = L.interior_facet_domains_shared_ptr();


    // Initialize extrapolation space and (fake) extrapolation
    V_Ez_h.reset(new CoefficientSpace___improved_dual(mesh));
    Ez_h.reset(new dolfin::Function(V_Ez_h));
    residual->set_coefficient("__improved_dual", Ez_h);

    // Create bilinear and linear form for computing cell residual R_T
    V_R_T.reset(new Form_4::TestSpace(mesh));
    a_R_T.reset(new Form_3(V_R_T, V_R_T));
    L_R_T.reset(new Form_4(V_R_T));

    // Initialize bubble and attach to a_R_T and L_R_T
    V_b_T.reset(new CoefficientSpace___cell_bubble(mesh));
    b_T.reset(new dolfin::Function(V_b_T));
    *b_T->vector() = 1.0;
    
    // Attach coefficients from a to L_R_T
    for (dolfin::uint i = 0; i < a.num_coefficients(); i++)
    {
      name = a.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed).
      if (name == "__discrete_primal_solution")
        continue;

      // Test whether L_R_T has coefficient named 'name'
      try {
        L_R_T->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to L_R_T";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      L_R_T->set_coefficient(name, a.coefficient(i));
    }
    

    // Attach coefficients from L to L_R_T
    for (dolfin::uint i = 0; i < L.num_coefficients(); i++)
    {
      name = L.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed).
      if (name == "__discrete_primal_solution")
        continue;

      // Test whether L_R_T has coefficient named 'name'
      try {
        L_R_T->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to L_R_T";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      L_R_T->set_coefficient(name, L.coefficient(i));
    }
    
    // Attach subdomains from L to L_R_T
    L_R_T->dx = L.cell_domains_shared_ptr();
    L_R_T->ds = L.exterior_facet_domains_shared_ptr();
    L_R_T->dS = L.interior_facet_domains_shared_ptr();


    // Attach bubble function to _a_R_T and _L_R_T
    a_R_T->set_coefficient("__cell_bubble", b_T);
    L_R_T->set_coefficient("__cell_bubble", b_T);

    // Create bilinear and linear form for computing facet residual R_dT
    V_R_dT.reset(new Form_6::TestSpace(mesh));
    a_R_dT.reset(new Form_5(V_R_dT, V_R_dT));
    L_R_dT.reset(new Form_6(V_R_dT));
    
    // Attach coefficients from a to L_R_dT
    for (dolfin::uint i = 0; i < a.num_coefficients(); i++)
    {
      name = a.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed).
      if (name == "__discrete_primal_solution")
        continue;

      // Test whether L_R_dT has coefficient named 'name'
      try {
        L_R_dT->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to L_R_dT";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      L_R_dT->set_coefficient(name, a.coefficient(i));
    }
    

    // Attach coefficients from L to L_R_dT
    for (dolfin::uint i = 0; i < L.num_coefficients(); i++)
    {
      name = L.coefficient_name(i);
      // Don't attach discrete primal solution here (not computed).
      if (name == "__discrete_primal_solution")
        continue;

      // Test whether L_R_dT has coefficient named 'name'
      try {
        L_R_dT->coefficient_number(name);
      } catch (...) {
        std::cout << "Attaching coefficient named: " << name << " to L_R_dT";
        std::cout << " failed! But this might be expected." << std::endl;
        continue;
      }
      L_R_dT->set_coefficient(name, L.coefficient(i));
    }
    
    // Attach subdomains from L to L_R_dT
    L_R_dT->dx = L.cell_domains_shared_ptr();
    L_R_dT->ds = L.exterior_facet_domains_shared_ptr();
    L_R_dT->dS = L.interior_facet_domains_shared_ptr();


    // Initialize (fake) cone and attach to a_R_dT and L_R_dT
    V_b_e.reset(new CoefficientSpace___cell_cone(mesh));
    b_e.reset(new dolfin::Function(V_b_e));
    a_R_dT->set_coefficient("__cell_cone", b_e);
    L_R_dT->set_coefficient("__cell_cone", b_e);

    // Create error indicator form
    V_eta_T.reset(new Form_7::TestSpace(mesh));
    eta_T.reset(new Form_7(V_eta_T));

    // Update error control
    _ec.reset(new dolfin::ErrorControl(a_star, L_star, residual,
                                       a_R_T, L_R_T, a_R_dT, L_R_dT, eta_T,
                                       false));

  }

};

// Class typedefs
typedef Form_8 BilinearForm;
typedef Form_9 LinearForm;
typedef Form_10 GoalFunctional;

}

#endif
